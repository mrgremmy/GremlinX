import { Bip32Derivation, PsbtInput } from 'bip174';
import { Transaction } from '../transaction.js';
import { Bytes32, MessageHash, PublicKey, Script } from '../types.js';
import { PsbtCache } from './PsbtCache.js';
import { HDSigner, HDSignerAsync } from './types.js';
export interface HashForSig {
    readonly pubkey: PublicKey;
    readonly hash: MessageHash;
    readonly leafHash?: Bytes32;
}
/**
 * Class wrapping all signing-related logic for PSBT.
 */
export declare class PsbtSigner {
    #private;
    constructor(cache: PsbtCache, txFromBuffer: (buf: Uint8Array) => Transaction);
    getHashAndSighashType(inputs: PsbtInput[], inputIndex: number, pubkey: Uint8Array, sighashTypes: number[]): {
        hash: MessageHash;
        sighashType: number;
    };
    getHashForSig(inputIndex: number, input: PsbtInput, forValidate: boolean, sighashTypes?: number[]): {
        script: Script;
        hash: MessageHash;
        sighashType: number;
    };
    getTaprootHashesForSig(inputIndex: number, input: PsbtInput, inputs: PsbtInput[], pubkey: Uint8Array, tapLeafHashToSign?: Uint8Array, allowedSighashTypes?: number[]): HashForSig[];
    getAllTaprootHashesForSig(inputIndex: number, input: PsbtInput, inputs: PsbtInput[]): HashForSig[];
    trimTaprootSig(signature: Uint8Array): Uint8Array;
    getSignersFromHD<T extends HDSigner | HDSignerAsync>(inputIndex: number, inputs: PsbtInput[], hdKeyPair: T): T[];
    bip32DerivationIsMine(root: HDSigner): (d: Bip32Derivation) => boolean;
}
//# sourceMappingURL=PsbtSigner.d.ts.map