const Mt = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  bech32Opnet: "op",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
}, Is = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bech32Opnet: "opr",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
}, vs = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bech32Opnet: "opt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
}, Ss = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "opt",
  bech32Opnet: "opt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
}, Ts = {
  messagePrefix: `Dogecoin Signed Message:
`,
  bech32: "",
  // Dogecoin does not currently use Bech32
  bech32Opnet: "",
  bip32: {
    public: 49990397,
    private: 49988504
  },
  pubKeyHash: 30,
  scriptHash: 22,
  wif: 158
}, Bs = {
  messagePrefix: `Dogecoin Signed Message:
`,
  bech32: "",
  // Dogecoin testnet does not currently use Bech32
  bech32Opnet: "",
  bip32: {
    public: 70429096,
    private: 70427203
  },
  pubKeyHash: 113,
  scriptHash: 196,
  wif: 241
}, xs = {
  messagePrefix: `Litecoin Signed Message:
`,
  bech32: "ltc",
  bech32Opnet: "opl",
  bip32: {
    public: 27108450,
    private: 27106558
  },
  pubKeyHash: 48,
  scriptHash: 50,
  wif: 176
}, Us = {
  messagePrefix: `Litecoin Signed Message:
`,
  bech32: "tltc",
  bech32Opnet: "oplt",
  bip32: {
    public: 70709117,
    private: 70711009
  },
  pubKeyHash: 111,
  scriptHash: 58,
  wif: 239
}, Os = {
  messagePrefix: `Bitcoin Signed Message:
`,
  // Cashaddr prefix differs from bech32 for general usage, but we can set it similarly.
  // Actual cashaddr prefix is "bitcoincash", but this field is for bech32 which BCH doesn't fully use for segwit (it doesn't have segwit).
  bech32: "bitcoincash",
  bech32Opnet: "opbch",
  bip32: {
    public: 76067358,
    private: 76066276
  },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
}, ks = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bchtest",
  bech32Opnet: "opbcht",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
}, Ps = {
  // Historically Dash used DarkCoin message prefix, and most implementations use this:
  // As of Dash Core 0.17, this has not changed in code.
  messagePrefix: `DarkCoin Signed Message:
`,
  bech32: "",
  // Dash does not use Bech32
  bech32Opnet: "",
  bip32: {
    public: 50221772,
    private: 50221816
  },
  pubKeyHash: 76,
  scriptHash: 16,
  wif: 204
}, Rs = {
  messagePrefix: `DarkCoin Signed Message:
`,
  bech32: "",
  // Dash testnet does not use Bech32
  bech32Opnet: "",
  bip32: {
    public: 981492128,
    private: 981489719
  },
  pubKeyHash: 140,
  scriptHash: 19,
  wif: 239
}, Xa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitcoin: Mt,
  bitcoinCash: Os,
  bitcoinCashTestnet: ks,
  dash: Ps,
  dashTestnet: Rs,
  dogecoin: Ts,
  dogecoinTestnet: Bs,
  litecoin: xs,
  litecoinTestnet: Us,
  opnetTestnet: Ss,
  regtest: Is,
  testnet: vs
}, Symbol.toStringTag, { value: "Module" }));
var ie = {}, bn;
function Hs() {
  if (bn) return ie;
  bn = 1, Object.defineProperty(ie, "__esModule", { value: !0 }), ie.bech32m = ie.bech32 = void 0;
  const e = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", t = {};
  for (let p = 0; p < e.length; p++) {
    const f = e.charAt(p);
    t[f] = p;
  }
  function r(p) {
    const f = p >> 25;
    return (p & 33554431) << 5 ^ -(f >> 0 & 1) & 996825010 ^ -(f >> 1 & 1) & 642813549 ^ -(f >> 2 & 1) & 513874426 ^ -(f >> 3 & 1) & 1027748829 ^ -(f >> 4 & 1) & 705979059;
  }
  function n(p) {
    let f = 1;
    for (let w = 0; w < p.length; ++w) {
      const b = p.charCodeAt(w);
      if (b < 33 || b > 126)
        return "Invalid prefix (" + p + ")";
      f = r(f) ^ b >> 5;
    }
    f = r(f);
    for (let w = 0; w < p.length; ++w) {
      const b = p.charCodeAt(w);
      f = r(f) ^ b & 31;
    }
    return f;
  }
  function i(p, f, w, b) {
    let y = 0, I = 0;
    const E = (1 << w) - 1, T = [];
    for (let O = 0; O < p.length; ++O)
      for (y = y << f | p[O], I += f; I >= w; )
        I -= w, T.push(y >> I & E);
    if (b)
      I > 0 && T.push(y << w - I & E);
    else {
      if (I >= f)
        return "Excess padding";
      if (y << w - I & E)
        return "Non-zero padding";
    }
    return T;
  }
  function h(p) {
    return i(p, 8, 5, !0);
  }
  function a(p) {
    const f = i(p, 5, 8, !1);
    if (Array.isArray(f))
      return f;
  }
  function c(p) {
    const f = i(p, 5, 8, !1);
    if (Array.isArray(f))
      return f;
    throw new Error(f);
  }
  function d(p) {
    let f;
    p === "bech32" ? f = 1 : f = 734539939;
    function w(E, T, O) {
      if (O = O || 90, E.length + 7 + T.length > O)
        throw new TypeError("Exceeds length limit");
      E = E.toLowerCase();
      let k = n(E);
      if (typeof k == "string")
        throw new Error(k);
      let P = E + "1";
      for (let x = 0; x < T.length; ++x) {
        const K = T[x];
        if (K >> 5 !== 0)
          throw new Error("Non 5-bit word");
        k = r(k) ^ K, P += e.charAt(K);
      }
      for (let x = 0; x < 6; ++x)
        k = r(k);
      k ^= f;
      for (let x = 0; x < 6; ++x) {
        const K = k >> (5 - x) * 5 & 31;
        P += e.charAt(K);
      }
      return P;
    }
    function b(E, T) {
      if (T = T || 90, E.length < 8)
        return E + " too short";
      if (E.length > T)
        return "Exceeds length limit";
      const O = E.toLowerCase(), k = E.toUpperCase();
      if (E !== O && E !== k)
        return "Mixed-case string " + E;
      E = O;
      const P = E.lastIndexOf("1");
      if (P === -1)
        return "No separator character for " + E;
      if (P === 0)
        return "Missing prefix for " + E;
      const x = E.slice(0, P), K = E.slice(P + 1);
      if (K.length < 6)
        return "Data too short";
      let tt = n(x);
      if (typeof tt == "string")
        return tt;
      const Bt = [];
      for (let F = 0; F < K.length; ++F) {
        const _ = K.charAt(F), ot = t[_];
        if (ot === void 0)
          return "Unknown character " + _;
        tt = r(tt) ^ ot, !(F + 6 >= K.length) && Bt.push(ot);
      }
      return tt !== f ? "Invalid checksum for " + E : { prefix: x, words: Bt };
    }
    function y(E, T) {
      const O = b(E, T);
      if (typeof O == "object")
        return O;
    }
    function I(E, T) {
      const O = b(E, T);
      if (typeof O == "object")
        return O;
      throw new Error(O);
    }
    return {
      decodeUnsafe: y,
      decode: I,
      encode: w,
      toWords: h,
      fromWordsUnsafe: a,
      fromWords: c
    };
  }
  return ie.bech32 = d("bech32"), ie.bech32m = d("bech32m"), ie;
}
var lt = Hs();
function Yr(e) {
  let t, r;
  try {
    t = lt.bech32.decode(e);
  } catch {
  }
  if (t) {
    if (r = t.words[0], r !== 0) throw new TypeError(e + " uses wrong encoding");
  } else if (t = lt.bech32m.decode(e), r = t.words[0], r === 0) throw new TypeError(e + " uses wrong encoding");
  const n = lt.bech32.fromWords(t.words.slice(1));
  return {
    version: r,
    prefix: t.prefix,
    data: new Uint8Array(n)
  };
}
const si = "0123456789abcdefABCDEF";
si.split("").map((e) => e.codePointAt(0));
Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), n = si.indexOf(r);
  return n < 0 ? void 0 : n < 16 ? n : n - 6;
});
new TextEncoder();
new TextDecoder();
function Ls(e, t, r, n) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255);
}
function Cs(e, t, r, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  n === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255);
}
function _s(e, t, r, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  n === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn));
}
function Ns(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 1], n = (n << 8) + e[t], n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t], n = (n << 8) + e[t + 1], n;
  }
}
function Vs(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0;
    return n = (n << 8) + e[t + 3] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t] >>> 0, n;
  } else {
    let n = 0;
    return n = (n << 8) + e[t] >>> 0, n = (n << 8) + e[t + 1] >>> 0, n = (n << 8) + e[t + 2] >>> 0, n = (n << 8) + e[t + 3] >>> 0, n;
  }
}
function Ms(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t + 7]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t]), n;
  } else {
    let n = 0n;
    return n = (n << 8n) + BigInt(e[t]), n = (n << 8n) + BigInt(e[t + 1]), n = (n << 8n) + BigInt(e[t + 2]), n = (n << 8n) + BigInt(e[t + 3]), n = (n << 8n) + BigInt(e[t + 4]), n = (n << 8n) + BigInt(e[t + 5]), n = (n << 8n) + BigInt(e[t + 6]), n = (n << 8n) + BigInt(e[t + 7]), n;
  }
}
const Fs = (e) => {
  if (e < 0 || e > 0xffffffffffffffffn)
    throw new RangeError("value out of range");
};
function $s(e) {
  if (e < 0 || e > Number.MAX_SAFE_INTEGER || e % 1 !== 0)
    throw new RangeError("value out of range");
}
function oi(e) {
  typeof e == "number" ? $s(e) : Fs(e);
}
function Xr(e, t, r) {
  oi(e), r === void 0 && (r = 0), t === void 0 && (t = new Uint8Array(re(e)));
  let n = 0;
  return e < 253 ? (t.set([Number(e)], r), n = 1) : e <= 65535 ? (t.set([253], r), Ls(t, r + 1, Number(e), "LE"), n = 3) : e <= 4294967295 ? (t.set([254], r), Cs(t, r + 1, Number(e), "LE"), n = 5) : (t.set([255], r), _s(t, r + 1, BigInt(e), "LE"), n = 9), { buffer: t, bytes: n };
}
function Ds(e, t) {
  t === void 0 && (t = 0);
  const r = e.at(t);
  if (r === void 0)
    throw new Error("buffer too small");
  if (r < 253)
    return { numberValue: r, bigintValue: BigInt(r), bytes: 1 };
  if (r === 253) {
    const n = Ns(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 3
    };
  } else if (r === 254) {
    const n = Vs(e, t + 1, "LE");
    return {
      numberValue: n,
      bigintValue: BigInt(n),
      bytes: 5
    };
  } else {
    const n = Ms(e, t + 1, "LE");
    return { numberValue: n <= Number.MAX_SAFE_INTEGER ? Number(n) : null, bigintValue: n, bytes: 9 };
  }
}
function re(e) {
  return oi(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
const Qa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Ds,
  encode: Xr,
  encodingLength: re
}, Symbol.toStringTag, { value: "Module" })), Ks = Array.from(
  { length: 256 },
  (e, t) => t.toString(16).padStart(2, "0")
), Vr = (() => {
  const e = new Array(128).fill(-1);
  for (let t = 0; t < 10; t++)
    e[48 + t] = t;
  for (let t = 0; t < 6; t++)
    e[65 + t] = 10 + t, e[97 + t] = 10 + t;
  return e;
})();
function xe(e) {
  let t = "";
  for (let r = 0; r < e.length; r++) {
    const n = Ks[e[r]];
    t += n;
  }
  return t;
}
function ne(e) {
  e.length >= 2 && e[0] === "0" && (e[1] === "x" || e[1] === "X") && (e = e.slice(2));
  const t = e.length;
  if (t % 2 !== 0)
    throw new TypeError("Invalid hex string: odd length");
  const r = t / 2, n = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const h = i * 2, a = e.charCodeAt(h), c = e.charCodeAt(h + 1);
    if (a >= 128 || c >= 128)
      throw new TypeError(`Invalid hex character at position ${h}`);
    const d = Vr[a], p = Vr[c];
    if (d === -1)
      throw new TypeError(`Invalid hex character at position ${h}`);
    if (p === -1)
      throw new TypeError(`Invalid hex character at position ${h + 1}`);
    n[i] = d << 4 | p;
  }
  return n;
}
function Ja(e) {
  let t = e;
  if (t.length >= 2 && t[0] === "0" && (t[1] === "x" || t[1] === "X") && (t = t.slice(2)), t.length % 2 !== 0)
    return !1;
  for (let r = 0; r < t.length; r++) {
    const n = t.charCodeAt(r);
    if (n >= 128 || Vr[n] === -1)
      return !1;
  }
  return !0;
}
class Qr {
  /**
   * The underlying byte array.
   */
  #e;
  /**
   * Single DataView instance reused for all reads.
   */
  #h;
  /**
   * Current read position.
   */
  #t;
  /**
   * Creates a new BinaryReader.
   *
   * @param data - The byte array to read from
   * @param offset - Initial read position (default 0)
   *
   * @example
   * ```typescript
   * import { BinaryReader, fromHex } from '@btc-vision/bitcoin';
   *
   * const data = fromHex('01020304');
   * const reader = new BinaryReader(data);
   * ```
   */
  constructor(t, r = 0) {
    this.#e = t, this.#h = new DataView(t.buffer, t.byteOffset, t.byteLength), this.#t = r;
  }
  /**
   * Current read position in the buffer.
   */
  get offset() {
    return this.#t;
  }
  /**
   * Sets the read position.
   *
   * @param value - New offset value
   * @throws RangeError if offset is negative or beyond buffer length
   */
  set offset(t) {
    if (t < 0 || t > this.#e.length)
      throw new RangeError(`Offset ${t} is out of bounds [0, ${this.#e.length}]`);
    this.#t = t;
  }
  /**
   * Total length of the underlying buffer.
   */
  get length() {
    return this.#e.length;
  }
  /**
   * Number of bytes remaining to be read.
   */
  get remaining() {
    return this.#e.length - this.#t;
  }
  /**
   * The underlying data buffer.
   */
  get data() {
    return this.#e;
  }
  /**
   * Creates a BinaryReader from a hex string.
   *
   * @param hex - Hex string (with or without 0x prefix)
   * @returns A new BinaryReader instance
   *
   * @example
   * ```typescript
   * import { BinaryReader } from '@btc-vision/bitcoin';
   *
   * const reader = BinaryReader.fromHex('01000000');
   * const version = reader.readInt32LE(); // 1
   * ```
   */
  static fromHex(t) {
    return new Qr(ne(t));
  }
  /**
   * Reads an 8-bit unsigned integer.
   *
   * @returns The value (0-255)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('ff');
   * reader.readUInt8(); // 255
   * ```
   */
  readUInt8() {
    if (this.#t >= this.#e.length)
      throw new RangeError("Read past end of buffer");
    return this.#e[this.#t++];
  }
  /**
   * Reads an 8-bit signed integer.
   *
   * @returns The value (-128 to 127)
   * @throws RangeError if reading past end of buffer
   */
  readInt8() {
    const t = this.readUInt8();
    return t > 127 ? t - 256 : t;
  }
  /**
   * Reads a 16-bit unsigned integer in little-endian format.
   *
   * @returns The value (0-65535)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('0100'); // 1 in LE
   * reader.readUInt16LE(); // 1
   * ```
   */
  readUInt16LE() {
    if (this.#t + 2 > this.#e.length)
      throw new RangeError("Read past end of buffer");
    const t = this.#h.getUint16(this.#t, !0);
    return this.#t += 2, t;
  }
  /**
   * Reads a 16-bit signed integer in little-endian format.
   *
   * @returns The value (-32768 to 32767)
   * @throws RangeError if reading past end of buffer
   */
  readInt16LE() {
    if (this.#t + 2 > this.#e.length)
      throw new RangeError("Read past end of buffer");
    const t = this.#h.getInt16(this.#t, !0);
    return this.#t += 2, t;
  }
  /**
   * Reads a 32-bit unsigned integer in little-endian format.
   *
   * @returns The value (0 to 4294967295)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('01000000'); // 1 in LE
   * reader.readUInt32LE(); // 1
   * ```
   */
  readUInt32LE() {
    if (this.#t + 4 > this.#e.length)
      throw new RangeError("Read past end of buffer");
    const t = this.#h.getUint32(this.#t, !0);
    return this.#t += 4, t;
  }
  /**
   * Reads a 32-bit signed integer in little-endian format.
   *
   * @returns The value (-2147483648 to 2147483647)
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('ffffffff'); // -1 in LE signed
   * reader.readInt32LE(); // -1
   * ```
   */
  readInt32LE() {
    if (this.#t + 4 > this.#e.length)
      throw new RangeError("Read past end of buffer");
    const t = this.#h.getInt32(this.#t, !0);
    return this.#t += 4, t;
  }
  /**
   * Reads a 64-bit unsigned integer in little-endian format as bigint.
   *
   * @returns The value as bigint
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('0100000000000000'); // 1 in LE 64-bit
   * reader.readUInt64LE(); // 1n
   * ```
   */
  readUInt64LE() {
    if (this.#t + 8 > this.#e.length)
      throw new RangeError("Read past end of buffer");
    const t = this.#h.getBigUint64(this.#t, !0);
    return this.#t += 8, t;
  }
  /**
   * Reads a 64-bit signed integer in little-endian format as bigint.
   *
   * @returns The value as bigint
   * @throws RangeError if reading past end of buffer
   */
  readInt64LE() {
    if (this.#t + 8 > this.#e.length)
      throw new RangeError("Read past end of buffer");
    const t = this.#h.getBigInt64(this.#t, !0);
    return this.#t += 8, t;
  }
  /**
   * Reads a specified number of bytes.
   *
   * Returns a subarray view (no copy) for performance.
   * Use readBytesCopy() if you need an independent copy.
   *
   * @param length - Number of bytes to read
   * @returns Uint8Array view into the buffer
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('deadbeefcafebabe');
   * const first4 = reader.readBytes(4); // deadbeef
   * const next4 = reader.readBytes(4); // cafebabe
   * ```
   */
  readBytes(t) {
    if (this.#t + t > this.#e.length)
      throw new RangeError("Read past end of buffer");
    const r = this.#e.subarray(this.#t, this.#t + t);
    return this.#t += t, r;
  }
  /**
   * Reads a specified number of bytes as an independent copy.
   *
   * @param length - Number of bytes to read
   * @returns New Uint8Array with copied data
   * @throws RangeError if reading past end of buffer
   */
  readBytesCopy(t) {
    if (this.#t + t > this.#e.length)
      throw new RangeError("Read past end of buffer");
    const r = this.#e.slice(this.#t, this.#t + t);
    return this.#t += t, r;
  }
  /**
   * Reads a Bitcoin CompactSize variable-length integer.
   *
   * CompactSize encoding:
   * - 0x00-0xFC: 1 byte (value as-is)
   * - 0xFD: 3 bytes (0xFD + 2-byte LE uint16)
   * - 0xFE: 5 bytes (0xFE + 4-byte LE uint32)
   * - 0xFF: 9 bytes (0xFF + 8-byte LE uint64)
   *
   * @returns The decoded integer value
   * @throws RangeError if reading past end of buffer
   * @throws RangeError if value exceeds MAX_SAFE_INTEGER
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('fd0302'); // 515 encoded
   * reader.readVarInt(); // 515
   * ```
   */
  readVarInt() {
    const t = this.readUInt8();
    if (t < 253)
      return t;
    if (t === 253)
      return this.readUInt16LE();
    if (t === 254)
      return this.readUInt32LE();
    const r = this.readUInt64LE();
    if (r > BigInt(Number.MAX_SAFE_INTEGER))
      throw new RangeError("VarInt value exceeds MAX_SAFE_INTEGER");
    return Number(r);
  }
  /**
   * Reads a Bitcoin CompactSize variable-length integer as bigint.
   *
   * Use this when you need the full 64-bit range.
   *
   * @returns The decoded integer value as bigint
   * @throws RangeError if reading past end of buffer
   */
  readVarIntBig() {
    const t = this.readUInt8();
    return t < 253 ? BigInt(t) : t === 253 ? BigInt(this.readUInt16LE()) : t === 254 ? BigInt(this.readUInt32LE()) : this.readUInt64LE();
  }
  /**
   * Reads a length-prefixed byte array (VarInt length + bytes).
   *
   * @returns Uint8Array view into the buffer
   * @throws RangeError if reading past end of buffer
   *
   * @example
   * ```typescript
   * const reader = BinaryReader.fromHex('04deadbeef');
   * reader.readVarBytes(); // Uint8Array [0xde, 0xad, 0xbe, 0xef]
   * ```
   */
  readVarBytes() {
    const t = this.readVarInt();
    return this.readBytes(t);
  }
  /**
   * Reads an array of length-prefixed byte arrays.
   *
   * Format: VarInt count + (VarInt length + bytes) for each item.
   *
   * @returns Array of Uint8Array views
   * @throws RangeError if reading past end of buffer
   */
  readVector() {
    const t = this.readVarInt(), r = [];
    for (let n = 0; n < t; n++)
      r.push(this.readVarBytes());
    return r;
  }
  /**
   * Peeks at the next byte without advancing the position.
   *
   * @returns The next byte value, or undefined if at end
   */
  peek() {
    if (!(this.#t >= this.#e.length))
      return this.#e[this.#t];
  }
  /**
   * Skips a specified number of bytes.
   *
   * @param length - Number of bytes to skip
   * @throws RangeError if skipping past end of buffer
   */
  skip(t) {
    if (this.#t + t > this.#e.length)
      throw new RangeError("Skip past end of buffer");
    this.#t += t;
  }
  /**
   * Resets the read position to the beginning.
   */
  reset() {
    this.#t = 0;
  }
  /**
   * Checks if there are more bytes to read.
   *
   * @returns True if there are remaining bytes
   */
  hasMore() {
    return this.#t < this.#e.length;
  }
}
class ut {
  /**
   * The underlying byte array.
   */
  #e;
  /**
   * Single DataView instance reused for all writes.
   */
  #h;
  /**
   * Current write position.
   */
  #t;
  constructor(t, r = 0) {
    typeof t == "number" ? (this.#e = new Uint8Array(t), this.#t = 0) : (this.#e = t, this.#t = r), this.#h = new DataView(this.#e.buffer, this.#e.byteOffset, this.#e.byteLength);
  }
  /**
   * Current write position in the buffer.
   */
  get offset() {
    return this.#t;
  }
  /**
   * Sets the write position.
   *
   * @param value - New offset value
   * @throws RangeError if offset is negative or beyond buffer length
   */
  set offset(t) {
    if (t < 0 || t > this.#e.length)
      throw new RangeError(`Offset ${t} is out of bounds [0, ${this.#e.length}]`);
    this.#t = t;
  }
  /**
   * Total capacity of the underlying buffer.
   */
  get capacity() {
    return this.#e.length;
  }
  /**
   * Number of bytes remaining in the buffer.
   */
  get remaining() {
    return this.#e.length - this.#t;
  }
  /**
   * The underlying data buffer.
   */
  get data() {
    return this.#e;
  }
  /**
   * Creates a BinaryWriter with automatic capacity management.
   *
   * Initial capacity is 256 bytes, grows as needed.
   *
   * @returns A new GrowableBinaryWriter instance
   *
   * @example
   * ```typescript
   * import { BinaryWriter } from '@btc-vision/bitcoin';
   *
   * const writer = BinaryWriter.growable();
   * writer.writeUInt32LE(1);
   * writer.writeBytes(new Uint8Array(1000)); // Automatically grows
   * ```
   */
  static growable(t = 256) {
    return new Ws(t);
  }
  /**
   * Writes an 8-bit unsigned integer.
   *
   * @param value - Value to write (0-255)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt8(255);
   * ```
   */
  writeUInt8(t) {
    if (this.#t >= this.#e.length)
      throw new RangeError("Write past end of buffer");
    return this.#e[this.#t++] = t & 255, this;
  }
  /**
   * Writes an 8-bit signed integer.
   *
   * @param value - Value to write (-128 to 127)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeInt8(t) {
    return this.writeUInt8(t < 0 ? t + 256 : t);
  }
  /**
   * Writes a 16-bit unsigned integer in little-endian format.
   *
   * @param value - Value to write (0-65535)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt16LE(1); // Writes 01 00
   * ```
   */
  writeUInt16LE(t) {
    if (this.#t + 2 > this.#e.length)
      throw new RangeError("Write past end of buffer");
    return this.#h.setUint16(this.#t, t, !0), this.#t += 2, this;
  }
  /**
   * Writes a 16-bit signed integer in little-endian format.
   *
   * @param value - Value to write (-32768 to 32767)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeInt16LE(t) {
    if (this.#t + 2 > this.#e.length)
      throw new RangeError("Write past end of buffer");
    return this.#h.setInt16(this.#t, t, !0), this.#t += 2, this;
  }
  /**
   * Writes a 32-bit unsigned integer in little-endian format.
   *
   * @param value - Value to write (0 to 4294967295)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt32LE(1); // Writes 01 00 00 00
   * ```
   */
  writeUInt32LE(t) {
    if (this.#t + 4 > this.#e.length)
      throw new RangeError("Write past end of buffer");
    return this.#h.setUint32(this.#t, t, !0), this.#t += 4, this;
  }
  /**
   * Writes a 32-bit signed integer in little-endian format.
   *
   * @param value - Value to write (-2147483648 to 2147483647)
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeInt32LE(-1); // Writes ff ff ff ff
   * ```
   */
  writeInt32LE(t) {
    if (this.#t + 4 > this.#e.length)
      throw new RangeError("Write past end of buffer");
    return this.#h.setInt32(this.#t, t, !0), this.#t += 4, this;
  }
  /**
   * Writes a 64-bit unsigned integer in little-endian format.
   *
   * @param value - Value to write as bigint
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeUInt64LE(50000n); // Writes 50 c3 00 00 00 00 00 00
   * ```
   */
  writeUInt64LE(t) {
    if (this.#t + 8 > this.#e.length)
      throw new RangeError("Write past end of buffer");
    return this.#h.setBigUint64(this.#t, t, !0), this.#t += 8, this;
  }
  /**
   * Writes a 64-bit signed integer in little-endian format.
   *
   * @param value - Value to write as bigint
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeInt64LE(t) {
    if (this.#t + 8 > this.#e.length)
      throw new RangeError("Write past end of buffer");
    return this.#h.setBigInt64(this.#t, t, !0), this.#t += 8, this;
  }
  /**
   * Writes raw bytes.
   *
   * @param bytes - Bytes to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeBytes(new Uint8Array([0xde, 0xad, 0xbe, 0xef]));
   * ```
   */
  writeBytes(t) {
    if (this.#t + t.length > this.#e.length)
      throw new RangeError("Write past end of buffer");
    return this.#e.set(t, this.#t), this.#t += t.length, this;
  }
  /**
   * Writes a Bitcoin CompactSize variable-length integer.
   *
   * CompactSize encoding:
   * - 0x00-0xFC: 1 byte (value as-is)
   * - 0xFD-0xFFFF: 3 bytes (0xFD + 2-byte LE uint16)
   * - 0x10000-0xFFFFFFFF: 5 bytes (0xFE + 4-byte LE uint32)
   * - Larger: 9 bytes (0xFF + 8-byte LE uint64)
   *
   * @param value - Value to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeVarInt(252);    // Writes fc
   * writer.writeVarInt(253);    // Writes fd fd 00
   * writer.writeVarInt(65535);  // Writes fd ff ff
   * writer.writeVarInt(65536);  // Writes fe 00 00 01 00
   * ```
   */
  writeVarInt(t) {
    return t < 253 ? this.writeUInt8(t) : t <= 65535 ? (this.writeUInt8(253), this.writeUInt16LE(t)) : t <= 4294967295 ? (this.writeUInt8(254), this.writeUInt32LE(t)) : (this.writeUInt8(255), this.writeUInt64LE(BigInt(t)));
  }
  /**
   * Writes a Bitcoin CompactSize variable-length integer from bigint.
   *
   * @param value - Value to write as bigint
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeVarIntBig(t) {
    return t < 0xfdn ? this.writeUInt8(Number(t)) : t <= 0xffffn ? (this.writeUInt8(253), this.writeUInt16LE(Number(t))) : t <= 0xffffffffn ? (this.writeUInt8(254), this.writeUInt32LE(Number(t))) : (this.writeUInt8(255), this.writeUInt64LE(t));
  }
  /**
   * Writes a length-prefixed byte array (VarInt length + bytes).
   *
   * @param bytes - Bytes to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   *
   * @example
   * ```typescript
   * writer.writeVarBytes(new Uint8Array([0xde, 0xad])); // Writes 02 de ad
   * ```
   */
  writeVarBytes(t) {
    return this.writeVarInt(t.length), this.writeBytes(t);
  }
  /**
   * Writes an array of length-prefixed byte arrays.
   *
   * Format: VarInt count + (VarInt length + bytes) for each item.
   *
   * @param vector - Array of byte arrays to write
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  writeVector(t) {
    this.writeVarInt(t.length);
    for (const r of t)
      this.writeVarBytes(r);
    return this;
  }
  /**
   * Fills a region with a specific byte value.
   *
   * @param value - Byte value to fill with
   * @param length - Number of bytes to fill
   * @returns This writer for chaining
   * @throws RangeError if writing past end of buffer
   */
  fill(t, r) {
    if (this.#t + r > this.#e.length)
      throw new RangeError("Write past end of buffer");
    return this.#e.fill(t, this.#t, this.#t + r), this.#t += r, this;
  }
  /**
   * Skips a specified number of bytes (leaves them unchanged).
   *
   * @param length - Number of bytes to skip
   * @returns This writer for chaining
   * @throws RangeError if skipping past end of buffer
   */
  skip(t) {
    if (this.#t + t > this.#e.length)
      throw new RangeError("Skip past end of buffer");
    return this.#t += t, this;
  }
  /**
   * Resets the write position to the beginning.
   *
   * @returns This writer for chaining
   */
  reset() {
    return this.#t = 0, this;
  }
  /**
   * Verifies the buffer was fully written and returns it.
   *
   * Unlike {@link finish}, this method throws if the writer has not
   * written exactly to the end of the buffer.
   *
   * @returns The underlying buffer
   * @throws Error if the buffer was not fully written
   *
   * @example
   * ```typescript
   * const writer = new BinaryWriter(8);
   * writer.writeUInt32LE(1);
   * writer.writeUInt32LE(2);
   * const bytes = writer.end(); // OK: wrote exactly 8 bytes
   *
   * const writer2 = new BinaryWriter(8);
   * writer2.writeUInt32LE(1);
   * writer2.end(); // throws: buffer size 8, offset 4
   * ```
   */
  end() {
    if (this.#t === this.#e.length)
      return this.#e;
    throw new Error(`buffer size ${this.#e.length}, offset ${this.#t}`);
  }
  /**
   * Returns the written portion of the buffer.
   *
   * If the entire buffer was written, returns the buffer directly (no copy).
   * Otherwise, returns a subarray view.
   *
   * @returns Uint8Array containing the written data
   *
   * @example
   * ```typescript
   * const writer = new BinaryWriter(100);
   * writer.writeUInt32LE(42);
   * const bytes = writer.finish(); // 4 bytes
   * ```
   */
  finish() {
    return this.#t === this.#e.length ? this.#e : this.#e.subarray(0, this.#t);
  }
  /**
   * Returns the written portion as a hex string.
   *
   * @returns Hex string representation
   *
   * @example
   * ```typescript
   * const writer = new BinaryWriter(4);
   * writer.writeUInt32LE(1);
   * writer.toHex(); // '01000000'
   * ```
   */
  toHex() {
    return xe(this.finish());
  }
}
class Ws {
  #e;
  #h;
  #t = 0;
  /**
   * Creates a new GrowableBinaryWriter.
   *
   * @param initialCapacity - Initial buffer size (default 256)
   */
  constructor(t = 256) {
    this.#e = new Uint8Array(t), this.#h = new DataView(this.#e.buffer);
  }
  /**
   * Current write position.
   */
  get offset() {
    return this.#t;
  }
  /**
   * Sets the write position.
   *
   * @param value - New offset value
   * @throws RangeError if offset is negative
   */
  set offset(t) {
    if (t < 0)
      throw new RangeError(`Offset ${t} cannot be negative`);
    this.#t = t;
  }
  /**
   * Current buffer capacity.
   */
  get capacity() {
    return this.#e.length;
  }
  writeUInt8(t) {
    return this.#s(1), this.#e[this.#t++] = t & 255, this;
  }
  writeUInt16LE(t) {
    return this.#s(2), this.#h.setUint16(this.#t, t, !0), this.#t += 2, this;
  }
  writeUInt32LE(t) {
    return this.#s(4), this.#h.setUint32(this.#t, t, !0), this.#t += 4, this;
  }
  writeInt32LE(t) {
    return this.#s(4), this.#h.setInt32(this.#t, t, !0), this.#t += 4, this;
  }
  writeUInt64LE(t) {
    return this.#s(8), this.#h.setBigUint64(this.#t, t, !0), this.#t += 8, this;
  }
  writeBytes(t) {
    return this.#s(t.length), this.#e.set(t, this.#t), this.#t += t.length, this;
  }
  writeVarInt(t) {
    return t < 253 ? this.writeUInt8(t) : t <= 65535 ? (this.writeUInt8(253), this.writeUInt16LE(t)) : t <= 4294967295 ? (this.writeUInt8(254), this.writeUInt32LE(t)) : (this.writeUInt8(255), this.writeUInt64LE(BigInt(t)));
  }
  writeVarBytes(t) {
    return this.writeVarInt(t.length), this.writeBytes(t);
  }
  writeVector(t) {
    this.writeVarInt(t.length);
    for (const r of t)
      this.writeVarBytes(r);
    return this;
  }
  /**
   * Returns the written data as a new Uint8Array.
   *
   * @returns Copy of the written data
   */
  finish() {
    return this.#e.slice(0, this.#t);
  }
  /**
   * Returns the written data as a hex string.
   *
   * @returns Hex string representation
   */
  toHex() {
    return xe(this.finish());
  }
  /**
   * Ensures the buffer has enough space for additional bytes.
   *
   * @param additionalBytes - Number of additional bytes needed
   */
  #s(t) {
    const r = this.#t + t;
    if (r <= this.#e.length)
      return;
    let n = this.#e.length * 2;
    for (; n < r; )
      n *= 2;
    const i = new Uint8Array(n);
    i.set(this.#e.subarray(0, this.#t)), this.#e = i, this.#h = new DataView(this.#e.buffer);
  }
}
function Gs(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function hi(e, t, r = "") {
  const n = Gs(e), i = e?.length;
  if (!n || t !== void 0) {
    const a = r && `"${r}" `, c = "", d = n ? `length=${i}` : `type=${typeof e}`;
    throw new Error(a + "expected Uint8Array" + c + ", got " + d);
  }
  return e;
}
function En(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function js(e, t) {
  hi(e, void 0, "digestInto() output");
  const r = t.outputLen;
  if (e.length < r)
    throw new Error('"digestInto() output" expected to be of length >=' + r);
}
function ce(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function Br(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function Ct(e, t) {
  return e << 32 - t | e >>> t;
}
function oe(e, t) {
  return e << t | e >>> 32 - t >>> 0;
}
function Jr(e, t = {}) {
  const r = (i, h) => e(h).update(i).digest(), n = e(void 0);
  return r.outputLen = n.outputLen, r.blockLen = n.blockLen, r.create = (i) => e(i), Object.assign(r, t), Object.freeze(r);
}
const qs = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function ai(e, t, r) {
  return e & t ^ ~e & r;
}
function ui(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
class tn {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(t, r, n, i) {
    this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = Br(this.buffer);
  }
  update(t) {
    En(this), hi(t);
    const { view: r, buffer: n, blockLen: i } = this, h = t.length;
    for (let a = 0; a < h; ) {
      const c = Math.min(i - this.pos, h - a);
      if (c === i) {
        const d = Br(t);
        for (; i <= h - a; a += i)
          this.process(d, a);
        continue;
      }
      n.set(t.subarray(a, a + c), this.pos), this.pos += c, a += c, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    En(this), js(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: h } = this;
    let { pos: a } = this;
    r[a++] = 128, ce(this.buffer.subarray(a)), this.padOffset > i - a && (this.process(n, 0), a = 0);
    for (let w = a; w < i; w++)
      r[w] = 0;
    n.setBigUint64(i - 8, BigInt(this.length * 8), h), this.process(n, 0);
    const c = Br(t), d = this.outputLen;
    if (d % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const p = d / 4, f = this.get();
    if (p > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let w = 0; w < p; w++)
      c.setUint32(4 * w, f[w], h);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t ||= new this.constructor(), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: h, destroyed: a, pos: c } = this;
    return t.destroyed = a, t.finished = h, t.length = i, t.pos = c, i % r && t.buffer.set(n), t;
  }
  clone() {
    return this._cloneInto();
  }
}
const jt = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), zs = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), qt = /* @__PURE__ */ new Uint32Array(64);
class Zs extends tn {
  constructor(t) {
    super(64, t, 8, !1);
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: h, F: a, G: c, H: d } = this;
    return [t, r, n, i, h, a, c, d];
  }
  // prettier-ignore
  set(t, r, n, i, h, a, c, d) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = h | 0, this.F = a | 0, this.G = c | 0, this.H = d | 0;
  }
  process(t, r) {
    for (let w = 0; w < 16; w++, r += 4)
      qt[w] = t.getUint32(r, !1);
    for (let w = 16; w < 64; w++) {
      const b = qt[w - 15], y = qt[w - 2], I = Ct(b, 7) ^ Ct(b, 18) ^ b >>> 3, E = Ct(y, 17) ^ Ct(y, 19) ^ y >>> 10;
      qt[w] = E + qt[w - 7] + I + qt[w - 16] | 0;
    }
    let { A: n, B: i, C: h, D: a, E: c, F: d, G: p, H: f } = this;
    for (let w = 0; w < 64; w++) {
      const b = Ct(c, 6) ^ Ct(c, 11) ^ Ct(c, 25), y = f + b + ai(c, d, p) + zs[w] + qt[w] | 0, E = (Ct(n, 2) ^ Ct(n, 13) ^ Ct(n, 22)) + ui(n, i, h) | 0;
      f = p, p = d, d = c, c = a + y | 0, a = h, h = i, i = n, n = y + E | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, h = h + this.C | 0, a = a + this.D | 0, c = c + this.E | 0, d = d + this.F | 0, p = p + this.G | 0, f = f + this.H | 0, this.set(n, i, h, a, c, d, p, f);
  }
  roundClean() {
    ce(qt);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ce(this.buffer);
  }
}
class Ys extends Zs {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = jt[0] | 0;
  B = jt[1] | 0;
  C = jt[2] | 0;
  D = jt[3] | 0;
  E = jt[4] | 0;
  F = jt[5] | 0;
  G = jt[6] | 0;
  H = jt[7] | 0;
  constructor() {
    super(32);
  }
}
const Ue = /* @__PURE__ */ Jr(
  () => new Ys(),
  /* @__PURE__ */ qs(1)
);
function Xs(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let p = 0; p < t.length; p++)
    t[p] = 255;
  for (let p = 0; p < e.length; p++) {
    const f = e.charAt(p), w = f.charCodeAt(0);
    if (t[w] !== 255)
      throw new TypeError(f + " is ambiguous");
    t[w] = p;
  }
  const r = e.length, n = e.charAt(0), i = Math.log(r) / Math.log(256), h = Math.log(256) / Math.log(r);
  function a(p) {
    if (p instanceof Uint8Array || (ArrayBuffer.isView(p) ? p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength) : Array.isArray(p) && (p = Uint8Array.from(p))), !(p instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (p.length === 0)
      return "";
    let f = 0, w = 0, b = 0;
    const y = p.length;
    for (; b !== y && p[b] === 0; )
      b++, f++;
    const I = (y - b) * h + 1 >>> 0, E = new Uint8Array(I);
    for (; b !== y; ) {
      let k = p[b], P = 0;
      for (let x = I - 1; (k !== 0 || P < w) && x !== -1; x--, P++)
        k += 256 * E[x] >>> 0, E[x] = k % r >>> 0, k = k / r >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      w = P, b++;
    }
    let T = I - w;
    for (; T !== I && E[T] === 0; )
      T++;
    let O = n.repeat(f);
    for (; T < I; ++T)
      O += e.charAt(E[T]);
    return O;
  }
  function c(p) {
    if (typeof p != "string")
      throw new TypeError("Expected String");
    if (p.length === 0)
      return new Uint8Array();
    let f = 0, w = 0, b = 0;
    for (; p[f] === n; )
      w++, f++;
    const y = (p.length - f) * i + 1 >>> 0, I = new Uint8Array(y);
    for (; f < p.length; ) {
      const k = p.charCodeAt(f);
      if (k > 255)
        return;
      let P = t[k];
      if (P === 255)
        return;
      let x = 0;
      for (let K = y - 1; (P !== 0 || x < b) && K !== -1; K--, x++)
        P += r * I[K] >>> 0, I[K] = P % 256 >>> 0, P = P / 256 >>> 0;
      if (P !== 0)
        throw new Error("Non-zero carry");
      b = x, f++;
    }
    let E = y - b;
    for (; E !== y && I[E] === 0; )
      E++;
    const T = new Uint8Array(w + (y - E));
    let O = w;
    for (; E !== y; )
      T[O++] = I[E++];
    return T;
  }
  function d(p) {
    const f = c(p);
    if (f)
      return f;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: a,
    decodeUnsafe: c,
    decode: d
  };
}
var Qs = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const xr = Xs(Qs);
function Js(e) {
  function t(h) {
    const a = e(h), c = h.length + 4, d = new Uint8Array(c);
    return d.set(h, 0), d.set(a.subarray(0, 4), h.length), xr.encode(d);
  }
  function r(h) {
    const a = h.slice(0, -4), c = h.slice(-4), d = e(a);
    if (!(c[0] ^ d[0] | c[1] ^ d[1] | c[2] ^ d[2] | c[3] ^ d[3]))
      return a;
  }
  function n(h) {
    const a = xr.decodeUnsafe(h);
    if (a !== void 0)
      return r(a);
  }
  function i(h) {
    const a = xr.decode(h), c = r(a);
    if (c === void 0)
      throw new Error("Invalid checksum");
    return c;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: n
  };
}
function to(e) {
  return Ue(Ue(e));
}
const { encode: fi, decode: ci } = Js(to);
function vt(e) {
  let t = 0;
  for (const i of e)
    t += i.length;
  const r = new Uint8Array(t);
  let n = 0;
  for (const i of e)
    r.set(i, n), n += i.length;
  return r;
}
function H(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function Kt(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; n++) {
    const i = e[n] - t[n];
    if (i !== 0)
      return i;
  }
  return e.length - t.length;
}
function Oe(e) {
  for (let t = 0; t < e.length; t++)
    if (e[t] !== 0)
      return !1;
  return !0;
}
function tu(e) {
  const t = new Uint8Array(e.length);
  return t.set(e), t;
}
function eo(e) {
  return e.reverse(), e;
}
function eu(e) {
  const t = new Uint8Array(e.length);
  for (let r = 0; r < e.length; r++)
    t[r] = e[e.length - 1 - r];
  return t;
}
function wt(e, t = 0) {
  const r = new Uint8Array(e);
  return t !== 0 && r.fill(t), r;
}
function ru(e, t) {
  if (e.length !== t.length)
    throw new TypeError("Arrays must have the same length for XOR operation");
  const r = new Uint8Array(e.length);
  for (let n = 0; n < e.length; n++)
    r[n] = e[n] ^ t[n];
  return r;
}
function nu(e) {
  return new TextEncoder().encode(e);
}
function iu(e) {
  return new TextDecoder().decode(e);
}
function ro(e) {
  if (e.length < 8 || e.length > 72 || e[0] !== 48 || e[1] !== e.length - 2 || e[2] !== 2) return !1;
  const t = e[3];
  if (t === 0 || 5 + t >= e.length || e[4 + t] !== 2) return !1;
  const r = e[5 + t];
  return !(r === 0 || 6 + t + r !== e.length || e[4] & 128 || t > 1 && e[4] === 0 && !(e[5] & 128) || e[t + 6] & 128 || r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128));
}
function no(e) {
  if (e.length < 8) throw new Error("DER sequence length is too short");
  if (e.length > 72) throw new Error("DER sequence length is too long");
  if (e[0] !== 48) throw new Error("Expected DER sequence");
  if (e[1] !== e.length - 2) throw new Error("DER sequence length is invalid");
  if (e[2] !== 2) throw new Error("Expected DER integer");
  const t = e[3];
  if (t === 0) throw new Error("R length is zero");
  if (5 + t >= e.length) throw new Error("R length is too long");
  if (e[4 + t] !== 2) throw new Error("Expected DER integer (2)");
  const r = e[5 + t];
  if (r === 0) throw new Error("S length is zero");
  if (6 + t + r !== e.length) throw new Error("S length is invalid");
  if (e[4] & 128) throw new Error("R value is negative");
  if (t > 1 && e[4] === 0 && !(e[5] & 128))
    throw new Error("R value excessively padded");
  if (e[t + 6] & 128) throw new Error("S value is negative");
  if (r > 1 && e[t + 6] === 0 && !(e[t + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: e.subarray(4, 4 + t),
    s: e.subarray(6 + t)
  };
}
function io(e, t) {
  const r = e.length, n = t.length;
  if (r === 0) throw new Error("R length is zero");
  if (n === 0) throw new Error("S length is zero");
  if (r > 33) throw new Error("R length is too long");
  if (n > 33) throw new Error("S length is too long");
  if (e[0] & 128) throw new Error("R value is negative");
  if (t[0] & 128) throw new Error("S value is negative");
  if (r > 1 && e[0] === 0 && !(e[1] & 128)) throw new Error("R value excessively padded");
  if (n > 1 && t[0] === 0 && !(t[1] & 128)) throw new Error("S value excessively padded");
  const i = wt(6 + r + n);
  return i[0] = 48, i[1] = i.length - 2, i[2] = 2, i[3] = e.length, i.set(e, 4), i[4 + r] = 2, i[5 + r] = t.length, i.set(t, 6 + r), i;
}
const z = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
let je;
function li() {
  if (!je) {
    je = {};
    for (const e of Object.keys(z)) {
      const t = z[e];
      je[t] = e;
    }
  }
  return je;
}
li();
function di(e) {
  return e < z.OP_PUSHDATA1 ? 1 : e <= 255 ? 2 : e <= 65535 ? 3 : 5;
}
function so(e, t, r) {
  const n = di(t), i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n === 1 ? e[r] = t : n === 2 ? (e[r] = z.OP_PUSHDATA1, e[r + 1] = t) : n === 3 ? (e[r] = z.OP_PUSHDATA2, i.setUint16(r + 1, t, !0)) : (e[r] = z.OP_PUSHDATA4, i.setUint32(r + 1, t, !0)), n;
}
function oo(e, t) {
  const r = new DataView(e.buffer, e.byteOffset, e.byteLength), n = e[t];
  let i, h;
  if (n < z.OP_PUSHDATA1)
    i = n, h = 1;
  else if (n === z.OP_PUSHDATA1) {
    if (t + 2 > e.length) return null;
    i = e[t + 1], h = 2;
  } else if (n === z.OP_PUSHDATA2) {
    if (t + 3 > e.length) return null;
    i = r.getUint16(t + 1, !0), h = 3;
  } else {
    if (t + 5 > e.length) return null;
    if (n !== z.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    i = r.getUint32(t + 1, !0), h = 5;
  }
  return {
    opcode: n,
    number: i,
    size: h
  };
}
var pi = {}, gr = {};
gr.byteLength = uo;
gr.toByteArray = co;
gr.fromByteArray = wo;
var Vt = [], Ot = [], ho = typeof Uint8Array < "u" ? Uint8Array : Array, Ur = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ge = 0, ao = Ur.length; ge < ao; ++ge)
  Vt[ge] = Ur[ge], Ot[Ur.charCodeAt(ge)] = ge;
Ot[45] = 62;
Ot[95] = 63;
function wi(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function uo(e) {
  var t = wi(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function fo(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function co(e) {
  var t, r = wi(e), n = r[0], i = r[1], h = new ho(fo(e, n, i)), a = 0, c = i > 0 ? n - 4 : n, d;
  for (d = 0; d < c; d += 4)
    t = Ot[e.charCodeAt(d)] << 18 | Ot[e.charCodeAt(d + 1)] << 12 | Ot[e.charCodeAt(d + 2)] << 6 | Ot[e.charCodeAt(d + 3)], h[a++] = t >> 16 & 255, h[a++] = t >> 8 & 255, h[a++] = t & 255;
  return i === 2 && (t = Ot[e.charCodeAt(d)] << 2 | Ot[e.charCodeAt(d + 1)] >> 4, h[a++] = t & 255), i === 1 && (t = Ot[e.charCodeAt(d)] << 10 | Ot[e.charCodeAt(d + 1)] << 4 | Ot[e.charCodeAt(d + 2)] >> 2, h[a++] = t >> 8 & 255, h[a++] = t & 255), h;
}
function lo(e) {
  return Vt[e >> 18 & 63] + Vt[e >> 12 & 63] + Vt[e >> 6 & 63] + Vt[e & 63];
}
function po(e, t, r) {
  for (var n, i = [], h = t; h < r; h += 3)
    n = (e[h] << 16 & 16711680) + (e[h + 1] << 8 & 65280) + (e[h + 2] & 255), i.push(lo(n));
  return i.join("");
}
function wo(e) {
  for (var t, r = e.length, n = r % 3, i = [], h = 16383, a = 0, c = r - n; a < c; a += h)
    i.push(po(e, a, a + h > c ? c : a + h));
  return n === 1 ? (t = e[r - 1], i.push(
    Vt[t >> 2] + Vt[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(
    Vt[t >> 10] + Vt[t >> 4 & 63] + Vt[t << 2 & 63] + "="
  )), i.join("");
}
var en = {};
en.read = function(e, t, r, n, i) {
  var h, a, c = i * 8 - n - 1, d = (1 << c) - 1, p = d >> 1, f = -7, w = r ? i - 1 : 0, b = r ? -1 : 1, y = e[t + w];
  for (w += b, h = y & (1 << -f) - 1, y >>= -f, f += c; f > 0; h = h * 256 + e[t + w], w += b, f -= 8)
    ;
  for (a = h & (1 << -f) - 1, h >>= -f, f += n; f > 0; a = a * 256 + e[t + w], w += b, f -= 8)
    ;
  if (h === 0)
    h = 1 - p;
  else {
    if (h === d)
      return a ? NaN : (y ? -1 : 1) * (1 / 0);
    a = a + Math.pow(2, n), h = h - p;
  }
  return (y ? -1 : 1) * a * Math.pow(2, h - n);
};
en.write = function(e, t, r, n, i, h) {
  var a, c, d, p = h * 8 - i - 1, f = (1 << p) - 1, w = f >> 1, b = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = n ? 0 : h - 1, I = n ? 1 : -1, E = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (c = isNaN(t) ? 1 : 0, a = f) : (a = Math.floor(Math.log(t) / Math.LN2), t * (d = Math.pow(2, -a)) < 1 && (a--, d *= 2), a + w >= 1 ? t += b / d : t += b * Math.pow(2, 1 - w), t * d >= 2 && (a++, d /= 2), a + w >= f ? (c = 0, a = f) : a + w >= 1 ? (c = (t * d - 1) * Math.pow(2, i), a = a + w) : (c = t * Math.pow(2, w - 1) * Math.pow(2, i), a = 0)); i >= 8; e[r + y] = c & 255, y += I, c /= 256, i -= 8)
    ;
  for (a = a << i | c, p += i; p > 0; e[r + y] = a & 255, y += I, a /= 256, p -= 8)
    ;
  e[r + y - I] |= E * 128;
};
(function(e) {
  const t = gr, r = en, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = f, e.SlowBuffer = K, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i;
  const { Uint8Array: h, ArrayBuffer: a, SharedArrayBuffer: c } = globalThis;
  f.TYPED_ARRAY_SUPPORT = d(), !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function d() {
    try {
      const u = new h(1), s = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(s, h.prototype), Object.setPrototypeOf(u, s), u.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(f.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (f.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(f.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (f.isBuffer(this))
        return this.byteOffset;
    }
  });
  function p(u) {
    if (u > i)
      throw new RangeError('The value "' + u + '" is invalid for option "size"');
    const s = new h(u);
    return Object.setPrototypeOf(s, f.prototype), s;
  }
  function f(u, s, o) {
    if (typeof u == "number") {
      if (typeof s == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return I(u);
    }
    return w(u, s, o);
  }
  f.poolSize = 8192;
  function w(u, s, o) {
    if (typeof u == "string")
      return E(u, s);
    if (a.isView(u))
      return O(u);
    if (u == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof u
      );
    if (Lt(u, a) || u && Lt(u.buffer, a) || typeof c < "u" && (Lt(u, c) || u && Lt(u.buffer, c)))
      return k(u, s, o);
    if (typeof u == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const l = u.valueOf && u.valueOf();
    if (l != null && l !== u)
      return f.from(l, s, o);
    const g = P(u);
    if (g) return g;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof u[Symbol.toPrimitive] == "function")
      return f.from(u[Symbol.toPrimitive]("string"), s, o);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof u
    );
  }
  f.from = function(u, s, o) {
    return w(u, s, o);
  }, Object.setPrototypeOf(f.prototype, h.prototype), Object.setPrototypeOf(f, h);
  function b(u) {
    if (typeof u != "number")
      throw new TypeError('"size" argument must be of type number');
    if (u < 0)
      throw new RangeError('The value "' + u + '" is invalid for option "size"');
  }
  function y(u, s, o) {
    return b(u), u <= 0 ? p(u) : s !== void 0 ? typeof o == "string" ? p(u).fill(s, o) : p(u).fill(s) : p(u);
  }
  f.alloc = function(u, s, o) {
    return y(u, s, o);
  };
  function I(u) {
    return b(u), p(u < 0 ? 0 : x(u) | 0);
  }
  f.allocUnsafe = function(u) {
    return I(u);
  }, f.allocUnsafeSlow = function(u) {
    return I(u);
  };
  function E(u, s) {
    if ((typeof s != "string" || s === "") && (s = "utf8"), !f.isEncoding(s))
      throw new TypeError("Unknown encoding: " + s);
    const o = tt(u, s) | 0;
    let l = p(o);
    const g = l.write(u, s);
    return g !== o && (l = l.slice(0, g)), l;
  }
  function T(u) {
    const s = u.length < 0 ? 0 : x(u.length) | 0, o = p(s);
    for (let l = 0; l < s; l += 1)
      o[l] = u[l] & 255;
    return o;
  }
  function O(u) {
    if (Lt(u, h)) {
      const s = new h(u);
      return k(s.buffer, s.byteOffset, s.byteLength);
    }
    return T(u);
  }
  function k(u, s, o) {
    if (s < 0 || u.byteLength < s)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (u.byteLength < s + (o || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let l;
    return s === void 0 && o === void 0 ? l = new h(u) : o === void 0 ? l = new h(u, s) : l = new h(u, s, o), Object.setPrototypeOf(l, f.prototype), l;
  }
  function P(u) {
    if (f.isBuffer(u)) {
      const s = x(u.length) | 0, o = p(s);
      return o.length === 0 || u.copy(o, 0, 0, s), o;
    }
    if (u.length !== void 0)
      return typeof u.length != "number" || Tr(u.length) ? p(0) : T(u);
    if (u.type === "Buffer" && Array.isArray(u.data))
      return T(u.data);
  }
  function x(u) {
    if (u >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return u | 0;
  }
  function K(u) {
    return +u != u && (u = 0), f.alloc(+u);
  }
  f.isBuffer = function(s) {
    return s != null && s._isBuffer === !0 && s !== f.prototype;
  }, f.compare = function(s, o) {
    if (Lt(s, h) && (s = f.from(s, s.offset, s.byteLength)), Lt(o, h) && (o = f.from(o, o.offset, o.byteLength)), !f.isBuffer(s) || !f.isBuffer(o))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (s === o) return 0;
    let l = s.length, g = o.length;
    for (let m = 0, A = Math.min(l, g); m < A; ++m)
      if (s[m] !== o[m]) {
        l = s[m], g = o[m];
        break;
      }
    return l < g ? -1 : g < l ? 1 : 0;
  }, f.isEncoding = function(s) {
    switch (String(s).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, f.concat = function(s, o) {
    if (!Array.isArray(s))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (s.length === 0)
      return f.alloc(0);
    let l;
    if (o === void 0)
      for (o = 0, l = 0; l < s.length; ++l)
        o += s[l].length;
    const g = f.allocUnsafe(o);
    let m = 0;
    for (l = 0; l < s.length; ++l) {
      let A = s[l];
      if (Lt(A, h))
        m + A.length > g.length ? (f.isBuffer(A) || (A = f.from(A)), A.copy(g, m)) : h.prototype.set.call(
          g,
          A,
          m
        );
      else if (f.isBuffer(A))
        A.copy(g, m);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      m += A.length;
    }
    return g;
  };
  function tt(u, s) {
    if (f.isBuffer(u))
      return u.length;
    if (a.isView(u) || Lt(u, a))
      return u.byteLength;
    if (typeof u != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof u
      );
    const o = u.length, l = arguments.length > 2 && arguments[2] === !0;
    if (!l && o === 0) return 0;
    let g = !1;
    for (; ; )
      switch (s) {
        case "ascii":
        case "latin1":
        case "binary":
          return o;
        case "utf8":
        case "utf-8":
          return Sr(u).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return o * 2;
        case "hex":
          return o >>> 1;
        case "base64":
          return mn(u).length;
        default:
          if (g)
            return l ? -1 : Sr(u).length;
          s = ("" + s).toLowerCase(), g = !0;
      }
  }
  f.byteLength = tt;
  function Bt(u, s, o) {
    let l = !1;
    if ((s === void 0 || s < 0) && (s = 0), s > this.length || ((o === void 0 || o > this.length) && (o = this.length), o <= 0) || (o >>>= 0, s >>>= 0, o <= s))
      return "";
    for (u || (u = "utf8"); ; )
      switch (u) {
        case "hex":
          return W(this, s, o);
        case "utf8":
        case "utf-8":
          return N(this, s, o);
        case "ascii":
          return C(this, s, o);
        case "latin1":
        case "binary":
          return D(this, s, o);
        case "base64":
          return U(this, s, o);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ht(this, s, o);
        default:
          if (l) throw new TypeError("Unknown encoding: " + u);
          u = (u + "").toLowerCase(), l = !0;
      }
  }
  f.prototype._isBuffer = !0;
  function F(u, s, o) {
    const l = u[s];
    u[s] = u[o], u[o] = l;
  }
  f.prototype.swap16 = function() {
    const s = this.length;
    if (s % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let o = 0; o < s; o += 2)
      F(this, o, o + 1);
    return this;
  }, f.prototype.swap32 = function() {
    const s = this.length;
    if (s % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let o = 0; o < s; o += 4)
      F(this, o, o + 3), F(this, o + 1, o + 2);
    return this;
  }, f.prototype.swap64 = function() {
    const s = this.length;
    if (s % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let o = 0; o < s; o += 8)
      F(this, o, o + 7), F(this, o + 1, o + 6), F(this, o + 2, o + 5), F(this, o + 3, o + 4);
    return this;
  }, f.prototype.toString = function() {
    const s = this.length;
    return s === 0 ? "" : arguments.length === 0 ? N(this, 0, s) : Bt.apply(this, arguments);
  }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(s) {
    if (!f.isBuffer(s)) throw new TypeError("Argument must be a Buffer");
    return this === s ? !0 : f.compare(this, s) === 0;
  }, f.prototype.inspect = function() {
    let s = "";
    const o = e.INSPECT_MAX_BYTES;
    return s = this.toString("hex", 0, o).replace(/(.{2})/g, "$1 ").trim(), this.length > o && (s += " ... "), "<Buffer " + s + ">";
  }, n && (f.prototype[n] = f.prototype.inspect), f.prototype.compare = function(s, o, l, g, m) {
    if (Lt(s, h) && (s = f.from(s, s.offset, s.byteLength)), !f.isBuffer(s))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof s
      );
    if (o === void 0 && (o = 0), l === void 0 && (l = s ? s.length : 0), g === void 0 && (g = 0), m === void 0 && (m = this.length), o < 0 || l > s.length || g < 0 || m > this.length)
      throw new RangeError("out of range index");
    if (g >= m && o >= l)
      return 0;
    if (g >= m)
      return -1;
    if (o >= l)
      return 1;
    if (o >>>= 0, l >>>= 0, g >>>= 0, m >>>= 0, this === s) return 0;
    let A = m - g, j = l - o;
    const rt = Math.min(A, j), et = this.slice(g, m), nt = s.slice(o, l);
    for (let X = 0; X < rt; ++X)
      if (et[X] !== nt[X]) {
        A = et[X], j = nt[X];
        break;
      }
    return A < j ? -1 : j < A ? 1 : 0;
  };
  function _(u, s, o, l, g) {
    if (u.length === 0) return -1;
    if (typeof o == "string" ? (l = o, o = 0) : o > 2147483647 ? o = 2147483647 : o < -2147483648 && (o = -2147483648), o = +o, Tr(o) && (o = g ? 0 : u.length - 1), o < 0 && (o = u.length + o), o >= u.length) {
      if (g) return -1;
      o = u.length - 1;
    } else if (o < 0)
      if (g) o = 0;
      else return -1;
    if (typeof s == "string" && (s = f.from(s, l)), f.isBuffer(s))
      return s.length === 0 ? -1 : ot(u, s, o, l, g);
    if (typeof s == "number")
      return s = s & 255, typeof h.prototype.indexOf == "function" ? g ? h.prototype.indexOf.call(u, s, o) : h.prototype.lastIndexOf.call(u, s, o) : ot(u, [s], o, l, g);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ot(u, s, o, l, g) {
    let m = 1, A = u.length, j = s.length;
    if (l !== void 0 && (l = String(l).toLowerCase(), l === "ucs2" || l === "ucs-2" || l === "utf16le" || l === "utf-16le")) {
      if (u.length < 2 || s.length < 2)
        return -1;
      m = 2, A /= 2, j /= 2, o /= 2;
    }
    function rt(nt, X) {
      return m === 1 ? nt[X] : nt.readUInt16BE(X * m);
    }
    let et;
    if (g) {
      let nt = -1;
      for (et = o; et < A; et++)
        if (rt(u, et) === rt(s, nt === -1 ? 0 : et - nt)) {
          if (nt === -1 && (nt = et), et - nt + 1 === j) return nt * m;
        } else
          nt !== -1 && (et -= et - nt), nt = -1;
    } else
      for (o + j > A && (o = A - j), et = o; et >= 0; et--) {
        let nt = !0;
        for (let X = 0; X < j; X++)
          if (rt(u, et + X) !== rt(s, X)) {
            nt = !1;
            break;
          }
        if (nt) return et;
      }
    return -1;
  }
  f.prototype.includes = function(s, o, l) {
    return this.indexOf(s, o, l) !== -1;
  }, f.prototype.indexOf = function(s, o, l) {
    return _(this, s, o, l, !0);
  }, f.prototype.lastIndexOf = function(s, o, l) {
    return _(this, s, o, l, !1);
  };
  function Pt(u, s, o, l) {
    o = Number(o) || 0;
    const g = u.length - o;
    l ? (l = Number(l), l > g && (l = g)) : l = g;
    const m = s.length;
    l > m / 2 && (l = m / 2);
    let A;
    for (A = 0; A < l; ++A) {
      const j = parseInt(s.substr(A * 2, 2), 16);
      if (Tr(j)) return A;
      u[o + A] = j;
    }
    return A;
  }
  function Z(u, s, o, l) {
    return Ge(Sr(s, u.length - o), u, o, l);
  }
  function B(u, s, o, l) {
    return Ge(ms(s), u, o, l);
  }
  function S(u, s, o, l) {
    return Ge(mn(s), u, o, l);
  }
  function v(u, s, o, l) {
    return Ge(bs(s, u.length - o), u, o, l);
  }
  f.prototype.write = function(s, o, l, g) {
    if (o === void 0)
      g = "utf8", l = this.length, o = 0;
    else if (l === void 0 && typeof o == "string")
      g = o, l = this.length, o = 0;
    else if (isFinite(o))
      o = o >>> 0, isFinite(l) ? (l = l >>> 0, g === void 0 && (g = "utf8")) : (g = l, l = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const m = this.length - o;
    if ((l === void 0 || l > m) && (l = m), s.length > 0 && (l < 0 || o < 0) || o > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    g || (g = "utf8");
    let A = !1;
    for (; ; )
      switch (g) {
        case "hex":
          return Pt(this, s, o, l);
        case "utf8":
        case "utf-8":
          return Z(this, s, o, l);
        case "ascii":
        case "latin1":
        case "binary":
          return B(this, s, o, l);
        case "base64":
          return S(this, s, o, l);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, s, o, l);
        default:
          if (A) throw new TypeError("Unknown encoding: " + g);
          g = ("" + g).toLowerCase(), A = !0;
      }
  }, f.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function U(u, s, o) {
    return s === 0 && o === u.length ? t.fromByteArray(u) : t.fromByteArray(u.slice(s, o));
  }
  function N(u, s, o) {
    o = Math.min(u.length, o);
    const l = [];
    let g = s;
    for (; g < o; ) {
      const m = u[g];
      let A = null, j = m > 239 ? 4 : m > 223 ? 3 : m > 191 ? 2 : 1;
      if (g + j <= o) {
        let rt, et, nt, X;
        switch (j) {
          case 1:
            m < 128 && (A = m);
            break;
          case 2:
            rt = u[g + 1], (rt & 192) === 128 && (X = (m & 31) << 6 | rt & 63, X > 127 && (A = X));
            break;
          case 3:
            rt = u[g + 1], et = u[g + 2], (rt & 192) === 128 && (et & 192) === 128 && (X = (m & 15) << 12 | (rt & 63) << 6 | et & 63, X > 2047 && (X < 55296 || X > 57343) && (A = X));
            break;
          case 4:
            rt = u[g + 1], et = u[g + 2], nt = u[g + 3], (rt & 192) === 128 && (et & 192) === 128 && (nt & 192) === 128 && (X = (m & 15) << 18 | (rt & 63) << 12 | (et & 63) << 6 | nt & 63, X > 65535 && X < 1114112 && (A = X));
        }
      }
      A === null ? (A = 65533, j = 1) : A > 65535 && (A -= 65536, l.push(A >>> 10 & 1023 | 55296), A = 56320 | A & 1023), l.push(A), g += j;
    }
    return M(l);
  }
  const V = 4096;
  function M(u) {
    const s = u.length;
    if (s <= V)
      return String.fromCharCode.apply(String, u);
    let o = "", l = 0;
    for (; l < s; )
      o += String.fromCharCode.apply(
        String,
        u.slice(l, l += V)
      );
    return o;
  }
  function C(u, s, o) {
    let l = "";
    o = Math.min(u.length, o);
    for (let g = s; g < o; ++g)
      l += String.fromCharCode(u[g] & 127);
    return l;
  }
  function D(u, s, o) {
    let l = "";
    o = Math.min(u.length, o);
    for (let g = s; g < o; ++g)
      l += String.fromCharCode(u[g]);
    return l;
  }
  function W(u, s, o) {
    const l = u.length;
    (!s || s < 0) && (s = 0), (!o || o < 0 || o > l) && (o = l);
    let g = "";
    for (let m = s; m < o; ++m)
      g += Es[u[m]];
    return g;
  }
  function ht(u, s, o) {
    const l = u.slice(s, o);
    let g = "";
    for (let m = 0; m < l.length - 1; m += 2)
      g += String.fromCharCode(l[m] + l[m + 1] * 256);
    return g;
  }
  f.prototype.slice = function(s, o) {
    const l = this.length;
    s = ~~s, o = o === void 0 ? l : ~~o, s < 0 ? (s += l, s < 0 && (s = 0)) : s > l && (s = l), o < 0 ? (o += l, o < 0 && (o = 0)) : o > l && (o = l), o < s && (o = s);
    const g = this.subarray(s, o);
    return Object.setPrototypeOf(g, f.prototype), g;
  };
  function G(u, s, o) {
    if (u % 1 !== 0 || u < 0) throw new RangeError("offset is not uint");
    if (u + s > o) throw new RangeError("Trying to access beyond buffer length");
  }
  f.prototype.readUintLE = f.prototype.readUIntLE = function(s, o, l) {
    s = s >>> 0, o = o >>> 0, l || G(s, o, this.length);
    let g = this[s], m = 1, A = 0;
    for (; ++A < o && (m *= 256); )
      g += this[s + A] * m;
    return g;
  }, f.prototype.readUintBE = f.prototype.readUIntBE = function(s, o, l) {
    s = s >>> 0, o = o >>> 0, l || G(s, o, this.length);
    let g = this[s + --o], m = 1;
    for (; o > 0 && (m *= 256); )
      g += this[s + --o] * m;
    return g;
  }, f.prototype.readUint8 = f.prototype.readUInt8 = function(s, o) {
    return s = s >>> 0, o || G(s, 1, this.length), this[s];
  }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(s, o) {
    return s = s >>> 0, o || G(s, 2, this.length), this[s] | this[s + 1] << 8;
  }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(s, o) {
    return s = s >>> 0, o || G(s, 2, this.length), this[s] << 8 | this[s + 1];
  }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(s, o) {
    return s = s >>> 0, o || G(s, 4, this.length), (this[s] | this[s + 1] << 8 | this[s + 2] << 16) + this[s + 3] * 16777216;
  }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(s, o) {
    return s = s >>> 0, o || G(s, 4, this.length), this[s] * 16777216 + (this[s + 1] << 16 | this[s + 2] << 8 | this[s + 3]);
  }, f.prototype.readBigUInt64LE = Gt(function(s) {
    s = s >>> 0, we(s, "offset");
    const o = this[s], l = this[s + 7];
    (o === void 0 || l === void 0) && _e(s, this.length - 8);
    const g = o + this[++s] * 2 ** 8 + this[++s] * 2 ** 16 + this[++s] * 2 ** 24, m = this[++s] + this[++s] * 2 ** 8 + this[++s] * 2 ** 16 + l * 2 ** 24;
    return BigInt(g) + (BigInt(m) << BigInt(32));
  }), f.prototype.readBigUInt64BE = Gt(function(s) {
    s = s >>> 0, we(s, "offset");
    const o = this[s], l = this[s + 7];
    (o === void 0 || l === void 0) && _e(s, this.length - 8);
    const g = o * 2 ** 24 + this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + this[++s], m = this[++s] * 2 ** 24 + this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + l;
    return (BigInt(g) << BigInt(32)) + BigInt(m);
  }), f.prototype.readIntLE = function(s, o, l) {
    s = s >>> 0, o = o >>> 0, l || G(s, o, this.length);
    let g = this[s], m = 1, A = 0;
    for (; ++A < o && (m *= 256); )
      g += this[s + A] * m;
    return m *= 128, g >= m && (g -= Math.pow(2, 8 * o)), g;
  }, f.prototype.readIntBE = function(s, o, l) {
    s = s >>> 0, o = o >>> 0, l || G(s, o, this.length);
    let g = o, m = 1, A = this[s + --g];
    for (; g > 0 && (m *= 256); )
      A += this[s + --g] * m;
    return m *= 128, A >= m && (A -= Math.pow(2, 8 * o)), A;
  }, f.prototype.readInt8 = function(s, o) {
    return s = s >>> 0, o || G(s, 1, this.length), this[s] & 128 ? (255 - this[s] + 1) * -1 : this[s];
  }, f.prototype.readInt16LE = function(s, o) {
    s = s >>> 0, o || G(s, 2, this.length);
    const l = this[s] | this[s + 1] << 8;
    return l & 32768 ? l | 4294901760 : l;
  }, f.prototype.readInt16BE = function(s, o) {
    s = s >>> 0, o || G(s, 2, this.length);
    const l = this[s + 1] | this[s] << 8;
    return l & 32768 ? l | 4294901760 : l;
  }, f.prototype.readInt32LE = function(s, o) {
    return s = s >>> 0, o || G(s, 4, this.length), this[s] | this[s + 1] << 8 | this[s + 2] << 16 | this[s + 3] << 24;
  }, f.prototype.readInt32BE = function(s, o) {
    return s = s >>> 0, o || G(s, 4, this.length), this[s] << 24 | this[s + 1] << 16 | this[s + 2] << 8 | this[s + 3];
  }, f.prototype.readBigInt64LE = Gt(function(s) {
    s = s >>> 0, we(s, "offset");
    const o = this[s], l = this[s + 7];
    (o === void 0 || l === void 0) && _e(s, this.length - 8);
    const g = this[s + 4] + this[s + 5] * 2 ** 8 + this[s + 6] * 2 ** 16 + (l << 24);
    return (BigInt(g) << BigInt(32)) + BigInt(o + this[++s] * 2 ** 8 + this[++s] * 2 ** 16 + this[++s] * 2 ** 24);
  }), f.prototype.readBigInt64BE = Gt(function(s) {
    s = s >>> 0, we(s, "offset");
    const o = this[s], l = this[s + 7];
    (o === void 0 || l === void 0) && _e(s, this.length - 8);
    const g = (o << 24) + // Overflow
    this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + this[++s];
    return (BigInt(g) << BigInt(32)) + BigInt(this[++s] * 2 ** 24 + this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + l);
  }), f.prototype.readFloatLE = function(s, o) {
    return s = s >>> 0, o || G(s, 4, this.length), r.read(this, s, !0, 23, 4);
  }, f.prototype.readFloatBE = function(s, o) {
    return s = s >>> 0, o || G(s, 4, this.length), r.read(this, s, !1, 23, 4);
  }, f.prototype.readDoubleLE = function(s, o) {
    return s = s >>> 0, o || G(s, 8, this.length), r.read(this, s, !0, 52, 8);
  }, f.prototype.readDoubleBE = function(s, o) {
    return s = s >>> 0, o || G(s, 8, this.length), r.read(this, s, !1, 52, 8);
  };
  function $(u, s, o, l, g, m) {
    if (!f.isBuffer(u)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (s > g || s < m) throw new RangeError('"value" argument is out of bounds');
    if (o + l > u.length) throw new RangeError("Index out of range");
  }
  f.prototype.writeUintLE = f.prototype.writeUIntLE = function(s, o, l, g) {
    if (s = +s, o = o >>> 0, l = l >>> 0, !g) {
      const j = Math.pow(2, 8 * l) - 1;
      $(this, s, o, l, j, 0);
    }
    let m = 1, A = 0;
    for (this[o] = s & 255; ++A < l && (m *= 256); )
      this[o + A] = s / m & 255;
    return o + l;
  }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(s, o, l, g) {
    if (s = +s, o = o >>> 0, l = l >>> 0, !g) {
      const j = Math.pow(2, 8 * l) - 1;
      $(this, s, o, l, j, 0);
    }
    let m = l - 1, A = 1;
    for (this[o + m] = s & 255; --m >= 0 && (A *= 256); )
      this[o + m] = s / A & 255;
    return o + l;
  }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 1, 255, 0), this[o] = s & 255, o + 1;
  }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 2, 65535, 0), this[o] = s & 255, this[o + 1] = s >>> 8, o + 2;
  }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 2, 65535, 0), this[o] = s >>> 8, this[o + 1] = s & 255, o + 2;
  }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 4, 4294967295, 0), this[o + 3] = s >>> 24, this[o + 2] = s >>> 16, this[o + 1] = s >>> 8, this[o] = s & 255, o + 4;
  }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 4, 4294967295, 0), this[o] = s >>> 24, this[o + 1] = s >>> 16, this[o + 2] = s >>> 8, this[o + 3] = s & 255, o + 4;
  };
  function Q(u, s, o, l, g) {
    yn(s, l, g, u, o, 7);
    let m = Number(s & BigInt(4294967295));
    u[o++] = m, m = m >> 8, u[o++] = m, m = m >> 8, u[o++] = m, m = m >> 8, u[o++] = m;
    let A = Number(s >> BigInt(32) & BigInt(4294967295));
    return u[o++] = A, A = A >> 8, u[o++] = A, A = A >> 8, u[o++] = A, A = A >> 8, u[o++] = A, o;
  }
  function at(u, s, o, l, g) {
    yn(s, l, g, u, o, 7);
    let m = Number(s & BigInt(4294967295));
    u[o + 7] = m, m = m >> 8, u[o + 6] = m, m = m >> 8, u[o + 5] = m, m = m >> 8, u[o + 4] = m;
    let A = Number(s >> BigInt(32) & BigInt(4294967295));
    return u[o + 3] = A, A = A >> 8, u[o + 2] = A, A = A >> 8, u[o + 1] = A, A = A >> 8, u[o] = A, o + 8;
  }
  f.prototype.writeBigUInt64LE = Gt(function(s, o = 0) {
    return Q(this, s, o, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeBigUInt64BE = Gt(function(s, o = 0) {
    return at(this, s, o, BigInt(0), BigInt("0xffffffffffffffff"));
  }), f.prototype.writeIntLE = function(s, o, l, g) {
    if (s = +s, o = o >>> 0, !g) {
      const rt = Math.pow(2, 8 * l - 1);
      $(this, s, o, l, rt - 1, -rt);
    }
    let m = 0, A = 1, j = 0;
    for (this[o] = s & 255; ++m < l && (A *= 256); )
      s < 0 && j === 0 && this[o + m - 1] !== 0 && (j = 1), this[o + m] = (s / A >> 0) - j & 255;
    return o + l;
  }, f.prototype.writeIntBE = function(s, o, l, g) {
    if (s = +s, o = o >>> 0, !g) {
      const rt = Math.pow(2, 8 * l - 1);
      $(this, s, o, l, rt - 1, -rt);
    }
    let m = l - 1, A = 1, j = 0;
    for (this[o + m] = s & 255; --m >= 0 && (A *= 256); )
      s < 0 && j === 0 && this[o + m + 1] !== 0 && (j = 1), this[o + m] = (s / A >> 0) - j & 255;
    return o + l;
  }, f.prototype.writeInt8 = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 1, 127, -128), s < 0 && (s = 255 + s + 1), this[o] = s & 255, o + 1;
  }, f.prototype.writeInt16LE = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 2, 32767, -32768), this[o] = s & 255, this[o + 1] = s >>> 8, o + 2;
  }, f.prototype.writeInt16BE = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 2, 32767, -32768), this[o] = s >>> 8, this[o + 1] = s & 255, o + 2;
  }, f.prototype.writeInt32LE = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 4, 2147483647, -2147483648), this[o] = s & 255, this[o + 1] = s >>> 8, this[o + 2] = s >>> 16, this[o + 3] = s >>> 24, o + 4;
  }, f.prototype.writeInt32BE = function(s, o, l) {
    return s = +s, o = o >>> 0, l || $(this, s, o, 4, 2147483647, -2147483648), s < 0 && (s = 4294967295 + s + 1), this[o] = s >>> 24, this[o + 1] = s >>> 16, this[o + 2] = s >>> 8, this[o + 3] = s & 255, o + 4;
  }, f.prototype.writeBigInt64LE = Gt(function(s, o = 0) {
    return Q(this, s, o, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), f.prototype.writeBigInt64BE = Gt(function(s, o = 0) {
    return at(this, s, o, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function St(u, s, o, l, g, m) {
    if (o + l > u.length) throw new RangeError("Index out of range");
    if (o < 0) throw new RangeError("Index out of range");
  }
  function J(u, s, o, l, g) {
    return s = +s, o = o >>> 0, g || St(u, s, o, 4), r.write(u, s, o, l, 23, 4), o + 4;
  }
  f.prototype.writeFloatLE = function(s, o, l) {
    return J(this, s, o, !0, l);
  }, f.prototype.writeFloatBE = function(s, o, l) {
    return J(this, s, o, !1, l);
  };
  function ft(u, s, o, l, g) {
    return s = +s, o = o >>> 0, g || St(u, s, o, 8), r.write(u, s, o, l, 52, 8), o + 8;
  }
  f.prototype.writeDoubleLE = function(s, o, l) {
    return ft(this, s, o, !0, l);
  }, f.prototype.writeDoubleBE = function(s, o, l) {
    return ft(this, s, o, !1, l);
  }, f.prototype.copy = function(s, o, l, g) {
    if (!f.isBuffer(s)) throw new TypeError("argument should be a Buffer");
    if (l || (l = 0), !g && g !== 0 && (g = this.length), o >= s.length && (o = s.length), o || (o = 0), g > 0 && g < l && (g = l), g === l || s.length === 0 || this.length === 0) return 0;
    if (o < 0)
      throw new RangeError("targetStart out of bounds");
    if (l < 0 || l >= this.length) throw new RangeError("Index out of range");
    if (g < 0) throw new RangeError("sourceEnd out of bounds");
    g > this.length && (g = this.length), s.length - o < g - l && (g = s.length - o + l);
    const m = g - l;
    return this === s && typeof h.prototype.copyWithin == "function" ? this.copyWithin(o, l, g) : h.prototype.set.call(
      s,
      this.subarray(l, g),
      o
    ), m;
  }, f.prototype.fill = function(s, o, l, g) {
    if (typeof s == "string") {
      if (typeof o == "string" ? (g = o, o = 0, l = this.length) : typeof l == "string" && (g = l, l = this.length), g !== void 0 && typeof g != "string")
        throw new TypeError("encoding must be a string");
      if (typeof g == "string" && !f.isEncoding(g))
        throw new TypeError("Unknown encoding: " + g);
      if (s.length === 1) {
        const A = s.charCodeAt(0);
        (g === "utf8" && A < 128 || g === "latin1") && (s = A);
      }
    } else typeof s == "number" ? s = s & 255 : typeof s == "boolean" && (s = Number(s));
    if (o < 0 || this.length < o || this.length < l)
      throw new RangeError("Out of range index");
    if (l <= o)
      return this;
    o = o >>> 0, l = l === void 0 ? this.length : l >>> 0, s || (s = 0);
    let m;
    if (typeof s == "number")
      for (m = o; m < l; ++m)
        this[m] = s;
    else {
      const A = f.isBuffer(s) ? s : f.from(s, g), j = A.length;
      if (j === 0)
        throw new TypeError('The value "' + s + '" is invalid for argument "value"');
      for (m = 0; m < l - o; ++m)
        this[m + o] = A[m % j];
    }
    return this;
  };
  const Rt = {};
  function pe(u, s, o) {
    Rt[u] = class extends o {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: s.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${u}]`, this.stack, delete this.name;
      }
      get code() {
        return u;
      }
      set code(g) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: g,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${u}]: ${this.message}`;
      }
    };
  }
  pe(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(u) {
      return u ? `${u} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), pe(
    "ERR_INVALID_ARG_TYPE",
    function(u, s) {
      return `The "${u}" argument must be of type number. Received type ${typeof s}`;
    },
    TypeError
  ), pe(
    "ERR_OUT_OF_RANGE",
    function(u, s, o) {
      let l = `The value of "${u}" is out of range.`, g = o;
      return Number.isInteger(o) && Math.abs(o) > 2 ** 32 ? g = Ce(String(o)) : typeof o == "bigint" && (g = String(o), (o > BigInt(2) ** BigInt(32) || o < -(BigInt(2) ** BigInt(32))) && (g = Ce(g)), g += "n"), l += ` It must be ${s}. Received ${g}`, l;
    },
    RangeError
  );
  function Ce(u) {
    let s = "", o = u.length;
    const l = u[0] === "-" ? 1 : 0;
    for (; o >= l + 4; o -= 3)
      s = `_${u.slice(o - 3, o)}${s}`;
    return `${u.slice(0, o)}${s}`;
  }
  function ws(u, s, o) {
    we(s, "offset"), (u[s] === void 0 || u[s + o] === void 0) && _e(s, u.length - (o + 1));
  }
  function yn(u, s, o, l, g, m) {
    if (u > o || u < s) {
      const A = typeof s == "bigint" ? "n" : "";
      let j;
      throw s === 0 || s === BigInt(0) ? j = `>= 0${A} and < 2${A} ** ${(m + 1) * 8}${A}` : j = `>= -(2${A} ** ${(m + 1) * 8 - 1}${A}) and < 2 ** ${(m + 1) * 8 - 1}${A}`, new Rt.ERR_OUT_OF_RANGE("value", j, u);
    }
    ws(l, g, m);
  }
  function we(u, s) {
    if (typeof u != "number")
      throw new Rt.ERR_INVALID_ARG_TYPE(s, "number", u);
  }
  function _e(u, s, o) {
    throw Math.floor(u) !== u ? (we(u, o), new Rt.ERR_OUT_OF_RANGE("offset", "an integer", u)) : s < 0 ? new Rt.ERR_BUFFER_OUT_OF_BOUNDS() : new Rt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${s}`,
      u
    );
  }
  const gs = /[^+/0-9A-Za-z-_]/g;
  function ys(u) {
    if (u = u.split("=")[0], u = u.trim().replace(gs, ""), u.length < 2) return "";
    for (; u.length % 4 !== 0; )
      u = u + "=";
    return u;
  }
  function Sr(u, s) {
    s = s || 1 / 0;
    let o;
    const l = u.length;
    let g = null;
    const m = [];
    for (let A = 0; A < l; ++A) {
      if (o = u.charCodeAt(A), o > 55295 && o < 57344) {
        if (!g) {
          if (o > 56319) {
            (s -= 3) > -1 && m.push(239, 191, 189);
            continue;
          } else if (A + 1 === l) {
            (s -= 3) > -1 && m.push(239, 191, 189);
            continue;
          }
          g = o;
          continue;
        }
        if (o < 56320) {
          (s -= 3) > -1 && m.push(239, 191, 189), g = o;
          continue;
        }
        o = (g - 55296 << 10 | o - 56320) + 65536;
      } else g && (s -= 3) > -1 && m.push(239, 191, 189);
      if (g = null, o < 128) {
        if ((s -= 1) < 0) break;
        m.push(o);
      } else if (o < 2048) {
        if ((s -= 2) < 0) break;
        m.push(
          o >> 6 | 192,
          o & 63 | 128
        );
      } else if (o < 65536) {
        if ((s -= 3) < 0) break;
        m.push(
          o >> 12 | 224,
          o >> 6 & 63 | 128,
          o & 63 | 128
        );
      } else if (o < 1114112) {
        if ((s -= 4) < 0) break;
        m.push(
          o >> 18 | 240,
          o >> 12 & 63 | 128,
          o >> 6 & 63 | 128,
          o & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return m;
  }
  function ms(u) {
    const s = [];
    for (let o = 0; o < u.length; ++o)
      s.push(u.charCodeAt(o) & 255);
    return s;
  }
  function bs(u, s) {
    let o, l, g;
    const m = [];
    for (let A = 0; A < u.length && !((s -= 2) < 0); ++A)
      o = u.charCodeAt(A), l = o >> 8, g = o % 256, m.push(g), m.push(l);
    return m;
  }
  function mn(u) {
    return t.toByteArray(ys(u));
  }
  function Ge(u, s, o, l) {
    let g;
    for (g = 0; g < l && !(g + o >= s.length || g >= u.length); ++g)
      s[g + o] = u[g];
    return g;
  }
  function Lt(u, s) {
    return u instanceof s || u != null && u.constructor != null && u.constructor.name != null && u.constructor.name === s.name;
  }
  function Tr(u) {
    return u !== u;
  }
  const Es = (function() {
    const u = "0123456789abcdef", s = new Array(256);
    for (let o = 0; o < 16; ++o) {
      const l = o * 16;
      for (let g = 0; g < 16; ++g)
        s[l + g] = u[o] + u[g];
    }
    return s;
  })();
  function Gt(u) {
    return typeof BigInt > "u" ? As : u;
  }
  function As() {
    throw new Error("BigInt not supported");
  }
})(pi);
const go = pi.Buffer;
function yo(e, t, r) {
  t = t || 4, r = r === void 0 ? !0 : r;
  const n = e.length;
  if (n === 0) return 0;
  if (n > t) throw new TypeError("Script number overflow");
  if (r && (e[n - 1] & 127) === 0 && (n <= 1 || (e[n - 2] & 128) === 0))
    throw new Error("Non-minimally encoded script number");
  if (n === 5) {
    const h = e.readUInt32LE(0), a = e.readUInt8(4);
    return a & 128 ? -((a & -129) * 4294967296 + h) : a * 4294967296 + h;
  }
  let i = 0;
  for (let h = 0; h < n; ++h)
    i |= e[h] << 8 * h;
  return e[n - 1] & 128 ? -(i & ~(128 << 8 * (n - 1))) : i;
}
function mo(e) {
  return e > 2147483647 ? 5 : e > 8388607 ? 4 : e > 32767 ? 3 : e > 127 ? 2 : e > 0 ? 1 : 0;
}
function gi(e) {
  let t = Math.abs(e);
  const r = mo(t), n = go.allocUnsafe(r), i = e < 0;
  for (let h = 0; h < r; ++h)
    n.writeUInt8(t & 255, h), t >>= 8;
  return n[r - 1] & 128 ? n.writeUInt8(i ? 128 : 0, r - 1) : i && (n[r - 1] = n[r - 1] | 128), n;
}
const bo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: yo,
  encode: gi
}, Symbol.toStringTag, { value: "Module" })), ir = ne("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), yi = ne("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Mr = 21n * 10n ** 14n, ue = 254;
function Eo(e) {
  return typeof e == "number" && Number.isInteger(e) && e >= 0 && e <= 255;
}
function Ao(e) {
  return typeof e == "number" && Number.isFinite(e);
}
function Io(e, t) {
  return e instanceof Uint8Array && e.length === t;
}
function rn(e) {
  return Array.isArray(e);
}
function vo(e) {
  return typeof e != "string" || e.length % 2 !== 0 ? !1 : /^[0-9a-fA-F]*$/.test(e);
}
function So(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function To(e) {
  return e instanceof Uint8Array && e.length === 20;
}
function Bo(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 || Oe(e) ? !1 : Kt(e, ir) < 0;
}
function le(e) {
  if (!(e instanceof Uint8Array) || e.length < 33) return !1;
  const t = e[0], r = e.subarray(1, 33);
  if (Oe(r) || Kt(r, ir) >= 0) return !1;
  if ((t === 2 || t === 3) && e.length === 33)
    return !0;
  if (e.length !== 65) return !1;
  const n = e.subarray(33);
  return Oe(n) || Kt(n, ir) >= 0 ? !1 : t === 4 || t === 6 || t === 7;
}
function ou(e) {
  return typeof e == "bigint" && e >= 0n && e <= Mr;
}
function hu(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 || Oe(e) ? !1 : Kt(e, yi) < 0;
}
function au(e) {
  return e instanceof Uint8Array && e.length === 64;
}
function uu(e) {
  return e instanceof Uint8Array && e.length >= 8 && e.length <= 73;
}
function fu(e) {
  return e instanceof Uint8Array;
}
function yr(e) {
  if (!e || typeof e != "object") return !1;
  const t = e;
  return !(!("output" in t) || !(t.output instanceof Uint8Array) || t.version !== void 0 && (typeof t.version != "number" || (t.version & ue) !== t.version));
}
function mi(e) {
  return Array.isArray(e) ? e.length !== 2 ? !1 : e.every((t) => mi(t)) : yr(e);
}
function ke(e, t) {
  return e.length !== t.length ? !1 : e.every((r, n) => H(r, t[n]));
}
function cu(e) {
  if (!So(e))
    throw new TypeError(`Expected 32-byte Uint8Array, got ${e.length} bytes`);
  return e;
}
function xo(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function tr(e) {
  if (!xo(e))
    throw new TypeError(`Expected 32-byte Uint8Array, got ${e.length} bytes`);
  return e;
}
function lu(e) {
  if (!To(e))
    throw new TypeError(`Expected 20-byte Uint8Array, got ${e.length} bytes`);
  return e;
}
function du(e) {
  if (e < 0n)
    throw new RangeError(`Satoshi cannot be negative, got ${e}`);
  if (e > Mr)
    throw new RangeError(`Satoshi exceeds maximum supply (${Mr}), got ${e}`);
  return e;
}
function pu(e, t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError(`${t} must be Uint8Array, got ${typeof e}`);
  if (e.length !== 32)
    throw new TypeError(`${t} must be 32 bytes, got ${e.length}`);
  if (Oe(e))
    throw new RangeError(`${t} cannot be zero`);
  if (Kt(e, ir) >= 0)
    throw new RangeError(`${t} exceeds curve order`);
}
function wu(e, t) {
  if (!(e instanceof Uint8Array))
    throw new TypeError(`${t} must be Uint8Array, got ${typeof e}`);
  if (e.length !== 32)
    throw new TypeError(`${t} must be 32 bytes, got ${e.length}`);
  if (Oe(e))
    throw new RangeError(`${t} cannot be zero`);
  if (Kt(e, yi) >= 0)
    throw new RangeError(`${t} exceeds curve order`);
}
const An = new Uint8Array([0]);
function mr(e) {
  const t = e & -129;
  return t > 0 && t < 4;
}
function In(e) {
  let t = 0;
  for (; e[t] === 0; ) ++t;
  return t === e.length ? An : (e = e.subarray(t), e[0] & 128 ? vt([An, e]) : e);
}
function vn(e) {
  e[0] === 0 && (e = e.subarray(1));
  const t = wt(32), r = Math.max(0, 32 - e.length);
  return t.set(e, r), t;
}
function Uo(e) {
  const t = e[e.length - 1];
  if (!mr(t))
    throw new Error(`Invalid hashType ${t}`);
  const r = no(e.subarray(0, -1)), n = vn(r.r), i = vn(r.s);
  return { signature: vt([n, i]), hashType: t };
}
function Oo(e, t) {
  if (!Io(e, 64))
    throw new TypeError("Expected signature to be a 64-byte Uint8Array");
  if (!Eo(t))
    throw new TypeError("Expected hashType to be a UInt8");
  if (!mr(t))
    throw new Error(`Invalid hashType ${t}`);
  const r = new Uint8Array([t]), n = In(e.subarray(0, 32)), i = In(e.subarray(32, 64));
  return vt([io(n, i), r]);
}
const ko = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Uo,
  encode: Oo,
  isDefinedHashType: mr
}, Symbol.toStringTag, { value: "Module" })), bi = z.OP_RESERVED;
function Po(e) {
  return Ao(e) && (e === z.OP_0 || e >= z.OP_1 && e <= z.OP_16 || e === z.OP_1NEGATE);
}
function Ei(e) {
  return e instanceof Uint8Array ? !0 : Po(e);
}
function br(e) {
  return rn(e) && e.every(Ei);
}
function nn(e) {
  return e.length - e.filter(Ei).length;
}
function sr(e) {
  if (e.length === 0) return z.OP_0;
  if (e.length !== 1) return;
  const t = e[0];
  if (t >= 1 && t <= 16) return bi + t;
  if (t === 129) return z.OP_1NEGATE;
}
function sn(e) {
  return e instanceof Uint8Array;
}
function Ro(e) {
  return rn(e);
}
function or(e) {
  return e instanceof Uint8Array;
}
function dt(e) {
  if (sn(e)) return e;
  if (!rn(e))
    throw new TypeError("Expected an array");
  const t = e.reduce((i, h) => or(h) ? h.length === 1 && sr(h) !== void 0 ? i + 1 : i + di(h.length) + h.length : i + 1, 0), r = new Uint8Array(t);
  let n = 0;
  if (e.forEach((i) => {
    if (or(i)) {
      const h = sr(i);
      if (h !== void 0) {
        r[n] = h, n += 1;
        return;
      }
      n += so(r, i.length, n), r.set(i, n), n += i.length;
    } else
      r[n] = i, n += 1;
  }), n !== r.length) throw new Error("Could not decode chunks");
  return r;
}
function it(e) {
  if (Ro(e)) return e;
  if (!(e instanceof Uint8Array))
    throw new TypeError("Expected a Uint8Array");
  const t = [];
  let r = 0;
  for (; r < e.length; ) {
    const n = e[r];
    if (n > z.OP_0 && n <= z.OP_PUSHDATA4) {
      const i = oo(e, r);
      if (i === null || (r += i.size, r + i.number > e.length)) return null;
      const h = e.subarray(r, r + i.number);
      r += i.number;
      const a = sr(h);
      a !== void 0 ? t.push(a) : t.push(h);
    } else
      t.push(n), r += 1;
  }
  return t;
}
function Ho(e) {
  let t;
  if (sn(e)) {
    const r = it(e);
    if (!r)
      throw new Error("Could not convert invalid chunks to ASM");
    t = r;
  } else
    t = e;
  return t.map((r) => {
    if (or(r)) {
      const n = sr(r);
      if (n === void 0) return xe(r);
      r = n;
    }
    return li()[r];
  }).join(" ");
}
function Lo(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return dt(
    e.split(" ").map((t) => {
      if (z[t] !== void 0)
        return z[t];
      if (!vo(t))
        throw new TypeError("Expected hex string");
      return ne(t);
    })
  );
}
function Ai(e) {
  const t = sn(e) ? it(e) : e;
  if (!t || !br(t))
    throw new TypeError("Expected push-only script");
  return t.map((r) => or(r) ? r : r === z.OP_0 ? wt(0) : gi(r - bi));
}
function Co(e) {
  return le(e);
}
function Le(e) {
  return !(e instanceof Uint8Array) || !mr(e[e.length - 1]) ? !1 : ro(e.subarray(0, -1));
}
const _o = bo, on = ko, gu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compile: dt,
  countNonPushOnlyOPs: nn,
  decompile: it,
  fromASM: Lo,
  isCanonicalPubKey: Co,
  isCanonicalScriptSignature: Le,
  isPushOnly: br,
  number: _o,
  opcodes: z,
  signature: on,
  toASM: Ho,
  toStack: Ai
}, Symbol.toStringTag, { value: "Module" })), ct = {
  P2PK: "p2pk",
  P2PKH: "p2pkh",
  P2SH: "p2sh",
  P2MS: "p2ms",
  P2WPKH: "p2wpkh",
  P2WSH: "p2wsh",
  P2TR: "p2tr",
  P2MR: "p2mr",
  P2OP: "p2op",
  Embed: "embed",
  ScriptRedeem: "scriptRedeem"
}, Sn = z, Tn = 16, Bn = 2, xn = 40;
class me {
  // Static public fields
  static NAME = ct.P2OP;
  // Private instance fields
  #e;
  #h;
  // Input data (provided by user)
  #t;
  #s;
  #n;
  #r;
  #i;
  // Cached computed values
  #o;
  #a;
  #f;
  #u;
  #c;
  // Cache flags
  #p = !1;
  #w = !1;
  #l = !1;
  #d = !1;
  #g = !1;
  // Decoded address cache
  #y;
  #b = !1;
  /**
   * Creates a new P2OP payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32m encoded OPNet address
   * @param params.program - Witness program (2-40 bytes)
   * @param params.deploymentVersion - Deployment version (0-255)
   * @param params.hash160 - 20-byte hash
   * @param params.output - The scriptPubKey
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    this.#e = t.network ?? Mt, this.#h = {
      validate: r?.validate ?? !0,
      allowIncomplete: r?.allowIncomplete ?? !1
    }, this.#t = t.address, this.#s = t.program, this.#n = t.deploymentVersion, this.#r = t.hash160, this.#i = t.output, this.#h.validate && this.#B();
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ct.P2OP;
  }
  /**
   * Network parameters.
   */
  get network() {
    return this.#e;
  }
  /**
   * Bech32m encoded OPNet address.
   */
  get address() {
    return this.#p || (this.#o = this.#I(), this.#p = !0), this.#o;
  }
  /**
   * Witness program (2-40 bytes).
   * Format: `{deploymentVersion:uint8}{hash160:20-bytes|...}`
   */
  get program() {
    return this.#w || (this.#a = this.#m(), this.#w = !0), this.#a;
  }
  /**
   * Deployment version (first byte of program).
   */
  get deploymentVersion() {
    return this.#l || (this.#f = this.#S(), this.#l = !0), this.#f;
  }
  /**
   * Hash160 (remaining bytes of program).
   */
  get hash160() {
    return this.#d || (this.#u = this.#v(), this.#d = !0), this.#u;
  }
  /**
   * The scriptPubKey: `OP_16 {program}`
   */
  get output() {
    return this.#g || (this.#c = this.#T(), this.#g = !0), this.#c;
  }
  // Static factory methods
  /**
   * Creates a P2OP payment from a witness program.
   *
   * @param program - Witness program (2-40 bytes)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromProgram(t, r) {
    return new me({ program: t, network: r });
  }
  /**
   * Creates a P2OP payment from deployment version and hash160.
   *
   * @param deploymentVersion - Deployment version (0-255)
   * @param hash160 - 20-byte hash
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromParts(t, r, n) {
    return new me({ deploymentVersion: t, hash160: r, network: n });
  }
  /**
   * Creates a P2OP payment from an OPNet address.
   *
   * @param address - Bech32m encoded OPNet address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromAddress(t, r) {
    return new me({ address: t, network: r });
  }
  /**
   * Creates a P2OP payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2OP payment instance
   */
  static fromOutput(t, r) {
    return new me({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2OPPayment object for backwards compatibility.
   *
   * @returns A P2OPPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      program: this.program,
      deploymentVersion: this.deploymentVersion,
      hash160: this.hash160,
      output: this.output
    };
  }
  #E() {
    if (!this.#b) {
      if (this.#t) {
        const t = Yr(this.#t);
        t && (this.#y = {
          version: t.version,
          prefix: t.prefix,
          data: t.data
        });
      }
      this.#b = !0;
    }
    return this.#y;
  }
  // Private computation methods
  #A() {
    if (typeof this.#n < "u" && typeof this.#r < "u") {
      if (this.#r.length !== 20)
        throw new TypeError("hash160 must be exactly 20 bytes");
      if (this.#n < 0 || this.#n > 255)
        throw new TypeError("deploymentVersion must fit in one byte");
      return vt([new Uint8Array([this.#n]), this.#r]);
    }
  }
  #I() {
    if (this.#t)
      return this.#t;
    const t = this.program;
    if (!t) return;
    if (!this.#e.bech32Opnet)
      throw new TypeError("Network does not support opnet");
    const r = lt.bech32m.toWords(t);
    return r.unshift(Tn), lt.bech32m.encode(this.#e.bech32Opnet, r);
  }
  #m() {
    if (this.#s)
      return this.#s;
    const t = this.#A();
    if (t)
      return t;
    if (this.#i) {
      if (this.#i[0] !== Sn.OP_16)
        throw new TypeError("Invalid P2OP script");
      let r = 1, n;
      const i = this.#i[1], h = this.#i[2];
      if (i !== void 0 && i < 76)
        n = i, r = 2;
      else if (i === 76 && h !== void 0)
        n = h, r = 3;
      else
        throw new TypeError("Unsupported push opcode in P2OP script");
      return this.#i.subarray(r, r + n);
    }
    if (this.#t)
      return this.#E()?.data;
  }
  #S() {
    if (this.#n !== void 0)
      return this.#n;
    const t = this.program;
    if (t)
      return t[0];
  }
  #v() {
    if (this.#r)
      return this.#r;
    const t = this.program;
    if (t)
      return t.subarray(1);
  }
  // Validation
  #T() {
    if (this.#i)
      return this.#i;
    const t = this.program;
    if (t)
      return dt([Sn.OP_16, t]);
  }
  #B() {
    let t = wt(0);
    if (this.#t) {
      const r = this.#E();
      if (!r)
        throw new TypeError("Invalid address");
      if (this.#e.bech32Opnet !== r.prefix)
        throw new TypeError("Invalid prefix or network mismatch");
      if (r.version !== Tn)
        throw new TypeError("Invalid witness version for p2op");
      if (r.data.length < Bn || r.data.length > xn)
        throw new TypeError("Invalid witness program length");
      t = r.data;
    }
    if (this.#s) {
      if (t.length > 0 && !H(t, this.#s))
        throw new TypeError("Program mismatch");
      t = this.#s;
    }
    if (!t.length && this.#n !== void 0 && this.#r) {
      const r = this.#A();
      r && (t = r);
    }
    if (this.#i) {
      const r = this.program;
      if (!r)
        throw new TypeError("Output program is required");
      if (t.length > 0 && !H(t, r))
        throw new TypeError("Program mismatch (output vs other source)");
      t = r;
    }
    if (t.length < Bn || t.length > xn)
      throw new TypeError(`Witness program must be 240 bytes. Was ${t.length} bytes`);
    if (this.#n !== void 0 && this.#n !== t[0])
      throw new TypeError("deploymentVersion mismatch");
    if (this.#r && !H(this.#r, t.subarray(1)))
      throw new TypeError("hash160 mismatch");
  }
}
function No(e, t) {
  if (!e.address && !e.output && !e.program && (typeof e.deploymentVersion > "u" || !e.hash160))
    throw new TypeError("At least one of address, output or program must be provided");
  const r = new me(
    {
      address: e.address,
      program: e.program,
      deploymentVersion: e.deploymentVersion,
      hash160: e.hash160,
      output: e.output,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
const Ne = /* @__PURE__ */ Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), zt = /* @__PURE__ */ new Uint32Array(80);
class Vo extends tn {
  A = Ne[0] | 0;
  B = Ne[1] | 0;
  C = Ne[2] | 0;
  D = Ne[3] | 0;
  E = Ne[4] | 0;
  constructor() {
    super(64, 20, 8, !1);
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: h } = this;
    return [t, r, n, i, h];
  }
  set(t, r, n, i, h) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = h | 0;
  }
  process(t, r) {
    for (let d = 0; d < 16; d++, r += 4)
      zt[d] = t.getUint32(r, !1);
    for (let d = 16; d < 80; d++)
      zt[d] = oe(zt[d - 3] ^ zt[d - 8] ^ zt[d - 14] ^ zt[d - 16], 1);
    let { A: n, B: i, C: h, D: a, E: c } = this;
    for (let d = 0; d < 80; d++) {
      let p, f;
      d < 20 ? (p = ai(i, h, a), f = 1518500249) : d < 40 ? (p = i ^ h ^ a, f = 1859775393) : d < 60 ? (p = ui(i, h, a), f = 2400959708) : (p = i ^ h ^ a, f = 3395469782);
      const w = oe(n, 5) + p + c + f + zt[d] | 0;
      c = a, a = h, h = oe(i, 30), i = n, n = w;
    }
    n = n + this.A | 0, i = i + this.B | 0, h = h + this.C | 0, a = a + this.D | 0, c = c + this.E | 0, this.set(n, i, h, a, c);
  }
  roundClean() {
    ce(zt);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), ce(this.buffer);
  }
}
const Mo = /* @__PURE__ */ Jr(() => new Vo()), Fo = /* @__PURE__ */ Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]), Ii = Uint8Array.from(new Array(16).fill(0).map((e, t) => t)), $o = Ii.map((e) => (9 * e + 5) % 16), vi = /* @__PURE__ */ (() => {
  const r = [[Ii], [$o]];
  for (let n = 0; n < 4; n++)
    for (let i of r)
      i.push(i[n].map((h) => Fo[h]));
  return r;
})(), Si = vi[0], Ti = vi[1], Bi = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((e) => Uint8Array.from(e)), Do = /* @__PURE__ */ Si.map((e, t) => e.map((r) => Bi[t][r])), Ko = /* @__PURE__ */ Ti.map((e, t) => e.map((r) => Bi[t][r])), Wo = /* @__PURE__ */ Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Go = /* @__PURE__ */ Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function Un(e, t, r, n) {
  return e === 0 ? t ^ r ^ n : e === 1 ? t & r | ~t & n : e === 2 ? (t | ~r) ^ n : e === 3 ? t & n | r & ~n : t ^ (r | ~n);
}
const qe = /* @__PURE__ */ new Uint32Array(16);
class jo extends tn {
  h0 = 1732584193;
  h1 = -271733879;
  h2 = -1732584194;
  h3 = 271733878;
  h4 = -1009589776;
  constructor() {
    super(64, 20, 8, !0);
  }
  get() {
    const { h0: t, h1: r, h2: n, h3: i, h4: h } = this;
    return [t, r, n, i, h];
  }
  set(t, r, n, i, h) {
    this.h0 = t | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = h | 0;
  }
  process(t, r) {
    for (let y = 0; y < 16; y++, r += 4)
      qe[y] = t.getUint32(r, !0);
    let n = this.h0 | 0, i = n, h = this.h1 | 0, a = h, c = this.h2 | 0, d = c, p = this.h3 | 0, f = p, w = this.h4 | 0, b = w;
    for (let y = 0; y < 5; y++) {
      const I = 4 - y, E = Wo[y], T = Go[y], O = Si[y], k = Ti[y], P = Do[y], x = Ko[y];
      for (let K = 0; K < 16; K++) {
        const tt = oe(n + Un(y, h, c, p) + qe[O[K]] + E, P[K]) + w | 0;
        n = w, w = p, p = oe(c, 10) | 0, c = h, h = tt;
      }
      for (let K = 0; K < 16; K++) {
        const tt = oe(i + Un(I, a, d, f) + qe[k[K]] + T, x[K]) + b | 0;
        i = b, b = f, f = oe(d, 10) | 0, d = a, a = tt;
      }
    }
    this.set(this.h1 + c + f | 0, this.h2 + p + b | 0, this.h3 + w + i | 0, this.h4 + n + a | 0, this.h0 + h + d | 0);
  }
  roundClean() {
    ce(qe);
  }
  destroy() {
    this.destroyed = !0, ce(this.buffer), this.set(0, 0, 0, 0, 0);
  }
}
const xi = /* @__PURE__ */ Jr(() => new jo());
function qo(e) {
  return xi(e);
}
function zo(e) {
  return Mo(e);
}
function pt(e) {
  return Ue(e);
}
function yt(e) {
  return xi(Ue(e));
}
function Jt(e) {
  return Ue(Ue(e));
}
const Zo = [
  "BIP0340/challenge",
  "BIP0340/aux",
  "BIP0340/nonce",
  "TapLeaf",
  "TapBranch",
  "TapSighash",
  "TapTweak",
  "KeyAgg list",
  "KeyAgg coefficient"
], Ui = {
  "BIP0340/challenge": new Uint8Array([
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124,
    123,
    181,
    45,
    122,
    159,
    239,
    88,
    50,
    62,
    177,
    191,
    122,
    64,
    125,
    179,
    130,
    210,
    243,
    242,
    216,
    27,
    177,
    34,
    79,
    73,
    254,
    81,
    143,
    109,
    72,
    211,
    124
  ]),
  "BIP0340/aux": new Uint8Array([
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144,
    241,
    239,
    78,
    94,
    192,
    99,
    202,
    218,
    109,
    148,
    202,
    250,
    157,
    152,
    126,
    160,
    105,
    38,
    88,
    57,
    236,
    193,
    31,
    151,
    45,
    119,
    165,
    46,
    216,
    193,
    204,
    144
  ]),
  "BIP0340/nonce": new Uint8Array([
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47,
    7,
    73,
    119,
    52,
    167,
    155,
    203,
    53,
    91,
    155,
    140,
    125,
    3,
    79,
    18,
    28,
    244,
    52,
    215,
    62,
    247,
    45,
    218,
    25,
    135,
    0,
    97,
    251,
    82,
    191,
    235,
    47
  ]),
  TapLeaf: new Uint8Array([
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238,
    174,
    234,
    143,
    220,
    66,
    8,
    152,
    49,
    5,
    115,
    75,
    88,
    8,
    29,
    30,
    38,
    56,
    211,
    95,
    28,
    181,
    64,
    8,
    212,
    211,
    87,
    202,
    3,
    190,
    120,
    233,
    238
  ]),
  TapBranch: new Uint8Array([
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21,
    25,
    65,
    161,
    242,
    229,
    110,
    185,
    95,
    162,
    169,
    241,
    148,
    190,
    92,
    1,
    247,
    33,
    111,
    51,
    237,
    130,
    176,
    145,
    70,
    52,
    144,
    208,
    91,
    245,
    22,
    160,
    21
  ]),
  TapSighash: new Uint8Array([
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49,
    244,
    10,
    72,
    223,
    75,
    42,
    112,
    200,
    180,
    146,
    75,
    242,
    101,
    70,
    97,
    237,
    61,
    149,
    253,
    102,
    163,
    19,
    235,
    135,
    35,
    117,
    151,
    198,
    40,
    228,
    160,
    49
  ]),
  TapTweak: new Uint8Array([
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233,
    232,
    15,
    225,
    99,
    156,
    156,
    160,
    80,
    227,
    175,
    27,
    57,
    193,
    67,
    198,
    62,
    66,
    156,
    188,
    235,
    21,
    217,
    64,
    251,
    181,
    197,
    161,
    244,
    175,
    87,
    197,
    233
  ]),
  "KeyAgg list": new Uint8Array([
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240,
    72,
    28,
    151,
    28,
    60,
    11,
    70,
    215,
    240,
    178,
    117,
    174,
    89,
    141,
    78,
    44,
    126,
    215,
    49,
    156,
    89,
    74,
    92,
    110,
    199,
    158,
    160,
    212,
    153,
    2,
    148,
    240
  ]),
  "KeyAgg coefficient": new Uint8Array([
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129,
    191,
    201,
    4,
    3,
    77,
    28,
    136,
    232,
    200,
    14,
    34,
    229,
    61,
    36,
    86,
    109,
    100,
    130,
    78,
    214,
    66,
    114,
    129,
    192,
    145,
    0,
    249,
    77,
    205,
    82,
    201,
    129
  ])
};
function We(e, t) {
  return pt(vt([Ui[e], t]));
}
const yu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TAGGED_HASH_PREFIXES: Ui,
  TAGS: Zo,
  hash160: yt,
  hash256: Jt,
  ripemd160: qo,
  sha1: zo,
  sha256: pt,
  taggedHash: We
}, Symbol.toStringTag, { value: "Module" }));
const Oi = {
  p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
  n: 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,
  h: 1n,
  a: 0n,
  b: 7n,
  Gx: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
  Gy: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n
}, { p: fe, n: Yo, Gx: Xo, Gy: Qo, b: ki } = Oi, Fr = 32, hn = 64, Jo = {
  publicKey: Fr + 1,
  publicKeyUncompressed: hn + 1
}, th = (...e) => {
  "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(...e);
}, It = (e = "") => {
  const t = new Error(e);
  throw th(t, It), t;
}, eh = (e) => typeof e == "bigint", rh = (e) => typeof e == "string", nh = (e) => e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array", an = (e, t, r = "") => {
  const n = nh(e), i = e?.length, h = t !== void 0;
  if (!n || h && i !== t) {
    const a = r && `"${r}" `, c = h ? ` of length ${t}` : "", d = n ? `length=${i}` : `type=${typeof e}`;
    It(a + "expected Uint8Array" + c + ", got " + d);
  }
  return e;
}, Pi = (e) => new Uint8Array(e), Ri = (e, t) => e.toString(16).padStart(t, "0"), Hi = (e) => Array.from(an(e)).map((t) => Ri(t, 2)).join(""), Ft = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }, On = (e) => {
  if (e >= Ft._0 && e <= Ft._9)
    return e - Ft._0;
  if (e >= Ft.A && e <= Ft.F)
    return e - (Ft.A - 10);
  if (e >= Ft.a && e <= Ft.f)
    return e - (Ft.a - 10);
}, Li = (e) => {
  const t = "hex invalid";
  if (!rh(e))
    return It(t);
  const r = e.length, n = r / 2;
  if (r % 2)
    return It(t);
  const i = Pi(n);
  for (let h = 0, a = 0; h < n; h++, a += 2) {
    const c = On(e.charCodeAt(a)), d = On(e.charCodeAt(a + 1));
    if (c === void 0 || d === void 0)
      return It(t);
    i[h] = c * 16 + d;
  }
  return i;
}, kn = (...e) => {
  const t = Pi(e.reduce((n, i) => n + an(i).length, 0));
  let r = 0;
  return e.forEach((n) => {
    t.set(n, r), r += n.length;
  }), t;
}, hr = BigInt, Er = (e, t, r, n = "bad number: out of range") => eh(e) && t <= e && e < r ? e : It(n), R = (e, t = fe) => {
  const r = e % t;
  return r >= 0n ? r : t + r;
}, ih = (e, t) => {
  (e === 0n || t <= 0n) && It("no inverse n=" + e + " mod=" + t);
  let r = R(e, t), n = t, i = 0n, h = 1n;
  for (; r !== 0n; ) {
    const a = n / r, c = n % r, d = i - h * a;
    n = r, r = c, i = h, h = d;
  }
  return n === 1n ? R(i, t) : It("no inverse");
}, Or = (e) => e instanceof Tt ? e : It("Point expected"), Ci = (e) => R(R(e * e) * e + ki), Pn = (e) => Er(e, 0n, fe), er = (e) => Er(e, 1n, fe), sh = (e) => Er(e, 1n, Yo), $r = (e) => (e & 1n) === 0n, _i = (e) => Uint8Array.of(e), oh = (e) => _i($r(e) ? 2 : 3), hh = (e) => {
  const t = Ci(er(e));
  let r = 1n;
  for (let n = t, i = (fe + 1n) / 4n; i > 0n; i >>= 1n)
    i & 1n && (r = r * n % fe), n = n * n % fe;
  return R(r * r) === t ? r : It("sqrt invalid");
};
class Tt {
  static BASE;
  static ZERO;
  X;
  Y;
  Z;
  constructor(t, r, n) {
    this.X = Pn(t), this.Y = er(r), this.Z = Pn(n), Object.freeze(this);
  }
  static CURVE() {
    return Oi;
  }
  /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */
  static fromAffine(t) {
    const { x: r, y: n } = t;
    return r === 0n && n === 0n ? se : new Tt(r, n, 1n);
  }
  /** Convert Uint8Array or hex string to Point. */
  static fromBytes(t) {
    an(t);
    const { publicKey: r, publicKeyUncompressed: n } = Jo;
    let i;
    const h = t.length, a = t[0], c = t.subarray(1), d = Rn(c, 0, Fr);
    if (h === r && (a === 2 || a === 3)) {
      let p = hh(d);
      const f = $r(p);
      $r(hr(a)) !== f && (p = R(-p)), i = new Tt(d, p, 1n);
    }
    return h === n && a === 4 && (i = new Tt(d, Rn(c, Fr, hn), 1n)), i ? i.assertValidity() : It("bad point: not on curve");
  }
  static fromHex(t) {
    return Tt.fromBytes(Li(t));
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  /** Equality check: compare points P&Q. */
  equals(t) {
    const { X: r, Y: n, Z: i } = this, { X: h, Y: a, Z: c } = Or(t), d = R(r * c), p = R(h * i), f = R(n * c), w = R(a * i);
    return d === p && f === w;
  }
  is0() {
    return this.equals(se);
  }
  /** Flip point over y coordinate. */
  negate() {
    return new Tt(this.X, R(-this.Y), this.Z);
  }
  /** Point doubling: P+P, complete formula. */
  double() {
    return this.add(this);
  }
  /**
   * Point addition: P+Q, complete, exception-free formula
   * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).
   * Cost: `12M + 0S + 3*a + 3*b3 + 23add`.
   */
  // prettier-ignore
  add(t) {
    const { X: r, Y: n, Z: i } = this, { X: h, Y: a, Z: c } = Or(t), d = 0n, p = ki;
    let f = 0n, w = 0n, b = 0n;
    const y = R(p * 3n);
    let I = R(r * h), E = R(n * a), T = R(i * c), O = R(r + n), k = R(h + a);
    O = R(O * k), k = R(I + E), O = R(O - k), k = R(r + i);
    let P = R(h + c);
    return k = R(k * P), P = R(I + T), k = R(k - P), P = R(n + i), f = R(a + c), P = R(P * f), f = R(E + T), P = R(P - f), b = R(d * k), f = R(y * T), b = R(f + b), f = R(E - b), b = R(E + b), w = R(f * b), E = R(I + I), E = R(E + I), T = R(d * T), k = R(y * k), E = R(E + T), T = R(I - T), T = R(d * T), k = R(k + T), I = R(E * k), w = R(w + I), I = R(P * k), f = R(O * f), f = R(f - I), I = R(O * E), b = R(P * b), b = R(b + I), new Tt(f, w, b);
  }
  subtract(t) {
    return this.add(Or(t).negate());
  }
  /**
   * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.
   * Uses {@link wNAF} for base point.
   * Uses fake point to mitigate side-channel leakage.
   * @param n scalar by which point is multiplied
   * @param safe safe mode guards against timing attacks; unsafe mode is faster
   */
  multiply(t, r = !0) {
    if (!r && t === 0n)
      return se;
    if (sh(t), t === 1n)
      return this;
    if (this.equals(De))
      return lh(t).p;
    let n = se, i = De;
    for (let h = this; t > 0n; h = h.double(), t >>= 1n)
      t & 1n ? n = n.add(h) : r && (i = i.add(h));
    return n;
  }
  multiplyUnsafe(t) {
    return this.multiply(t, !1);
  }
  /** Convert point to 2d xy affine point. (X, Y, Z)  (x=X/Z, y=Y/Z) */
  toAffine() {
    const { X: t, Y: r, Z: n } = this;
    if (this.equals(se))
      return { x: 0n, y: 0n };
    if (n === 1n)
      return { x: t, y: r };
    const i = ih(n, fe);
    return R(n * i) !== 1n && It("inverse invalid"), { x: R(t * i), y: R(r * i) };
  }
  /** Checks if the point is valid and on-curve. */
  assertValidity() {
    const { x: t, y: r } = this.toAffine();
    return er(t), er(r), R(r * r) === Ci(t) ? this : It("bad point: not on curve");
  }
  /** Converts point to 33/65-byte Uint8Array. */
  toBytes(t = !0) {
    const { x: r, y: n } = this.assertValidity().toAffine(), i = Hn(r);
    return t ? kn(oh(n), i) : kn(_i(4), i, Hn(n));
  }
  toHex(t) {
    return Hi(this.toBytes(t));
  }
}
const De = new Tt(Xo, Qo, 1n), se = new Tt(0n, 1n, 0n);
Tt.BASE = De;
Tt.ZERO = se;
const ah = (e) => hr("0x" + (Hi(e) || "0")), Rn = (e, t, r) => ah(e.subarray(t, r)), uh = 2n ** 256n, Hn = (e) => Li(Ri(Er(e, 0n, uh), hn)), ar = 8, fh = 256, Ni = Math.ceil(fh / ar) + 1, Dr = 2 ** (ar - 1), ch = () => {
  const e = [];
  let t = De, r = t;
  for (let n = 0; n < Ni; n++) {
    r = t, e.push(r);
    for (let i = 1; i < Dr; i++)
      r = r.add(t), e.push(r);
    t = r.double();
  }
  return e;
};
let Ln;
const Cn = (e, t) => {
  const r = t.negate();
  return e ? r : t;
}, lh = (e) => {
  const t = Ln || (Ln = ch());
  let r = se, n = De;
  const i = 2 ** ar, h = i, a = hr(i - 1), c = hr(ar);
  for (let d = 0; d < Ni; d++) {
    let p = Number(e & a);
    e >>= c, p > Dr && (p -= h, e += 1n);
    const f = d * Dr, w = f, b = f + Math.abs(p) - 1, y = d % 2 !== 0, I = p < 0;
    p === 0 ? n = n.add(Cn(y, t[w])) : r = r.add(Cn(I, t[b]));
  }
  return e !== 0n && It("invalid wnaf"), { p: r, f: n };
}, Vi = (e) => e.length === 32 ? e : e.subarray(1, 33);
function _n(e) {
  let t = e.toString(16);
  return t = t.padStart(64, "0"), t.length > 64 && (t = t.slice(-64)), ne(t);
}
function Kr(e) {
  if (e.length === 32)
    return;
  if (![33, 65].includes(e.length)) {
    console.warn(
      `Unsupported key length=${e.length}. Must be 33 (compressed) or 65 (uncompressed).`
    );
    return;
  }
  let t;
  try {
    t = Tt.fromHex(xe(e));
  } catch (d) {
    throw new Error("Invalid secp256k1 public key bytes. Cannot parse.", { cause: d });
  }
  const r = _n(t.x), n = _n(t.y), h = t.y % 2n === 0n ? 6 : 7, a = wt(65);
  a[0] = h, a.set(r, 1), a.set(n, 33);
  const c = vt([new Uint8Array([4]), r, n]);
  return {
    hybrid: a,
    uncompressed: c
  };
}
function ze(e, t) {
  if (H(e, t)) return !0;
  if (e.length === 65 && t.length === 65) {
    const r = new Uint8Array(e), n = new Uint8Array(t);
    return (r[0] === 6 || r[0] === 7) && (r[0] = 4), (n[0] === 6 || n[0] === 7) && (n[0] = 4), H(r, n);
  }
  return !1;
}
const Zt = z;
class be {
  // Static public fields
  static NAME = ct.P2PKH;
  // Private instance fields
  #e;
  #h;
  // Input data (provided by user)
  #t;
  #s;
  #n;
  #r;
  #i;
  #o;
  // Hybrid/uncompressed key flags
  #a = !1;
  #f = !1;
  // Cached computed values
  #u;
  #c;
  #p;
  #w;
  #l;
  #d;
  #g;
  // Cache flags
  #y = !1;
  #b = !1;
  #E = !1;
  #A = !1;
  #I = !1;
  #m = !1;
  #S = !1;
  // Decoded address cache
  #v;
  #T = !1;
  // Decoded input chunks cache
  #B;
  #O = !1;
  /**
   * Creates a new P2PKH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Base58Check encoded address
   * @param params.hash - 20-byte pubkey hash (RIPEMD160(SHA256(pubkey)))
   * @param params.pubkey - The public key (33 or 65 bytes)
   * @param params.signature - DER-encoded signature
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    this.#e = t.network ?? Mt, this.#h = {
      validate: r?.validate ?? !0,
      allowIncomplete: r?.allowIncomplete ?? !1
    }, this.#t = t.address, this.#s = t.hash, this.#n = t.pubkey, this.#r = t.signature, this.#i = t.output, this.#o = t.input, this.#a = t.useHybrid ?? !1, this.#f = t.useUncompressed ?? !1, this.#h.validate && this.#N();
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ct.P2PKH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return this.#e;
  }
  /**
   * Base58Check encoded Bitcoin address.
   */
  get address() {
    return this.#y || (this.#u = this.#k(), this.#y = !0), this.#u;
  }
  /**
   * 20-byte pubkey hash (RIPEMD160(SHA256(pubkey))).
   */
  get hash() {
    return this.#b || (this.#c = this.#P(), this.#b = !0), this.#c;
  }
  /**
   * The public key (33 or 65 bytes).
   */
  get pubkey() {
    return this.#E || (this.#p = this.#R(), this.#E = !0), this.#p;
  }
  /**
   * The DER-encoded signature.
   */
  get signature() {
    return this.#A || (this.#w = this.#H(), this.#A = !0), this.#w;
  }
  /**
   * The scriptPubKey:
   * `OP_DUP OP_HASH160 {hash} OP_EQUALVERIFY OP_CHECKSIG`
   */
  get output() {
    return this.#I || (this.#l = this.#L(), this.#I = !0), this.#l;
  }
  /**
   * The scriptSig: `{signature} {pubkey}`
   */
  get input() {
    return this.#m || (this.#d = this.#C(), this.#m = !0), this.#d;
  }
  /**
   * Witness stack (empty for P2PKH as it's not a SegWit type).
   */
  get witness() {
    return this.#S || (this.#g = this.#_(), this.#S = !0), this.#g;
  }
  // Static factory methods
  /**
   * Creates a P2PKH payment from a public key.
   *
   * @param pubkey - The public key (33 or 65 bytes)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PKH.fromPubkey(pubkey);
   * const address = payment.address;
   * ```
   */
  static fromPubkey(t, r) {
    return new be({ pubkey: t, network: r });
  }
  /**
   * Creates a P2PKH payment from a Base58Check address.
   *
   * @param address - Base58Check encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PKH.fromAddress('1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2');
   * const hash = payment.hash;
   * ```
   */
  static fromAddress(t, r) {
    return new be({ address: t, network: r });
  }
  /**
   * Creates a P2PKH payment from a 20-byte pubkey hash.
   *
   * @param hash - 20-byte pubkey hash
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PKH.fromHash(hash160);
   * const address = payment.address;
   * ```
   */
  static fromHash(t, r) {
    return new be({ hash: t, network: r });
  }
  /**
   * Creates a P2PKH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PKH payment instance
   */
  static fromOutput(t, r) {
    return new be({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2PKHPayment object for backwards compatibility.
   *
   * @returns A P2PKHPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      pubkey: this.pubkey,
      signature: this.signature,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
  #x() {
    if (!this.#T) {
      if (this.#t) {
        const t = new Uint8Array(ci(this.#t));
        this.#v = {
          version: t[0],
          hash: t.subarray(1)
        };
      }
      this.#T = !0;
    }
    return this.#v;
  }
  // Private computation methods
  #U() {
    return this.#O || (this.#o && (this.#B = it(this.#o) ?? void 0), this.#O = !0), this.#B;
  }
  #k() {
    if (this.#t)
      return this.#t;
    const t = this.hash;
    if (!t) return;
    const r = wt(21);
    return r[0] = this.#e.pubKeyHash, r.set(t, 1), fi(r);
  }
  #P() {
    if (this.#s)
      return this.#s;
    if (this.#i)
      return this.#i.subarray(3, 23);
    if (this.#t)
      return this.#x()?.hash;
    const t = this.pubkey;
    if (t)
      return yt(t);
  }
  #R() {
    if (this.#n)
      return this.#n;
    if (this.#o) {
      const t = this.#U();
      if (t && t.length >= 2)
        return t[1];
    }
  }
  #H() {
    if (this.#r)
      return this.#r;
    if (this.#o) {
      const t = this.#U();
      if (t && t.length >= 1)
        return t[0];
    }
  }
  #L() {
    if (this.#i)
      return this.#i;
    const t = this.hash;
    if (t)
      return dt([
        Zt.OP_DUP,
        Zt.OP_HASH160,
        t,
        Zt.OP_EQUALVERIFY,
        Zt.OP_CHECKSIG
      ]);
  }
  #C() {
    if (this.#o)
      return this.#o;
    if (!this.#n || !this.#r)
      return;
    let t = this.#n;
    if (this.#a || this.#f) {
      const r = Kr(this.#n);
      r && (this.#f ? t = r.uncompressed : t = r.hybrid);
    }
    return dt([this.#r, t]);
  }
  // Validation
  #_() {
    if (this.input)
      return [];
  }
  #N() {
    let t = new Uint8Array(0);
    if (this.#t) {
      const r = this.#x();
      if (!r)
        throw new TypeError("Invalid address");
      if (r.version !== this.#e.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (r.hash.length !== 20)
        throw new TypeError("Invalid address");
      t = r.hash;
    }
    if (this.#s) {
      if (t.length > 0 && !H(t, this.#s))
        throw new TypeError("Hash mismatch");
      t = this.#s;
    }
    if (this.#i) {
      if (this.#i.length !== 25 || this.#i[0] !== Zt.OP_DUP || this.#i[1] !== Zt.OP_HASH160 || this.#i[2] !== 20 || this.#i[23] !== Zt.OP_EQUALVERIFY || this.#i[24] !== Zt.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const r = this.#i.subarray(3, 23);
      if (t.length > 0 && !H(t, r))
        throw new TypeError("Hash mismatch");
      t = r;
    }
    if (this.#n) {
      const r = yt(this.#n);
      let n = t.length > 0 && !H(t, r);
      if (n && (this.#n.length === 33 && (this.#n[0] === 2 || this.#n[0] === 3) || this.#n.length === 65 && this.#n[0] === 4)) {
        const i = Kr(this.#n);
        if (i) {
          const h = yt(i.uncompressed);
          if (H(t, h))
            n = !1, this.#f = !0;
          else {
            const a = yt(i.hybrid);
            n = !H(t, a), n || (this.#a = !0);
          }
        }
      }
      if (n)
        throw new TypeError("Hash mismatch");
      t = r;
    }
    if (this.#o) {
      const r = this.#U();
      if (!r || r.length !== 2)
        throw new TypeError("Input is invalid");
      if (!Le(r[0]))
        throw new TypeError("Input has invalid signature");
      if (!le(r[1]))
        throw new TypeError("Input has invalid pubkey");
      if (this.#r && !H(this.#r, r[0]))
        throw new TypeError("Signature mismatch");
      if (this.#n && !H(this.#n, r[1]))
        throw new TypeError("Pubkey mismatch");
      const n = yt(r[1]);
      if (t.length > 0 && !H(t, n))
        throw new TypeError("Hash mismatch (input)");
    }
  }
}
function dh(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.input)
    throw new TypeError("Not enough data");
  const r = new be(
    {
      address: e.address,
      hash: e.hash,
      pubkey: e.pubkey,
      signature: e.signature,
      output: e.output,
      input: e.input,
      network: e.network,
      useHybrid: e.useHybrid,
      useUncompressed: e.useUncompressed
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
const Ve = z;
class Ee {
  // Static public fields
  static NAME = ct.P2SH;
  // Private instance fields
  #e;
  #h;
  // Input data (provided by user)
  #t;
  #s;
  #n;
  #r;
  #i;
  #o;
  // Cached computed values
  #a;
  #f;
  #u;
  #c;
  #p;
  #w;
  // Cache flags
  #l = !1;
  #d = !1;
  #g = !1;
  #y = !1;
  #b = !1;
  #E = !1;
  // Decoded address cache
  #A;
  #I = !1;
  // Decoded input chunks cache
  #m;
  #S = !1;
  // Derived redeem from input
  #v;
  #T = !1;
  /**
   * Creates a new P2SH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Base58Check encoded address (3...)
   * @param params.hash - 20-byte script hash
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.redeem - The redeem script information
   * @param params.witness - The witness stack (for wrapped SegWit)
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    let n = t.network;
    n || (n = t.redeem && t.redeem.network || Mt), this.#e = n, this.#h = {
      validate: r?.validate ?? !0,
      allowIncomplete: r?.allowIncomplete ?? !1
    }, this.#t = t.address, this.#s = t.hash, this.#n = t.output, this.#r = t.input, this.#i = t.redeem, this.#o = t.witness, this.#h.validate && this.#_();
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    const t = this.redeem;
    return t !== void 0 && t.name !== void 0 ? `p2sh-${t.name}` : ct.P2SH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return this.#e;
  }
  /**
   * Base58Check encoded address (3... for mainnet).
   */
  get address() {
    return this.#l || (this.#a = this.#U(), this.#l = !0), this.#a;
  }
  /**
   * 20-byte script hash (HASH160 of redeem script).
   */
  get hash() {
    return this.#d || (this.#f = this.#k(), this.#d = !0), this.#f;
  }
  /**
   * The scriptPubKey: `OP_HASH160 {hash} OP_EQUAL`
   */
  get output() {
    return this.#g || (this.#u = this.#P(), this.#g = !0), this.#u;
  }
  /**
   * The scriptSig: `{redeemScriptSig...} {redeemScript}`
   */
  get input() {
    return this.#y || (this.#c = this.#R(), this.#y = !0), this.#c;
  }
  /**
   * The redeem script information.
   */
  get redeem() {
    return this.#b || (this.#p = this.#H(), this.#b = !0), this.#p;
  }
  /**
   * The witness stack (for wrapped SegWit).
   */
  get witness() {
    return this.#E || (this.#w = this.#L(), this.#E = !0), this.#w;
  }
  // Static factory methods
  /**
   * Creates a P2SH payment from a redeem script.
   *
   * @param redeem - The redeem script information
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   *
   * @example
   * ```typescript
   * const p2sh = P2SH.fromRedeem({ output: redeemScript });
   * ```
   */
  static fromRedeem(t, r) {
    return new Ee({ redeem: t, network: r });
  }
  /**
   * Creates a P2SH payment from a Base58Check address.
   *
   * @param address - Base58Check encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   */
  static fromAddress(t, r) {
    return new Ee({ address: t, network: r });
  }
  /**
   * Creates a P2SH payment from a 20-byte script hash.
   *
   * @param hash - 20-byte script hash
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   */
  static fromHash(t, r) {
    return new Ee({ hash: t, network: r });
  }
  /**
   * Creates a P2SH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2SH payment instance
   */
  static fromOutput(t, r) {
    return new Ee({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2SHPayment object for backwards compatibility.
   *
   * @returns A P2SHPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      output: this.output,
      input: this.input,
      redeem: this.redeem,
      witness: this.witness
    };
  }
  #B() {
    if (!this.#I) {
      if (this.#t) {
        const t = new Uint8Array(ci(this.#t));
        this.#A = {
          version: t[0],
          hash: t.subarray(1)
        };
      }
      this.#I = !0;
    }
    return this.#A;
  }
  #O() {
    return this.#S || (this.#r && (this.#m = it(this.#r) ?? void 0), this.#S = !0), this.#m;
  }
  // Private computation methods
  #x() {
    if (!this.#T) {
      const t = this.#O();
      if (t) {
        const r = t[t.length - 1];
        this.#v = {
          network: this.#e,
          output: r === Ve.OP_FALSE ? new Uint8Array(0) : r,
          input: dt(t.slice(0, -1)),
          witness: this.#o || []
        };
      }
      this.#T = !0;
    }
    return this.#v;
  }
  #U() {
    if (this.#t)
      return this.#t;
    const t = this.hash;
    if (!t) return;
    const r = wt(21);
    return r[0] = this.#e.scriptHash, r.set(t, 1), fi(r);
  }
  #k() {
    if (this.#s)
      return this.#s;
    if (this.#n)
      return this.#n.subarray(2, 22);
    if (this.#t)
      return this.#B()?.hash;
    const t = this.redeem;
    if (t && t.output)
      return yt(t.output);
  }
  #P() {
    if (this.#n)
      return this.#n;
    const t = this.hash;
    if (t)
      return dt([Ve.OP_HASH160, t, Ve.OP_EQUAL]);
  }
  #R() {
    if (this.#r)
      return this.#r;
    const t = this.#i;
    if (!(!t || !t.input || !t.output))
      return dt(
        [].concat(it(t.input), t.output)
      );
  }
  #H() {
    if (this.#i)
      return this.#i;
    if (this.#r)
      return this.#x();
  }
  // Validation
  #L() {
    if (this.#o)
      return this.#o;
    const t = this.redeem;
    if (t && t.witness)
      return t.witness;
    if (this.input)
      return [];
  }
  #C(t) {
    if (t.output) {
      const r = it(t.output);
      if (!r || r.length < 1)
        throw new TypeError("Redeem.output too short");
      if (t.output.byteLength > 520)
        throw new TypeError("Redeem.output unspendable if larger than 520 bytes");
      if (nn(r) > 201)
        throw new TypeError("Redeem.output unspendable with more than 201 non-push ops");
    }
    if (t.input) {
      const r = t.input.length > 0, n = t.witness && t.witness.length > 0;
      if (!r && !n)
        throw new TypeError("Empty input");
      if (r && n)
        throw new TypeError("Input and witness provided");
      if (r) {
        const i = it(t.input);
        if (!br(i))
          throw new TypeError("Non push-only scriptSig");
      }
    }
  }
  #_() {
    let t = new Uint8Array(0);
    if (this.#t) {
      const r = this.#B();
      if (!r)
        throw new TypeError("Invalid address");
      if (r.version !== this.#e.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (r.hash.length !== 20)
        throw new TypeError("Invalid address");
      t = r.hash;
    }
    if (this.#s) {
      if (t.length > 0 && !H(t, this.#s))
        throw new TypeError("Hash mismatch");
      t = this.#s;
    }
    if (this.#n) {
      if (this.#n.length !== 23 || this.#n[0] !== Ve.OP_HASH160 || this.#n[1] !== 20 || this.#n[22] !== Ve.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const r = this.#n.subarray(2, 22);
      if (t.length > 0 && !H(t, r))
        throw new TypeError("Hash mismatch");
      t = r;
    }
    if (this.#r) {
      const r = this.#O();
      if (!r || r.length < 1)
        throw new TypeError("Input too short");
      const n = this.#x();
      if (!n || !(n.output instanceof Uint8Array))
        throw new TypeError("Input is invalid");
      if (this.#C(n), n.output) {
        const i = yt(n.output);
        if (t.length > 0 && !H(t, i))
          throw new TypeError("Hash mismatch");
        t = i;
      }
    }
    if (this.#i) {
      if (this.#i.network && this.#i.network !== this.#e)
        throw new TypeError("Network mismatch");
      if (this.#r) {
        const r = this.#x();
        if (r) {
          if (this.#i.output && r.output && !H(this.#i.output, r.output))
            throw new TypeError("Redeem.output mismatch");
          if (this.#i.input && r.input && !H(this.#i.input, r.input))
            throw new TypeError("Redeem.input mismatch");
        }
      }
      if (this.#C(this.#i), this.#i.output) {
        const r = yt(this.#i.output);
        if (t.length > 0 && !H(t, r))
          throw new TypeError("Hash mismatch");
      }
    }
    if (this.#o && this.#i && this.#i.witness && !ke(this.#i.witness, this.#o))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
}
function ph(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.input)
    throw new TypeError("Not enough data");
  const r = new Ee(
    {
      address: e.address,
      hash: e.hash,
      output: e.output,
      input: e.input,
      redeem: e.redeem,
      witness: e.witness,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
function wh(e) {
  const t = e.length;
  if (t % 2 !== 0) throw new TypeError("fromHexInternal: odd-length hex string");
  const r = new Uint8Array(t / 2);
  for (let n = 0; n < t; n += 2) {
    const i = Nn(e.charCodeAt(n)), h = Nn(e.charCodeAt(n + 1));
    if (i === -1 || h === -1) throw new TypeError("fromHexInternal: invalid hex character");
    r[n >> 1] = i << 4 | h;
  }
  return r;
}
function Nn(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function bt(e, t) {
  if (e.length !== t.length) return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r]) return !1;
  return !0;
}
function un(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function de(e, t = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const r = t && `"${t}" `;
    throw new Error(`${r}expected integer >= 0, got ${e}`);
  }
}
function st(e, t, r = "") {
  const n = un(e), i = e?.length, h = t !== void 0;
  if (!n || h && i !== t) {
    const a = r && `"${r}" `, c = h ? ` of length ${t}` : "", d = n ? `length=${i}` : `type=${typeof e}`;
    throw new Error(a + "expected Uint8Array" + c + ", got " + d);
  }
  return e;
}
function Mi(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  de(e.outputLen), de(e.blockLen);
}
function ur(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function gh(e, t) {
  st(e, void 0, "digestInto() output");
  const r = t.outputLen;
  if (e.length < r)
    throw new Error('"digestInto() output" expected to be of length >=' + r);
}
function fr(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function kr(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function _t(e, t) {
  return e << 32 - t | e >>> t;
}
const Fi = (
  /* @ts-ignore */
  typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
), yh = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ar(e) {
  if (st(e), Fi)
    return e.toHex();
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += yh[e[r]];
  return t;
}
const $t = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Vn(e) {
  if (e >= $t._0 && e <= $t._9)
    return e - $t._0;
  if (e >= $t.A && e <= $t.F)
    return e - ($t.A - 10);
  if (e >= $t.a && e <= $t.f)
    return e - ($t.a - 10);
}
function cr(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (Fi)
    return Uint8Array.fromHex(e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let i = 0, h = 0; i < r; i++, h += 2) {
    const a = Vn(e.charCodeAt(h)), c = Vn(e.charCodeAt(h + 1));
    if (a === void 0 || c === void 0) {
      const d = e[h] + e[h + 1];
      throw new Error('hex string expected, got non-hex character "' + d + '" at index ' + h);
    }
    n[i] = a * 16 + c;
  }
  return n;
}
function ee(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    st(i), t += i.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, i = 0; n < e.length; n++) {
    const h = e[n];
    r.set(h, i), i += h.length;
  }
  return r;
}
function mh(e, t = {}) {
  const r = (i, h) => e(h).update(i).digest(), n = e(void 0);
  return r.outputLen = n.outputLen, r.blockLen = n.blockLen, r.create = (i) => e(i), Object.assign(r, t), Object.freeze(r);
}
function $i(e = 32) {
  const t = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof t?.getRandomValues != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t.getRandomValues(new Uint8Array(e));
}
const bh = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function Eh(e, t, r) {
  return e & t ^ ~e & r;
}
function Ah(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
class Ih {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(t, r, n, i) {
    this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = kr(this.buffer);
  }
  update(t) {
    ur(this), st(t);
    const { view: r, buffer: n, blockLen: i } = this, h = t.length;
    for (let a = 0; a < h; ) {
      const c = Math.min(i - this.pos, h - a);
      if (c === i) {
        const d = kr(t);
        for (; i <= h - a; a += i)
          this.process(d, a);
        continue;
      }
      n.set(t.subarray(a, a + c), this.pos), this.pos += c, a += c, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    ur(this), gh(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: h } = this;
    let { pos: a } = this;
    r[a++] = 128, fr(this.buffer.subarray(a)), this.padOffset > i - a && (this.process(n, 0), a = 0);
    for (let w = a; w < i; w++)
      r[w] = 0;
    n.setBigUint64(i - 8, BigInt(this.length * 8), h), this.process(n, 0);
    const c = kr(t), d = this.outputLen;
    if (d % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const p = d / 4, f = this.get();
    if (p > f.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let w = 0; w < p; w++)
      c.setUint32(4 * w, f[w], h);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t ||= new this.constructor(), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: h, destroyed: a, pos: c } = this;
    return t.destroyed = a, t.finished = h, t.length = i, t.pos = c, i % r && t.buffer.set(n), t;
  }
  clone() {
    return this._cloneInto();
  }
}
const Yt = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), vh = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Xt = /* @__PURE__ */ new Uint32Array(64);
class Sh extends Ih {
  constructor(t) {
    super(64, t, 8, !1);
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: h, F: a, G: c, H: d } = this;
    return [t, r, n, i, h, a, c, d];
  }
  // prettier-ignore
  set(t, r, n, i, h, a, c, d) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = h | 0, this.F = a | 0, this.G = c | 0, this.H = d | 0;
  }
  process(t, r) {
    for (let w = 0; w < 16; w++, r += 4)
      Xt[w] = t.getUint32(r, !1);
    for (let w = 16; w < 64; w++) {
      const b = Xt[w - 15], y = Xt[w - 2], I = _t(b, 7) ^ _t(b, 18) ^ b >>> 3, E = _t(y, 17) ^ _t(y, 19) ^ y >>> 10;
      Xt[w] = E + Xt[w - 7] + I + Xt[w - 16] | 0;
    }
    let { A: n, B: i, C: h, D: a, E: c, F: d, G: p, H: f } = this;
    for (let w = 0; w < 64; w++) {
      const b = _t(c, 6) ^ _t(c, 11) ^ _t(c, 25), y = f + b + Eh(c, d, p) + vh[w] + Xt[w] | 0, I = (_t(n, 2) ^ _t(n, 13) ^ _t(n, 22)) + Ah(n, i, h) | 0;
      f = p, p = d, d = c, c = a + y | 0, a = h, h = i, i = n, n = y + I | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, h = h + this.C | 0, a = a + this.D | 0, c = c + this.E | 0, d = d + this.F | 0, p = p + this.G | 0, f = f + this.H | 0, this.set(n, i, h, a, c, d, p, f);
  }
  roundClean() {
    fr(Xt);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), fr(this.buffer);
  }
}
class Th extends Sh {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = Yt[0] | 0;
  B = Yt[1] | 0;
  C = Yt[2] | 0;
  D = Yt[3] | 0;
  E = Yt[4] | 0;
  F = Yt[5] | 0;
  G = Yt[6] | 0;
  H = Yt[7] | 0;
  constructor() {
    super(32);
  }
}
const Bh = /* @__PURE__ */ mh(
  () => new Th(),
  /* @__PURE__ */ bh(1)
);
function xh(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let p = 0; p < t.length; p++)
    t[p] = 255;
  for (let p = 0; p < e.length; p++) {
    const f = e.charAt(p), w = f.charCodeAt(0);
    if (t[w] !== 255)
      throw new TypeError(f + " is ambiguous");
    t[w] = p;
  }
  const r = e.length, n = e.charAt(0), i = Math.log(r) / Math.log(256), h = Math.log(256) / Math.log(r);
  function a(p) {
    if (p instanceof Uint8Array || (ArrayBuffer.isView(p) ? p = new Uint8Array(p.buffer, p.byteOffset, p.byteLength) : Array.isArray(p) && (p = Uint8Array.from(p))), !(p instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (p.length === 0)
      return "";
    let f = 0, w = 0, b = 0;
    const y = p.length;
    for (; b !== y && p[b] === 0; )
      b++, f++;
    const I = (y - b) * h + 1 >>> 0, E = new Uint8Array(I);
    for (; b !== y; ) {
      let k = p[b], P = 0;
      for (let x = I - 1; (k !== 0 || P < w) && x !== -1; x--, P++)
        k += 256 * E[x] >>> 0, E[x] = k % r >>> 0, k = k / r >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      w = P, b++;
    }
    let T = I - w;
    for (; T !== I && E[T] === 0; )
      T++;
    let O = n.repeat(f);
    for (; T < I; ++T)
      O += e.charAt(E[T]);
    return O;
  }
  function c(p) {
    if (typeof p != "string")
      throw new TypeError("Expected String");
    if (p.length === 0)
      return new Uint8Array();
    let f = 0, w = 0, b = 0;
    for (; p[f] === n; )
      w++, f++;
    const y = (p.length - f) * i + 1 >>> 0, I = new Uint8Array(y);
    for (; f < p.length; ) {
      const k = p.charCodeAt(f);
      if (k > 255)
        return;
      let P = t[k];
      if (P === 255)
        return;
      let x = 0;
      for (let K = y - 1; (P !== 0 || x < b) && K !== -1; K--, x++)
        P += r * I[K] >>> 0, I[K] = P % 256 >>> 0, P = P / 256 >>> 0;
      if (P !== 0)
        throw new Error("Non-zero carry");
      b = x, f++;
    }
    let E = y - b;
    for (; E !== y && I[E] === 0; )
      E++;
    const T = new Uint8Array(w + (y - E));
    let O = w;
    for (; E !== y; )
      T[O++] = I[E++];
    return T;
  }
  function d(p) {
    const f = c(p);
    if (f)
      return f;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: a,
    decodeUnsafe: c,
    decode: d
  };
}
var Uh = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
xh(Uh);
const fn = /* @__PURE__ */ BigInt(0), Wr = /* @__PURE__ */ BigInt(1);
function lr(e, t = "") {
  if (typeof e != "boolean") {
    const r = t && `"${t}" `;
    throw new Error(r + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function Di(e) {
  if (typeof e == "bigint") {
    if (!rr(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    de(e);
  return e;
}
function Ze(e) {
  const t = Di(e).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function Ki(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? fn : BigInt("0x" + e);
}
function Ir(e) {
  return Ki(Ar(e));
}
function Wi(e) {
  return Ki(Ar(Oh(st(e)).reverse()));
}
function cn(e, t) {
  de(t), e = Di(e);
  const r = cr(e.toString(16).padStart(t * 2, "0"));
  if (r.length !== t)
    throw new Error("number too large");
  return r;
}
function Gi(e, t) {
  return cn(e, t).reverse();
}
function Oh(e) {
  return Uint8Array.from(e);
}
const rr = (e) => typeof e == "bigint" && fn <= e;
function kh(e, t, r) {
  return rr(e) && rr(t) && rr(r) && t <= e && e < r;
}
function Ph(e, t, r, n) {
  if (!kh(t, r, n))
    throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t);
}
function Rh(e) {
  let t;
  for (t = 0; e > fn; e >>= Wr, t += 1)
    ;
  return t;
}
const ln = (e) => (Wr << BigInt(e)) - Wr;
function Hh(e, t, r) {
  if (de(e, "hashLen"), de(t, "qByteLen"), typeof r != "function")
    throw new Error("hmacFn must be a function");
  const n = (E) => new Uint8Array(E), i = Uint8Array.of(), h = Uint8Array.of(0), a = Uint8Array.of(1), c = 1e3;
  let d = n(e), p = n(e), f = 0;
  const w = () => {
    d.fill(1), p.fill(0), f = 0;
  }, b = (...E) => r(p, ee(d, ...E)), y = (E = i) => {
    p = b(h, E), d = b(), E.length !== 0 && (p = b(a, E), d = b());
  }, I = () => {
    if (f++ >= c)
      throw new Error("drbg: tried max amount of iterations");
    let E = 0;
    const T = [];
    for (; E < t; ) {
      d = b();
      const O = d.slice();
      T.push(O), E += d.length;
    }
    return ee(...T);
  };
  return (E, T) => {
    w(), y(E);
    let O;
    for (; !(O = T(I())); )
      y();
    return w(), O;
  };
}
function dn(e, t = {}, r = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function n(h, a, c) {
    const d = e[h];
    if (c && d === void 0)
      return;
    const p = typeof d;
    if (p !== a || d === null)
      throw new Error(`param "${h}" is invalid: expected ${a}, got ${p}`);
  }
  const i = (h, a) => Object.entries(h).forEach(([c, d]) => n(c, d, a));
  i(t, !1), i(r, !0);
}
function Mn(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const i = t.get(r);
    if (i !== void 0)
      return i;
    const h = e(r, ...n);
    return t.set(r, h), h;
  };
}
const At = /* @__PURE__ */ BigInt(0), mt = /* @__PURE__ */ BigInt(1), he = /* @__PURE__ */ BigInt(2), ji = /* @__PURE__ */ BigInt(3), qi = /* @__PURE__ */ BigInt(4), zi = /* @__PURE__ */ BigInt(5), Lh = /* @__PURE__ */ BigInt(7), Zi = /* @__PURE__ */ BigInt(8), Ch = /* @__PURE__ */ BigInt(9), Yi = /* @__PURE__ */ BigInt(16);
function Ht(e, t) {
  const r = e % t;
  return r >= At ? r : t + r;
}
function xt(e, t, r) {
  let n = e;
  for (; t-- > At; )
    n *= n, n %= r;
  return n;
}
function Fn(e, t) {
  if (e === At)
    throw new Error("invert: expected non-zero number");
  if (t <= At)
    throw new Error("invert: expected positive modulus, got " + t);
  let r = Ht(e, t), n = t, i = At, h = mt;
  for (; r !== At; ) {
    const a = n / r, c = n % r, d = i - h * a;
    n = r, r = c, i = h, h = d;
  }
  if (n !== mt)
    throw new Error("invert: does not exist");
  return Ht(i, t);
}
function pn(e, t, r) {
  if (!e.eql(e.sqr(t), r))
    throw new Error("Cannot find square root");
}
function Xi(e, t) {
  const r = (e.ORDER + mt) / qi, n = e.pow(t, r);
  return pn(e, n, t), n;
}
function _h(e, t) {
  const r = (e.ORDER - zi) / Zi, n = e.mul(t, he), i = e.pow(n, r), h = e.mul(t, i), a = e.mul(e.mul(h, he), i), c = e.mul(h, e.sub(a, e.ONE));
  return pn(e, c, t), c;
}
function Nh(e) {
  const t = vr(e), r = Qi(e), n = r(t, t.neg(t.ONE)), i = r(t, n), h = r(t, t.neg(n)), a = (e + Lh) / Yi;
  return (c, d) => {
    let p = c.pow(d, a), f = c.mul(p, n);
    const w = c.mul(p, i), b = c.mul(p, h), y = c.eql(c.sqr(f), d), I = c.eql(c.sqr(w), d);
    p = c.cmov(p, f, y), f = c.cmov(b, w, I);
    const E = c.eql(c.sqr(f), d), T = c.cmov(p, f, E);
    return pn(c, T, d), T;
  };
}
function Qi(e) {
  if (e < ji)
    throw new Error("sqrt is not defined for small field");
  let t = e - mt, r = 0;
  for (; t % he === At; )
    t /= he, r++;
  let n = he;
  const i = vr(e);
  for (; $n(i, n) === 1; )
    if (n++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (r === 1)
    return Xi;
  let h = i.pow(n, t);
  const a = (t + mt) / he;
  return function(c, d) {
    if (c.is0(d))
      return d;
    if ($n(c, d) !== 1)
      throw new Error("Cannot find square root");
    let p = r, f = c.mul(c.ONE, h), w = c.pow(d, t), b = c.pow(d, a);
    for (; !c.eql(w, c.ONE); ) {
      if (c.is0(w))
        return c.ZERO;
      let y = 1, I = c.sqr(w);
      for (; !c.eql(I, c.ONE); )
        if (y++, I = c.sqr(I), y === p)
          throw new Error("Cannot find square root");
      const E = mt << BigInt(p - y - 1), T = c.pow(f, E);
      p = y, f = c.sqr(T), w = c.mul(w, f), b = c.mul(b, T);
    }
    return b;
  };
}
function Vh(e) {
  return e % qi === ji ? Xi : e % Zi === zi ? _h : e % Yi === Ch ? Nh(e) : Qi(e);
}
const Mh = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Fh(e) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, r = Mh.reduce((n, i) => (n[i] = "function", n), t);
  return dn(e, r), e;
}
function $h(e, t, r) {
  if (r < At)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === At)
    return e.ONE;
  if (r === mt)
    return t;
  let n = e.ONE, i = t;
  for (; r > At; )
    r & mt && (n = e.mul(n, i)), i = e.sqr(i), r >>= mt;
  return n;
}
function Ji(e, t, r = !1) {
  const n = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((a, c, d) => e.is0(c) ? a : (n[d] = a, e.mul(a, c)), e.ONE), h = e.inv(i);
  return t.reduceRight((a, c, d) => e.is0(c) ? a : (n[d] = e.mul(a, n[d]), e.mul(a, c)), h), n;
}
function $n(e, t) {
  const r = (e.ORDER - mt) / he, n = e.pow(t, r), i = e.eql(n, e.ONE), h = e.eql(n, e.ZERO), a = e.eql(n, e.neg(e.ONE));
  if (!i && !h && !a)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : h ? 0 : -1;
}
function Dh(e, t) {
  t !== void 0 && de(t);
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
class Kh {
  ORDER;
  BITS;
  BYTES;
  isLE;
  ZERO = At;
  ONE = mt;
  _lengths;
  _sqrt;
  // cached sqrt
  _mod;
  constructor(t, r = {}) {
    if (t <= At)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let n;
    this.isLE = !1, r != null && typeof r == "object" && (typeof r.BITS == "number" && (n = r.BITS), typeof r.sqrt == "function" && (this.sqrt = r.sqrt), typeof r.isLE == "boolean" && (this.isLE = r.isLE), r.allowedLengths && (this._lengths = r.allowedLengths?.slice()), typeof r.modFromBytes == "boolean" && (this._mod = r.modFromBytes));
    const { nBitLength: i, nByteLength: h } = Dh(t, n);
    if (h > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = i, this.BYTES = h, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return Ht(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return At <= t && t < this.ORDER;
  }
  is0(t) {
    return t === At;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & mt) === mt;
  }
  neg(t) {
    return Ht(-t, this.ORDER);
  }
  eql(t, r) {
    return t === r;
  }
  sqr(t) {
    return Ht(t * t, this.ORDER);
  }
  add(t, r) {
    return Ht(t + r, this.ORDER);
  }
  sub(t, r) {
    return Ht(t - r, this.ORDER);
  }
  mul(t, r) {
    return Ht(t * r, this.ORDER);
  }
  pow(t, r) {
    return $h(this, t, r);
  }
  div(t, r) {
    return Ht(t * Fn(r, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, r) {
    return t + r;
  }
  subN(t, r) {
    return t - r;
  }
  mulN(t, r) {
    return t * r;
  }
  inv(t) {
    return Fn(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = Vh(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? Gi(t, this.BYTES) : cn(t, this.BYTES);
  }
  fromBytes(t, r = !1) {
    st(t);
    const { _lengths: n, BYTES: i, isLE: h, ORDER: a, _mod: c } = this;
    if (n) {
      if (!n.includes(t.length) || t.length > i)
        throw new Error("Field.fromBytes: expected " + n + " bytes, got " + t.length);
      const p = new Uint8Array(i);
      p.set(t, h ? 0 : p.length - t.length), t = p;
    }
    if (t.length !== i)
      throw new Error("Field.fromBytes: expected " + i + " bytes, got " + t.length);
    let d = h ? Wi(t) : Ir(t);
    if (c && (d = Ht(d, a)), !r && !this.isValid(d))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return d;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return Ji(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, r, n) {
    return n ? r : t;
  }
}
function vr(e, t = {}) {
  return new Kh(e, t);
}
function ts(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function es(e) {
  const t = ts(e);
  return t + Math.ceil(t / 2);
}
function Wh(e, t, r = !1) {
  st(e);
  const n = e.length, i = ts(t), h = es(t);
  if (n < 16 || n < h || n > 1024)
    throw new Error("expected " + h + "-1024 bytes of input, got " + n);
  const a = r ? Wi(e) : Ir(e), c = Ht(a, t - mt) + mt;
  return r ? Gi(c, i) : cn(c, i);
}
const Pe = /* @__PURE__ */ BigInt(0), ae = /* @__PURE__ */ BigInt(1);
function dr(e, t) {
  const r = t.negate();
  return e ? r : t;
}
function Dn(e, t) {
  const r = Ji(e.Fp, t.map((n) => n.Z));
  return t.map((n, i) => e.fromAffine(n.toAffine(r[i])));
}
function rs(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function Pr(e, t) {
  rs(e, t);
  const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i = 2 ** e, h = ln(e), a = BigInt(e);
  return { windows: r, windowSize: n, mask: h, maxNumber: i, shiftBy: a };
}
function Kn(e, t, r) {
  const { windowSize: n, mask: i, maxNumber: h, shiftBy: a } = r;
  let c = Number(e & i), d = e >> a;
  c > n && (c -= h, d += ae);
  const p = t * n, f = p + Math.abs(c) - 1, w = c === 0, b = c < 0, y = t % 2 !== 0;
  return { nextN: d, offset: f, isZero: w, isNeg: b, isNegF: y, offsetF: p };
}
const Rr = /* @__PURE__ */ new WeakMap(), ns = /* @__PURE__ */ new WeakMap();
function Hr(e) {
  return ns.get(e) || 1;
}
function Wn(e) {
  if (e !== Pe)
    throw new Error("invalid wNAF");
}
class Gh {
  BASE;
  ZERO;
  Fn;
  bits;
  // Parametrized with a given Point class (not individual point)
  constructor(t, r) {
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = r;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, r, n = this.ZERO) {
    let i = t;
    for (; r > Pe; )
      r & ae && (n = n.add(i)), i = i.double(), r >>= ae;
    return n;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, r) {
    const { windows: n, windowSize: i } = Pr(r, this.bits), h = [];
    let a = t, c = a;
    for (let d = 0; d < n; d++) {
      c = a, h.push(c);
      for (let p = 1; p < i; p++)
        c = c.add(a), h.push(c);
      a = c.double();
    }
    return h;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, r, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let i = this.ZERO, h = this.BASE;
    const a = Pr(t, this.bits);
    for (let c = 0; c < a.windows; c++) {
      const { nextN: d, offset: p, isZero: f, isNeg: w, isNegF: b, offsetF: y } = Kn(n, c, a);
      n = d, f ? h = h.add(dr(b, r[y])) : i = i.add(dr(w, r[p]));
    }
    return Wn(n), { p: i, f: h };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, r, n, i = this.ZERO) {
    const h = Pr(t, this.bits);
    for (let a = 0; a < h.windows && n !== Pe; a++) {
      const { nextN: c, offset: d, isZero: p, isNeg: f } = Kn(n, a, h);
      if (n = c, !p) {
        const w = r[d];
        i = i.add(f ? w.negate() : w);
      }
    }
    return Wn(n), i;
  }
  getPrecomputes(t, r, n) {
    let i = Rr.get(r);
    return i || (i = this.precomputeWindow(r, t), t !== 1 && (typeof n == "function" && (i = n(i)), Rr.set(r, i))), i;
  }
  cached(t, r, n) {
    const i = Hr(t);
    return this.wNAF(i, this.getPrecomputes(i, t, n), r);
  }
  unsafe(t, r, n, i) {
    const h = Hr(t);
    return h === 1 ? this._unsafeLadder(t, r, i) : this.wNAFUnsafe(h, this.getPrecomputes(h, t, n), r, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, r) {
    rs(r, this.bits), ns.set(t, r), Rr.delete(t);
  }
  hasCache(t) {
    return Hr(t) !== 1;
  }
}
function jh(e, t, r, n) {
  let i = t, h = e.ZERO, a = e.ZERO;
  for (; r > Pe || n > Pe; )
    r & ae && (h = h.add(i)), n & ae && (a = a.add(i)), i = i.double(), r >>= ae, n >>= ae;
  return { p1: h, p2: a };
}
function Gn(e, t, r) {
  if (t) {
    if (t.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Fh(t), t;
  } else
    return vr(e, { isLE: r });
}
function qh(e, t, r = {}, n) {
  if (n === void 0 && (n = e === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const d = t[c];
    if (!(typeof d == "bigint" && d > Pe))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const i = Gn(t.p, r.Fp, n), h = Gn(t.n, r.Fn, n), a = ["Gx", "Gy", "a", "b"];
  for (const c of a)
    if (!i.isValid(t[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: i, Fn: h };
}
function zh(e, t) {
  return function(r) {
    const n = e(r);
    return { secretKey: n, publicKey: t(n) };
  };
}
class is {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = !1;
  destroyed = !1;
  constructor(t, r) {
    if (Mi(t), st(r, void 0, "key"), this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n = this.blockLen, i = new Uint8Array(n);
    i.set(r.length > n ? t.create().update(r).digest() : r);
    for (let h = 0; h < i.length; h++)
      i[h] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let h = 0; h < i.length; h++)
      i[h] ^= 106;
    this.oHash.update(i), fr(i);
  }
  update(t) {
    return ur(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    ur(this), st(t, this.outputLen, "output"), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash: r, iHash: n, finished: i, destroyed: h, blockLen: a, outputLen: c } = this;
    return t = t, t.finished = i, t.destroyed = h, t.blockLen = a, t.outputLen = c, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const ss = (e, t, r) => new is(e, t).update(r).digest();
ss.create = (e, t) => new is(e, t);
const jn = (e, t) => (e + (e >= 0 ? t : -t) / os) / t;
function Zh(e, t, r) {
  const [[n, i], [h, a]] = t, c = jn(a * e, r), d = jn(-i * e, r);
  let p = e - c * n - d * h, f = -c * i - d * a;
  const w = p < Dt, b = f < Dt;
  w && (p = -p), b && (f = -f);
  const y = ln(Math.ceil(Rh(r) / 2)) + Te;
  if (p < Dt || p >= y || f < Dt || f >= y)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: w, k1: p, k2neg: b, k2: f };
}
function Gr(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function Lr(e, t) {
  const r = {};
  for (let n of Object.keys(t))
    r[n] = e[n] === void 0 ? t[n] : e[n];
  return lr(r.lowS, "lowS"), lr(r.prehash, "prehash"), r.format !== void 0 && Gr(r.format), r;
}
class Yh extends Error {
  constructor(t = "") {
    super(t);
  }
}
const te = {
  // asn.1 DER encoding utils
  Err: Yh,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = te;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const n = t.length / 2, i = Ze(n);
      if (i.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const h = n > 127 ? Ze(i.length / 2 | 128) : "";
      return Ze(e) + h + i + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = te;
      let n = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const i = t[n++], h = !!(i & 128);
      let a = 0;
      if (!h)
        a = i;
      else {
        const d = i & 127;
        if (!d)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (d > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const p = t.subarray(n, n + d);
        if (p.length !== d)
          throw new r("tlv.decode: length bytes not complete");
        if (p[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const f of p)
          a = a << 8 | f;
        if (n += d, a < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const c = t.subarray(n, n + a);
      if (c.length !== a)
        throw new r("tlv.decode: wrong value length");
      return { v: c, l: t.subarray(n + a) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = te;
      if (e < Dt)
        throw new t("integer: negative integers are not allowed");
      let r = Ze(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(e) {
      const { Err: t } = te;
      if (e[0] & 128)
        throw new t("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return Ir(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: n } = te, i = st(e, void 0, "signature"), { v: h, l: a } = n.decode(48, i);
    if (a.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: c, l: d } = n.decode(2, h), { v: p, l: f } = n.decode(2, d);
    if (f.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: r.decode(c), s: r.decode(p) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = te, n = t.encode(2, r.encode(e.r)), i = t.encode(2, r.encode(e.s)), h = n + i;
    return t.encode(48, h);
  }
}, Dt = BigInt(0), Te = BigInt(1), os = BigInt(2), Ye = BigInt(3), Xh = BigInt(4);
function Qh(e, t = {}) {
  const r = qh("weierstrass", e, t), { Fp: n, Fn: i } = r;
  let h = r.CURVE;
  const { h: a, n: c } = h;
  dn(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: d } = t;
  if (d && (!n.is0(h.a) || typeof d.beta != "bigint" || !Array.isArray(d.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const p = as(n, i);
  function f() {
    if (!n.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function w(Z, B, S) {
    const { x: v, y: U } = B.toAffine(), N = n.toBytes(v);
    if (lr(S, "isCompressed"), S) {
      f();
      const V = !n.isOdd(U);
      return ee(hs(V), N);
    } else
      return ee(Uint8Array.of(4), N, n.toBytes(U));
  }
  function b(Z) {
    st(Z, void 0, "Point");
    const { publicKey: B, publicKeyUncompressed: S } = p, v = Z.length, U = Z[0], N = Z.subarray(1);
    if (v === B && (U === 2 || U === 3)) {
      const V = n.fromBytes(N);
      if (!n.isValid(V))
        throw new Error("bad point: is not on curve, wrong x");
      const M = E(V);
      let C;
      try {
        C = n.sqrt(M);
      } catch (W) {
        const ht = W instanceof Error ? ": " + W.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + ht);
      }
      f();
      const D = n.isOdd(C);
      return (U & 1) === 1 !== D && (C = n.neg(C)), { x: V, y: C };
    } else if (v === S && U === 4) {
      const V = n.BYTES, M = n.fromBytes(N.subarray(0, V)), C = n.fromBytes(N.subarray(V, V * 2));
      if (!T(M, C))
        throw new Error("bad point: is not on curve");
      return { x: M, y: C };
    } else
      throw new Error(`bad point: got length ${v}, expected compressed=${B} or uncompressed=${S}`);
  }
  const y = t.toBytes || w, I = t.fromBytes || b;
  function E(Z) {
    const B = n.sqr(Z), S = n.mul(B, Z);
    return n.add(n.add(S, n.mul(Z, h.a)), h.b);
  }
  function T(Z, B) {
    const S = n.sqr(B), v = E(Z);
    return n.eql(S, v);
  }
  if (!T(h.Gx, h.Gy))
    throw new Error("bad curve params: generator point");
  const O = n.mul(n.pow(h.a, Ye), Xh), k = n.mul(n.sqr(h.b), BigInt(27));
  if (n.is0(n.add(O, k)))
    throw new Error("bad curve params: a or b");
  function P(Z, B, S = !1) {
    if (!n.isValid(B) || S && n.is0(B))
      throw new Error(`bad point coordinate ${Z}`);
    return B;
  }
  function x(Z) {
    if (!(Z instanceof _))
      throw new Error("Weierstrass Point expected");
  }
  function K(Z) {
    if (!d || !d.basises)
      throw new Error("no endo");
    return Zh(Z, d.basises, i.ORDER);
  }
  const tt = Mn((Z, B) => {
    const { X: S, Y: v, Z: U } = Z;
    if (n.eql(U, n.ONE))
      return { x: S, y: v };
    const N = Z.is0();
    B == null && (B = N ? n.ONE : n.inv(U));
    const V = n.mul(S, B), M = n.mul(v, B), C = n.mul(U, B);
    if (N)
      return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(C, n.ONE))
      throw new Error("invZ was invalid");
    return { x: V, y: M };
  }), Bt = Mn((Z) => {
    if (Z.is0()) {
      if (t.allowInfinityPoint && !n.is0(Z.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: B, y: S } = Z.toAffine();
    if (!n.isValid(B) || !n.isValid(S))
      throw new Error("bad point: x or y not field elements");
    if (!T(B, S))
      throw new Error("bad point: equation left != right");
    if (!Z.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function F(Z, B, S, v, U) {
    return S = new _(n.mul(S.X, Z), S.Y, S.Z), B = dr(v, B), S = dr(U, S), B.add(S);
  }
  class _ {
    // base / generator point
    static BASE = new _(h.Gx, h.Gy, n.ONE);
    // zero / infinity / identity point
    static ZERO = new _(n.ZERO, n.ONE, n.ZERO);
    // 0, 1, 0
    // math field
    static Fp = n;
    // scalar field
    static Fn = i;
    X;
    Y;
    Z;
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(B, S, v) {
      this.X = P("x", B), this.Y = P("y", S, !0), this.Z = P("z", v), Object.freeze(this);
    }
    static CURVE() {
      return h;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(B) {
      const { x: S, y: v } = B || {};
      if (!B || !n.isValid(S) || !n.isValid(v))
        throw new Error("invalid affine point");
      if (B instanceof _)
        throw new Error("projective point not allowed");
      return n.is0(S) && n.is0(v) ? _.ZERO : new _(S, v, n.ONE);
    }
    static fromBytes(B) {
      const S = _.fromAffine(I(st(B, void 0, "point")));
      return S.assertValidity(), S;
    }
    static fromHex(B) {
      return _.fromBytes(cr(B));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(B = 8, S = !0) {
      return Pt.createCache(this, B), S || this.multiply(Ye), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      Bt(this);
    }
    hasEvenY() {
      const { y: B } = this.toAffine();
      if (!n.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n.isOdd(B);
    }
    /** Compare one point to another. */
    equals(B) {
      x(B);
      const { X: S, Y: v, Z: U } = this, { X: N, Y: V, Z: M } = B, C = n.eql(n.mul(S, M), n.mul(N, U)), D = n.eql(n.mul(v, M), n.mul(V, U));
      return C && D;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new _(this.X, n.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: B, b: S } = h, v = n.mul(S, Ye), { X: U, Y: N, Z: V } = this;
      let M = n.ZERO, C = n.ZERO, D = n.ZERO, W = n.mul(U, U), ht = n.mul(N, N), G = n.mul(V, V), $ = n.mul(U, N);
      return $ = n.add($, $), D = n.mul(U, V), D = n.add(D, D), M = n.mul(B, D), C = n.mul(v, G), C = n.add(M, C), M = n.sub(ht, C), C = n.add(ht, C), C = n.mul(M, C), M = n.mul($, M), D = n.mul(v, D), G = n.mul(B, G), $ = n.sub(W, G), $ = n.mul(B, $), $ = n.add($, D), D = n.add(W, W), W = n.add(D, W), W = n.add(W, G), W = n.mul(W, $), C = n.add(C, W), G = n.mul(N, V), G = n.add(G, G), W = n.mul(G, $), M = n.sub(M, W), D = n.mul(G, ht), D = n.add(D, D), D = n.add(D, D), new _(M, C, D);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(B) {
      x(B);
      const { X: S, Y: v, Z: U } = this, { X: N, Y: V, Z: M } = B;
      let C = n.ZERO, D = n.ZERO, W = n.ZERO;
      const ht = h.a, G = n.mul(h.b, Ye);
      let $ = n.mul(S, N), Q = n.mul(v, V), at = n.mul(U, M), St = n.add(S, v), J = n.add(N, V);
      St = n.mul(St, J), J = n.add($, Q), St = n.sub(St, J), J = n.add(S, U);
      let ft = n.add(N, M);
      return J = n.mul(J, ft), ft = n.add($, at), J = n.sub(J, ft), ft = n.add(v, U), C = n.add(V, M), ft = n.mul(ft, C), C = n.add(Q, at), ft = n.sub(ft, C), W = n.mul(ht, J), C = n.mul(G, at), W = n.add(C, W), C = n.sub(Q, W), W = n.add(Q, W), D = n.mul(C, W), Q = n.add($, $), Q = n.add(Q, $), at = n.mul(ht, at), J = n.mul(G, J), Q = n.add(Q, at), at = n.sub($, at), at = n.mul(ht, at), J = n.add(J, at), $ = n.mul(Q, J), D = n.add(D, $), $ = n.mul(ft, J), C = n.mul(St, C), C = n.sub(C, $), $ = n.mul(St, Q), W = n.mul(ft, W), W = n.add(W, $), new _(C, D, W);
    }
    subtract(B) {
      return this.add(B.negate());
    }
    is0() {
      return this.equals(_.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(B) {
      const { endo: S } = t;
      if (!i.isValidNot0(B))
        throw new Error("invalid scalar: out of range");
      let v, U;
      const N = (V) => Pt.cached(this, V, (M) => Dn(_, M));
      if (S) {
        const { k1neg: V, k1: M, k2neg: C, k2: D } = K(B), { p: W, f: ht } = N(M), { p: G, f: $ } = N(D);
        U = ht.add($), v = F(S.beta, W, G, V, C);
      } else {
        const { p: V, f: M } = N(B);
        v = V, U = M;
      }
      return Dn(_, [v, U])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(B) {
      const { endo: S } = t, v = this;
      if (!i.isValid(B))
        throw new Error("invalid scalar: out of range");
      if (B === Dt || v.is0())
        return _.ZERO;
      if (B === Te)
        return v;
      if (Pt.hasCache(this))
        return this.multiply(B);
      if (S) {
        const { k1neg: U, k1: N, k2neg: V, k2: M } = K(B), { p1: C, p2: D } = jh(_, v, N, M);
        return F(S.beta, C, D, U, V);
      } else
        return Pt.unsafe(v, B);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(B) {
      return tt(this, B);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: B } = t;
      return a === Te ? !0 : B ? B(_, this) : Pt.unsafe(this, c).is0();
    }
    clearCofactor() {
      const { clearCofactor: B } = t;
      return a === Te ? this : B ? B(_, this) : this.multiplyUnsafe(a);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(a).is0();
    }
    toBytes(B = !0) {
      return lr(B, "isCompressed"), this.assertValidity(), y(_, this, B);
    }
    toHex(B = !0) {
      return Ar(this.toBytes(B));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const ot = i.BITS, Pt = new Gh(_, t.endo ? Math.ceil(ot / 2) : ot);
  return _.BASE.precompute(8), _;
}
function hs(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function as(e, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: !0,
    signature: 2 * t.BYTES
  };
}
function Jh(e, t = {}) {
  const { Fn: r } = e, n = t.randomBytes || $i, i = Object.assign(as(e.Fp, r), { seed: es(r.ORDER) });
  function h(y) {
    try {
      const I = r.fromBytes(y);
      return r.isValidNot0(I);
    } catch {
      return !1;
    }
  }
  function a(y, I) {
    const { publicKey: E, publicKeyUncompressed: T } = i;
    try {
      const O = y.length;
      return I === !0 && O !== E || I === !1 && O !== T ? !1 : !!e.fromBytes(y);
    } catch {
      return !1;
    }
  }
  function c(y = n(i.seed)) {
    return Wh(st(y, i.seed, "seed"), r.ORDER);
  }
  function d(y, I = !0) {
    return e.BASE.multiply(r.fromBytes(y)).toBytes(I);
  }
  function p(y) {
    const { secretKey: I, publicKey: E, publicKeyUncompressed: T } = i;
    if (!un(y) || "_lengths" in r && r._lengths || I === E)
      return;
    const O = st(y, void 0, "key").length;
    return O === E || O === T;
  }
  function f(y, I, E = !0) {
    if (p(y) === !0)
      throw new Error("first arg must be private key");
    if (p(I) === !1)
      throw new Error("second arg must be public key");
    const T = r.fromBytes(y);
    return e.fromBytes(I).multiply(T).toBytes(E);
  }
  const w = {
    isValidSecretKey: h,
    isValidPublicKey: a,
    randomSecretKey: c
  }, b = zh(c, d);
  return Object.freeze({ getPublicKey: d, getSharedSecret: f, keygen: b, Point: e, utils: w, lengths: i });
}
function ta(e, t, r = {}) {
  Mi(t), dn(r, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), r = Object.assign({}, r);
  const n = r.randomBytes || $i, i = r.hmac || ((S, v) => ss(t, S, v)), { Fp: h, Fn: a } = e, { ORDER: c, BITS: d } = a, { keygen: p, getPublicKey: f, getSharedSecret: w, utils: b, lengths: y } = Jh(e, r), I = {
    prehash: !0,
    lowS: typeof r.lowS == "boolean" ? r.lowS : !0,
    format: "compact",
    extraEntropy: !1
  }, E = c * os < h.ORDER;
  function T(S) {
    const v = c >> Te;
    return S > v;
  }
  function O(S, v) {
    if (!a.isValidNot0(v))
      throw new Error(`invalid signature ${S}: out of range 1..Point.Fn.ORDER`);
    return v;
  }
  function k() {
    if (E)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function P(S, v) {
    Gr(v);
    const U = y.signature, N = v === "compact" ? U : v === "recovered" ? U + 1 : void 0;
    return st(S, N);
  }
  class x {
    r;
    s;
    recovery;
    constructor(v, U, N) {
      if (this.r = O("r", v), this.s = O("s", U), N != null) {
        if (k(), ![0, 1, 2, 3].includes(N))
          throw new Error("invalid recovery id");
        this.recovery = N;
      }
      Object.freeze(this);
    }
    static fromBytes(v, U = I.format) {
      P(v, U);
      let N;
      if (U === "der") {
        const { r: D, s: W } = te.toSig(st(v));
        return new x(D, W);
      }
      U === "recovered" && (N = v[0], U = "compact", v = v.subarray(1));
      const V = y.signature / 2, M = v.subarray(0, V), C = v.subarray(V, V * 2);
      return new x(a.fromBytes(M), a.fromBytes(C), N);
    }
    static fromHex(v, U) {
      return this.fromBytes(cr(v), U);
    }
    assertRecovery() {
      const { recovery: v } = this;
      if (v == null)
        throw new Error("invalid recovery id: must be present");
      return v;
    }
    addRecoveryBit(v) {
      return new x(this.r, this.s, v);
    }
    recoverPublicKey(v) {
      const { r: U, s: N } = this, V = this.assertRecovery(), M = V === 2 || V === 3 ? U + c : U;
      if (!h.isValid(M))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const C = h.toBytes(M), D = e.fromBytes(ee(hs((V & 1) === 0), C)), W = a.inv(M), ht = tt(st(v, void 0, "msgHash")), G = a.create(-ht * W), $ = a.create(N * W), Q = e.BASE.multiplyUnsafe(G).add(D.multiplyUnsafe($));
      if (Q.is0())
        throw new Error("invalid recovery: point at infinify");
      return Q.assertValidity(), Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return T(this.s);
    }
    toBytes(v = I.format) {
      if (Gr(v), v === "der")
        return cr(te.hexFromSig(this));
      const { r: U, s: N } = this, V = a.toBytes(U), M = a.toBytes(N);
      return v === "recovered" ? (k(), ee(Uint8Array.of(this.assertRecovery()), V, M)) : ee(V, M);
    }
    toHex(v) {
      return Ar(this.toBytes(v));
    }
  }
  const K = r.bits2int || function(S) {
    if (S.length > 8192)
      throw new Error("input is too large");
    const v = Ir(S), U = S.length * 8 - d;
    return U > 0 ? v >> BigInt(U) : v;
  }, tt = r.bits2int_modN || function(S) {
    return a.create(K(S));
  }, Bt = ln(d);
  function F(S) {
    return Ph("num < 2^" + d, S, Dt, Bt), a.toBytes(S);
  }
  function _(S, v) {
    return st(S, void 0, "message"), v ? st(t(S), void 0, "prehashed message") : S;
  }
  function ot(S, v, U) {
    const { lowS: N, prehash: V, extraEntropy: M } = Lr(U, I);
    S = _(S, V);
    const C = tt(S), D = a.fromBytes(v);
    if (!a.isValidNot0(D))
      throw new Error("invalid private key");
    const W = [F(D), F(C)];
    if (M != null && M !== !1) {
      const Q = M === !0 ? n(y.secretKey) : M;
      W.push(st(Q, void 0, "extraEntropy"));
    }
    const ht = ee(...W), G = C;
    function $(Q) {
      const at = K(Q);
      if (!a.isValidNot0(at))
        return;
      const St = a.inv(at), J = e.BASE.multiply(at).toAffine(), ft = a.create(J.x);
      if (ft === Dt)
        return;
      const Rt = a.create(St * a.create(G + ft * D));
      if (Rt === Dt)
        return;
      let pe = (J.x === ft ? 0 : 2) | Number(J.y & Te), Ce = Rt;
      return N && T(Rt) && (Ce = a.neg(Rt), pe ^= 1), new x(ft, Ce, E ? void 0 : pe);
    }
    return { seed: ht, k2sig: $ };
  }
  function Pt(S, v, U = {}) {
    const { seed: N, k2sig: V } = ot(S, v, U);
    return Hh(t.outputLen, a.BYTES, i)(N, V).toBytes(U.format);
  }
  function Z(S, v, U, N = {}) {
    const { lowS: V, prehash: M, format: C } = Lr(N, I);
    if (U = st(U, void 0, "publicKey"), v = _(v, M), !un(S)) {
      const D = S instanceof x ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + D);
    }
    P(S, C);
    try {
      const D = x.fromBytes(S, C), W = e.fromBytes(U);
      if (V && D.hasHighS())
        return !1;
      const { r: ht, s: G } = D, $ = tt(v), Q = a.inv(G), at = a.create($ * Q), St = a.create(ht * Q), J = e.BASE.multiplyUnsafe(at).add(W.multiplyUnsafe(St));
      return J.is0() ? !1 : a.create(J.x) === ht;
    } catch {
      return !1;
    }
  }
  function B(S, v, U = {}) {
    const { prehash: N } = Lr(U, I);
    return v = _(v, N), x.fromBytes(S, "recovered").recoverPublicKey(v).toBytes();
  }
  return Object.freeze({
    keygen: p,
    getPublicKey: f,
    getSharedSecret: w,
    utils: b,
    lengths: y,
    Point: e,
    sign: Pt,
    verify: Z,
    recoverPublicKey: B,
    Signature: x,
    hash: t
  });
}
const wn = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, ea = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, qn = /* @__PURE__ */ BigInt(2);
function ra(e) {
  const t = wn.p, r = BigInt(3), n = BigInt(6), i = BigInt(11), h = BigInt(22), a = BigInt(23), c = BigInt(44), d = BigInt(88), p = e * e * e % t, f = p * p * e % t, w = xt(f, r, t) * f % t, b = xt(w, r, t) * f % t, y = xt(b, qn, t) * p % t, I = xt(y, i, t) * y % t, E = xt(I, h, t) * I % t, T = xt(E, c, t) * E % t, O = xt(T, d, t) * T % t, k = xt(O, c, t) * E % t, P = xt(k, r, t) * f % t, x = xt(P, a, t) * I % t, K = xt(x, n, t) * p % t, tt = xt(K, qn, t);
  if (!jr.eql(jr.sqr(tt), e))
    throw new Error("Cannot find square root");
  return tt;
}
const jr = vr(wn.p, { sqrt: ra }), na = /* @__PURE__ */ Qh(wn, {
  Fp: jr,
  endo: ea
}), ia = /* @__PURE__ */ ta(na, Bh), sa = ia.Point;
sa.Fn.ORDER;
function L(e) {
  return wh(e);
}
function Y(e, t) {
  if (!e) throw new Error(`verifyCryptoBackend: ${t}`);
}
function oa(e) {
  Y(
    e.isPoint(L("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPoint should accept generator point"
  ), Y(
    !e.isPoint(L("030000000000000000000000000000000000000000000000000000000000000005")),
    "isPoint should reject invalid point"
  ), Y(
    e.isXOnlyPoint(
      L("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "isXOnlyPoint should accept generator x-coordinate"
  ), Y(
    !e.isXOnlyPoint(
      L("0000000000000000000000000000000000000000000000000000000000000005")
    ),
    "isXOnlyPoint should reject x-coordinate not on curve"
  ), Y(
    !e.isXOnlyPoint(
      L("0000000000000000000000000000000000000000000000000000000000000000")
    ),
    "isXOnlyPoint should reject zero"
  ), Y(
    !e.isXOnlyPoint(L("79be667ef9dcbbac55a06295ce870b07")),
    "isXOnlyPoint should reject wrong length"
  ), Y(
    e.isPrivate(L("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPrivate should accept valid scalar"
  ), Y(
    e.isPrivate(L("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")),
    "isPrivate should accept n-1"
  ), Y(
    !e.isPrivate(L("0000000000000000000000000000000000000000000000000000000000000000")),
    "isPrivate should reject zero"
  ), Y(
    !e.isPrivate(L("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")),
    "isPrivate should reject n"
  ), Y(
    !e.isPrivate(L("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")),
    "isPrivate should reject n+1"
  );
  const t = e.privateAdd(
    L("0000000000000000000000000000000000000000000000000000000000000001"),
    L("0000000000000000000000000000000000000000000000000000000000000000")
  );
  Y(
    t !== null && bt(
      t,
      L("0000000000000000000000000000000000000000000000000000000000000001")
    ),
    "privateAdd: 1 + 0 should equal 1"
  ), Y(
    e.privateAdd(
      L("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      L("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null,
    "privateAdd: (n-3) + 3 should return null (result is zero mod n)"
  );
  const r = e.privateAdd(
    L("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
    L("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
  );
  Y(
    r !== null && bt(
      r,
      L("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    ),
    "privateAdd: known vector failed"
  ), Y(
    bt(
      e.privateNegate(
        L("0000000000000000000000000000000000000000000000000000000000000001")
      ),
      L("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ),
    "privateNegate(1) should equal n-1"
  ), Y(
    bt(
      e.privateNegate(
        L("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      ),
      L("0000000000000000000000000000000000000000000000000000000000000003")
    ),
    "privateNegate(n-3) should equal 3"
  ), Y(
    bt(
      e.privateNegate(
        L("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      ),
      L("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    ),
    "privateNegate known vector failed"
  ), Y(
    bt(
      e.pointCompress(
        L(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !0
      ),
      L("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress uncompressed->compressed failed"
  ), Y(
    bt(
      e.pointCompress(
        L(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !1
      ),
      L(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress uncompressed->uncompressed failed"
  ), Y(
    bt(
      e.pointCompress(
        L(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        !0
      ),
      L("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress compressed->compressed failed"
  ), Y(
    bt(
      e.pointCompress(
        L(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        !1
      ),
      L(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress compressed->uncompressed failed"
  );
  const n = e.pointFromScalar(
    L("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
  );
  Y(
    n !== null && bt(
      n,
      L("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    ),
    "pointFromScalar known vector failed"
  ), Y(
    e.xOnlyPointAddTweak(
      L("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      L("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null,
    "xOnlyPointAddTweak should return null for infinity result"
  );
  let i = e.xOnlyPointAddTweak(
    L("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    L("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  Y(
    i !== null && bt(
      i.xOnlyPubkey,
      L("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && i.parity === 1,
    "xOnlyPointAddTweak parity=1 case failed"
  ), i = e.xOnlyPointAddTweak(
    L("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    L("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), Y(
    i !== null && bt(
      i.xOnlyPubkey,
      L("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && i.parity === 0,
    "xOnlyPointAddTweak parity=0 case failed"
  );
  const h = e.sign(
    L("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
    L("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
  );
  if (Y(
    bt(
      h,
      L(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    ),
    "sign known vector failed"
  ), Y(
    e.verify(
      L("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      L("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      h
    ),
    "verify known vector failed"
  ), e.signSchnorr) {
    const a = e.signSchnorr(
      L("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      L("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
      L("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
    );
    Y(
      bt(
        a,
        L(
          "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
        )
      ),
      "signSchnorr known vector failed"
    );
  }
  e.verifySchnorr && Y(
    e.verifySchnorr(
      L(
        "7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"
      ),
      L(
        "dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"
      ),
      L(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    ),
    "verifySchnorr known vector failed"
  );
}
class Et {
  static #e;
  #h;
  constructor(t) {
    this.#h = t;
  }
  /**
   * The underlying ECC library instance.
   */
  get lib() {
    return this.#h;
  }
  /**
   * Initializes the ECC context with the provided library.
   * The library is verified before being set as active.
   *
   * @param lib - The CryptoBackend instance to initialize
   * @returns The initialized EccContext instance
   * @throws Error if the CryptoBackend fails verification
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   * import { createNobleBackend } from '@btc-vision/ecpair';
   *
   * const context = EccContext.init(createNobleBackend());
   * ```
   */
  static init(t) {
    return Et.#e && Et.#e.#h === t ? Et.#e : (oa(t), Et.#e = new Et(t), Et.#e);
  }
  /**
   * Gets the initialized ECC context.
   *
   * @returns The EccContext instance
   * @throws Error if the context has not been initialized
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * const context = EccContext.get();
   * const tweaked = context.lib.xOnlyPointAddTweak(key, tweak);
   * ```
   */
  static get() {
    if (!Et.#e)
      throw new Error(
        "ECC library not initialized. Call EccContext.init() or initEccLib() first."
      );
    return Et.#e;
  }
  /**
   * Clears the ECC context.
   * Useful for testing or when reinitializing with a different library.
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * EccContext.clear();
   * // Context is now uninitialized
   * ```
   */
  static clear() {
    Et.#e = void 0;
  }
  /**
   * Checks if the ECC context has been initialized.
   *
   * @returns True if initialized
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * if (!EccContext.isInitialized()) {
   *     EccContext.init(createNobleBackend());
   * }
   * ```
   */
  static isInitialized() {
    return Et.#e !== void 0;
  }
}
function mu(e) {
  if (e === void 0) {
    Et.clear();
    return;
  }
  Et.init(e);
}
function ha() {
  return Et.get().lib;
}
const Re = 192, us = 128, aa = (e) => "left" in e && "right" in e;
function qr(e, t) {
  if (e.length < 33)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 33.`
    );
  const r = (e.length - 33) / 32;
  let n = t;
  for (let i = 0; i < r; i++) {
    const h = e.subarray(33 + 32 * i, 65 + 32 * i);
    Kt(n, h) < 0 ? n = Ke(n, h) : n = Ke(h, n);
  }
  return n;
}
function pr(e, t) {
  if (e.length < 1)
    throw new TypeError(
      `The control-block length is too small. Got ${e.length}, expected min 1.`
    );
  const r = (e.length - 1) / 32;
  let n = t;
  for (let i = 0; i < r; i++) {
    const h = e.subarray(1 + 32 * i, 33 + 32 * i);
    Kt(n, h) < 0 ? n = Ke(n, h) : n = Ke(h, n);
  }
  return n;
}
function wr(e) {
  if (yr(e)) return { hash: kt(e) };
  const t = [wr(e[0]), wr(e[1])];
  t.sort((i, h) => Kt(i.hash, h.hash));
  const r = t[0], n = t[1];
  return {
    hash: Ke(r.hash, n.hash),
    left: r,
    right: n
  };
}
function He(e, t) {
  if (aa(e)) {
    const r = He(e.left, t);
    if (r !== void 0) return [...r, e.right.hash];
    const n = He(e.right, t);
    if (n !== void 0) return [...n, e.left.hash];
  } else if (H(e.hash, t))
    return [];
}
function kt(e) {
  const t = e.version || Re;
  return We(
    "TapLeaf",
    vt([new Uint8Array([t]), fa(e.output)])
  );
}
function ua(e, t) {
  return We("TapTweak", t ? vt([e, t]) : e);
}
function Me(e, t) {
  if (!(e instanceof Uint8Array) || e.length !== 32 || t && t.length !== 32) return null;
  const r = ua(e, t), n = ha().xOnlyPointAddTweak(e, r);
  return !n || n.xOnlyPubkey === null ? null : {
    parity: n.parity,
    x: new Uint8Array(n.xOnlyPubkey)
  };
}
function Ke(e, t) {
  return We("TapBranch", vt([e, t]));
}
function fa(e) {
  const t = re(e.length), r = wt(t);
  return Xr(e.length, r), vt([r, e]);
}
const zn = z, Zn = 2, ca = 80;
class Ae {
  static NAME = ct.P2MR;
  #e;
  #h;
  #t;
  #s;
  #n;
  #r;
  #i;
  #o;
  #a;
  #f;
  #u;
  #c;
  #p;
  #w;
  #l;
  #d = !1;
  #g = !1;
  #y = !1;
  #b = !1;
  #E = !1;
  #A = !1;
  #I;
  #m = !1;
  #S;
  #v = !1;
  #T;
  #B = !1;
  /**
   * Creates a new P2MR payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32m encoded address (bc1z...)
   * @param params.hash - Merkle root (32 bytes, = witness program)
   * @param params.scriptTree - Full script tree definition
   * @param params.output - The scriptPubKey
   * @param params.witness - The witness stack
   * @param params.redeem - Redeem script for script-path spending
   * @param params.redeemVersion - Leaf version (defaults to LEAF_VERSION_TAPSCRIPT)
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    this.#e = t.network ?? Mt, this.#h = {
      validate: r?.validate ?? !0,
      allowIncomplete: r?.allowIncomplete ?? !1
    }, this.#t = t.address, this.#s = t.hash, this.#n = t.scriptTree, this.#r = t.output, this.#i = t.witness, this.#o = t.redeem, this.#a = t.redeemVersion, this.#h.validate && this.#_();
  }
  /**
   * Payment type discriminant.
   *
   * @returns The P2MR payment type constant.
   */
  get name() {
    return ct.P2MR;
  }
  /**
   * Network parameters used for address encoding.
   *
   * @returns The network configuration (mainnet, testnet, or regtest).
   */
  get network() {
    return this.#e;
  }
  /**
   * Bech32m encoded address (bc1z... for mainnet).
   *
   * @returns The bech32m-encoded address, or `undefined` if insufficient data.
   */
  get address() {
    return this.#d || (this.#f = this.#k(), this.#d = !0), this.#f;
  }
  /**
   * Merkle root hash (32 bytes). This is the witness program and directly
   * appears in the output script.
   *
   * @returns The 32-byte merkle root, or `undefined` if insufficient data.
   */
  get hash() {
    return this.#g || (this.#u = this.#P(), this.#g = !0), this.#u;
  }
  /**
   * The scriptPubKey: `OP_2 <32-byte merkle root>` (34 bytes total).
   *
   * @returns The output script, or `undefined` if insufficient data.
   */
  get output() {
    return this.#y || (this.#c = this.#R(), this.#y = !0), this.#c;
  }
  /**
   * Redeem script information for script-path spending.
   *
   * @returns The redeem script data, or `undefined` if not available.
   */
  get redeem() {
    return this.#b || (this.#p = this.#H(), this.#b = !0), this.#p;
  }
  /**
   * Leaf version used for script-path hashing.
   *
   * @returns The leaf version byte (defaults to LEAF_VERSION_TAPSCRIPT = 0xc0).
   */
  get redeemVersion() {
    return this.#E || (this.#w = this.#L(), this.#E = !0), this.#w ?? Re;
  }
  /**
   * Witness stack for script-path spending.
   * Format: `[script inputs..., script, control block]`
   *
   * @returns The witness stack array, or `undefined` if insufficient data.
   */
  get witness() {
    return this.#A || (this.#l = this.#C(), this.#A = !0), this.#l;
  }
  /**
   * Creates a P2MR payment from a script tree.
   *
   * @param scriptTree - The script tree
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromScriptTree(t, r) {
    return new Ae({ scriptTree: t, network: r });
  }
  /**
   * Creates a P2MR payment from a bech32m address.
   *
   * @param address - Bech32m encoded address (bc1z...)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromAddress(t, r) {
    return new Ae({ address: t, network: r });
  }
  /**
   * Creates a P2MR payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromOutput(t, r) {
    return new Ae({ output: t, network: r });
  }
  /**
   * Creates a P2MR payment from a merkle root hash.
   *
   * @param hash - The 32-byte merkle root
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MR payment instance
   */
  static fromHash(t, r) {
    return new Ae({ hash: t, network: r });
  }
  /**
   * Converts to a plain P2MRPayment object for backwards compatibility.
   *
   * @returns A P2MRPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      scriptTree: this.#n,
      output: this.output,
      redeem: this.redeem,
      redeemVersion: this.redeemVersion,
      witness: this.witness
    };
  }
  #O() {
    if (!this.#m) {
      if (this.#t) {
        const t = Yr(this.#t);
        t && (this.#I = {
          version: t.version,
          prefix: t.prefix,
          data: t.data
        });
      }
      this.#m = !0;
    }
    return this.#I;
  }
  #x() {
    if (!this.#v) {
      if (this.#i && this.#i.length > 0) {
        const t = this.#i[this.#i.length - 1];
        this.#i.length >= 2 && t && t[0] === ca ? this.#S = this.#i.slice(0, -1) : this.#S = this.#i.slice();
      }
      this.#v = !0;
    }
    return this.#S;
  }
  #U() {
    return this.#B || (this.#n ? this.#T = wr(this.#n) : this.#s && (this.#T = { hash: this.#s }), this.#B = !0), this.#T;
  }
  #k() {
    if (this.#t)
      return this.#t;
    const t = this.hash;
    if (!t) return;
    const r = lt.bech32m.toWords(t);
    return r.unshift(Zn), lt.bech32m.encode(this.#e.bech32, r);
  }
  #P() {
    if (this.#s)
      return this.#s;
    const t = this.#U();
    if (t)
      return t.hash;
    if (this.#r)
      return this.#r.subarray(2);
    if (this.#t)
      return this.#O()?.data;
    const r = this.#x();
    if (r && r.length > 1) {
      const n = r[r.length - 1], i = n[0] & ue, h = r[r.length - 2], a = kt({
        output: h,
        version: i
      });
      return pr(n, a);
    }
  }
  #R() {
    if (this.#r)
      return this.#r;
    const t = this.hash;
    if (t)
      return dt([zn.OP_2, t]);
  }
  #H() {
    if (this.#o)
      return this.#o;
    const t = this.#x();
    if (!t || t.length < 2)
      return;
    const r = t[t.length - 1];
    return {
      output: t[t.length - 2],
      witness: t.slice(0, -2),
      redeemVersion: r[0] & ue
    };
  }
  #L() {
    return this.#a !== void 0 ? this.#a : this.#o && this.#o.redeemVersion !== void 0 && this.#o.redeemVersion !== null ? this.#o.redeemVersion : Re;
  }
  #C() {
    if (this.#i)
      return this.#i;
    const t = this.#U();
    if (t && this.#o?.output) {
      const r = kt({
        output: this.#o.output,
        version: this.redeemVersion
      }), n = He(t, r);
      if (!n) return;
      const i = this.redeemVersion ?? 192, h = vt([
        new Uint8Array([i | 1]),
        ...n
      ]);
      return [this.#o.output, h];
    }
  }
  #_() {
    let t = new Uint8Array(0);
    if (this.#t) {
      const i = this.#O();
      if (!i)
        throw new TypeError("Invalid address");
      if (this.#e && this.#e.bech32 !== i.prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (i.version !== Zn)
        throw new TypeError("Invalid address version");
      if (i.data.length !== 32)
        throw new TypeError("Invalid address data");
      t = i.data;
    }
    if (this.#r) {
      if (this.#r.length !== 34 || this.#r[0] !== zn.OP_2 || this.#r[1] !== 32)
        throw new TypeError("Output is invalid");
      if (t.length > 0 && !H(t, this.#r.subarray(2)))
        throw new TypeError("Hash mismatch");
      t = this.#r.subarray(2);
    }
    if (this.#s) {
      if (this.#s.length !== 32)
        throw new TypeError("Invalid hash length");
      if (t.length > 0 && !H(t, this.#s))
        throw new TypeError("Hash mismatch");
    }
    const r = this.#U();
    if (this.#s && r && !H(this.#s, r.hash))
      throw new TypeError("Hash mismatch");
    if (this.#o?.output && r) {
      const i = kt({
        output: this.#o.output,
        version: this.redeemVersion
      });
      if (!He(r, i))
        throw new TypeError("Redeem script not in tree");
    }
    const n = this.#x();
    if (this.#o && this.redeem) {
      if (this.#o.redeemVersion && this.#o.redeemVersion !== this.redeem.redeemVersion)
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      if (this.#o.output) {
        const i = it(this.#o.output);
        if (!i || i.length === 0)
          throw new TypeError("Redeem.output is invalid");
        if (this.redeem.output && !H(this.#o.output, this.redeem.output))
          throw new TypeError("Redeem.output and witness mismatch");
      }
      if (this.#o.witness && this.redeem.witness && !ke(this.#o.witness, this.redeem.witness))
        throw new TypeError("Redeem.witness and witness mismatch");
    }
    if (n && n.length > 0) {
      if (n.length < 2)
        throw new TypeError(
          "P2MR requires at least 2 witness items (script + control block)"
        );
      const i = n[n.length - 1];
      if (i.length < 1)
        throw new TypeError(
          `The control-block length is too small. Got ${i.length}, expected min 1.`
        );
      if ((i.length - 1) % 32 !== 0)
        throw new TypeError(
          `The control-block length of ${i.length} is incorrect!`
        );
      const h = (i.length - 1) / 32;
      if (h > 128)
        throw new TypeError(`The script path is too long. Got ${h}, expected max 128.`);
      const a = i[0];
      if ((a & 1) !== 1)
        throw new TypeError("P2MR control byte parity bit must be 1");
      const c = a & ue, d = n[n.length - 2], p = kt({
        output: d,
        version: c
      }), f = pr(i, p);
      if (t.length > 0 && !H(t, f))
        throw new TypeError("Merkle root mismatch for p2mr witness");
    }
  }
}
function la(e, t) {
  if (!e.address && !e.output && !e.hash && !e.scriptTree && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  const r = new Ae(
    {
      address: e.address,
      hash: e.hash,
      scriptTree: e.scriptTree,
      output: e.output,
      witness: e.witness,
      redeem: e.redeem,
      redeemVersion: e.redeemVersion,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
const Yn = z, Xn = 1, da = 80;
class Ie {
  // Static public fields
  static NAME = ct.P2TR;
  // Private instance fields
  #e;
  #h;
  // Input data (provided by user)
  #t;
  #s;
  #n;
  #r;
  #i;
  #o;
  #a;
  #f;
  #u;
  #c;
  // Cached computed values
  #p;
  #w;
  #l;
  #d;
  #g;
  #y;
  #b;
  #E;
  #A;
  // Cache flags
  #I = !1;
  #m = !1;
  #S = !1;
  #v = !1;
  #T = !1;
  #B = !1;
  #O = !1;
  #x = !1;
  #U = !1;
  // Decoded address cache
  #k;
  #P = !1;
  // Witness without annex
  #R;
  #H = !1;
  // Hash tree cache
  #L;
  #C = !1;
  /**
   * Creates a new P2TR payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32m encoded address (bc1p...)
   * @param params.pubkey - x-only output pubkey (32 bytes)
   * @param params.internalPubkey - x-only internal pubkey (32 bytes)
   * @param params.hash - Merkle root (32 bytes, or empty for key-path only)
   * @param params.scriptTree - Full script tree definition
   * @param params.signature - Schnorr signature (for key-path spending)
   * @param params.output - The scriptPubKey
   * @param params.witness - The witness stack
   * @param params.redeem - Redeem script for script-path spending
   * @param params.redeemVersion - Leaf version (defaults to LEAF_VERSION_TAPSCRIPT)
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    this.#e = t.network ?? Mt, this.#h = {
      validate: r?.validate ?? !0,
      allowIncomplete: r?.allowIncomplete ?? !1
    }, this.#t = t.address, this.#s = t.pubkey, this.#n = t.internalPubkey, this.#r = t.hash, this.#i = t.scriptTree, this.#o = t.signature, this.#a = t.output, this.#f = t.witness, this.#u = t.redeem, this.#c = t.redeemVersion, this.#h.validate && this.#z();
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ct.P2TR;
  }
  /**
   * Network parameters.
   */
  get network() {
    return this.#e;
  }
  /**
   * Bech32m encoded address (bc1p... for mainnet).
   */
  get address() {
    return this.#I || (this.#p = this.#M(), this.#I = !0), this.#p;
  }
  /**
   * x-only output pubkey (32 bytes).
   * This is the tweaked pubkey that appears in the output.
   */
  get pubkey() {
    return this.#m || (this.#w = this.#F(), this.#m = !0), this.#w;
  }
  /**
   * x-only internal pubkey (32 bytes).
   * This is the untweaked pubkey before adding the merkle root tweak.
   */
  get internalPubkey() {
    return this.#S || (this.#l = this.#$(), this.#S = !0), this.#l;
  }
  /**
   * Merkle root hash (32 bytes).
   * Present when a script tree is defined.
   */
  get hash() {
    return this.#v || (this.#d = this.#D(), this.#v = !0), this.#d;
  }
  /**
   * Schnorr signature (for key-path spending).
   */
  get signature() {
    return this.#T || (this.#g = this.#K(), this.#T = !0), this.#g;
  }
  /**
   * The scriptPubKey: `OP_1 {32-byte x-only pubkey}`
   */
  get output() {
    return this.#B || (this.#y = this.#W(), this.#B = !0), this.#y;
  }
  /**
   * Redeem script information (for script-path spending).
   */
  get redeem() {
    return this.#O || (this.#b = this.#G(), this.#O = !0), this.#b;
  }
  /**
   * Leaf version (defaults to LEAF_VERSION_TAPSCRIPT = 0xc0).
   */
  get redeemVersion() {
    return this.#x || (this.#E = this.#j(), this.#x = !0), this.#E ?? Re;
  }
  /**
   * Witness stack.
   * Key-path: `[signature]`
   * Script-path: `[script inputs..., script, control block]`
   */
  get witness() {
    return this.#U || (this.#A = this.#q(), this.#U = !0), this.#A;
  }
  // Static factory methods
  /**
   * Creates a P2TR payment from an internal pubkey (key-path only).
   *
   * @param internalPubkey - x-only internal pubkey (32 bytes)
   * @param scriptTree - Optional script tree
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   *
   * @example
   * ```typescript
   * // Key-path only
   * const p2tr = P2TR.fromInternalPubkey(internalPubkey);
   *
   * // With script tree
   * const withScripts = P2TR.fromInternalPubkey(internalPubkey, scriptTree);
   * ```
   */
  static fromInternalPubkey(t, r, n) {
    return new Ie({ internalPubkey: t, scriptTree: r, network: n });
  }
  /**
   * Creates a P2TR payment from a bech32m address.
   *
   * @param address - Bech32m encoded address (bc1p...)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   */
  static fromAddress(t, r) {
    return new Ie({ address: t, network: r });
  }
  /**
   * Creates a P2TR payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   */
  static fromOutput(t, r) {
    return new Ie({ output: t, network: r });
  }
  /**
   * Creates a P2TR payment from a signature (for key-path spending).
   *
   * @param signature - Schnorr signature
   * @param internalPubkey - x-only internal pubkey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2TR payment instance
   */
  static fromSignature(t, r, n) {
    return new Ie({ signature: t, internalPubkey: r, network: n });
  }
  // Private helper methods
  /**
   * Converts to a plain P2TRPayment object for backwards compatibility.
   *
   * @returns A P2TRPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      pubkey: this.pubkey,
      internalPubkey: this.internalPubkey,
      hash: this.hash,
      scriptTree: this.#i,
      signature: this.signature,
      output: this.output,
      redeem: this.redeem,
      redeemVersion: this.redeemVersion,
      witness: this.witness
    };
  }
  #_() {
    if (!this.#P) {
      if (this.#t) {
        const t = Yr(this.#t);
        t && (this.#k = {
          version: t.version,
          prefix: t.prefix,
          data: t.data
        });
      }
      this.#P = !0;
    }
    return this.#k;
  }
  #N() {
    if (!this.#H) {
      if (this.#f && this.#f.length > 0) {
        const t = this.#f[this.#f.length - 1];
        this.#f.length >= 2 && t && t[0] === da ? this.#R = this.#f.slice(0, -1) : this.#R = this.#f.slice();
      }
      this.#H = !0;
    }
    return this.#R;
  }
  // Private computation methods
  #V() {
    return this.#C || (this.#i ? this.#L = wr(this.#i) : this.#r && (this.#L = { hash: this.#r }), this.#C = !0), this.#L;
  }
  #M() {
    if (this.#t)
      return this.#t;
    const t = this.pubkey;
    if (!t) return;
    const r = lt.bech32m.toWords(t);
    return r.unshift(Xn), lt.bech32m.encode(this.#e.bech32, r);
  }
  #F() {
    if (this.#s)
      return this.#s;
    if (this.#a)
      return this.#a.subarray(2);
    if (this.#t)
      return this.#_()?.data;
    const t = this.internalPubkey;
    if (t) {
      const r = Me(t, this.hash);
      if (r)
        return r.x;
    }
  }
  #$() {
    if (this.#n)
      return this.#n;
    const t = this.#N();
    if (t && t.length > 1) {
      const r = t[t.length - 1];
      if (r)
        return r.subarray(1, 33);
    }
  }
  #D() {
    const t = this.#V();
    if (t)
      return t.hash;
    const r = this.#N();
    if (r && r.length > 1) {
      const n = r[r.length - 1], i = n[0] & ue, h = r[r.length - 2], a = kt({
        output: h,
        version: i
      });
      return qr(n, a);
    }
  }
  #K() {
    if (this.#o)
      return this.#o;
    const t = this.#N();
    if (t && t.length === 1)
      return t[0];
  }
  #W() {
    if (this.#a)
      return this.#a;
    const t = this.pubkey;
    if (t)
      return dt([Yn.OP_1, t]);
  }
  #G() {
    if (this.#u)
      return this.#u;
    const t = this.#N();
    if (!t || t.length < 2)
      return;
    const r = t[t.length - 1];
    return {
      output: t[t.length - 2],
      witness: t.slice(0, -2),
      redeemVersion: r[0] & ue
    };
  }
  #j() {
    return this.#c !== void 0 ? this.#c : this.#u && this.#u.redeemVersion !== void 0 && this.#u.redeemVersion !== null ? this.#u.redeemVersion : Re;
  }
  // Validation
  #q() {
    if (this.#f)
      return this.#f;
    const t = this.#V();
    if (t && this.#u?.output && this.#n) {
      const r = kt({
        output: this.#u.output,
        version: this.redeemVersion
      }), n = He(t, r);
      if (!n) return;
      const i = Me(this.#n, t.hash);
      if (!i) return;
      const h = this.redeemVersion ?? 192, a = vt([
        new Uint8Array([h | i.parity]),
        this.#n,
        ...n
      ]);
      return [this.#u.output, a];
    }
    if (this.#o)
      return [this.#o];
  }
  #z() {
    let t = new Uint8Array(0);
    if (this.#t) {
      const i = this.#_();
      if (!i)
        throw new TypeError("Invalid address");
      if (this.#e && this.#e.bech32 !== i.prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (i.version !== Xn)
        throw new TypeError("Invalid address version");
      if (i.data.length !== 32)
        throw new TypeError("Invalid address data");
      t = i.data;
    }
    if (this.#s) {
      if (t.length > 0 && !H(t, this.#s))
        throw new TypeError("Pubkey mismatch");
      t = this.#s;
    }
    if (this.#a) {
      if (this.#a.length !== 34 || this.#a[0] !== Yn.OP_1 || this.#a[1] !== 32)
        throw new TypeError("Output is invalid");
      if (t.length > 0 && !H(t, this.#a.subarray(2)))
        throw new TypeError("Pubkey mismatch");
      t = this.#a.subarray(2);
    }
    if (this.#n) {
      const i = Me(this.#n, this.hash);
      if (!i)
        throw new TypeError("Invalid internal pubkey");
      if (t.length > 0 && !H(t, i.x))
        throw new TypeError("Pubkey mismatch");
      t = i.x;
    }
    const r = this.#V();
    if (this.#r && r && !H(this.#r, r.hash))
      throw new TypeError("Hash mismatch");
    if (this.#u?.output && r) {
      const i = kt({
        output: this.#u.output,
        version: this.redeemVersion
      });
      if (!He(r, i))
        throw new TypeError("Redeem script not in tree");
    }
    const n = this.#N();
    if (this.#u && this.redeem) {
      if (this.#u.redeemVersion && this.#u.redeemVersion !== this.redeem.redeemVersion)
        throw new TypeError("Redeem.redeemVersion and witness mismatch");
      if (this.#u.output) {
        const i = it(this.#u.output);
        if (!i || i.length === 0)
          throw new TypeError("Redeem.output is invalid");
        if (this.redeem.output && !H(this.#u.output, this.redeem.output))
          throw new TypeError("Redeem.output and witness mismatch");
      }
      if (this.#u.witness && this.redeem.witness && !ke(this.#u.witness, this.redeem.witness))
        throw new TypeError("Redeem.witness and witness mismatch");
    }
    if (n && n.length > 0)
      if (n.length === 1) {
        const i = n[0];
        if (this.#o && !H(this.#o, i))
          throw new TypeError("Signature mismatch");
      } else {
        const i = n[n.length - 1];
        if (i.length < 33)
          throw new TypeError(
            `The control-block length is too small. Got ${i.length}, expected min 33.`
          );
        if ((i.length - 33) % 32 !== 0)
          throw new TypeError(
            `The control-block length of ${i.length} is incorrect!`
          );
        const h = (i.length - 33) / 32;
        if (h > 128)
          throw new TypeError(`The script path is too long. Got ${h}, expected max 128.`);
        const a = i.subarray(1, 33);
        if (this.#n && !H(this.#n, a))
          throw new TypeError("Internal pubkey mismatch");
        if (!Bo(a))
          throw new TypeError("Invalid internalPubkey for p2tr witness");
        const c = i[0], d = c & ue, p = n[n.length - 2], f = kt({
          output: p,
          version: d
        }), w = qr(i, f), b = Me(a, w);
        if (!b)
          throw new TypeError("Invalid outputKey for p2tr witness");
        if (t.length > 0 && !H(t, b.x))
          throw new TypeError("Pubkey mismatch for p2tr witness");
        if (b.parity !== (c & 1))
          throw new Error("Incorrect parity");
      }
  }
}
function fs(e, t) {
  if (!e.address && !e.output && !e.pubkey && !e.internalPubkey && !(e.witness && e.witness.length > 1))
    throw new TypeError("Not enough data");
  const r = new Ie(
    {
      address: e.address,
      pubkey: e.pubkey,
      internalPubkey: e.internalPubkey,
      hash: e.hash,
      scriptTree: e.scriptTree,
      signature: e.signature,
      output: e.output,
      witness: e.witness,
      redeem: e.redeem,
      redeemVersion: e.redeemVersion,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
const Qn = z, pa = new Uint8Array(0);
class ve {
  // Static public fields
  static NAME = ct.P2WPKH;
  // Private instance fields
  #e;
  #h;
  // Input data (provided by user)
  #t;
  #s;
  #n;
  #r;
  #i;
  #o;
  // Cached computed values
  #a;
  #f;
  #u;
  #c;
  #p;
  #w;
  #l;
  // Cache flags
  #d = !1;
  #g = !1;
  #y = !1;
  #b = !1;
  #E = !1;
  #A = !1;
  #I = !1;
  // Decoded address cache
  #m;
  #S = !1;
  /**
   * Creates a new P2WPKH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32 encoded address
   * @param params.hash - 20-byte witness program (pubkey hash)
   * @param params.pubkey - The public key (must be 33 bytes compressed)
   * @param params.signature - DER-encoded signature
   * @param params.output - The scriptPubKey
   * @param params.witness - The witness stack [signature, pubkey]
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    this.#e = t.network ?? Mt, this.#h = {
      validate: r?.validate ?? !0,
      allowIncomplete: r?.allowIncomplete ?? !1
    }, this.#t = t.address, this.#s = t.hash, this.#n = t.pubkey, this.#r = t.signature, this.#i = t.output, this.#o = t.witness, this.#h.validate && this.#R();
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ct.P2WPKH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return this.#e;
  }
  /**
   * Bech32 encoded address (bc1q... for mainnet).
   */
  get address() {
    return this.#d || (this.#a = this.#T(), this.#d = !0), this.#a;
  }
  /**
   * 20-byte witness program (RIPEMD160(SHA256(pubkey))).
   */
  get hash() {
    return this.#g || (this.#f = this.#B(), this.#g = !0), this.#f;
  }
  /**
   * The public key (33 bytes compressed).
   */
  get pubkey() {
    return this.#y || (this.#u = this.#O(), this.#y = !0), this.#u;
  }
  /**
   * The DER-encoded signature.
   */
  get signature() {
    return this.#b || (this.#c = this.#x(), this.#b = !0), this.#c;
  }
  /**
   * The scriptPubKey: `OP_0 {20-byte hash}`
   */
  get output() {
    return this.#E || (this.#p = this.#U(), this.#E = !0), this.#p;
  }
  /**
   * The scriptSig (always empty for native SegWit).
   */
  get input() {
    return this.#A || (this.#w = this.#k(), this.#A = !0), this.#w;
  }
  /**
   * Witness stack: `[signature, pubkey]`
   */
  get witness() {
    return this.#I || (this.#l = this.#P(), this.#I = !0), this.#l;
  }
  // Static factory methods
  /**
   * Creates a P2WPKH payment from a compressed public key.
   *
   * @param pubkey - The public key (must be 33 bytes compressed)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2WPKH.fromPubkey(pubkey);
   * const address = payment.address; // bc1q...
   * ```
   */
  static fromPubkey(t, r) {
    return new ve({ pubkey: t, network: r });
  }
  /**
   * Creates a P2WPKH payment from a bech32 address.
   *
   * @param address - Bech32 encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   *
   * @example
   * ```typescript
   * const payment = P2WPKH.fromAddress('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
   * const hash = payment.hash;
   * ```
   */
  static fromAddress(t, r) {
    return new ve({ address: t, network: r });
  }
  /**
   * Creates a P2WPKH payment from a 20-byte witness program.
   *
   * @param hash - 20-byte witness program (pubkey hash)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   */
  static fromHash(t, r) {
    return new ve({ hash: t, network: r });
  }
  /**
   * Creates a P2WPKH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WPKH payment instance
   */
  static fromOutput(t, r) {
    return new ve({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2WPKHPayment object for backwards compatibility.
   *
   * @returns A P2WPKHPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      pubkey: this.pubkey,
      signature: this.signature,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
  // Private computation methods
  #v() {
    if (!this.#S) {
      if (this.#t) {
        const t = lt.bech32.decode(this.#t), r = t.words.shift(), n = lt.bech32.fromWords(t.words);
        this.#m = {
          version: r ?? 0,
          prefix: t.prefix,
          data: new Uint8Array(n)
        };
      }
      this.#S = !0;
    }
    return this.#m;
  }
  #T() {
    if (this.#t)
      return this.#t;
    const t = this.hash;
    if (!t) return;
    const r = lt.bech32.toWords(t);
    return r.unshift(0), lt.bech32.encode(this.#e.bech32, r);
  }
  #B() {
    if (this.#s)
      return this.#s;
    if (this.#i)
      return this.#i.subarray(2, 22);
    if (this.#t)
      return this.#v()?.data;
    const t = this.#n ?? this.pubkey;
    if (t)
      return yt(t);
  }
  #O() {
    if (this.#n)
      return this.#n;
    if (this.#o && this.#o.length >= 2)
      return this.#o[1];
  }
  #x() {
    if (this.#r)
      return this.#r;
    if (this.#o && this.#o.length >= 1)
      return this.#o[0];
  }
  #U() {
    if (this.#i)
      return this.#i;
    const t = this.hash;
    if (t)
      return dt([Qn.OP_0, t]);
  }
  #k() {
    if (this.witness)
      return pa;
  }
  // Validation
  #P() {
    if (this.#o)
      return this.#o;
    if (!(!this.#n || !this.#r))
      return [this.#r, this.#n];
  }
  #R() {
    let t = new Uint8Array(0);
    if (this.#t) {
      const r = this.#v();
      if (!r)
        throw new TypeError("Invalid address");
      if (this.#e && this.#e.bech32 !== r.prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r.version !== 0)
        throw new TypeError("Invalid address version");
      if (r.data.length !== 20)
        throw new TypeError("Invalid address data");
      t = r.data;
    }
    if (this.#s) {
      if (t.length > 0 && !H(t, this.#s))
        throw new TypeError("Hash mismatch");
      t = this.#s;
    }
    if (this.#i) {
      if (this.#i.length !== 22 || this.#i[0] !== Qn.OP_0 || this.#i[1] !== 20)
        throw new TypeError("Output is invalid");
      if (t.length > 0 && !H(t, this.#i.subarray(2)))
        throw new TypeError("Hash mismatch");
      t = this.#i.subarray(2);
    }
    if (this.#n) {
      const r = yt(this.#n);
      if (t.length > 0 && !H(t, r))
        throw new TypeError("Hash mismatch");
      if (t = r, !le(this.#n) || this.#n.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (this.#o) {
      if (this.#o.length !== 2)
        throw new TypeError("Witness is invalid");
      const r = this.#o[0], n = this.#o[1];
      if (!Le(r))
        throw new TypeError("Witness has invalid signature");
      if (!le(n) || n.length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (this.#r && !H(this.#r, r))
        throw new TypeError("Signature mismatch");
      if (this.#n && !H(this.#n, n))
        throw new TypeError("Pubkey mismatch");
      const i = yt(n);
      if (t.length > 0 && !H(t, i))
        throw new TypeError("Hash mismatch");
    }
  }
}
function wa(e, t) {
  if (!e.address && !e.hash && !e.output && !e.pubkey && !e.witness)
    throw new TypeError("Not enough data");
  const r = new ve(
    {
      address: e.address,
      hash: e.hash,
      pubkey: e.pubkey,
      signature: e.signature,
      output: e.output,
      witness: e.witness,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
const Jn = z, Cr = new Uint8Array(0);
function Xe(e) {
  return !!(e instanceof Uint8Array && e.length === 65 && e[0] === 4 && le(e));
}
class Se {
  // Static public fields
  static NAME = ct.P2WSH;
  // Private instance fields
  #e;
  #h;
  // Input data (provided by user)
  #t;
  #s;
  #n;
  #r;
  #i;
  // Cached computed values
  #o;
  #a;
  #f;
  #u;
  #c;
  #p;
  // Cache flags
  #w = !1;
  #l = !1;
  #d = !1;
  #g = !1;
  #y = !1;
  #b = !1;
  // Decoded address cache
  #E;
  #A = !1;
  // Decoded redeem chunks cache
  #I;
  #m = !1;
  /**
   * Creates a new P2WSH payment instance.
   *
   * @param params - Payment parameters
   * @param params.address - Bech32 encoded address
   * @param params.hash - 32-byte witness program (SHA256 of script)
   * @param params.output - The scriptPubKey
   * @param params.redeem - The redeem script information
   * @param params.witness - The witness stack
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    let n = t.network;
    n || (n = t.redeem && t.redeem.network || Mt), this.#e = n, this.#h = {
      validate: r?.validate ?? !0,
      allowIncomplete: r?.allowIncomplete ?? !1
    }, this.#t = t.address, this.#s = t.hash, this.#n = t.output, this.#r = t.redeem, this.#i = t.witness, this.#h.validate && this.#P();
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    const t = this.redeem;
    return t !== void 0 && t.name !== void 0 ? `p2wsh-${t.name}` : ct.P2WSH;
  }
  /**
   * Network parameters.
   */
  get network() {
    return this.#e;
  }
  /**
   * Bech32 encoded address (bc1q... for mainnet).
   */
  get address() {
    return this.#w || (this.#o = this.#T(), this.#w = !0), this.#o;
  }
  /**
   * 32-byte witness program (SHA256 of redeem script).
   */
  get hash() {
    return this.#l || (this.#a = this.#B(), this.#l = !0), this.#a;
  }
  /**
   * The scriptPubKey: `OP_0 {32-byte hash}`
   */
  get output() {
    return this.#d || (this.#f = this.#O(), this.#d = !0), this.#f;
  }
  /**
   * The scriptSig (always empty for native SegWit).
   */
  get input() {
    return this.#g || (this.#u = this.#x(), this.#g = !0), this.#u;
  }
  /**
   * The redeem script information.
   */
  get redeem() {
    return this.#y || (this.#c = this.#U(), this.#y = !0), this.#c;
  }
  /**
   * Witness stack: `[{scriptSig...}, {redeemScript}]`
   */
  get witness() {
    return this.#b || (this.#p = this.#k(), this.#b = !0), this.#p;
  }
  // Static factory methods
  /**
   * Creates a P2WSH payment from a redeem script.
   *
   * @param redeem - The redeem script information
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   *
   * @example
   * ```typescript
   * const p2wsh = P2WSH.fromRedeem({ output: redeemScript });
   * ```
   */
  static fromRedeem(t, r) {
    return new Se({ redeem: t, network: r });
  }
  /**
   * Creates a P2WSH payment from a bech32 address.
   *
   * @param address - Bech32 encoded address
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   */
  static fromAddress(t, r) {
    return new Se({ address: t, network: r });
  }
  /**
   * Creates a P2WSH payment from a 32-byte witness program.
   *
   * @param hash - 32-byte witness program (SHA256 of script)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   */
  static fromHash(t, r) {
    return new Se({ hash: t, network: r });
  }
  /**
   * Creates a P2WSH payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2WSH payment instance
   */
  static fromOutput(t, r) {
    return new Se({ output: t, network: r });
  }
  // Private helper methods
  /**
   * Converts to a plain P2WSHPayment object for backwards compatibility.
   *
   * @returns A P2WSHPayment object
   */
  toPayment() {
    const t = this.witness, r = this.redeem;
    return {
      name: this.name,
      network: this.network,
      address: this.address,
      hash: this.hash,
      output: this.output,
      input: this.input,
      redeem: r,
      witness: t
    };
  }
  #S() {
    if (!this.#A) {
      if (this.#t) {
        const t = lt.bech32.decode(this.#t), r = t.words.shift(), n = lt.bech32.fromWords(t.words);
        this.#E = {
          version: r ?? 0,
          prefix: t.prefix,
          data: new Uint8Array(n)
        };
      }
      this.#A = !0;
    }
    return this.#E;
  }
  // Private computation methods
  #v() {
    return this.#m || (this.#r?.input && (this.#I = it(this.#r.input) ?? void 0), this.#m = !0), this.#I;
  }
  #T() {
    if (this.#t)
      return this.#t;
    const t = this.hash;
    if (!t) return;
    const r = lt.bech32.toWords(t);
    return r.unshift(0), lt.bech32.encode(this.#e.bech32, r);
  }
  #B() {
    if (this.#s)
      return this.#s;
    if (this.#n)
      return this.#n.subarray(2);
    if (this.#t)
      return this.#S()?.data;
    const t = this.redeem;
    if (t && t.output)
      return pt(t.output);
  }
  #O() {
    if (this.#n)
      return this.#n;
    const t = this.hash;
    if (t)
      return dt([Jn.OP_0, t]);
  }
  #x() {
    if (this.witness)
      return Cr;
  }
  #U() {
    if (this.#r)
      return this.#r;
    if (this.#i && this.#i.length > 0)
      return {
        output: this.#i[this.#i.length - 1],
        input: Cr,
        witness: this.#i.slice(0, -1)
      };
  }
  // Validation
  #k() {
    if (this.#i)
      return this.#i;
    const t = this.#r;
    if (t) {
      if (t.input && t.input.length > 0 && t.output && t.output.length > 0) {
        const r = this.#v();
        if (r) {
          const n = Ai(r);
          return this.#c = Object.assign({ witness: n }, t, { input: Cr }), this.#y = !0, [].concat(n, t.output);
        }
      }
      return !t.output || !t.witness ? void 0 : [].concat(t.witness, t.output);
    }
  }
  #P() {
    let t = new Uint8Array(0);
    if (this.#t) {
      const r = this.#S();
      if (!r)
        throw new TypeError("Invalid address");
      if (r.prefix !== this.#e.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (r.version !== 0)
        throw new TypeError("Invalid address version");
      if (r.data.length !== 32)
        throw new TypeError("Invalid address data");
      t = r.data;
    }
    if (this.#s) {
      if (t.length > 0 && !H(t, this.#s))
        throw new TypeError("Hash mismatch");
      t = this.#s;
    }
    if (this.#n) {
      if (this.#n.length !== 34 || this.#n[0] !== Jn.OP_0 || this.#n[1] !== 32)
        throw new TypeError("Output is invalid");
      const r = this.#n.subarray(2);
      if (t.length > 0 && !H(t, r))
        throw new TypeError("Hash mismatch");
      t = r;
    }
    if (this.#r) {
      if (this.#r.network && this.#r.network !== this.#e)
        throw new TypeError("Network mismatch");
      if (this.#r.input && this.#r.input.length > 0 && this.#r.witness && this.#r.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (this.#r.output) {
        const n = it(this.#r.output);
        if (!n || n.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (this.#r.output.byteLength > 3600)
          throw new TypeError("Redeem.output unspendable if larger than 3600 bytes");
        if (nn(n) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const i = pt(this.#r.output);
        if (t.length > 0 && !H(t, i))
          throw new TypeError("Hash mismatch");
        t = i;
      }
      const r = this.#v();
      if (this.#r.input && r && !br(r))
        throw new TypeError("Non push-only scriptSig");
      if (this.#i && this.#r.witness && !ke(this.#i, this.#r.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (this.#r.input && r?.some(Xe) || this.#r.output && (it(this.#r.output) || []).some(
        Xe
      ))
        throw new TypeError("redeem.input or redeem.output contains uncompressed pubkey");
    }
    if (this.#i && this.#i.length > 0) {
      const r = this.#i[this.#i.length - 1];
      if (this.#r && this.#r.output && !H(this.#r.output, r))
        throw new TypeError("Witness and redeem.output mismatch");
      if (this.#i.some(Xe) || (it(r) || []).some(Xe))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
}
function ga(e, t) {
  if (!e.address && !e.hash && !e.output && !e.redeem && !e.witness)
    throw new TypeError("Not enough data");
  return new Se(
    {
      address: e.address,
      hash: e.hash,
      output: e.output,
      redeem: e.redeem,
      witness: e.witness,
      network: e.network
    },
    t
  ).toPayment();
}
const ti = z;
class Fe {
  // Static public fields
  static NAME = ct.P2PK;
  // Private instance fields
  #e;
  #h;
  // Input data (provided by user)
  #t;
  #s;
  #n;
  #r;
  // Cached computed values
  #i;
  #o;
  #a;
  #f;
  #u;
  // Cache flags
  #c = !1;
  #p = !1;
  #w = !1;
  #l = !1;
  #d = !1;
  /**
   * Creates a new P2PK payment instance.
   *
   * @param params - Payment parameters
   * @param params.pubkey - The public key (33 or 65 bytes)
   * @param params.signature - DER-encoded signature
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    this.#e = t.network ?? Mt, this.#h = {
      validate: r?.validate ?? !0,
      allowIncomplete: r?.allowIncomplete ?? !1
    }, this.#t = t.pubkey, this.#s = t.signature, this.#n = t.output, this.#r = t.input, this.#h.validate && this.#I();
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return ct.P2PK;
  }
  /**
   * Network parameters.
   */
  get network() {
    return this.#e;
  }
  /**
   * The public key (33 or 65 bytes).
   * Computed lazily from output if not provided directly.
   */
  get pubkey() {
    return this.#c || (this.#i = this.#g(), this.#c = !0), this.#i;
  }
  /**
   * The DER-encoded signature.
   * Computed lazily from input if not provided directly.
   */
  get signature() {
    return this.#p || (this.#o = this.#y(), this.#p = !0), this.#o;
  }
  /**
   * The scriptPubKey: `{pubKey} OP_CHECKSIG`
   * Computed lazily from pubkey if not provided directly.
   */
  get output() {
    return this.#w || (this.#a = this.#b(), this.#w = !0), this.#a;
  }
  /**
   * The scriptSig: `{signature}`
   * Computed lazily from signature if not provided directly.
   */
  get input() {
    return this.#l || (this.#f = this.#E(), this.#l = !0), this.#f;
  }
  /**
   * Witness stack (empty for P2PK as it's not a SegWit type).
   */
  get witness() {
    return this.#d || (this.#u = this.#A(), this.#d = !0), this.#u;
  }
  // Static factory methods
  /**
   * Creates a P2PK payment from a public key.
   *
   * @param pubkey - The public key (33 or 65 bytes)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PK payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PK.fromPubkey(pubkey);
   * const scriptPubKey = payment.output;
   * ```
   */
  static fromPubkey(t, r) {
    return new Fe({ pubkey: t, network: r });
  }
  /**
   * Creates a P2PK payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PK payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PK.fromOutput(scriptPubKey);
   * const pubkey = payment.pubkey;
   * ```
   */
  static fromOutput(t, r) {
    return new Fe({ output: t, network: r });
  }
  /**
   * Creates a P2PK payment from a signature (for spending).
   *
   * @param signature - The DER-encoded signature
   * @param pubkey - The public key (optional, for validation)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2PK payment instance
   *
   * @example
   * ```typescript
   * const payment = P2PK.fromSignature(signature, pubkey);
   * const scriptSig = payment.input;
   * ```
   */
  static fromSignature(t, r, n) {
    return new Fe({ signature: t, pubkey: r, network: n });
  }
  // Private computation methods
  /**
   * Converts to a plain P2PKPayment object for backwards compatibility.
   *
   * @returns A P2PKPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      pubkey: this.pubkey,
      signature: this.signature,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
  #g() {
    if (this.#t)
      return this.#t;
    if (this.#n)
      return this.#n.subarray(1, -1);
  }
  #y() {
    if (this.#s)
      return this.#s;
    if (this.#r) {
      const t = it(this.#r);
      if (t && t.length > 0)
        return t[0];
    }
  }
  #b() {
    if (this.#n)
      return this.#n;
    const t = this.#t;
    if (t)
      return dt([t, ti.OP_CHECKSIG]);
  }
  #E() {
    if (this.#r)
      return this.#r;
    const t = this.#s;
    if (t)
      return dt([t]);
  }
  // Validation
  #A() {
    if (this.input)
      return [];
  }
  #I() {
    if (this.#n) {
      if (this.#n[this.#n.length - 1] !== ti.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const t = this.pubkey;
      if (!le(t))
        throw new TypeError("Output pubkey is invalid");
      if (this.#t && t && !H(this.#t, t))
        throw new TypeError("Pubkey mismatch");
    }
    if (this.#s) {
      const t = this.input;
      if (this.#r && t && !H(this.#r, t))
        throw new TypeError("Signature mismatch");
    }
    if (this.#r) {
      const t = it(this.#r);
      if (!t || t.length !== 1)
        throw new TypeError("Input is invalid");
      const r = this.signature;
      if (!r || !Le(r))
        throw new TypeError("Input has invalid signature");
    }
  }
}
function ya(e, t) {
  if (!e.input && !e.output && !e.pubkey && !e.signature)
    throw new TypeError("Not enough data");
  const r = new Fe(
    {
      pubkey: e.pubkey,
      signature: e.signature,
      output: e.output,
      input: e.input,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
const ye = z, Qe = ye.OP_RESERVED;
class $e {
  // Static public fields
  static NAME = ct.P2MS;
  // Private instance fields
  #e;
  #h;
  // Input data (provided by user)
  #t;
  #s;
  #n;
  #r;
  #i;
  #o;
  // Cached computed values
  #a;
  #f;
  #u;
  #c;
  #p;
  #w;
  #l;
  // Cache flags
  #d = !1;
  #g = !1;
  #y = !1;
  #b = !1;
  #E = !1;
  #A = !1;
  #I = !1;
  // Decoded chunks cache
  #m;
  #S = !1;
  /**
   * Creates a new P2MS payment instance.
   *
   * @param params - Payment parameters
   * @param params.m - Required number of signatures
   * @param params.n - Total number of public keys (optional, derived from pubkeys)
   * @param params.pubkeys - Array of public keys
   * @param params.signatures - Array of signatures
   * @param params.output - The scriptPubKey
   * @param params.input - The scriptSig
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   * @param opts.allowIncomplete - Allow incomplete signatures (default: false)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, r) {
    this.#e = t.network ?? Mt, this.#h = {
      validate: r?.validate ?? !0,
      allowIncomplete: r?.allowIncomplete ?? !1
    }, this.#t = t.m, this.#s = t.n, this.#n = t.pubkeys, this.#r = t.signatures, this.#i = t.output, this.#o = t.input, this.#h.validate && this.#H();
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    const t = this.m, r = this.n;
    return t !== void 0 && r !== void 0 ? `p2ms(${t} of ${r})` : ct.P2MS;
  }
  /**
   * Network parameters.
   */
  get network() {
    return this.#e;
  }
  /**
   * Required number of signatures (M in M-of-N).
   */
  get m() {
    return this.#d || (this.#a = this.#T(), this.#d = !0), this.#a;
  }
  /**
   * Total number of public keys (N in M-of-N).
   */
  get n() {
    return this.#g || (this.#f = this.#B(), this.#g = !0), this.#f;
  }
  /**
   * Array of public keys.
   */
  get pubkeys() {
    return this.#y || (this.#u = this.#O(), this.#y = !0), this.#u;
  }
  /**
   * Array of signatures.
   */
  get signatures() {
    return this.#b || (this.#c = this.#x(), this.#b = !0), this.#c;
  }
  /**
   * The scriptPubKey: `m {pubkeys} n OP_CHECKMULTISIG`
   */
  get output() {
    return this.#E || (this.#p = this.#U(), this.#E = !0), this.#p;
  }
  /**
   * The scriptSig: `OP_0 {signatures}`
   */
  get input() {
    return this.#A || (this.#w = this.#k(), this.#A = !0), this.#w;
  }
  /**
   * Witness stack (empty for P2MS as it's not a SegWit type).
   */
  get witness() {
    return this.#I || (this.#l = this.#P(), this.#I = !0), this.#l;
  }
  // Static factory methods
  /**
   * Creates a P2MS payment from public keys.
   *
   * @param m - Required number of signatures
   * @param pubkeys - Array of public keys
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MS payment instance
   *
   * @example
   * ```typescript
   * // Create a 2-of-3 multisig
   * const payment = P2MS.fromPubkeys(2, [pubkey1, pubkey2, pubkey3]);
   * ```
   */
  static fromPubkeys(t, r, n) {
    return new $e({ m: t, pubkeys: r, network: n });
  }
  /**
   * Creates a P2MS payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MS payment instance
   */
  static fromOutput(t, r) {
    return new $e({ output: t, network: r });
  }
  /**
   * Creates a P2MS payment from signatures (for spending).
   *
   * @param signatures - Array of signatures
   * @param m - Required number of signatures (optional)
   * @param pubkeys - Array of public keys (optional, for validation)
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new P2MS payment instance
   */
  static fromSignatures(t, r, n, i) {
    return new $e({ signatures: t, m: r, pubkeys: n, network: i });
  }
  // Private helper methods
  /**
   * Converts to a plain P2MSPayment object for backwards compatibility.
   *
   * @returns A P2MSPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      m: this.m,
      n: this.n,
      pubkeys: this.pubkeys,
      signatures: this.signatures,
      output: this.output,
      input: this.input,
      witness: this.witness
    };
  }
  // Private computation methods
  #v(t) {
    this.#S || (this.#S = !0, this.#m = it(t) ?? [], this.#a = this.#m[0] - Qe, this.#f = this.#m[this.#m.length - 2] - Qe, this.#u = this.#m.slice(1, -2), this.#d = !0, this.#g = !0, this.#y = !0);
  }
  #T() {
    if (this.#t !== void 0)
      return this.#t;
    const t = this.#i ?? this.output;
    if (t)
      return this.#v(t), this.#a;
  }
  #B() {
    if (this.#s !== void 0)
      return this.#s;
    if (this.#n)
      return this.#n.length;
    if (this.#i)
      return this.#v(this.#i), this.#f;
  }
  #O() {
    if (this.#n)
      return this.#n;
    if (this.#i)
      return this.#v(this.#i), this.#u;
  }
  #x() {
    if (this.#r)
      return this.#r;
    if (this.#o) {
      const t = it(this.#o);
      return t?.slice(1);
    }
  }
  #U() {
    if (this.#i)
      return this.#i;
    const t = this.#t, r = this.n, n = this.#n;
    if (!(t === void 0 || r === void 0 || !n))
      return dt(
        [].concat(Qe + t, n, Qe + r, ye.OP_CHECKMULTISIG)
      );
  }
  #k() {
    if (this.#o)
      return this.#o;
    if (this.#r)
      return dt([ye.OP_0].concat(this.#r));
  }
  // Validation
  #P() {
    if (this.input)
      return [];
  }
  #R(t) {
    return Le(t) || this.#h.allowIncomplete && t === ye.OP_0;
  }
  #H() {
    if (this.#i) {
      this.#v(this.#i);
      const t = this.#m;
      if (!t)
        throw new TypeError("Output is invalid");
      if (typeof t[0] != "number")
        throw new TypeError("Output is invalid");
      if (typeof t[t.length - 2] != "number")
        throw new TypeError("Output is invalid");
      if (t[t.length - 1] !== ye.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      const r = this.#a, n = this.#f, i = this.#u;
      if (r === void 0 || n === void 0 || !i)
        throw new TypeError("Output is invalid");
      if (r <= 0 || n > 16 || r > n || n !== t.length - 3)
        throw new TypeError("Output is invalid");
      if (!i.every((h) => le(h)))
        throw new TypeError("Output is invalid");
      if (this.#t !== void 0 && this.#t !== r)
        throw new TypeError("m mismatch");
      if (this.#s !== void 0 && this.#s !== n)
        throw new TypeError("n mismatch");
      if (this.#n && !ke(this.#n, i))
        throw new TypeError("Pubkeys mismatch");
    }
    if (this.#n) {
      if (this.#s !== void 0 && this.#s !== this.#n.length)
        throw new TypeError("Pubkey count mismatch");
      if (this.#f = this.#n.length, this.#g = !0, this.#a !== void 0 && this.#f < this.#a)
        throw new TypeError("Pubkey count cannot be less than m");
    }
    if (this.#r) {
      if (this.#a !== void 0 && this.#r.length < this.#a)
        throw new TypeError("Not enough signatures provided");
      if (this.#a !== void 0 && this.#r.length > this.#a)
        throw new TypeError("Too many signatures provided");
    }
    if (this.#o) {
      if (this.#o[0] !== ye.OP_0)
        throw new TypeError("Input is invalid");
      const t = this.signatures;
      if (!t || t.length === 0 || !t.every((r) => this.#R(r)))
        throw new TypeError("Input has invalid signature(s)");
      if (this.#r && !ke(this.#r, t))
        throw new TypeError("Signature mismatch");
      if (this.#t !== void 0 && this.#r && this.#t !== this.#r.length)
        throw new TypeError("Signature count mismatch");
    }
  }
}
function ma(e, t) {
  if (!e.input && !e.output && !(e.pubkeys && e.m !== void 0) && !e.signatures)
    throw new TypeError("Not enough data");
  const r = new $e(
    {
      m: e.m,
      n: e.n,
      pubkeys: e.pubkeys,
      signatures: e.signatures,
      output: e.output,
      input: e.input,
      network: e.network
    },
    t
  );
  return Object.assign(r.toPayment(), e);
}
function Ut(e) {
  const t = e.length;
  return re(t) + t;
}
function ba(e) {
  const t = e.length;
  return re(t) + e.reduce((r, n) => r + Ut(n), 0);
}
const Qt = new Uint8Array(0), ei = [], Je = ne("0000000000000000000000000000000000000000000000000000000000000000"), ri = tr(ne("0000000000000000000000000000000000000000000000000000000000000001")), Ea = 0xffffffffffffffffn;
class q {
  static DEFAULT_SEQUENCE = 4294967295;
  static SIGHASH_DEFAULT = 0;
  static SIGHASH_ALL = 1;
  static SIGHASH_NONE = 2;
  static SIGHASH_SINGLE = 3;
  static SIGHASH_ANYONECANPAY = 128;
  static SIGHASH_OUTPUT_MASK = 3;
  static SIGHASH_INPUT_MASK = 128;
  static ADVANCED_TRANSACTION_MARKER = 0;
  static ADVANCED_TRANSACTION_FLAG = 1;
  static TRUC_VERSION = 3;
  static TRUC_MAX_VSIZE = 1e4;
  static TRUC_CHILD_MAX_VSIZE = 1e3;
  version = 1;
  locktime = 0;
  ins = [];
  outs = [];
  /**
   * Parse a transaction from a Uint8Array buffer.
   *
   * @param buffer - The raw transaction bytes
   * @param _NO_STRICT - If true, allow extra data after transaction
   * @returns Parsed Transaction instance
   */
  static fromBuffer(t, r) {
    const n = new Qr(t), i = new q();
    i.version = n.readInt32LE();
    const h = n.readUInt8(), a = n.readUInt8();
    let c = !1;
    h === q.ADVANCED_TRANSACTION_MARKER && a === q.ADVANCED_TRANSACTION_FLAG ? c = !0 : n.offset -= 2;
    const d = n.readVarInt();
    for (let f = 0; f < d; ++f) {
      const w = n.readBytes(32), b = n.readUInt32LE(), y = n.readVarBytes(), I = n.readUInt32LE();
      i.ins.push({
        hash: w,
        index: b,
        script: y,
        sequence: I,
        witness: ei
      });
    }
    const p = n.readVarInt();
    for (let f = 0; f < p; ++f)
      i.outs.push({
        value: n.readUInt64LE(),
        script: n.readVarBytes()
      });
    if (c) {
      for (let f = 0; f < d; ++f)
        i.ins[f].witness = n.readVector();
      if (!i.hasWitnesses()) throw new Error("Transaction has superfluous witness data");
    }
    if (i.locktime = n.readUInt32LE(), r) return i;
    if (n.offset !== t.length)
      throw new Error("Transaction has unexpected data");
    return i;
  }
  /**
   * Parse a transaction from a hex string.
   *
   * @param hex - The transaction as a hex string
   * @returns Parsed Transaction instance
   */
  static fromHex(t) {
    return q.fromBuffer(ne(t), !1);
  }
  /**
   * Check if a hash is a coinbase hash (all zeros).
   *
   * @param hash - 32-byte hash to check
   * @returns true if hash is all zeros (coinbase)
   */
  static isCoinbaseHash(t) {
    if (t.length !== 32)
      throw new TypeError("Expected 32-byte hash");
    for (let r = 0; r < 32; ++r)
      if (t[r] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    const t = this.ins[0];
    return this.ins.length === 1 && t !== void 0 && q.isCoinbaseHash(t.hash);
  }
  /**
   * Add an input to this transaction.
   *
   * @param hash - 32-byte hash of the previous transaction
   * @param index - Output index in the previous transaction
   * @param sequence - Sequence number (defaults to 0xffffffff)
   * @param scriptSig - Input script (defaults to empty)
   * @returns The index of the newly added input
   */
  addInput(t, r, n, i) {
    if (t.length !== 32)
      throw new TypeError("Expected 32-byte hash");
    if (!Number.isInteger(r) || r < 0 || r > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for index");
    if (n != null && (!Number.isInteger(n) || n < 0 || n > 4294967295))
      throw new TypeError("Expected unsigned 32-bit integer for sequence");
    return n == null && (n = q.DEFAULT_SEQUENCE), this.ins.push({
      hash: t,
      index: r,
      script: i || Qt,
      sequence: n,
      witness: ei
    }) - 1;
  }
  /**
   * Add an output to this transaction.
   *
   * @param scriptPubKey - Output script (locking script)
   * @param value - Output value in satoshis (bigint)
   * @returns The index of the newly added output
   */
  addOutput(t, r) {
    if (!(t instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array for scriptPubKey");
    if (typeof r != "bigint" || r < 0n || r > 0x7fffffffffffffffn)
      throw new TypeError("Expected bigint satoshi value (0 to 2^63-1)");
    return this.outs.push({
      script: t,
      value: r
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((t) => t.witness.length !== 0);
  }
  weight() {
    const t = this.byteLength(!1), r = this.byteLength(!0);
    return t * 3 + r;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(t = !0) {
    const r = t && this.hasWitnesses();
    return (r ? 10 : 8) + re(this.ins.length) + re(this.outs.length) + this.ins.reduce((n, i) => n + 40 + Ut(i.script), 0) + this.outs.reduce((n, i) => n + 8 + Ut(i.script), 0) + (r ? this.ins.reduce((n, i) => n + ba(i.witness), 0) : 0);
  }
  clone() {
    const t = new q();
    return t.version = this.version, t.locktime = this.locktime, t.ins = this.ins.map((r) => ({
      hash: r.hash,
      index: r.index,
      script: r.script,
      sequence: r.sequence,
      witness: r.witness
    })), t.outs = this.outs.map((r) => ({
      script: r.script,
      value: r.value
    })), t;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   *
   * @param inIndex - Index of the input being signed
   * @param prevOutScript - The script of the output being spent
   * @param hashType - Signature hash type
   * @returns 32-byte hash for signing
   */
  hashForSignature(t, r, n) {
    if (!Number.isInteger(t) || t < 0)
      throw new TypeError("Expected non-negative integer for inIndex");
    if (!(r instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array for prevOutScript");
    if (!Number.isInteger(n))
      throw new TypeError("Expected integer for hashType");
    if (t >= this.ins.length) return ri;
    const i = it(r);
    if (!i) throw new Error("Could not decompile prevOutScript");
    const h = dt(
      i.filter((p) => p !== z.OP_CODESEPARATOR)
    ), a = this.clone();
    if ((n & 31) === q.SIGHASH_NONE)
      a.outs = [], a.ins.forEach((p, f) => {
        f !== t && (p.sequence = 0);
      });
    else if ((n & 31) === q.SIGHASH_SINGLE) {
      if (t >= this.outs.length) return ri;
      a.outs.length = t + 1;
      for (let p = 0; p < t; p++)
        a.outs[p] = {
          script: Qt,
          value: Ea
        };
      a.ins.forEach((p, f) => {
        f !== t && (p.sequence = 0);
      });
    }
    n & q.SIGHASH_ANYONECANPAY ? (a.ins = [a.ins[t]], a.ins[0].script = h) : (a.ins.forEach((p) => {
      p.script = Qt;
    }), a.ins[t].script = h);
    const c = wt(a.byteLength(!1) + 4);
    return new ut(c, a.byteLength(!1)).writeInt32LE(n), a.#e(c, 0, !1), tr(Jt(c));
  }
  /**
   * Hash transaction for signing a Taproot (witness v1) input.
   *
   * @param inIndex - Index of the input being signed
   * @param prevOutScripts - Scripts of all inputs being spent
   * @param values - Values of all inputs being spent (bigint satoshis)
   * @param hashType - Signature hash type
   * @param leafHash - Optional leaf hash for script path spending
   * @param annex - Optional annex data
   * @returns 32-byte hash for signing
   */
  hashForWitnessV1(t, r, n, i, h, a, c) {
    if (!Number.isInteger(t) || t < 0 || t > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for inIndex");
    if (!Array.isArray(r) || !r.every((F) => F instanceof Uint8Array))
      throw new TypeError("Expected array of Uint8Array for prevOutScripts");
    if (!Array.isArray(n) || !n.every((F) => typeof F == "bigint"))
      throw new TypeError("Expected array of bigint for values");
    if (!Number.isInteger(i) || i < 0 || i > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for hashType");
    if (n.length !== this.ins.length || r.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const d = i === q.SIGHASH_DEFAULT ? q.SIGHASH_ALL : i & q.SIGHASH_OUTPUT_MASK, f = (i & q.SIGHASH_INPUT_MASK) === q.SIGHASH_ANYONECANPAY, w = d === q.SIGHASH_NONE, b = d === q.SIGHASH_SINGLE;
    let y = Qt, I = Qt, E = Qt, T = Qt, O = Qt;
    if (!f)
      if (c)
        y = c.hashPrevouts, I = c.hashAmounts, E = c.hashScriptPubKeys, T = c.hashSequences;
      else {
        let F = new ut(36 * this.ins.length);
        this.ins.forEach((_) => {
          F.writeBytes(_.hash), F.writeUInt32LE(_.index);
        }), y = pt(F.finish()), F = new ut(8 * this.ins.length), n.forEach((_) => F.writeUInt64LE(_)), I = pt(F.finish()), F = new ut(
          r.map(Ut).reduce((_, ot) => _ + ot)
        ), r.forEach(
          (_) => F.writeVarBytes(_)
        ), E = pt(F.finish()), F = new ut(4 * this.ins.length), this.ins.forEach((_) => F.writeUInt32LE(_.sequence)), T = pt(F.finish());
      }
    if (w || b) {
      if (b && t < this.outs.length) {
        const F = this.outs[t], _ = new ut(8 + Ut(F.script));
        _.writeUInt64LE(F.value), _.writeVarBytes(F.script), O = pt(_.finish());
      }
    } else if (c)
      O = c.hashOutputs;
    else {
      if (!this.outs.length)
        throw new Error("Add outputs to the transaction before signing.");
      const F = this.outs.map((ot) => 8 + Ut(ot.script)).reduce((ot, Pt) => ot + Pt), _ = new ut(F);
      this.outs.forEach((ot) => {
        _.writeUInt64LE(ot.value), _.writeVarBytes(ot.script);
      }), O = pt(_.finish());
    }
    const k = (h ? 2 : 0) + (a ? 1 : 0), P = 174 - (f ? 49 : 0) - (w ? 32 : 0) + (a ? 32 : 0) + (h ? 37 : 0), x = new ut(P);
    if (x.writeUInt8(i), x.writeInt32LE(this.version), x.writeUInt32LE(this.locktime), x.writeBytes(y), x.writeBytes(I), x.writeBytes(E), x.writeBytes(T), w || b || x.writeBytes(O), x.writeUInt8(k), f) {
      const F = this.ins[t];
      x.writeBytes(F.hash), x.writeUInt32LE(F.index), x.writeUInt64LE(n[t]), x.writeVarBytes(r[t]), x.writeUInt32LE(F.sequence);
    } else
      x.writeUInt32LE(t);
    if (a) {
      const F = new ut(Ut(a));
      F.writeVarBytes(a), x.writeBytes(pt(F.finish()));
    }
    b && x.writeBytes(O), h && (x.writeBytes(h), x.writeUInt8(0), x.writeUInt32LE(4294967295));
    const K = new Uint8Array([0]), tt = x.finish(), Bt = new Uint8Array(1 + tt.length);
    return Bt.set(K), Bt.set(tt, 1), tr(We("TapSighash", Bt));
  }
  /**
   * Pre-compute intermediate hashes for Taproot signing.
   * Call this once before signing multiple inputs to avoid O(n^2) performance.
   *
   * @param prevOutScripts - Array of previous output scripts for all inputs
   * @param values - Array of previous output values for all inputs
   * @returns Cache object to pass to hashForWitnessV1
   */
  getTaprootHashCache(t, r) {
    let n = new ut(36 * this.ins.length);
    for (const w of this.ins)
      n.writeBytes(w.hash), n.writeUInt32LE(w.index);
    const i = pt(n.finish());
    n = new ut(8 * r.length);
    for (const w of r)
      n.writeUInt64LE(w);
    const h = pt(n.finish());
    let a = 0;
    for (const w of t)
      a += Ut(w);
    n = new ut(a);
    for (const w of t)
      n.writeVarBytes(w);
    const c = pt(n.finish());
    n = new ut(4 * this.ins.length);
    for (const w of this.ins)
      n.writeUInt32LE(w.sequence);
    const d = pt(n.finish());
    let p = 0;
    for (const w of this.outs)
      p += 8 + Ut(w.script);
    n = new ut(p);
    for (const w of this.outs)
      n.writeUInt64LE(w.value), n.writeVarBytes(w.script);
    const f = this.outs.length ? pt(n.finish()) : Je;
    return { hashPrevouts: i, hashAmounts: h, hashScriptPubKeys: c, hashSequences: d, hashOutputs: f };
  }
  /**
   * Hash transaction for signing a SegWit v0 (P2WPKH/P2WSH) input.
   *
   * @param inIndex - Index of the input being signed
   * @param prevOutScript - The script of the output being spent
   * @param value - Value of the output being spent (bigint satoshis)
   * @param hashType - Signature hash type
   * @returns 32-byte hash for signing
   */
  hashForWitnessV0(t, r, n, i) {
    if (!Number.isInteger(t) || t < 0 || t > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for inIndex");
    if (!(r instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array for prevOutScript");
    if (typeof n != "bigint")
      throw new TypeError("Expected bigint for value");
    if (!Number.isInteger(i) || i < 0 || i > 4294967295)
      throw new TypeError("Expected unsigned 32-bit integer for hashType");
    let h, a, c = Je, d = Je, p = Je;
    if (i & q.SIGHASH_ANYONECANPAY || (h = wt(36 * this.ins.length), a = new ut(h, 0), this.ins.forEach((w) => {
      a.writeBytes(w.hash), a.writeUInt32LE(w.index);
    }), d = Jt(h)), !(i & q.SIGHASH_ANYONECANPAY) && (i & 31) !== q.SIGHASH_SINGLE && (i & 31) !== q.SIGHASH_NONE && (h = wt(4 * this.ins.length), a = new ut(h, 0), this.ins.forEach((w) => {
      a.writeUInt32LE(w.sequence);
    }), p = Jt(h)), (i & 31) !== q.SIGHASH_SINGLE && (i & 31) !== q.SIGHASH_NONE) {
      const w = this.outs.reduce((b, y) => b + 8 + Ut(y.script), 0);
      h = wt(w), a = new ut(h, 0), this.outs.forEach((b) => {
        a.writeUInt64LE(b.value), a.writeVarBytes(b.script);
      }), c = Jt(h);
    } else if ((i & 31) === q.SIGHASH_SINGLE && t < this.outs.length) {
      const w = this.outs[t];
      h = wt(8 + Ut(w.script)), a = new ut(h, 0), a.writeUInt64LE(w.value), a.writeVarBytes(w.script), c = Jt(h);
    }
    h = wt(156 + Ut(r)), a = new ut(h, 0);
    const f = this.ins[t];
    return a.writeInt32LE(this.version), a.writeBytes(d), a.writeBytes(p), a.writeBytes(f.hash), a.writeUInt32LE(f.index), a.writeVarBytes(r), a.writeUInt64LE(n), a.writeUInt32LE(f.sequence), a.writeBytes(c), a.writeUInt32LE(this.locktime), a.writeUInt32LE(i), tr(Jt(h));
  }
  /**
   * Get the transaction hash.
   *
   * @param forWitness - If true, include witness data (wtxid)
   * @returns 32-byte transaction hash
   */
  getHash(t) {
    return t && this.isCoinbase() ? new Uint8Array(32) : Jt(this.#e(void 0, void 0, t));
  }
  /**
   * Get the transaction ID (txid) as a hex string.
   *
   * @returns Transaction ID in reversed hex format
   */
  getId() {
    return xe(eo(this.getHash(!1)));
  }
  /**
   * Serialize the transaction to a Uint8Array buffer.
   *
   * @param buffer - Optional pre-allocated buffer
   * @param initialOffset - Optional starting offset in buffer
   * @returns Serialized transaction bytes
   */
  toBuffer(t, r) {
    return this.#e(t, r, !0);
  }
  /**
   * Serialize the transaction to a hex string.
   *
   * @returns Transaction as hex string
   */
  toHex() {
    return xe(this.toBuffer(void 0, void 0));
  }
  /**
   * Set the input script for a specific input.
   *
   * @param index - Input index
   * @param scriptSig - The script to set
   */
  setInputScript(t, r) {
    if (!Number.isInteger(t) || t < 0)
      throw new TypeError("Expected non-negative integer for index");
    if (!(r instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array for scriptSig");
    this.ins[t].script = r;
  }
  /**
   * Set the witness data for a specific input.
   *
   * @param index - Input index
   * @param witness - Array of witness elements
   */
  setWitness(t, r) {
    if (!Number.isInteger(t) || t < 0)
      throw new TypeError("Expected non-negative integer for index");
    if (!Array.isArray(r) || !r.every((n) => n instanceof Uint8Array))
      throw new TypeError("Expected array of Uint8Array for witness");
    this.ins[t].witness = r;
  }
  /**
   * Internal method to serialize the transaction.
   *
   * @param buffer - Optional pre-allocated buffer
   * @param initialOffset - Optional starting offset
   * @param _ALLOW_WITNESS - Whether to include witness data
   * @returns Serialized transaction bytes
   */
  #e(t, r, n = !1) {
    t || (t = wt(this.byteLength(n)));
    const i = new ut(t, r || 0);
    i.writeInt32LE(this.version);
    const h = n && this.hasWitnesses();
    return h && (i.writeUInt8(q.ADVANCED_TRANSACTION_MARKER), i.writeUInt8(q.ADVANCED_TRANSACTION_FLAG)), i.writeVarInt(this.ins.length), this.ins.forEach((a) => {
      i.writeBytes(a.hash), i.writeUInt32LE(a.index), i.writeVarBytes(a.script), i.writeUInt32LE(a.sequence);
    }), i.writeVarInt(this.outs.length), this.outs.forEach((a) => {
      i.writeUInt64LE(a.value), i.writeVarBytes(a.script);
    }), h && this.ins.forEach((a) => {
      i.writeVector(a.witness);
    }), i.writeUInt32LE(this.locktime), r !== void 0 ? t.subarray(r, i.offset) : t;
  }
}
const bu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Transaction: q
}, Symbol.toStringTag, { value: "Module" }));
function Wt(e) {
  return (t) => {
    try {
      return e({ output: t }), !0;
    } catch {
      return !1;
    }
  };
}
const Eu = Wt(ma), Au = Wt(ya), Iu = Wt(dh), vu = Wt(wa), Su = Wt(ga), Tu = Wt(ph), cs = Wt(fs), gn = Wt(la), Bu = Wt(No), xu = (e) => e.length === 4 && e[0] === 81 && // OP_1
e[1] === 2 && // push 2 bytes
e[2] === 78 && e[3] === 115;
function Aa(e) {
  const t = [];
  function r(a) {
    t.push(a);
  }
  function n(a) {
    const c = re(a), d = wt(c);
    Xr(a, d, 0), t.push(d);
  }
  function i(a) {
    n(a.length), r(a);
  }
  function h(a) {
    n(a.length), a.forEach(i);
  }
  return h(e), vt(t);
}
function ls(e, t) {
  const r = it(t);
  if (r === null) throw new Error("Unknown script error");
  const n = yt(e), i = Vi(e), h = Kr(e), a = h?.hybrid ? yt(h.hybrid) : void 0, c = h?.uncompressed ? yt(h.uncompressed) : void 0;
  return r.findIndex((d) => typeof d == "number" ? !1 : !!(ze(d, e) || ze(d, i) || H(d, n) || h && (ze(d, h.uncompressed) || ze(d, h.hybrid) || a && H(d, a) || c && H(d, c))));
}
function Uu(e, t) {
  return ls(e, t) !== -1;
}
function Ou(e, t) {
  return Ia(e).some((n) => ds(n, on.decode, t));
}
function ds(e, t, r) {
  const { hashType: n } = t(e), i = [];
  switch (n & q.SIGHASH_ANYONECANPAY && i.push("addInput"), n & 31) {
    case q.SIGHASH_ALL:
      break;
    case q.SIGHASH_SINGLE:
    case q.SIGHASH_NONE:
      i.push("addOutput"), i.push("setInputSequence");
      break;
  }
  return i.indexOf(r) === -1;
}
function Ia(e) {
  const { partialSig: t } = e;
  let r;
  if (!t || t.length === 0) {
    if (!e.finalScriptSig && !e.finalScriptWitness) return [];
    r = va(e);
  } else
    r = t;
  return r.map((n) => new Uint8Array(n.signature));
}
function va(e) {
  const t = e.finalScriptSig ? it(new Uint8Array(e.finalScriptSig)) || [] : [], r = e.finalScriptWitness ? it(new Uint8Array(e.finalScriptWitness)) || [] : [];
  return t.concat(r).filter((n) => n instanceof Uint8Array && Le(n)).map((n) => ({ signature: n }));
}
function ku(e, t, r) {
  const n = _a(t, e, r);
  try {
    const h = La(t, n).concat(new Uint8Array(n.script)).concat(new Uint8Array(n.controlBlock));
    return { finalScriptWitness: Aa(h) };
  } catch (i) {
    throw new Error(`Can not finalize taproot input #${e}: ${i}`, { cause: i });
  }
}
function ni(e, t) {
  const r = t ? new Uint8Array([t]) : new Uint8Array(0);
  return vt([e, r]);
}
function nr(e) {
  return e && !!(e.tapInternalKey || e.tapMerkleRoot || e.tapLeafScript && e.tapLeafScript.length || e.tapBip32Derivation && e.tapBip32Derivation.length || e.witnessUtxo && (cs(new Uint8Array(e.witnessUtxo.script)) || gn(new Uint8Array(e.witnessUtxo.script))));
}
function ii(e) {
  return !!(e.witnessUtxo && gn(new Uint8Array(e.witnessUtxo.script)));
}
function _r(e, t) {
  return e && !!(e.tapInternalKey || e.tapTree || e.tapBip32Derivation && e.tapBip32Derivation.length || t && (cs(t) || gn(t)));
}
function Pu(e, t, r) {
  Pa(e, t, r), Ha(e, t, r);
}
function Ru(e, t, r) {
  Ra(e, t, r), Sa(e, t);
}
function Sa(e, t) {
  if (!t.tapTree && !t.tapInternalKey) return;
  const r = t.tapInternalKey || e.tapInternalKey, n = t.tapTree || e.tapTree;
  if (r) {
    const i = e.script, h = Ta(r, n);
    if (i && !H(i, h))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function Ta(e, t) {
  const r = t && Ba(t.leaves), { output: n } = fs({
    internalPubkey: new Uint8Array(e),
    scriptTree: r
  });
  if (!n) throw new Error("Failed to generate taproot script pubkey");
  return n;
}
function Hu(e, t) {
  const r = t.tapInternalKey, n = r ? new Uint8Array(r) : void 0, i = t.tapMerkleRoot ? new Uint8Array(t.tapMerkleRoot) : void 0, h = n && Me(n, i);
  if (!h)
    throw new Error(
      `Cannot tweak tap internal key for input #${e}. Public key: ${n && Array.from(n).map((a) => a.toString(16).padStart(2, "0")).join("")}`
    );
  return h.x;
}
function Lu(e) {
  if (!mi(e))
    throw new Error("Cannot convert taptree to tapleaf list. Expecting a tapree structure.");
  return zr(e);
}
function Ba(e = []) {
  const t = e[0];
  return e.length === 1 && t && t.depth === 0 ? {
    output: new Uint8Array(t.script),
    version: t.leafVersion
  } : ka(e);
}
function Cu(e, t) {
  return Ua(e).some((n) => ds(n, xa, t));
}
function xa(e) {
  return {
    signature: e.subarray(0, 64),
    hashType: e.subarray(64)[0] || q.SIGHASH_DEFAULT
  };
}
function Ua(e) {
  const t = [];
  if (e.tapKeySig && t.push(new Uint8Array(e.tapKeySig)), e.tapScriptSig && t.push(...e.tapScriptSig.map((r) => new Uint8Array(r.signature))), !t.length) {
    const r = Oa(
      e.finalScriptWitness ? new Uint8Array(e.finalScriptWitness) : void 0
    );
    r && t.push(r);
  }
  return t;
}
function Oa(e) {
  if (!e) return;
  const t = e.subarray(2);
  if (t.length === 64 || t.length === 65) return t;
}
function zr(e, t = [], r = 0) {
  if (r > us) throw new Error("Max taptree depth exceeded.");
  return e ? yr(e) ? (t.push({
    depth: r,
    leafVersion: e.version || Re,
    script: e.output
  }), t) : (e[0] && zr(e[0], t, r + 1), e[1] && zr(e[1], t, r + 1), t) : [];
}
function ka(e) {
  let t;
  for (const r of e)
    if (t = Zr(r, t), !t) throw new Error("No room left to insert tapleaf in tree");
  return t;
}
function Zr(e, t, r = 0) {
  if (r > us) throw new Error("Max taptree depth exceeded.");
  if (e.depth === r)
    return t ? void 0 : {
      output: new Uint8Array(e.script),
      version: e.leafVersion
    };
  if (yr(t)) return;
  const n = Zr(e, t && t[0], r + 1);
  if (n) return [n, t && t[1]];
  const i = Zr(e, t && t[1], r + 1);
  if (i) return [t && t[0], i];
}
function Pa(e, t, r) {
  const n = nr(e) && Be(t), i = Be(e) && nr(t), h = e === t && nr(t) && Be(t);
  if (n || i || h)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function Ra(e, t, r) {
  const n = _r(e) && Be(t), i = Be(e) && _r(t), h = e === t && _r(t) && Be(t);
  if (n || i || h)
    throw new Error(
      `Invalid arguments for Psbt.${r}. Cannot use both taproot and non-taproot fields.`
    );
}
function Ha(e, t, r) {
  const n = ii(e) || ii(t);
  if (t.tapMerkleRoot) {
    const i = new Uint8Array(t.tapMerkleRoot), h = (t.tapLeafScript || []).every(
      (c) => Nr(c, i, n)
    ), a = (e.tapLeafScript || []).every(
      (c) => Nr(c, i, n)
    );
    if (!h || !a)
      throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
  } else if (e.tapMerkleRoot) {
    const i = new Uint8Array(e.tapMerkleRoot);
    if (!(t.tapLeafScript || []).every(
      (a) => Nr(a, i, n)
    ))
      throw new Error(`Invalid arguments for Psbt.${r}. Tapleaf not part of taptree.`);
  }
}
function Nr(e, t, r = !1) {
  if (!t) return !0;
  const n = kt({
    output: new Uint8Array(e.script),
    version: e.leafVersion
  }), i = new Uint8Array(e.controlBlock);
  if (r)
    return H(pr(i, n), t);
  const h = i.length >= 33 && (i.length - 33) % 32 === 0, a = i.length >= 1 && (i.length - 1) % 32 === 0;
  if (h) {
    const c = qr(i, n);
    if (H(c, t)) return !0;
  }
  if (a) {
    const c = pr(i, n);
    if (H(c, t)) return !0;
  }
  return !1;
}
function La(e, t) {
  const r = new Uint8Array(t.script), n = kt({
    output: r,
    version: t.leafVersion
  });
  return (e.tapScriptSig || []).filter((i) => H(new Uint8Array(i.leafHash), n)).map((i) => Ca(r, i)).sort((i, h) => h.positionInScript - i.positionInScript).map((i) => new Uint8Array(i.signature));
}
function Ca(e, t) {
  return Object.assign(
    {
      positionInScript: ls(new Uint8Array(t.pubkey), e)
    },
    t
  );
}
function _a(e, t, r) {
  const { tapScriptSig: n } = e;
  if (!n || !n.length)
    throw new Error(
      `Can not finalize taproot input #${t}. No tapleaf script signature provided.`
    );
  const i = (e.tapLeafScript || []).sort((h, a) => h.controlBlock.length - a.controlBlock.length).find((h) => Na(h, n, r));
  if (!i)
    throw new Error(
      `Can not finalize taproot input #${t}. Signature for tapleaf script not found.`
    );
  return i;
}
function Na(e, t, r) {
  const n = kt({
    output: new Uint8Array(e.script),
    version: e.leafVersion
  });
  return (!r || H(r, n)) && t.find((h) => H(new Uint8Array(h.leafHash), n)) !== void 0;
}
function Be(e) {
  return e && !!(e.redeemScript || e.witnessScript || e.bip32Derivation && e.bip32Derivation.length);
}
const ps = {
  /** ECDSA signature (secp256k1) */
  ECDSA: 0,
  /** Schnorr signature (BIP340) */
  Schnorr: 1
};
function _u(e) {
  return e.type === "error";
}
function Nu(e) {
  return e.type === "result";
}
function Va(e) {
  return e.type === "batchResult";
}
function Ma(e) {
  return e.type === "ready";
}
const gt = {
  /** Worker is initializing */
  Initializing: 0,
  /** Worker is ready and idle */
  Idle: 1,
  /** Worker is processing a task */
  Busy: 2,
  /** Worker is shutting down */
  ShuttingDown: 3,
  /** Worker has terminated */
  Terminated: 4
}, Fa = '"use strict";var nobleBundle=(()=>{var rt=Object.defineProperty;var _e=Object.getOwnPropertyDescriptor;var Ce=Object.getOwnPropertyNames;var ke=Object.prototype.hasOwnProperty;var Ve=(e,t,n)=>t in e?rt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var Ct=(e,t)=>{for(var n in t)rt(e,n,{get:t[n],enumerable:!0})},Te=(e,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of Ce(t))!ke.call(e,r)&&r!==n&&rt(e,r,{get:()=>t[r],enumerable:!(s=_e(t,r))||s.enumerable});return e};var Ge=e=>Te(rt({},"__esModule",{value:!0}),e);var l=(e,t,n)=>Ve(e,typeof t!="symbol"?t+"":t,n);var yn={};Ct(yn,{hmac:()=>lt,secp:()=>Lt,sha256:()=>ht});var Lt={};Ct(Lt,{Point:()=>U,Signature:()=>R,etc:()=>sn,getPublicKey:()=>Pt,getSharedSecret:()=>en,hash:()=>je,hashes:()=>K,keygen:()=>nn,recoverPublicKey:()=>Qe,recoverPublicKeyAsync:()=>tn,schnorr:()=>un,sign:()=>We,signAsync:()=>ze,utils:()=>rn,verify:()=>qe,verifyAsync:()=>Je});var Nt={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:D,n:v,Gx:Fe,Gy:De,b:Zt}=Nt,w=32,Z=64,et={publicKey:w+1,publicKeyUncompressed:Z+1,signature:Z,seed:w+w/2},Ke=(...e)=>{"captureStackTrace"in Error&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(...e)},b=(e="")=>{let t=new Error(e);throw Ke(t,b),t},Oe=e=>typeof e=="bigint",Ne=e=>typeof e=="string",Ze=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array",A=(e,t,n="")=>{let s=Ze(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`"${n}" `,i=o?` of length ${t}`:"",u=s?`length=${r}`:`type=${typeof e}`;b(c+"expected Uint8Array"+i+", got "+u)}return e},k=e=>new Uint8Array(e),jt=(e,t)=>e.toString(16).padStart(t,"0"),wt=e=>Array.from(A(e)).map(t=>jt(t,2)).join(""),V={_0:48,_9:57,A:65,F:70,a:97,f:102},kt=e=>{if(e>=V._0&&e<=V._9)return e-V._0;if(e>=V.A&&e<=V.F)return e-(V.A-10);if(e>=V.a&&e<=V.f)return e-(V.a-10)},mt=e=>{let t="hex invalid";if(!Ne(e))return b(t);let n=e.length,s=n/2;if(n%2)return b(t);let r=k(s);for(let o=0,c=0;o<s;o++,c+=2){let i=kt(e.charCodeAt(c)),u=kt(e.charCodeAt(c+1));if(i===void 0||u===void 0)return b(t);r[o]=i*16+u}return r},Rt=()=>globalThis?.crypto,Vt=()=>Rt()?.subtle??b("crypto.subtle must be defined, consider polyfill"),L=(...e)=>{let t=k(e.reduce((s,r)=>s+A(r).length,0)),n=0;return e.forEach(s=>{t.set(s,n),n+=s.length}),t},nt=(e=w)=>Rt().getRandomValues(k(e)),Y=BigInt,j=(e,t,n,s="bad number: out of range")=>Oe(e)&&t<=e&&e<n?e:b(s),a=(e,t=D)=>{let n=e%t;return n>=0n?n:t+n},E=e=>a(e,v),st=(e,t)=>{(e===0n||t<=0n)&&b("no inverse n="+e+" mod="+t);let n=a(e,t),s=t,r=0n,o=1n,c=1n,i=0n;for(;n!==0n;){let u=s/n,d=s%n,f=r-c*u,h=o-i*u;s=n,n=d,r=c,o=i,c=f,i=h}return s===1n?a(r,t):b("no inverse")},it=e=>{let t=K[e];return typeof t!="function"&&b("hashes."+e+" not set"),t},je=e=>it("sha256")(e),xt=e=>e instanceof U?e:b("Point expected"),Xt=e=>a(a(e*e)*e+Zt),Tt=e=>j(e,0n,D),tt=e=>j(e,1n,D),bt=e=>j(e,1n,v),M=e=>(e&1n)===0n,ft=e=>Uint8Array.of(e),Yt=e=>ft(M(e)?2:3),Mt=e=>{let t=Xt(tt(e)),n=1n;for(let s=t,r=(D+1n)/4n;r>0n;r>>=1n)r&1n&&(n=n*s%D),s=s*s%D;return a(n*n)===t?n:b("sqrt invalid")},C=class C{constructor(t,n,s){l(this,"X");l(this,"Y");l(this,"Z");this.X=Tt(t),this.Y=tt(n),this.Z=Tt(s),Object.freeze(this)}static CURVE(){return Nt}static fromAffine(t){let{x:n,y:s}=t;return n===0n&&s===0n?N:new C(n,s,1n)}static fromBytes(t){A(t);let{publicKey:n,publicKeyUncompressed:s}=et,r,o=t.length,c=t[0],i=t.subarray(1),u=P(i,0,w);if(o===n&&(c===2||c===3)){let d=Mt(u),f=M(d);M(Y(c))!==f&&(d=a(-d)),r=new C(u,d,1n)}return o===s&&c===4&&(r=new C(u,P(i,w,Z),1n)),r?r.assertValidity():b("bad point: not on curve")}static fromHex(t){return C.fromBytes(mt(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=a(n*i),d=a(o*r),f=a(s*i),h=a(c*r);return u===d&&f===h}is0(){return this.equals(N)}negate(){return new C(this.X,a(-this.Y),this.Z)}double(){return this.add(this)}add(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=0n,d=Zt,f=0n,h=0n,x=0n,y=a(d*3n),p=a(n*o),g=a(s*c),H=a(r*i),I=a(n+s),m=a(o+c);I=a(I*m),m=a(p+g),I=a(I-m),m=a(n+r);let S=a(o+i);return m=a(m*S),S=a(p+H),m=a(m-S),S=a(s+r),f=a(c+i),S=a(S*f),f=a(g+H),S=a(S-f),x=a(u*m),f=a(y*H),x=a(f+x),f=a(g-x),x=a(g+x),h=a(f*x),g=a(p+p),g=a(g+p),H=a(u*H),m=a(y*m),g=a(g+H),H=a(p-H),H=a(u*H),m=a(m+H),p=a(g*m),h=a(h+p),p=a(S*m),f=a(I*f),f=a(f-p),p=a(I*g),x=a(S*x),x=a(x+p),new C(f,h,x)}subtract(t){return this.add(xt(t).negate())}multiply(t,n=!0){if(!n&&t===0n)return N;if(bt(t),t===1n)return this;if(this.equals(T))return ln(t).p;let s=N,r=T;for(let o=this;t>0n;o=o.double(),t>>=1n)t&1n?s=s.add(o):n&&(r=r.add(o));return s}multiplyUnsafe(t){return this.multiply(t,!1)}toAffine(){let{X:t,Y:n,Z:s}=this;if(this.equals(N))return{x:0n,y:0n};if(s===1n)return{x:t,y:n};let r=st(s,D);return a(s*r)!==1n&&b("inverse invalid"),{x:a(t*r),y:a(n*r)}}assertValidity(){let{x:t,y:n}=this.toAffine();return tt(t),tt(n),a(n*n)===Xt(t)?this:b("bad point: not on curve")}toBytes(t=!0){let{x:n,y:s}=this.assertValidity().toAffine(),r=B(n);return t?L(Yt(s),r):L(ft(4),r,B(s))}toHex(t){return wt(this.toBytes(t))}};l(C,"BASE"),l(C,"ZERO");var U=C,T=new U(Fe,De,1n),N=new U(0n,1n,0n);U.BASE=T;U.ZERO=N;var At=(e,t,n)=>T.multiply(t,!1).add(e.multiply(n,!1)).assertValidity(),G=e=>Y("0x"+(wt(e)||"0")),P=(e,t,n)=>G(e.subarray(t,n)),Re=2n**256n,B=e=>mt(jt(j(e,0n,Re),Z)),W=e=>{let t=G(A(e,w,"secret key"));return j(t,1n,v,"invalid secret key: outside of range")},Ht=e=>e>v>>1n,Pt=(e,t=!0)=>T.multiply(W(e)).toBytes(t),Xe=e=>{try{return!!W(e)}catch{return!1}},Ye=(e,t)=>{let{publicKey:n,publicKeyUncompressed:s}=et;try{let r=e.length;return t===!0&&r!==n||t===!1&&r!==s?!1:!!U.fromBytes(e)}catch{return!1}},$t=e=>{[0,1,2,3].includes(e)||b("recovery id must be valid and present")},Me=e=>{e!=null&&!Gt.includes(e)&&b(`Signature format must be one of: ${Gt.join(", ")}`),e===qt&&b(\'Signature format "der" is not supported: switch to noble-curves\')},Wt=(e,t=$)=>{Me(t);let n=et.signature,s=n+1,r=`Signature format "${t}" expects Uint8Array with length `;t===$&&e.length!==n&&b(r+n),t===ot&&e.length!==s&&b(r+s)},R=class e{constructor(t,n,s){l(this,"r");l(this,"s");l(this,"recovery");this.r=bt(t),this.s=bt(n),s!=null&&(this.recovery=s),Object.freeze(this)}static fromBytes(t,n=$){Wt(t,n);let s;n===ot&&(s=t[0],t=t.subarray(1));let r=P(t,0,w),o=P(t,w,Z);return new e(r,o,s)}addRecoveryBit(t){return new e(this.r,this.s,t)}hasHighS(){return Ht(this.s)}toBytes(t=$){let{r:n,s,recovery:r}=this,o=L(B(n),B(s));return t===ot?($t(r),L(Uint8Array.of(r),o)):o}},zt=e=>{let t=e.length*8-256;t>1024&&b("msg invalid");let n=G(e);return t>0?n>>Y(t):n},St=e=>E(zt(A(e))),$="compact",ot="recovered",qt="der",Gt=[$,ot,qt],Ft={lowS:!0,prehash:!0,format:$,extraEntropy:!1},Dt="SHA-256",K={hmacSha256Async:async(e,t)=>{let n=Vt(),s="HMAC",r=await n.importKey("raw",e,{name:s,hash:{name:Dt}},!1,["sign"]);return k(await n.sign(s,r,t))},hmacSha256:void 0,sha256Async:async e=>k(await Vt().digest(Dt,e)),sha256:void 0},z=(e,t,n)=>(A(e,void 0,"message"),t.prehash?n?K.sha256Async(e):it("sha256")(e):e),Jt=k(0),Qt=ft(0),te=ft(1),ee=1e3,ne="drbg: tried max amount of iterations",Pe=(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>it("hmacSha256")(s,L(n,...f)),i=(f=Jt)=>{s=c(Qt,f),n=c(),f.length!==0&&(s=c(te,f),n=c())},u=()=>(r++>=ee&&b(ne),n=c(),n);o(),i(e);let d;for(;!(d=t(u()));)i();return o(),d},$e=async(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>K.hmacSha256Async(s,L(n,...f)),i=async(f=Jt)=>{s=await c(Qt,f),n=await c(),f.length!==0&&(s=await c(te,f),n=await c())},u=async()=>(r++>=ee&&b(ne),n=await c(),n);o(),await i(e);let d;for(;!(d=t(await u()));)await i();return o(),d},se=(e,t,n,s)=>{let{lowS:r,extraEntropy:o}=n,c=B,i=St(e),u=c(i),d=W(t),f=[c(d),u];if(o!=null&&o!==!1){let p=o===!0?nt(w):o;f.push(A(p,void 0,"extraEntropy"))}let h=L(...f),x=i;return s(h,p=>{let g=zt(p);if(!(1n<=g&&g<v))return;let H=st(g,v),I=T.multiply(g).toAffine(),m=E(I.x);if(m===0n)return;let S=E(H*E(x+m*d));if(S===0n)return;let vt=(I.x===m?0:2)|Number(I.y&1n),_t=S;return r&&Ht(S)&&(_t=E(-S),vt^=1),new R(m,_t,vt).toBytes(n.format)})},re=(e,t,n,s={})=>{let{lowS:r,format:o}=s;e instanceof R&&b("Signature must be in Uint8Array, use .toBytes()"),Wt(e,o),A(n,void 0,"publicKey");try{let{r:c,s:i}=R.fromBytes(e,o),u=St(t),d=U.fromBytes(n);if(r&&Ht(i))return!1;let f=st(i,v),h=E(u*f),x=E(c*f),y=At(d,h,x).toAffine();return E(y.x)===c}catch{return!1}},q=e=>{let t={};return Object.keys(Ft).forEach(n=>{t[n]=e[n]??Ft[n]}),t},We=(e,t,n={})=>(n=q(n),e=z(e,n,!1),se(e,t,n,Pe)),ze=async(e,t,n={})=>(n=q(n),e=await z(e,n,!0),se(e,t,n,$e)),qe=(e,t,n,s={})=>(s=q(s),t=z(t,s,!1),re(e,t,n,s)),Je=async(e,t,n,s={})=>(s=q(s),t=await z(t,s,!0),re(e,t,n,s)),oe=(e,t)=>{let n=R.fromBytes(e,"recovered"),{r:s,s:r,recovery:o}=n;$t(o);let c=St(A(t,w)),i=o===2||o===3?s+v:s;tt(i);let u=Yt(Y(o)),d=L(u,B(i)),f=U.fromBytes(d),h=st(i,v),x=E(-c*h),y=E(r*h);return At(f,x,y).toBytes()},Qe=(e,t,n={})=>(t=z(t,q(n),!1),oe(e,t)),tn=async(e,t,n={})=>(t=await z(t,q(n),!0),oe(e,t)),en=(e,t,n=!0)=>U.fromBytes(t).multiply(W(e)).toBytes(n),ce=(e=nt(et.seed))=>{A(e),(e.length<et.seed||e.length>1024)&&b("expected 40-1024b");let t=a(G(e),v-1n);return B(t+1n)},ie=e=>t=>{let n=ce(t);return{secretKey:n,publicKey:e(n)}},nn=ie(Pt),sn={hexToBytes:mt,bytesToHex:wt,concatBytes:L,bytesToNumberBE:G,numberToBytesBE:B,mod:a,invert:st,randomBytes:nt,secretKeyToScalar:W,abytes:A},rn={isValidSecretKey:Xe,isValidPublicKey:Ye,randomSecretKey:ce},fe=e=>Uint8Array.from("BIP0340/"+e,t=>t.charCodeAt(0)),ae="aux",ue="nonce",he="challenge",yt=(e,...t)=>{let n=it("sha256"),s=n(fe(e));return n(L(s,s,...t))},pt=async(e,...t)=>{let n=K.sha256Async,s=await n(fe(e));return await n(L(s,s,...t))},Bt=e=>{let t=W(e),n=T.multiply(t),{x:s,y:r}=n.assertValidity().toAffine(),o=M(r)?t:E(-t),c=B(s);return{d:o,px:c}},Et=e=>E(G(e)),de=(...e)=>Et(yt(he,...e)),le=async(...e)=>Et(await pt(he,...e)),xe=e=>Bt(e).px,on=ie(xe),be=(e,t,n)=>{let{px:s,d:r}=Bt(t);return{m:A(e),px:s,d:r,a:A(n,w)}},ye=e=>{let t=Et(e);t===0n&&b("sign failed: k is zero");let{px:n,d:s}=Bt(B(t));return{rx:n,k:s}},pe=(e,t,n,s)=>L(t,B(E(e+n*s))),ge="invalid signature produced",cn=(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=yt(ae,c),u=B(o^G(i)),d=yt(ue,u,r,s),{rx:f,k:h}=ye(d),x=de(f,r,s),y=pe(h,f,x,o);return me(y,s,r)||b(ge),y},fn=async(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=await pt(ae,c),u=B(o^G(i)),d=await pt(ue,u,r,s),{rx:f,k:h}=ye(d),x=await le(f,r,s),y=pe(h,f,x,o);return await Ae(y,s,r)||b(ge),y},an=(e,t)=>e instanceof Promise?e.then(t):t(e),we=(e,t,n,s)=>{let r=A(e,Z,"signature"),o=A(t,void 0,"message"),c=A(n,w,"publicKey");try{let i=G(c),u=Mt(i),d=M(u)?u:a(-u),f=new U(i,d,1n).assertValidity(),h=B(f.toAffine().x),x=P(r,0,w);j(x,1n,D);let y=P(r,w,Z);j(y,1n,v);let p=L(B(x),h,o);return an(s(p),g=>{let{x:H,y:I}=At(f,y,E(-g)).toAffine();return!(!M(I)||H!==x)})}catch{return!1}},me=(e,t,n)=>we(e,t,n,de),Ae=async(e,t,n)=>we(e,t,n,le),un={keygen:on,getPublicKey:xe,sign:cn,verify:me,signAsync:fn,verifyAsync:Ae},ct=8,hn=256,He=Math.ceil(hn/ct)+1,gt=2**(ct-1),dn=()=>{let e=[],t=T,n=t;for(let s=0;s<He;s++){n=t,e.push(n);for(let r=1;r<gt;r++)n=n.add(t),e.push(n);t=n.double()}return e},Kt,Ot=(e,t)=>{let n=t.negate();return e?n:t},ln=e=>{let t=Kt||(Kt=dn()),n=N,s=T,r=2**ct,o=r,c=Y(r-1),i=Y(ct);for(let u=0;u<He;u++){let d=Number(e&c);e>>=i,d>gt&&(d-=o,e+=1n);let f=u*gt,h=f,x=f+Math.abs(d)-1,y=u%2!==0,p=d<0;d===0?s=s.add(Ot(y,t[h])):n=n.add(Ot(p,t[x]))}return e!==0n&&b("invalid wnaf"),{p:n,f:s}};function xn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Se(e,t=""){if(!Number.isSafeInteger(e)||e<0){let n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function J(e,t,n=""){let s=xn(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`"${n}" `,i=o?` of length ${t}`:"",u=s?`length=${r}`:`type=${typeof e}`;throw new Error(c+"expected Uint8Array"+i+", got "+u)}return e}function Be(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Se(e.outputLen),Se(e.blockLen)}function Q(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Ee(e,t){J(e,void 0,"digestInto() output");let n=t.outputLen;if(e.length<n)throw new Error(\'"digestInto() output" expected to be of length >=\'+n)}function X(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function at(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function _(e,t){return e<<32-t|e>>>t}function Le(e,t={}){let n=(r,o)=>e(o).update(r).digest(),s=e(void 0);return n.outputLen=s.outputLen,n.blockLen=s.blockLen,n.create=r=>e(r),Object.assign(n,t),Object.freeze(n)}var Ue=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function Ie(e,t,n){return e&t^~e&n}function ve(e,t,n){return e&t^e&n^t&n}var ut=class{constructor(t,n,s,r){l(this,"blockLen");l(this,"outputLen");l(this,"padOffset");l(this,"isLE");l(this,"buffer");l(this,"view");l(this,"finished",!1);l(this,"length",0);l(this,"pos",0);l(this,"destroyed",!1);this.blockLen=t,this.outputLen=n,this.padOffset=s,this.isLE=r,this.buffer=new Uint8Array(t),this.view=at(this.buffer)}update(t){Q(this),J(t);let{view:n,buffer:s,blockLen:r}=this,o=t.length;for(let c=0;c<o;){let i=Math.min(r-this.pos,o-c);if(i===r){let u=at(t);for(;r<=o-c;c+=r)this.process(u,c);continue}s.set(t.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Q(this),Ee(t,this),this.finished=!0;let{buffer:n,view:s,blockLen:r,isLE:o}=this,{pos:c}=this;n[c++]=128,X(this.buffer.subarray(c)),this.padOffset>r-c&&(this.process(s,0),c=0);for(let h=c;h<r;h++)n[h]=0;s.setBigUint64(r-8,BigInt(this.length*8),o),this.process(s,0);let i=at(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen must be aligned to 32bit");let d=u/4,f=this.get();if(d>f.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<d;h++)i.setUint32(4*h,f[h],o)}digest(){let{buffer:t,outputLen:n}=this;this.digestInto(t);let s=t.slice(0,n);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:n,buffer:s,length:r,finished:o,destroyed:c,pos:i}=this;return t.destroyed=c,t.finished=o,t.length=r,t.pos=i,r%n&&t.buffer.set(s),t}clone(){return this._cloneInto()}},F=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var bn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),O=new Uint32Array(64),Ut=class extends ut{constructor(t){super(64,t,8,!1)}get(){let{A:t,B:n,C:s,D:r,E:o,F:c,G:i,H:u}=this;return[t,n,s,r,o,c,i,u]}set(t,n,s,r,o,c,i,u){this.A=t|0,this.B=n|0,this.C=s|0,this.D=r|0,this.E=o|0,this.F=c|0,this.G=i|0,this.H=u|0}process(t,n){for(let h=0;h<16;h++,n+=4)O[h]=t.getUint32(n,!1);for(let h=16;h<64;h++){let x=O[h-15],y=O[h-2],p=_(x,7)^_(x,18)^x>>>3,g=_(y,17)^_(y,19)^y>>>10;O[h]=g+O[h-7]+p+O[h-16]|0}let{A:s,B:r,C:o,D:c,E:i,F:u,G:d,H:f}=this;for(let h=0;h<64;h++){let x=_(i,6)^_(i,11)^_(i,25),y=f+x+Ie(i,u,d)+bn[h]+O[h]|0,g=(_(s,2)^_(s,13)^_(s,22))+ve(s,r,o)|0;f=d,d=u,u=i,i=c+y|0,c=o,o=r,r=s,s=y+g|0}s=s+this.A|0,r=r+this.B|0,o=o+this.C|0,c=c+this.D|0,i=i+this.E|0,u=u+this.F|0,d=d+this.G|0,f=f+this.H|0,this.set(s,r,o,c,i,u,d,f)}roundClean(){X(O)}destroy(){this.set(0,0,0,0,0,0,0,0),X(this.buffer)}},It=class extends Ut{constructor(){super(32);l(this,"A",F[0]|0);l(this,"B",F[1]|0);l(this,"C",F[2]|0);l(this,"D",F[3]|0);l(this,"E",F[4]|0);l(this,"F",F[5]|0);l(this,"G",F[6]|0);l(this,"H",F[7]|0)}};var ht=Le(()=>new It,Ue(1));var dt=class{constructor(t,n){l(this,"oHash");l(this,"iHash");l(this,"blockLen");l(this,"outputLen");l(this,"finished",!1);l(this,"destroyed",!1);if(Be(t),J(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let s=this.blockLen,r=new Uint8Array(s);r.set(n.length>s?t.create().update(n).digest():n);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r),this.oHash=t.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r),X(r)}update(t){return Q(this),this.iHash.update(t),this}digestInto(t){Q(this),J(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:n,iHash:s,finished:r,destroyed:o,blockLen:c,outputLen:i}=this;return t=t,t.finished=r,t.destroyed=o,t.blockLen=c,t.outputLen=i,t.oHash=n._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},lt=(e,t,n)=>new dt(e,t).update(n).digest();lt.create=(e,t)=>new dt(e,t);K.sha256=ht;K.hmacSha256=(e,...t)=>{let n=new Uint8Array(t.reduce((r,o)=>r+o.length,0)),s=0;for(let r of t)n.set(r,s),s+=r.length;return lt(ht,e,n)};return Ge(yn);})();\n/*! Bundled license information:\n\n@noble/secp256k1/index.js:\n  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)\n\n@noble/hashes/utils.js:\n  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n*/\n', Vu = 18327;
function $a() {
  return `
'use strict';

/**
 * Zero out a Uint8Array to clear sensitive data.
 * @param {Uint8Array} arr - Array to zero
 */
function secureZero(arr) {
    if (arr && arr.fill) {
        arr.fill(0);
        // Double-write to prevent optimization
        for (let i = 0; i < arr.length; i++) {
            arr[i] = 0;
        }
    }
}

/**
 * Bundled @noble/secp256k1 + hashes library (embedded at compile time).
 */
const eccBundle = ${JSON.stringify(Fa)};

/**
 * Initialize the ECC library from the bundle.
 * The bundle exports nobleBundle with { secp, sha256, hmac }.
 */
const eccModule = (function() {
    // Execute the IIFE and return the nobleBundle object
    const fn = new Function(eccBundle + '; return nobleBundle;');
    return fn();
})();

/**
 * ECC library wrapper with the interface we need.
 * Uses eccModule.secp which has hashes pre-configured.
 */
const eccLib = {
    sign: (hash, privateKey) => {
        // noble's sign returns Signature object, we need compact 64-byte format
        const sig = eccModule.secp.sign(hash, privateKey, { lowS: true });
        return sig.toCompactRawBytes();
    },
    signSchnorr: (hash, privateKey) => {
        return eccModule.secp.schnorr.sign(hash, privateKey);
    }
};

/**
 * Whether initialization is complete.
 */
let initialized = false;

/**
 * Pending messages received before init completes.
 */
const pendingMessages = [];

/**
 * Handle incoming messages from main thread.
 */
self.onmessage = async function(event) {
    const msg = event.data;

    // Queue messages until initialized (except init)
    if (!initialized && msg.type !== 'init') {
        pendingMessages.push(msg);
        return;
    }

    await handleMessage(msg);
};

/**
 * Process a message.
 */
async function handleMessage(msg) {
    switch (msg.type) {
        case 'init':
            handleInit(msg);
            break;
        case 'sign':
            handleSign(msg);
            break;
        case 'signBatch':
            handleSignBatch(msg);
            break;
        case 'shutdown':
            handleShutdown();
            break;
        default:
            self.postMessage({
                type: 'error',
                taskId: msg.taskId || 'unknown',
                error: 'Unknown message type: ' + msg.type,
                inputIndex: msg.inputIndex || -1
            });
    }
}

/**
 * Initialize the worker.
 * ECC library is already bundled, so this just marks as ready.
 */
function handleInit(msg) {
    initialized = true;

    // Signal ready
    self.postMessage({ type: 'ready' });

    // Process pending messages
    while (pendingMessages.length > 0) {
        handleMessage(pendingMessages.shift());
    }
}

/**
 * Handle a signing request.
 *
 * SECURITY: Private key is zeroed immediately after use.
 *
 * @param {Object} msg - Signing task message
 */
function handleSign(msg) {
    const {
        taskId,
        hash,
        privateKey,
        publicKey,
        signatureType,
        lowR,
        inputIndex,
        sighashType,
        leafHash
    } = msg;

    // Validate inputs
    if (!hash || hash.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: 'Invalid hash: must be 32 bytes',
            inputIndex: inputIndex
        });
        return;
    }

    if (!privateKey || privateKey.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: 'Invalid private key: must be 32 bytes',
            inputIndex: inputIndex
        });
        return;
    }

    let signature;

    try {
        if (signatureType === 1) {
            // Schnorr signature (BIP340)
            if (typeof eccLib.signSchnorr !== 'function') {
                throw new Error('ECC library does not support Schnorr signatures');
            }
            signature = eccLib.signSchnorr(hash, privateKey);
        } else {
            // ECDSA signature
            if (typeof eccLib.sign !== 'function') {
                throw new Error('ECC library does not support ECDSA signatures');
            }
            signature = eccLib.sign(hash, privateKey, { lowR: lowR || false });
        }

        if (!signature) {
            throw new Error('Signing returned null or undefined');
        }

    } catch (error) {
        // ALWAYS zero the key, even on error
        secureZero(privateKey);

        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: error.message || 'Signing failed',
            inputIndex: inputIndex
        });
        return;
    }

    // CRITICAL: Zero the private key immediately after signing
    secureZero(privateKey);

    // Send result back
    const result = {
        type: 'result',
        taskId: taskId,
        signature: signature,
        inputIndex: inputIndex,
        publicKey: publicKey,
        signatureType: signatureType
    };

    if (leafHash) {
        result.leafHash = leafHash;
    }

    self.postMessage(result);
}

/**
 * Handle a batch signing request.
 * Signs multiple tasks and returns all results in a single message.
 *
 * SECURITY: Private key is zeroed immediately after all signatures.
 *
 * @param {Object} msg - Batch signing message with tasks array
 */
function handleSignBatch(msg) {
    const { batchId, tasks, privateKey } = msg;
    const results = [];
    const errors = [];

    // Validate private key once
    if (!privateKey || privateKey.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'batchResult',
            batchId: batchId,
            results: [],
            errors: [{ inputIndex: -1, error: 'Invalid private key: must be 32 bytes' }]
        });
        return;
    }

    // Process all tasks
    for (const task of tasks) {
        const { taskId, hash, publicKey, signatureType, lowR, inputIndex, sighashType, leafHash } = task;

        // Validate hash
        if (!hash || hash.length !== 32) {
            errors.push({ taskId, inputIndex, error: 'Invalid hash: must be 32 bytes' });
            continue;
        }

        try {
            let signature;
            if (signatureType === 1) {
                // Schnorr signature (BIP340)
                signature = eccLib.signSchnorr(hash, privateKey);
            } else {
                // ECDSA signature
                signature = eccLib.sign(hash, privateKey, { lowR: lowR || false });
            }

            if (!signature) {
                throw new Error('Signing returned null or undefined');
            }

            const result = {
                taskId: taskId,
                signature: signature,
                inputIndex: inputIndex,
                publicKey: publicKey,
                signatureType: signatureType
            };

            if (leafHash) {
                result.leafHash = leafHash;
            }

            results.push(result);
        } catch (error) {
            errors.push({ taskId, inputIndex, error: error.message || 'Signing failed' });
        }
    }

    // CRITICAL: Zero the private key after processing all tasks
    secureZero(privateKey);

    // Send batch result back
    self.postMessage({
        type: 'batchResult',
        batchId: batchId,
        results: results,
        errors: errors
    });
}

/**
 * Handle shutdown request.
 */
function handleShutdown() {
    initialized = false;
    pendingMessages.length = 0;

    self.postMessage({ type: 'shutdown-ack' });

    // Close the worker
    self.close();
}
`;
}
function Da() {
  const e = $a(), t = new Blob([e], { type: "application/javascript" });
  return URL.createObjectURL(t);
}
function Ka(e) {
  URL.revokeObjectURL(e);
}
const Wa = {
  workerCount: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
  taskTimeoutMs: 3e4,
  maxKeyHoldTimeMs: 5e3,
  verifySignatures: !0,
  preserveWorkers: !1
};
class Nt {
  /**
   * Singleton instance.
   */
  static #e = null;
  /**
   * Pool configuration.
   */
  #h;
  /**
   * Worker pool.
   */
  #t = [];
  /**
   * Pending batches awaiting completion.
   */
  #s = /* @__PURE__ */ new Map();
  /**
   * Worker blob URL (shared across all workers).
   */
  #n = null;
  /**
   * Whether workers are preserved between batches.
   */
  #r = !1;
  /**
   * Next worker ID counter.
   */
  #i = 0;
  /**
   * Next task ID counter.
   */
  #o = 0;
  /**
   * Whether the pool is initialized.
   */
  #a = !1;
  /**
   * Whether the pool is shutting down.
   */
  #f = !1;
  /**
   * Creates a new WorkerSigningPool.
   *
   * @param config - Pool configuration
   */
  constructor(t = {}) {
    this.#h = { ...Wa, ...t }, this.#r = this.#h.preserveWorkers;
  }
  /**
   * Number of workers in the pool.
   */
  get workerCount() {
    return this.#t.length;
  }
  /**
   * Number of idle workers available.
   */
  get idleWorkerCount() {
    return this.#t.filter((t) => t.state === gt.Idle).length;
  }
  /**
   * Number of busy workers.
   */
  get busyWorkerCount() {
    return this.#t.filter((t) => t.state === gt.Busy).length;
  }
  /**
   * Whether workers are being preserved between batches.
   */
  get isPreservingWorkers() {
    return this.#r;
  }
  /**
   * Gets the singleton pool instance.
   *
   * @param config - Optional configuration (only used on first call)
   * @returns The singleton pool instance
   *
   * @example
   * ```typescript
   * const pool = WorkerSigningPool.getInstance({ workerCount: 8 });
   * ```
   */
  static getInstance(t) {
    return Nt.#e || (Nt.#e = new Nt(t)), Nt.#e;
  }
  /**
   * Resets the singleton instance (for testing).
   */
  static resetInstance() {
    Nt.#e && (Nt.#e.shutdown().catch(() => {
    }), Nt.#e = null);
  }
  /**
   * Enables worker preservation between signing batches.
   *
   * When enabled, workers remain alive after completing a batch,
   * ready for the next signing operation. This is faster but
   * keeps workers in memory.
   *
   * Call shutdown() when done to terminate all workers.
   *
   * @example
   * ```typescript
   * const pool = WorkerSigningPool.getInstance();
   * pool.preserveWorkers(); // Enable at app startup
   *
   * // ... do many signing operations ...
   *
   * await pool.shutdown(); // Cleanup at app shutdown
   * ```
   */
  preserveWorkers() {
    this.#r = !0;
  }
  /**
   * Disables worker preservation.
   *
   * Workers will be terminated after each signing batch.
   * More secure (no persistent workers) but slower for multiple batches.
   */
  releaseWorkers() {
    this.#r = !1;
  }
  /**
   * Initializes the worker pool.
   *
   * Creates workers and waits for them to be ready.
   * Called automatically on first signBatch() if not called manually.
   *
   * @returns Promise that resolves when all workers are ready
   */
  async initialize() {
    if (this.#a)
      return;
    if (this.#f)
      throw new Error("Cannot initialize pool while shutting down");
    this.#n = Da();
    const t = [];
    for (let r = 0; r < this.#h.workerCount; r++)
      t.push(this.#u());
    await Promise.all(t), this.#a = !0;
  }
  /**
   * Signs a batch of tasks in parallel.
   *
   * SECURITY: Private keys are obtained via keyPair.getPrivateKey() and
   * cloned to workers. Keys are zeroed in workers immediately after signing.
   *
   * Tasks are distributed across workers and processed in batches for efficiency.
   *
   * @param tasks - Signing tasks (hashes, input indices, etc.)
   * @param keyPair - Key pair with getPrivateKey() method
   * @returns Promise resolving to signing results
   *
   * @example
   * ```typescript
   * const tasks: SigningTask[] = [
   *     { taskId: '1', inputIndex: 0, hash: hash0, signatureType: SignatureType.ECDSA, sighashType: 0x01 },
   *     { taskId: '2', inputIndex: 1, hash: hash1, signatureType: SignatureType.Schnorr, sighashType: 0x00 },
   * ];
   *
   * const result = await pool.signBatch(tasks, keyPair);
   *
   * if (result.success) {
   *     for (const [inputIndex, sig] of result.signatures) {
   *         console.log(`Input ${inputIndex}: ${sig.signature}`);
   *     }
   * }
   * ```
   */
  async signBatch(t, r) {
    const n = performance.now();
    if (this.#a || await this.initialize(), t.length === 0)
      return {
        success: !0,
        signatures: /* @__PURE__ */ new Map(),
        errors: /* @__PURE__ */ new Map(),
        durationMs: performance.now() - n
      };
    const i = Math.min(this.#t.length, t.length), h = Array.from({ length: i }, () => []);
    for (let c = 0; c < t.length; c++)
      h[c % i].push(t[c]);
    const a = r.getPrivateKey();
    try {
      const c = await Promise.allSettled(
        h.map(
          (f, w) => this.#c(f, a, r.publicKey, w)
        )
      ), d = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map();
      for (let f = 0; f < c.length; f++) {
        const w = c[f];
        if (w.status === "fulfilled") {
          const b = w.value;
          for (const y of b.results)
            d.set(y.inputIndex, {
              type: "result",
              taskId: y.taskId,
              signature: y.signature,
              inputIndex: y.inputIndex,
              publicKey: y.publicKey,
              signatureType: y.signatureType,
              leafHash: y.leafHash
            });
          for (const y of b.errors)
            p.set(y.inputIndex, y.error);
        } else {
          const y = w.reason?.message ?? "Batch signing failed", I = h[f];
          for (const E of I)
            p.set(E.inputIndex, y);
        }
      }
      return this.#r || await this.#d(), {
        success: p.size === 0,
        signatures: d,
        errors: p,
        durationMs: performance.now() - n
      };
    } finally {
      a.fill(0);
    }
  }
  /**
   * Disposes of the pool by shutting down all workers.
   *
   * Enables `await using pool = ...` syntax for automatic cleanup.
   */
  async [Symbol.asyncDispose]() {
    await this.shutdown();
  }
  /**
   * Shuts down the pool and terminates all workers.
   *
   * Call this when the application is done with signing operations.
   *
   * @returns Promise that resolves when all workers are terminated
   */
  async shutdown() {
    if (this.#f)
      return;
    this.#f = !0;
    const t = this.#t.map((r) => this.#l(r));
    await Promise.all(t), this.#t.length = 0, this.#s.clear(), this.#n && (Ka(this.#n), this.#n = null), this.#a = !1, this.#f = !1;
  }
  [Symbol.dispose]() {
    this.shutdown();
  }
  /**
   * Creates a new worker and adds it to the pool.
   */
  async #u() {
    if (!this.#n)
      throw new Error("Worker blob URL not created");
    const t = this.#i++, r = new Worker(this.#n, {
      name: `signing-worker-${t}`
    }), n = {
      id: t,
      state: gt.Initializing,
      worker: r,
      currentTaskId: null,
      taskStartTime: null
    };
    this.#t.push(n), await new Promise((i, h) => {
      const a = setTimeout(() => {
        h(new Error(`Worker ${t} initialization timeout`));
      }, 1e4), c = (d) => {
        Ma(d.data) && (clearTimeout(a), r.removeEventListener("message", c), n.state = gt.Idle, i());
      };
      r.addEventListener("message", c), r.addEventListener("error", (d) => {
        clearTimeout(a), h(new Error(`Worker ${t} error: ${d.message}`));
      }), r.postMessage({
        type: "init"
      });
    }), r.addEventListener("message", (i) => {
      this.#w(n, i.data);
    });
  }
  /**
   * Signs a batch of tasks on a specific worker.
   */
  async #c(t, r, n, i) {
    if (t.length === 0)
      return { type: "batchResult", batchId: "", results: [], errors: [] };
    const h = this.#t[i] ?? await this.#p(), a = `batch-${this.#o++}`;
    return new Promise((c, d) => {
      const p = setTimeout(() => {
        this.#s.delete(a), h.state = gt.Idle, h.currentTaskId = null, h.taskStartTime = null, this.#l(h).catch(() => {
        }), this.#u().catch(() => {
        }), d(new Error(`Batch signing timeout for ${t.length} tasks`));
      }, this.#h.maxKeyHoldTimeMs), f = {
        batchId: a,
        resolve: c,
        reject: d,
        timeoutId: p
      };
      this.#s.set(a, f), h.state = gt.Busy, h.currentTaskId = a, h.taskStartTime = Date.now();
      const w = t.map((y) => ({
        taskId: y.taskId,
        hash: y.hash,
        publicKey: n,
        signatureType: y.signatureType,
        lowR: y.lowR,
        inputIndex: y.inputIndex,
        sighashType: y.sighashType,
        leafHash: y.leafHash
      })), b = {
        type: "signBatch",
        batchId: a,
        tasks: w,
        privateKey: r
        // Cloned to worker, zeroed there after all signatures
      };
      h.worker.postMessage(b);
    });
  }
  /**
   * Gets an idle worker, creating one if necessary.
   */
  async #p() {
    let t = this.#t.find((r) => r.state === gt.Idle);
    return t || this.#t.length < this.#h.workerCount && (await this.#u(), t = this.#t.find((r) => r.state === gt.Idle), t) ? t : new Promise((r) => {
      const n = setInterval(() => {
        const i = this.#t.find((h) => h.state === gt.Idle);
        i && (clearInterval(n), r(i));
      }, 10);
    });
  }
  /**
   * Handles a message from a worker.
   */
  #w(t, r) {
    if (Va(r)) {
      const n = this.#s.get(r.batchId);
      n && (clearTimeout(n.timeoutId), this.#s.delete(r.batchId), t.state = gt.Idle, t.currentTaskId = null, t.taskStartTime = null, n.resolve(r));
    }
  }
  /**
   * Terminates a worker.
   */
  async #l(t) {
    if (t.state === gt.Terminated)
      return;
    t.state = gt.ShuttingDown, t.worker.postMessage({ type: "shutdown" }), await new Promise((n) => {
      const i = setTimeout(() => {
        t.worker.terminate(), t.state = gt.Terminated, n();
      }, 1e3), h = (a) => {
        a.data.type === "shutdown-ack" && (clearTimeout(i), t.worker.removeEventListener("message", h), t.worker.terminate(), t.state = gt.Terminated, n());
      };
      t.worker.addEventListener("message", h);
    });
    const r = this.#t.indexOf(t);
    r >= 0 && this.#t.splice(r, 1);
  }
  /**
   * Terminates all idle workers.
   */
  async #d() {
    const t = this.#t.filter((r) => r.state === gt.Idle);
    await Promise.all(t.map((r) => this.#l(r)));
  }
}
function Ga(e) {
  return Nt.getInstance(e);
}
const ja = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WorkerSigningPool: Nt,
  getSigningPool: Ga
}, Symbol.toStringTag, { value: "Module" }));
async function Mu(e, t, r, n = {}) {
  let i, h = !1;
  if (r && "signBatch" in r)
    i = r;
  else {
    const { WorkerSigningPool: a } = await Promise.resolve().then(() => ja);
    i = a.getInstance(r), i.isPreservingWorkers || (h = !0);
  }
  try {
    await i.initialize();
    const a = qa(e, t, n);
    if (a.length === 0)
      return {
        success: !0,
        signatures: /* @__PURE__ */ new Map(),
        errors: /* @__PURE__ */ new Map(),
        durationMs: 0
      };
    const c = await i.signBatch(a, t);
    return c.success && Ya(e, c, t), c;
  } finally {
    h && await i.shutdown();
  }
}
function qa(e, t, r = {}) {
  const n = [], i = e.data.inputs, h = t.publicKey;
  for (let a = 0; a < i.length; a++) {
    const c = i[a];
    if (e.inputHasPubkey(a, h))
      if (nr(c)) {
        const d = za(e, a, c, t, r);
        n.push(...d);
      } else {
        const d = Za(e, a, c, t, r);
        d && n.push(d);
      }
  }
  return n;
}
function za(e, t, r, n, i) {
  const h = [];
  try {
    const a = e.checkTaprootHashesForSig(
      t,
      r,
      n,
      i.tapLeafHash,
      i.sighashTypes
    );
    for (const { hash: c, leafHash: d } of a)
      h.push({
        taskId: `taproot-${t}-${d ? "script" : "key"}`,
        inputIndex: t,
        hash: c,
        signatureType: ps.Schnorr,
        sighashType: r.sighashType ?? q.SIGHASH_DEFAULT,
        leafHash: d
      });
  } catch {
  }
  return h;
}
function Za(e, t, r, n, i) {
  try {
    const h = r.sighashType ?? q.SIGHASH_ALL;
    return (i.sighashTypes ?? [q.SIGHASH_ALL]).includes(h), null;
  } catch {
    return null;
  }
}
function Ya(e, t, r) {
  const n = r.publicKey;
  for (const [i, h] of t.signatures) {
    const a = e.data.inputs[i];
    if (h.signatureType === ps.Schnorr)
      if (h.leafHash) {
        const c = [
          {
            pubkey: Vi(n),
            signature: ni(
              h.signature,
              a.sighashType
            ),
            leafHash: h.leafHash
          }
        ];
        e.data.updateInput(i, { tapScriptSig: c });
      } else {
        const c = ni(h.signature, a.sighashType);
        e.data.updateInput(i, { tapKeySig: c });
      }
    else {
      const c = on.encode(
        h.signature,
        a.sighashType ?? q.SIGHASH_ALL
      ), d = [
        {
          pubkey: Uint8Array.from(n),
          signature: c
        }
      ];
      e.data.updateInput(i, { partialSig: d });
    }
  }
}
export {
  Ds as $,
  be as A,
  Ee as B,
  Ie as C,
  ve as D,
  Se as E,
  He as F,
  ma as G,
  ya as H,
  qr as I,
  pr as J,
  Ke as K,
  Re as L,
  us as M,
  kt as N,
  wr as O,
  ct as P,
  Me as Q,
  Qr as R,
  ne as S,
  Jt as T,
  H as U,
  re as V,
  xe as W,
  eo as X,
  ut as Y,
  Kt as Z,
  q as _,
  lt as a,
  qo as a$,
  Xr as a0,
  nr as a1,
  Cu as a2,
  Ou as a3,
  on as a4,
  Uu as a5,
  vu as a6,
  Tu as a7,
  Su as a8,
  Iu as a9,
  vt as aA,
  Kr as aB,
  nu as aC,
  ha as aD,
  va as aE,
  Ga as aF,
  Oa as aG,
  yt as aH,
  mu as aI,
  So as aJ,
  Ja as aK,
  xu as aL,
  gn as aM,
  Bu as aN,
  le as aO,
  hu as aP,
  ou as aQ,
  au as aR,
  fu as aS,
  uu as aT,
  _r as aU,
  Bo as aV,
  Oe as aW,
  qa as aX,
  ls as aY,
  ze as aZ,
  eu as a_,
  Eu as aa,
  Au as ab,
  Co as ac,
  Le as ad,
  cs as ae,
  Vi as af,
  Aa as ag,
  tu as ah,
  Pu as ai,
  Ru as aj,
  ku as ak,
  ii as al,
  ni as am,
  bu as an,
  yu as ao,
  gu as ap,
  Xa as aq,
  Et as ar,
  ps as as,
  Ui as at,
  Zo as au,
  ue as av,
  Nt as aw,
  Ya as ax,
  wu as ay,
  pu as az,
  Eo as b,
  zo as b0,
  pt as b1,
  Mu as b2,
  ds as b3,
  We as b4,
  Ba as b5,
  Lu as b6,
  ua as b7,
  du as b8,
  iu as b9,
  Hu as ba,
  Qa as bb,
  ru as bc,
  Fa as bd,
  Vu as be,
  gt as bf,
  Da as bg,
  $a as bh,
  Va as bi,
  _u as bj,
  Nu as bk,
  Ma as bl,
  Ka as bm,
  ja as bn,
  wt as c,
  ci as d,
  fi as e,
  Mt as f,
  ph as g,
  Yr as h,
  To as i,
  wa as j,
  lu as k,
  ga as l,
  cu as m,
  fs as n,
  z as o,
  dh as p,
  la as q,
  No as r,
  dt as s,
  Ho as t,
  it as u,
  ke as v,
  Ae as w,
  $e as x,
  me as y,
  Fe as z
};
