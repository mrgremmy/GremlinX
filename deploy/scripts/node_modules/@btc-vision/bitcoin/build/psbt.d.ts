import type { KeyValue, PsbtGlobalUpdate, PsbtInput, PsbtInputUpdate, PsbtOutputUpdate } from 'bip174';
import { Transaction } from './transaction.js';
import type { Bytes32, MessageHash, PublicKey, Script } from './types.js';
import type { AllScriptType, FinalScriptsFunc, FinalTaprootScriptsFunc, HDSigner, HDSignerAsync, PsbtBaseExtended, PsbtInputExtended, PsbtOptsOptional, PsbtOutputExtended, PsbtTxInput, PsbtTxOutput, Signer, SignerAsync, TaprootHashCheckSigner, ValidateSigFunction } from './psbt/types.js';
export type { TransactionInput, PsbtTxInput, TransactionOutput, PsbtTxOutput, ValidateSigFunction, PsbtBaseExtended, PsbtOptsOptional, PsbtOpts, PsbtInputExtended, PsbtOutputExtended, PsbtOutputExtendedScript, PsbtOutputExtendedAddress, HDSigner, HDSignerAsync, Signer, SignerAsync, TaprootHashCheckSigner, PsbtCacheInterface, TxCacheNumberKey, ScriptType, AllScriptType, GetScriptReturn, FinalScriptsFunc, FinalTaprootScriptsFunc, } from './psbt/types.js';
export { getFinalScripts, prepareFinalScripts };
export { PsbtCache } from './psbt/PsbtCache.js';
export { PsbtSigner } from './psbt/PsbtSigner.js';
export { PsbtFinalizer } from './psbt/PsbtFinalizer.js';
export { PsbtTransaction, transactionFromBuffer } from './psbt/PsbtTransaction.js';
declare function getFinalScripts(inputIndex: number, input: PsbtInput, script: Script, isSegwit: boolean, isP2SH: boolean, isP2WSH: boolean, canRunChecks?: boolean, solution?: Uint8Array[]): {
    finalScriptSig: Script | undefined;
    finalScriptWitness: Uint8Array | undefined;
};
declare function prepareFinalScripts(script: Uint8Array, scriptType: string, partialSig: import('bip174').PartialSig[], isSegwit: boolean, isP2SH: boolean, isP2WSH: boolean, solution?: Uint8Array[]): {
    finalScriptSig: Script | undefined;
    finalScriptWitness: Uint8Array | undefined;
};
/**
 * Psbt class can parse and generate a PSBT binary based off of the BIP174.
 * There are 6 roles that this class fulfills. (Explained in BIP174)
 *
 * Creator: This can be done with `new Psbt()`
 *
 * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
 *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
 *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
 *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
 *   addInput requires hash: Uint8Array | string; and index: number; as attributes
 *   and can also include any attributes that are used in updateInput method.
 *   addOutput requires script: Uint8Array; and value: bigint; and likewise can include
 *   data for updateOutput.
 *   For a list of what attributes should be what types. Check the bip174 library.
 *   Also, check the integration tests for some examples of usage.
 *
 * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
 *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
 *   your info. Or you can explicitly sign a specific input with signInput and
 *   signInputAsync. For the async methods you can create a SignerAsync object
 *   and use something like a hardware wallet to sign with. (You must implement this)
 *
 * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
 *   the psbt calling combine will always have precedence when a conflict occurs.
 *   Combine checks if the internal bitcoin transaction is the same, so be sure that
 *   all sequences, version, locktime, etc. are the same before combining.
 *
 * Input Finalizer: This role is fairly important. Not only does it need to construct
 *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
 *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
 *   Running any finalize method will delete any data in the input(s) that are no longer
 *   needed due to the finalized scripts containing the information.
 *
 * Transaction Extractor: This role will perform some checks before returning a
 *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
 */
export declare class Psbt {
    #private;
    data: PsbtBaseExtended;
    constructor(opts?: PsbtOptsOptional, data?: PsbtBaseExtended);
    get inputCount(): number;
    get version(): number;
    set version(version: number);
    get locktime(): number;
    set locktime(locktime: number);
    get txInputs(): PsbtTxInput[];
    get txOutputs(): PsbtTxOutput[];
    static fromBase64(data: string, opts?: PsbtOptsOptional): Psbt;
    static fromHex(data: string, opts?: PsbtOptsOptional): Psbt;
    static fromBuffer(buffer: Uint8Array, opts?: PsbtOptsOptional): Psbt;
    combine(...those: Psbt[]): this;
    clone(): Psbt;
    get maximumFeeRate(): number;
    setMaximumFeeRate(satoshiPerByte: number): void;
    setVersion(version: number): this;
    setVersionTRUC(): this;
    setLocktime(locktime: number): this;
    setInputSequence(inputIndex: number, sequence: number): this;
    addInputs(inputDatas: PsbtInputExtended[], checkPartialSigs?: boolean): this;
    addInput(inputData: PsbtInputExtended, checkPartialSigs?: boolean): this;
    addOutputs(outputDatas: PsbtOutputExtended[], checkPartialSigs?: boolean): this;
    addOutput(outputData: PsbtOutputExtended, checkPartialSigs?: boolean): this;
    extractTransaction(disableFeeCheck?: boolean, disableOutputChecks?: boolean): Transaction;
    getFeeRate(disableOutputChecks?: boolean): number;
    getFee(disableOutputChecks?: boolean): number;
    finalizeAllInputs(): this;
    finalizeInput(inputIndex: number, finalScriptsFunc?: FinalScriptsFunc | FinalTaprootScriptsFunc, canRunChecks?: boolean): this;
    finalizeTaprootInput(inputIndex: number, tapLeafHashToFinalize?: Bytes32, finalScriptsFunc?: FinalTaprootScriptsFunc): this;
    getInputType(inputIndex: number): AllScriptType;
    inputHasPubkey(inputIndex: number, pubkey: PublicKey): boolean;
    inputHasHDKey(inputIndex: number, root: HDSigner): boolean;
    outputHasPubkey(outputIndex: number, pubkey: PublicKey): boolean;
    outputHasHDKey(outputIndex: number, root: HDSigner): boolean;
    validateSignaturesOfAllInputs(validator: ValidateSigFunction): boolean;
    validateSignaturesOfInput(inputIndex: number, validator: ValidateSigFunction, pubkey?: PublicKey): boolean;
    signAllInputsHD(hdKeyPair: HDSigner, sighashTypes?: number[]): this;
    signAllInputsHDAsync(hdKeyPair: HDSigner | HDSignerAsync, sighashTypes?: number[]): Promise<void>;
    signInputHD(inputIndex: number, hdKeyPair: HDSigner, sighashTypes?: number[]): this;
    signInputHDAsync(inputIndex: number, hdKeyPair: HDSigner | HDSignerAsync, sighashTypes?: number[]): Promise<void>;
    signAllInputs(keyPair: Signer | HDSigner, sighashTypes?: number[]): this;
    signAllInputsAsync(keyPair: Signer | SignerAsync | HDSigner | HDSignerAsync, sighashTypes?: number[]): Promise<void>;
    signInput(inputIndex: number, keyPair: Signer | HDSigner, sighashTypes?: number[]): this;
    signTaprootInput(inputIndex: number, keyPair: Signer | HDSigner, tapLeafHashToSign?: Uint8Array, sighashTypes?: number[]): this;
    signInputAsync(inputIndex: number, keyPair: Signer | SignerAsync | HDSigner | HDSignerAsync, sighashTypes?: number[]): Promise<void>;
    signTaprootInputAsync(inputIndex: number, keyPair: Signer | SignerAsync | HDSigner | HDSignerAsync, tapLeafHash?: Uint8Array, sighashTypes?: number[]): Promise<void>;
    toBuffer(): Uint8Array;
    toHex(): string;
    toBase64(): string;
    updateGlobal(updateData: PsbtGlobalUpdate): this;
    updateInput(inputIndex: number, updateData: PsbtInputUpdate): this;
    updateOutput(outputIndex: number, updateData: PsbtOutputUpdate): this;
    addUnknownKeyValToGlobal(keyVal: KeyValue): this;
    addUnknownKeyValToInput(inputIndex: number, keyVal: KeyValue): this;
    addUnknownKeyValToOutput(outputIndex: number, keyVal: KeyValue): this;
    clearFinalizedInput(inputIndex: number): this;
    checkTaprootHashesForSig(inputIndex: number, input: PsbtInput, keyPair: Signer | SignerAsync | HDSigner | HDSignerAsync | TaprootHashCheckSigner, tapLeafHashToSign?: Uint8Array, allowedSighashTypes?: number[]): {
        hash: MessageHash;
        leafHash?: Bytes32;
    }[];
}
//# sourceMappingURL=psbt.d.ts.map