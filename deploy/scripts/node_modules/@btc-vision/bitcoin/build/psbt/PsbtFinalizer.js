import { equals } from '../io/index.js';
import * as payments from '../payments/index.js';
import { witnessStackToScriptWitness } from './psbtutils.js';
import { classifyScript, compressPubkey } from './utils.js';
/**
 * Class wrapping all finalization logic for PSBT.
 */
export class PsbtFinalizer {
    #cache;
    #txFromBuffer;
    constructor(cache, txFromBuffer) {
        this.#cache = cache;
        this.#txFromBuffer = txFromBuffer;
    }
    getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
        const scriptType = classifyScript(script);
        if (!canFinalize(input, script, scriptType) && canRunChecks) {
            throw new Error(`Can not finalize input #${inputIndex}`);
        }
        if (!input.partialSig)
            throw new Error('Input missing partial signatures');
        return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH, solution);
    }
    getScriptFromInput(inputIndex, input) {
        return this.#cache.getScriptFromInput(inputIndex, input, this.#txFromBuffer);
    }
}
export function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
    const scriptType = classifyScript(script);
    if (!canFinalize(input, script, scriptType) && canRunChecks) {
        throw new Error(`Can not finalize input #${inputIndex}`);
    }
    if (!input.partialSig)
        throw new Error('Input missing partial signatures');
    return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH, solution);
}
export function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH, solution) {
    let finalScriptSig;
    let finalScriptWitness;
    const payment = getPayment(script, scriptType, partialSig);
    const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
    const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
    if (isSegwit) {
        if (p2wsh && p2wsh.witness) {
            finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);
        }
        else if (payment && payment.witness) {
            finalScriptWitness = witnessStackToScriptWitness(payment.witness);
        }
        else {
            finalScriptWitness = witnessStackToScriptWitness(solution ?? [new Uint8Array([0x00])]);
        }
        if (p2sh) {
            finalScriptSig = p2sh?.input;
        }
    }
    else {
        if (p2sh) {
            finalScriptSig = p2sh?.input;
        }
        else {
            if (!payment) {
                finalScriptSig = (Array.isArray(solution) && solution[0] ? solution[0] : new Uint8Array([0x01]));
            }
            else {
                finalScriptSig = payment.input;
            }
        }
    }
    return { finalScriptSig, finalScriptWitness };
}
function canFinalize(input, script, scriptType) {
    switch (scriptType) {
        case 'pubkey':
        case 'pubkeyhash':
        case 'witnesspubkeyhash':
            return hasSigs(1, input.partialSig);
        case 'multisig': {
            const p2ms = payments.p2ms({
                output: script,
            });
            if (p2ms.m === undefined)
                throw new Error('Cannot determine m for multisig');
            return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
        }
        case 'nonstandard':
            return true;
        default:
            return false;
    }
}
function hasSigs(neededSigs, partialSig, pubkeys) {
    if (!partialSig)
        return false;
    let sigs;
    if (pubkeys) {
        sigs = pubkeys
            .map((pkey) => {
            const pubkey = compressPubkey(pkey);
            return partialSig.find((pSig) => equals(pSig.pubkey, pubkey));
        })
            .filter((v) => !!v);
    }
    else {
        sigs = partialSig;
    }
    if (sigs.length > neededSigs)
        throw new Error('Too many signatures');
    return sigs.length === neededSigs;
}
function getPayment(script, scriptType, partialSig) {
    const scriptBranded = script;
    switch (scriptType) {
        case 'multisig': {
            const sigs = getSortedSigs(script, partialSig);
            return payments.p2ms({
                output: scriptBranded,
                signatures: sigs,
            });
        }
        case 'pubkey': {
            const sig0 = partialSig[0];
            return payments.p2pk({
                output: scriptBranded,
                signature: sig0.signature,
            });
        }
        case 'pubkeyhash': {
            const sig0 = partialSig[0];
            return payments.p2pkh({
                output: scriptBranded,
                pubkey: sig0.pubkey,
                signature: sig0.signature,
            });
        }
        case 'witnesspubkeyhash': {
            const sig0 = partialSig[0];
            return payments.p2wpkh({
                output: scriptBranded,
                pubkey: sig0.pubkey,
                signature: sig0.signature,
            });
        }
        default:
            throw new Error(`Unknown script type: ${scriptType}`);
    }
}
function getSortedSigs(script, partialSig) {
    const p2ms = payments.p2ms({ output: script });
    if (!p2ms.pubkeys)
        throw new Error('Cannot extract pubkeys from multisig script');
    const result = [];
    for (const pk of p2ms.pubkeys) {
        const matched = partialSig.filter((ps) => {
            return equals(ps.pubkey, pk);
        })[0];
        if (matched) {
            result.push(new Uint8Array(matched.signature));
        }
    }
    return result;
}
//# sourceMappingURL=PsbtFinalizer.js.map