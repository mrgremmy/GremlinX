import type { Bytes32, MessageHash, Satoshi, Script } from './types.js';
/**
 * Cache for Taproot sighash intermediate values.
 * These are identical for all inputs with SIGHASH_ALL, so compute once and reuse.
 */
export interface TaprootHashCache {
    readonly hashPrevouts: Bytes32;
    readonly hashAmounts: Bytes32;
    readonly hashScriptPubKeys: Bytes32;
    readonly hashSequences: Bytes32;
    readonly hashOutputs: Bytes32;
}
export interface Output {
    readonly script: Script;
    readonly value: Satoshi;
}
export interface Input {
    readonly hash: Bytes32;
    readonly index: number;
    script: Script;
    sequence: number;
    witness: Uint8Array[];
}
/**
 * Represents a Bitcoin transaction.
 *
 * @example
 * ```typescript
 * import { Transaction, fromHex } from '@btc-vision/bitcoin';
 *
 * // Parse a transaction from hex
 * const tx = Transaction.fromHex('0100000001...');
 *
 * // Create a new transaction
 * const newTx = new Transaction();
 * newTx.version = 2;
 * newTx.addInput(prevTxHash, 0);
 * newTx.addOutput(scriptPubKey, 50000n);
 * ```
 */
export declare class Transaction {
    #private;
    static readonly DEFAULT_SEQUENCE = 4294967295;
    static readonly SIGHASH_DEFAULT = 0;
    static readonly SIGHASH_ALL = 1;
    static readonly SIGHASH_NONE = 2;
    static readonly SIGHASH_SINGLE = 3;
    static readonly SIGHASH_ANYONECANPAY = 128;
    static readonly SIGHASH_OUTPUT_MASK = 3;
    static readonly SIGHASH_INPUT_MASK = 128;
    static readonly ADVANCED_TRANSACTION_MARKER = 0;
    static readonly ADVANCED_TRANSACTION_FLAG = 1;
    static readonly TRUC_VERSION = 3;
    static readonly TRUC_MAX_VSIZE = 10000;
    static readonly TRUC_CHILD_MAX_VSIZE = 1000;
    version: number;
    locktime: number;
    ins: Input[];
    outs: Output[];
    /**
     * Parse a transaction from a Uint8Array buffer.
     *
     * @param buffer - The raw transaction bytes
     * @param _NO_STRICT - If true, allow extra data after transaction
     * @returns Parsed Transaction instance
     */
    static fromBuffer(buffer: Uint8Array, _NO_STRICT?: boolean): Transaction;
    /**
     * Parse a transaction from a hex string.
     *
     * @param hex - The transaction as a hex string
     * @returns Parsed Transaction instance
     */
    static fromHex(hex: string): Transaction;
    /**
     * Check if a hash is a coinbase hash (all zeros).
     *
     * @param hash - 32-byte hash to check
     * @returns true if hash is all zeros (coinbase)
     */
    static isCoinbaseHash(hash: Bytes32): boolean;
    isCoinbase(): boolean;
    /**
     * Add an input to this transaction.
     *
     * @param hash - 32-byte hash of the previous transaction
     * @param index - Output index in the previous transaction
     * @param sequence - Sequence number (defaults to 0xffffffff)
     * @param scriptSig - Input script (defaults to empty)
     * @returns The index of the newly added input
     */
    addInput(hash: Bytes32, index: number, sequence?: number, scriptSig?: Script): number;
    /**
     * Add an output to this transaction.
     *
     * @param scriptPubKey - Output script (locking script)
     * @param value - Output value in satoshis (bigint)
     * @returns The index of the newly added output
     */
    addOutput(scriptPubKey: Script, value: Satoshi): number;
    hasWitnesses(): boolean;
    weight(): number;
    virtualSize(): number;
    byteLength(_ALLOW_WITNESS?: boolean): number;
    clone(): Transaction;
    /**
     * Hash transaction for signing a specific input.
     *
     * Bitcoin uses a different hash for each signed transaction input.
     * This method copies the transaction, makes the necessary changes based on the
     * hashType, and then hashes the result.
     * This hash can then be used to sign the provided transaction input.
     *
     * @param inIndex - Index of the input being signed
     * @param prevOutScript - The script of the output being spent
     * @param hashType - Signature hash type
     * @returns 32-byte hash for signing
     */
    hashForSignature(inIndex: number, prevOutScript: Script, hashType: number): MessageHash;
    /**
     * Hash transaction for signing a Taproot (witness v1) input.
     *
     * @param inIndex - Index of the input being signed
     * @param prevOutScripts - Scripts of all inputs being spent
     * @param values - Values of all inputs being spent (bigint satoshis)
     * @param hashType - Signature hash type
     * @param leafHash - Optional leaf hash for script path spending
     * @param annex - Optional annex data
     * @returns 32-byte hash for signing
     */
    hashForWitnessV1(inIndex: number, prevOutScripts: readonly Script[], values: readonly Satoshi[], hashType: number, leafHash?: Bytes32, annex?: Uint8Array, taprootCache?: TaprootHashCache): MessageHash;
    /**
     * Pre-compute intermediate hashes for Taproot signing.
     * Call this once before signing multiple inputs to avoid O(n^2) performance.
     *
     * @param prevOutScripts - Array of previous output scripts for all inputs
     * @param values - Array of previous output values for all inputs
     * @returns Cache object to pass to hashForWitnessV1
     */
    getTaprootHashCache(prevOutScripts: readonly Script[], values: readonly Satoshi[]): TaprootHashCache;
    /**
     * Hash transaction for signing a SegWit v0 (P2WPKH/P2WSH) input.
     *
     * @param inIndex - Index of the input being signed
     * @param prevOutScript - The script of the output being spent
     * @param value - Value of the output being spent (bigint satoshis)
     * @param hashType - Signature hash type
     * @returns 32-byte hash for signing
     */
    hashForWitnessV0(inIndex: number, prevOutScript: Script, value: Satoshi, hashType: number): MessageHash;
    /**
     * Get the transaction hash.
     *
     * @param forWitness - If true, include witness data (wtxid)
     * @returns 32-byte transaction hash
     */
    getHash(forWitness?: boolean): Bytes32;
    /**
     * Get the transaction ID (txid) as a hex string.
     *
     * @returns Transaction ID in reversed hex format
     */
    getId(): string;
    /**
     * Serialize the transaction to a Uint8Array buffer.
     *
     * @param buffer - Optional pre-allocated buffer
     * @param initialOffset - Optional starting offset in buffer
     * @returns Serialized transaction bytes
     */
    toBuffer(buffer?: Uint8Array, initialOffset?: number): Uint8Array;
    /**
     * Serialize the transaction to a hex string.
     *
     * @returns Transaction as hex string
     */
    toHex(): string;
    /**
     * Set the input script for a specific input.
     *
     * @param index - Input index
     * @param scriptSig - The script to set
     */
    setInputScript(index: number, scriptSig: Script): void;
    /**
     * Set the witness data for a specific input.
     *
     * @param index - Input index
     * @param witness - Array of witness elements
     */
    setWitness(index: number, witness: Uint8Array[]): void;
}
//# sourceMappingURL=transaction.d.ts.map