/**
 * Worklet-based parallel signing pool for React Native.
 *
 * Uses `react-native-worklets` (Software Mansion v0.7+) to run signing
 * operations in parallel across multiple worklet runtimes.
 * Each runtime gets its own ECC module instance via eval of the bundled
 * @noble/secp256k1 IIFE string.
 *
 * SECURITY ARCHITECTURE:
 * - Private keys are cloned per-runtime (structuredClone semantics)
 * - Keys are zeroed inside worklet AND in main thread finally block
 * - Tainted runtimes (timeout) are replaced, not reused
 *
 * @packageDocumentation
 */
import { SignatureType } from './types.js';
/**
 * Default configuration for the worklet pool.
 */
const DEFAULT_CONFIG = {
    workerCount: 4,
    taskTimeoutMs: 30000,
    maxKeyHoldTimeMs: 5000,
    verifySignatures: true,
    preserveWorkers: false,
};
/**
 * Worklet-based parallel signing pool for React Native.
 *
 * Mirrors the API of WorkerSigningPool (browser) but uses
 * `react-native-worklets` runtimes instead of Web Workers.
 * `runOnRuntime()` returns a Promise directly — no postMessage protocol.
 *
 * @example
 * ```typescript
 * import { WorkletSigningPool } from '@btc-vision/bitcoin/workers';
 *
 * const pool = WorkletSigningPool.getInstance();
 * pool.preserveWorkers();
 *
 * const result = await pool.signBatch(tasks, keyPair);
 * await pool.shutdown();
 * ```
 */
export class WorkletSigningPool {
    static #instance = null;
    #config;
    #runtimes = [];
    #workletsModule = null;
    #eccBundleCode = null;
    #preserveWorkers = false;
    #nextRuntimeId = 0;
    #initialized = false;
    #shuttingDown = false;
    /**
     * Whether Uint8Array survives worklet boundary.
     * Detected during initialize(); if false, we encode as number[].
     */
    #uint8ArraySupported = true;
    constructor(config = {}) {
        this.#config = { ...DEFAULT_CONFIG, ...config };
        this.#preserveWorkers = this.#config.preserveWorkers;
    }
    /** Number of active runtimes. */
    get workerCount() {
        return this.#runtimes.length;
    }
    /** Idle runtimes (all non-tainted). */
    get idleWorkerCount() {
        return this.#runtimes.filter((r) => !r.tainted).length;
    }
    /** Busy runtimes — always 0 outside of signBatch. */
    get busyWorkerCount() {
        return 0;
    }
    /** Whether runtimes are preserved between batches. */
    get isPreservingWorkers() {
        return this.#preserveWorkers;
    }
    /**
     * Gets the singleton pool instance.
     *
     * @param config - Optional configuration (only used on first call)
     */
    static getInstance(config) {
        if (!WorkletSigningPool.#instance) {
            WorkletSigningPool.#instance = new WorkletSigningPool(config);
        }
        return WorkletSigningPool.#instance;
    }
    /** Resets the singleton instance (for testing). */
    static resetInstance() {
        if (WorkletSigningPool.#instance) {
            WorkletSigningPool.#instance.shutdown().catch(() => { });
            WorkletSigningPool.#instance = null;
        }
    }
    /** Enable runtime preservation between signing batches. */
    preserveWorkers() {
        this.#preserveWorkers = true;
    }
    /** Disable runtime preservation. */
    releaseWorkers() {
        this.#preserveWorkers = false;
    }
    /**
     * Initializes the worklet pool.
     *
     * Dynamically imports `react-native-worklets`, creates N runtimes,
     * and injects the ECC bundle into each via eval.
     *
     * @throws If `react-native-worklets` is not installed or eval fails
     */
    async initialize() {
        if (this.#initialized) {
            return;
        }
        if (this.#shuttingDown) {
            throw new Error('Cannot initialize pool while shutting down');
        }
        // Lazy dynamic import — module loads even without the dep
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const worklets = await import('react-native-worklets');
        this.#workletsModule = worklets;
        // Load ECC bundle
        const { ECC_BUNDLE } = await import('./ecc-bundle.js');
        this.#eccBundleCode = ECC_BUNDLE;
        // Create runtimes and inject ECC
        for (let i = 0; i < this.#config.workerCount; i++) {
            await this.#createRuntime();
        }
        // Feature-detect Uint8Array support across worklet boundary
        const firstRuntime = this.#runtimes[0];
        if (firstRuntime) {
            try {
                const result = await this.#workletsModule.runOnRuntime(firstRuntime.runtime, () => {
                    const arr = new Uint8Array([1, 2, 3]);
                    return arr instanceof Uint8Array;
                });
                this.#uint8ArraySupported = result;
            }
            catch {
                this.#uint8ArraySupported = false;
            }
        }
        this.#initialized = true;
    }
    /**
     * Signs a batch of tasks in parallel across worklet runtimes.
     *
     * SECURITY: Private keys are cloned per-runtime and zeroed both
     * inside the worklet and in the main thread finally block.
     */
    async signBatch(tasks, keyPair) {
        const startTime = performance.now();
        if (!this.#initialized) {
            await this.initialize();
        }
        if (tasks.length === 0) {
            return {
                success: true,
                signatures: new Map(),
                errors: new Map(),
                durationMs: performance.now() - startTime,
            };
        }
        // Distribute tasks round-robin
        const runtimeCount = Math.min(this.#runtimes.length, tasks.length);
        const taskBatches = Array.from({ length: runtimeCount }, () => []);
        for (let i = 0; i < tasks.length; i++) {
            const batch = taskBatches[i % runtimeCount];
            const task = tasks[i];
            if (batch && task) {
                batch.push(task);
            }
        }
        const privateKey = keyPair.getPrivateKey();
        try {
            const batchResults = await Promise.allSettled(taskBatches.map((batch, index) => this.#signBatchOnRuntime(batch, privateKey, keyPair.publicKey, index)));
            const signatures = new Map();
            const errors = new Map();
            for (let i = 0; i < batchResults.length; i++) {
                const result = batchResults[i];
                if (!result)
                    continue;
                if (result.status === 'fulfilled') {
                    for (const sig of result.value.signatures) {
                        signatures.set(sig.inputIndex, sig);
                    }
                    for (const [idx, errMsg] of result.value.errors) {
                        errors.set(idx, errMsg);
                    }
                }
                else {
                    const reason = result.reason;
                    const errorMsg = reason?.message ?? 'Worklet batch signing failed';
                    const failedBatch = taskBatches[i];
                    if (failedBatch) {
                        for (const task of failedBatch) {
                            errors.set(task.inputIndex, errorMsg);
                        }
                    }
                }
            }
            // Cleanup runtimes if not preserving
            if (!this.#preserveWorkers) {
                await this.shutdown();
            }
            return {
                success: errors.size === 0,
                signatures,
                errors,
                durationMs: performance.now() - startTime,
            };
        }
        finally {
            // SECURITY: Zero the key in main thread
            privateKey.fill(0);
        }
    }
    /** Shuts down all runtimes. */
    // eslint-disable-next-line @typescript-eslint/require-await
    async shutdown() {
        if (this.#shuttingDown) {
            return;
        }
        this.#shuttingDown = true;
        // Worklet runtimes don't have a destroy() — clear references for GC
        this.#runtimes.length = 0;
        this.#workletsModule = null;
        this.#eccBundleCode = null;
        this.#initialized = false;
        this.#shuttingDown = false;
    }
    [Symbol.dispose]() {
        void this.shutdown();
    }
    async [Symbol.asyncDispose]() {
        await this.shutdown();
    }
    /**
     * Creates a new worklet runtime and injects the ECC bundle.
     */
    async #createRuntime() {
        if (!this.#workletsModule || !this.#eccBundleCode) {
            throw new Error('Worklets module or ECC bundle not loaded');
        }
        const id = this.#nextRuntimeId++;
        const runtime = this.#workletsModule.createWorkletRuntime(`signing-runtime-${id}`);
        // Inject ECC bundle into the worklet runtime.
        // The bundle declares `var nobleBundle = (()=>{...})()` with "use strict",
        // so a plain eval won't leak it to globalThis. We use `new Function` to
        // execute the bundle and then explicitly assign the result.
        const bundleCode = this.#eccBundleCode;
        await this.#workletsModule.runOnRuntime(runtime, () => {
            'worklet';
            // eslint-disable-next-line @typescript-eslint/no-implied-eval
            const fn = new Function(bundleCode + '; return nobleBundle;');
            globalThis['nobleBundle'] = fn();
        });
        const pooled = { id, runtime, tainted: false };
        this.#runtimes.push(pooled);
        return pooled;
    }
    /**
     * Replaces a tainted runtime with a fresh one.
     */
    async #replaceRuntime(pooled) {
        const idx = this.#runtimes.indexOf(pooled);
        if (idx >= 0) {
            this.#runtimes.splice(idx, 1);
        }
        try {
            await this.#createRuntime();
        }
        catch {
            // If replacement fails, pool continues with fewer runtimes
        }
    }
    /**
     * Signs a batch of tasks on a specific runtime.
     */
    async #signBatchOnRuntime(tasks, privateKey, publicKey, runtimeIndex) {
        if (tasks.length === 0) {
            return { signatures: [], errors: new Map() };
        }
        const pooled = this.#runtimes[runtimeIndex];
        if (!pooled || pooled.tainted) {
            throw new Error(`Runtime ${runtimeIndex} unavailable or tainted`);
        }
        if (!this.#workletsModule) {
            throw new Error('Worklets module not loaded');
        }
        // Prepare data for worklet transfer
        const useArrayEncoding = !this.#uint8ArraySupported;
        const keyData = useArrayEncoding
            ? Array.from(privateKey)
            : new Uint8Array(privateKey);
        const taskData = tasks.map((t) => ({
            taskId: t.taskId,
            inputIndex: t.inputIndex,
            hash: useArrayEncoding ? Array.from(t.hash) : new Uint8Array(t.hash),
            signatureType: t.signatureType,
            lowR: t.lowR,
            sighashType: t.sighashType,
            leafHash: t.leafHash
                ? (useArrayEncoding ? Array.from(t.leafHash) : new Uint8Array(t.leafHash))
                : undefined,
        }));
        const pubKeyData = useArrayEncoding
            ? Array.from(publicKey)
            : new Uint8Array(publicKey);
        // Dispatch to worklet runtime with timeout
        const signingPromise = this.#workletsModule.runOnRuntime(pooled.runtime, () => {
            'worklet';
            // Inside the worklet runtime, nobleBundle is available from init eval
            // The bundled secp.sign() returns a compact 64-byte Uint8Array directly
            // (not a Signature object). secp.schnorr.sign() also returns Uint8Array.
            const eccModule = globalThis['nobleBundle'];
            const toU8 = (data) => data instanceof Uint8Array ? data : new Uint8Array(data);
            const privKey = toU8(keyData);
            const results = [];
            const errors = [];
            try {
                for (const task of taskData) {
                    try {
                        const hash = toU8(task.hash);
                        let signature;
                        if (task.signatureType === 1) {
                            signature = eccModule.secp.schnorr.sign(hash, privKey);
                        }
                        else {
                            // prehash: false — input is already a 32-byte hash
                            signature = eccModule.secp.sign(hash, privKey, {
                                lowS: true,
                                prehash: false,
                            });
                        }
                        const entry = {
                            type: 'result',
                            taskId: task.taskId,
                            signature: Array.from(signature),
                            inputIndex: task.inputIndex,
                            publicKey: Array.from(toU8(pubKeyData)),
                            signatureType: task.signatureType,
                        };
                        if (task.leafHash) {
                            entry.leafHash = Array.from(toU8(task.leafHash));
                        }
                        results.push(entry);
                    }
                    catch (err) {
                        const msg = err instanceof Error ? err.message : 'Signing failed';
                        errors.push({ inputIndex: task.inputIndex, error: msg });
                    }
                }
            }
            finally {
                // SECURITY: Zero key inside worklet
                privKey.fill(0);
            }
            return { results, errors };
        });
        // Timeout guard
        const timeoutPromise = new Promise((_resolve, reject) => {
            setTimeout(() => {
                pooled.tainted = true;
                this.#replaceRuntime(pooled).catch(() => { });
                reject(new Error(`Worklet signing timeout for ${tasks.length} tasks`));
            }, this.#config.maxKeyHoldTimeMs);
        });
        const raw = await Promise.race([signingPromise, timeoutPromise]);
        // Convert results back to proper types
        const signatures = raw.results.map((r) => ({
            type: 'result',
            taskId: r.taskId,
            signature: new Uint8Array(r.signature),
            inputIndex: r.inputIndex,
            publicKey: new Uint8Array(r.publicKey),
            signatureType: r.signatureType,
            leafHash: r.leafHash ? new Uint8Array(r.leafHash) : undefined,
        }));
        const errors = new Map();
        for (const e of raw.errors) {
            errors.set(e.inputIndex, e.error);
        }
        return { signatures, errors };
    }
}
//# sourceMappingURL=WorkerSigningPool.worklet.js.map