/**
 * Bundled @noble/secp256k1 + hashes for worker embedding.
 *
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: scripts/bundle-ecc.ts
 *
 * This embeds the entire @noble/secp256k1 library with sha256/hmac
 * as an IIFE string that can be executed in a Web Worker without network requests.
 *
 * @packageDocumentation
 */
/**
 * Bundled @noble/secp256k1 + hashes library as an IIFE string.
 *
 * When executed, this creates a global `nobleBundle` object with:
 * - secp: The full @noble/secp256k1 module (with hashes configured)
 * - sha256: The sha256 hash function
 * - hmac: The hmac function
 */
export declare const ECC_BUNDLE = "\"use strict\";var nobleBundle=(()=>{var rt=Object.defineProperty;var _e=Object.getOwnPropertyDescriptor;var Ce=Object.getOwnPropertyNames;var ke=Object.prototype.hasOwnProperty;var Ve=(e,t,n)=>t in e?rt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var Ct=(e,t)=>{for(var n in t)rt(e,n,{get:t[n],enumerable:!0})},Te=(e,t,n,s)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let r of Ce(t))!ke.call(e,r)&&r!==n&&rt(e,r,{get:()=>t[r],enumerable:!(s=_e(t,r))||s.enumerable});return e};var Ge=e=>Te(rt({},\"__esModule\",{value:!0}),e);var l=(e,t,n)=>Ve(e,typeof t!=\"symbol\"?t+\"\":t,n);var yn={};Ct(yn,{hmac:()=>lt,secp:()=>Lt,sha256:()=>ht});var Lt={};Ct(Lt,{Point:()=>U,Signature:()=>R,etc:()=>sn,getPublicKey:()=>Pt,getSharedSecret:()=>en,hash:()=>je,hashes:()=>K,keygen:()=>nn,recoverPublicKey:()=>Qe,recoverPublicKeyAsync:()=>tn,schnorr:()=>un,sign:()=>We,signAsync:()=>ze,utils:()=>rn,verify:()=>qe,verifyAsync:()=>Je});var Nt={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:D,n:v,Gx:Fe,Gy:De,b:Zt}=Nt,w=32,Z=64,et={publicKey:w+1,publicKeyUncompressed:Z+1,signature:Z,seed:w+w/2},Ke=(...e)=>{\"captureStackTrace\"in Error&&typeof Error.captureStackTrace==\"function\"&&Error.captureStackTrace(...e)},b=(e=\"\")=>{let t=new Error(e);throw Ke(t,b),t},Oe=e=>typeof e==\"bigint\",Ne=e=>typeof e==\"string\",Ze=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name===\"Uint8Array\",A=(e,t,n=\"\")=>{let s=Ze(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`\"${n}\" `,i=o?` of length ${t}`:\"\",u=s?`length=${r}`:`type=${typeof e}`;b(c+\"expected Uint8Array\"+i+\", got \"+u)}return e},k=e=>new Uint8Array(e),jt=(e,t)=>e.toString(16).padStart(t,\"0\"),wt=e=>Array.from(A(e)).map(t=>jt(t,2)).join(\"\"),V={_0:48,_9:57,A:65,F:70,a:97,f:102},kt=e=>{if(e>=V._0&&e<=V._9)return e-V._0;if(e>=V.A&&e<=V.F)return e-(V.A-10);if(e>=V.a&&e<=V.f)return e-(V.a-10)},mt=e=>{let t=\"hex invalid\";if(!Ne(e))return b(t);let n=e.length,s=n/2;if(n%2)return b(t);let r=k(s);for(let o=0,c=0;o<s;o++,c+=2){let i=kt(e.charCodeAt(c)),u=kt(e.charCodeAt(c+1));if(i===void 0||u===void 0)return b(t);r[o]=i*16+u}return r},Rt=()=>globalThis?.crypto,Vt=()=>Rt()?.subtle??b(\"crypto.subtle must be defined, consider polyfill\"),L=(...e)=>{let t=k(e.reduce((s,r)=>s+A(r).length,0)),n=0;return e.forEach(s=>{t.set(s,n),n+=s.length}),t},nt=(e=w)=>Rt().getRandomValues(k(e)),Y=BigInt,j=(e,t,n,s=\"bad number: out of range\")=>Oe(e)&&t<=e&&e<n?e:b(s),a=(e,t=D)=>{let n=e%t;return n>=0n?n:t+n},E=e=>a(e,v),st=(e,t)=>{(e===0n||t<=0n)&&b(\"no inverse n=\"+e+\" mod=\"+t);let n=a(e,t),s=t,r=0n,o=1n,c=1n,i=0n;for(;n!==0n;){let u=s/n,d=s%n,f=r-c*u,h=o-i*u;s=n,n=d,r=c,o=i,c=f,i=h}return s===1n?a(r,t):b(\"no inverse\")},it=e=>{let t=K[e];return typeof t!=\"function\"&&b(\"hashes.\"+e+\" not set\"),t},je=e=>it(\"sha256\")(e),xt=e=>e instanceof U?e:b(\"Point expected\"),Xt=e=>a(a(e*e)*e+Zt),Tt=e=>j(e,0n,D),tt=e=>j(e,1n,D),bt=e=>j(e,1n,v),M=e=>(e&1n)===0n,ft=e=>Uint8Array.of(e),Yt=e=>ft(M(e)?2:3),Mt=e=>{let t=Xt(tt(e)),n=1n;for(let s=t,r=(D+1n)/4n;r>0n;r>>=1n)r&1n&&(n=n*s%D),s=s*s%D;return a(n*n)===t?n:b(\"sqrt invalid\")},C=class C{constructor(t,n,s){l(this,\"X\");l(this,\"Y\");l(this,\"Z\");this.X=Tt(t),this.Y=tt(n),this.Z=Tt(s),Object.freeze(this)}static CURVE(){return Nt}static fromAffine(t){let{x:n,y:s}=t;return n===0n&&s===0n?N:new C(n,s,1n)}static fromBytes(t){A(t);let{publicKey:n,publicKeyUncompressed:s}=et,r,o=t.length,c=t[0],i=t.subarray(1),u=P(i,0,w);if(o===n&&(c===2||c===3)){let d=Mt(u),f=M(d);M(Y(c))!==f&&(d=a(-d)),r=new C(u,d,1n)}return o===s&&c===4&&(r=new C(u,P(i,w,Z),1n)),r?r.assertValidity():b(\"bad point: not on curve\")}static fromHex(t){return C.fromBytes(mt(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=a(n*i),d=a(o*r),f=a(s*i),h=a(c*r);return u===d&&f===h}is0(){return this.equals(N)}negate(){return new C(this.X,a(-this.Y),this.Z)}double(){return this.add(this)}add(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=0n,d=Zt,f=0n,h=0n,x=0n,y=a(d*3n),p=a(n*o),g=a(s*c),H=a(r*i),I=a(n+s),m=a(o+c);I=a(I*m),m=a(p+g),I=a(I-m),m=a(n+r);let S=a(o+i);return m=a(m*S),S=a(p+H),m=a(m-S),S=a(s+r),f=a(c+i),S=a(S*f),f=a(g+H),S=a(S-f),x=a(u*m),f=a(y*H),x=a(f+x),f=a(g-x),x=a(g+x),h=a(f*x),g=a(p+p),g=a(g+p),H=a(u*H),m=a(y*m),g=a(g+H),H=a(p-H),H=a(u*H),m=a(m+H),p=a(g*m),h=a(h+p),p=a(S*m),f=a(I*f),f=a(f-p),p=a(I*g),x=a(S*x),x=a(x+p),new C(f,h,x)}subtract(t){return this.add(xt(t).negate())}multiply(t,n=!0){if(!n&&t===0n)return N;if(bt(t),t===1n)return this;if(this.equals(T))return ln(t).p;let s=N,r=T;for(let o=this;t>0n;o=o.double(),t>>=1n)t&1n?s=s.add(o):n&&(r=r.add(o));return s}multiplyUnsafe(t){return this.multiply(t,!1)}toAffine(){let{X:t,Y:n,Z:s}=this;if(this.equals(N))return{x:0n,y:0n};if(s===1n)return{x:t,y:n};let r=st(s,D);return a(s*r)!==1n&&b(\"inverse invalid\"),{x:a(t*r),y:a(n*r)}}assertValidity(){let{x:t,y:n}=this.toAffine();return tt(t),tt(n),a(n*n)===Xt(t)?this:b(\"bad point: not on curve\")}toBytes(t=!0){let{x:n,y:s}=this.assertValidity().toAffine(),r=B(n);return t?L(Yt(s),r):L(ft(4),r,B(s))}toHex(t){return wt(this.toBytes(t))}};l(C,\"BASE\"),l(C,\"ZERO\");var U=C,T=new U(Fe,De,1n),N=new U(0n,1n,0n);U.BASE=T;U.ZERO=N;var At=(e,t,n)=>T.multiply(t,!1).add(e.multiply(n,!1)).assertValidity(),G=e=>Y(\"0x\"+(wt(e)||\"0\")),P=(e,t,n)=>G(e.subarray(t,n)),Re=2n**256n,B=e=>mt(jt(j(e,0n,Re),Z)),W=e=>{let t=G(A(e,w,\"secret key\"));return j(t,1n,v,\"invalid secret key: outside of range\")},Ht=e=>e>v>>1n,Pt=(e,t=!0)=>T.multiply(W(e)).toBytes(t),Xe=e=>{try{return!!W(e)}catch{return!1}},Ye=(e,t)=>{let{publicKey:n,publicKeyUncompressed:s}=et;try{let r=e.length;return t===!0&&r!==n||t===!1&&r!==s?!1:!!U.fromBytes(e)}catch{return!1}},$t=e=>{[0,1,2,3].includes(e)||b(\"recovery id must be valid and present\")},Me=e=>{e!=null&&!Gt.includes(e)&&b(`Signature format must be one of: ${Gt.join(\", \")}`),e===qt&&b('Signature format \"der\" is not supported: switch to noble-curves')},Wt=(e,t=$)=>{Me(t);let n=et.signature,s=n+1,r=`Signature format \"${t}\" expects Uint8Array with length `;t===$&&e.length!==n&&b(r+n),t===ot&&e.length!==s&&b(r+s)},R=class e{constructor(t,n,s){l(this,\"r\");l(this,\"s\");l(this,\"recovery\");this.r=bt(t),this.s=bt(n),s!=null&&(this.recovery=s),Object.freeze(this)}static fromBytes(t,n=$){Wt(t,n);let s;n===ot&&(s=t[0],t=t.subarray(1));let r=P(t,0,w),o=P(t,w,Z);return new e(r,o,s)}addRecoveryBit(t){return new e(this.r,this.s,t)}hasHighS(){return Ht(this.s)}toBytes(t=$){let{r:n,s,recovery:r}=this,o=L(B(n),B(s));return t===ot?($t(r),L(Uint8Array.of(r),o)):o}},zt=e=>{let t=e.length*8-256;t>1024&&b(\"msg invalid\");let n=G(e);return t>0?n>>Y(t):n},St=e=>E(zt(A(e))),$=\"compact\",ot=\"recovered\",qt=\"der\",Gt=[$,ot,qt],Ft={lowS:!0,prehash:!0,format:$,extraEntropy:!1},Dt=\"SHA-256\",K={hmacSha256Async:async(e,t)=>{let n=Vt(),s=\"HMAC\",r=await n.importKey(\"raw\",e,{name:s,hash:{name:Dt}},!1,[\"sign\"]);return k(await n.sign(s,r,t))},hmacSha256:void 0,sha256Async:async e=>k(await Vt().digest(Dt,e)),sha256:void 0},z=(e,t,n)=>(A(e,void 0,\"message\"),t.prehash?n?K.sha256Async(e):it(\"sha256\")(e):e),Jt=k(0),Qt=ft(0),te=ft(1),ee=1e3,ne=\"drbg: tried max amount of iterations\",Pe=(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>it(\"hmacSha256\")(s,L(n,...f)),i=(f=Jt)=>{s=c(Qt,f),n=c(),f.length!==0&&(s=c(te,f),n=c())},u=()=>(r++>=ee&&b(ne),n=c(),n);o(),i(e);let d;for(;!(d=t(u()));)i();return o(),d},$e=async(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>K.hmacSha256Async(s,L(n,...f)),i=async(f=Jt)=>{s=await c(Qt,f),n=await c(),f.length!==0&&(s=await c(te,f),n=await c())},u=async()=>(r++>=ee&&b(ne),n=await c(),n);o(),await i(e);let d;for(;!(d=t(await u()));)await i();return o(),d},se=(e,t,n,s)=>{let{lowS:r,extraEntropy:o}=n,c=B,i=St(e),u=c(i),d=W(t),f=[c(d),u];if(o!=null&&o!==!1){let p=o===!0?nt(w):o;f.push(A(p,void 0,\"extraEntropy\"))}let h=L(...f),x=i;return s(h,p=>{let g=zt(p);if(!(1n<=g&&g<v))return;let H=st(g,v),I=T.multiply(g).toAffine(),m=E(I.x);if(m===0n)return;let S=E(H*E(x+m*d));if(S===0n)return;let vt=(I.x===m?0:2)|Number(I.y&1n),_t=S;return r&&Ht(S)&&(_t=E(-S),vt^=1),new R(m,_t,vt).toBytes(n.format)})},re=(e,t,n,s={})=>{let{lowS:r,format:o}=s;e instanceof R&&b(\"Signature must be in Uint8Array, use .toBytes()\"),Wt(e,o),A(n,void 0,\"publicKey\");try{let{r:c,s:i}=R.fromBytes(e,o),u=St(t),d=U.fromBytes(n);if(r&&Ht(i))return!1;let f=st(i,v),h=E(u*f),x=E(c*f),y=At(d,h,x).toAffine();return E(y.x)===c}catch{return!1}},q=e=>{let t={};return Object.keys(Ft).forEach(n=>{t[n]=e[n]??Ft[n]}),t},We=(e,t,n={})=>(n=q(n),e=z(e,n,!1),se(e,t,n,Pe)),ze=async(e,t,n={})=>(n=q(n),e=await z(e,n,!0),se(e,t,n,$e)),qe=(e,t,n,s={})=>(s=q(s),t=z(t,s,!1),re(e,t,n,s)),Je=async(e,t,n,s={})=>(s=q(s),t=await z(t,s,!0),re(e,t,n,s)),oe=(e,t)=>{let n=R.fromBytes(e,\"recovered\"),{r:s,s:r,recovery:o}=n;$t(o);let c=St(A(t,w)),i=o===2||o===3?s+v:s;tt(i);let u=Yt(Y(o)),d=L(u,B(i)),f=U.fromBytes(d),h=st(i,v),x=E(-c*h),y=E(r*h);return At(f,x,y).toBytes()},Qe=(e,t,n={})=>(t=z(t,q(n),!1),oe(e,t)),tn=async(e,t,n={})=>(t=await z(t,q(n),!0),oe(e,t)),en=(e,t,n=!0)=>U.fromBytes(t).multiply(W(e)).toBytes(n),ce=(e=nt(et.seed))=>{A(e),(e.length<et.seed||e.length>1024)&&b(\"expected 40-1024b\");let t=a(G(e),v-1n);return B(t+1n)},ie=e=>t=>{let n=ce(t);return{secretKey:n,publicKey:e(n)}},nn=ie(Pt),sn={hexToBytes:mt,bytesToHex:wt,concatBytes:L,bytesToNumberBE:G,numberToBytesBE:B,mod:a,invert:st,randomBytes:nt,secretKeyToScalar:W,abytes:A},rn={isValidSecretKey:Xe,isValidPublicKey:Ye,randomSecretKey:ce},fe=e=>Uint8Array.from(\"BIP0340/\"+e,t=>t.charCodeAt(0)),ae=\"aux\",ue=\"nonce\",he=\"challenge\",yt=(e,...t)=>{let n=it(\"sha256\"),s=n(fe(e));return n(L(s,s,...t))},pt=async(e,...t)=>{let n=K.sha256Async,s=await n(fe(e));return await n(L(s,s,...t))},Bt=e=>{let t=W(e),n=T.multiply(t),{x:s,y:r}=n.assertValidity().toAffine(),o=M(r)?t:E(-t),c=B(s);return{d:o,px:c}},Et=e=>E(G(e)),de=(...e)=>Et(yt(he,...e)),le=async(...e)=>Et(await pt(he,...e)),xe=e=>Bt(e).px,on=ie(xe),be=(e,t,n)=>{let{px:s,d:r}=Bt(t);return{m:A(e),px:s,d:r,a:A(n,w)}},ye=e=>{let t=Et(e);t===0n&&b(\"sign failed: k is zero\");let{px:n,d:s}=Bt(B(t));return{rx:n,k:s}},pe=(e,t,n,s)=>L(t,B(E(e+n*s))),ge=\"invalid signature produced\",cn=(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=yt(ae,c),u=B(o^G(i)),d=yt(ue,u,r,s),{rx:f,k:h}=ye(d),x=de(f,r,s),y=pe(h,f,x,o);return me(y,s,r)||b(ge),y},fn=async(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=await pt(ae,c),u=B(o^G(i)),d=await pt(ue,u,r,s),{rx:f,k:h}=ye(d),x=await le(f,r,s),y=pe(h,f,x,o);return await Ae(y,s,r)||b(ge),y},an=(e,t)=>e instanceof Promise?e.then(t):t(e),we=(e,t,n,s)=>{let r=A(e,Z,\"signature\"),o=A(t,void 0,\"message\"),c=A(n,w,\"publicKey\");try{let i=G(c),u=Mt(i),d=M(u)?u:a(-u),f=new U(i,d,1n).assertValidity(),h=B(f.toAffine().x),x=P(r,0,w);j(x,1n,D);let y=P(r,w,Z);j(y,1n,v);let p=L(B(x),h,o);return an(s(p),g=>{let{x:H,y:I}=At(f,y,E(-g)).toAffine();return!(!M(I)||H!==x)})}catch{return!1}},me=(e,t,n)=>we(e,t,n,de),Ae=async(e,t,n)=>we(e,t,n,le),un={keygen:on,getPublicKey:xe,sign:cn,verify:me,signAsync:fn,verifyAsync:Ae},ct=8,hn=256,He=Math.ceil(hn/ct)+1,gt=2**(ct-1),dn=()=>{let e=[],t=T,n=t;for(let s=0;s<He;s++){n=t,e.push(n);for(let r=1;r<gt;r++)n=n.add(t),e.push(n);t=n.double()}return e},Kt,Ot=(e,t)=>{let n=t.negate();return e?n:t},ln=e=>{let t=Kt||(Kt=dn()),n=N,s=T,r=2**ct,o=r,c=Y(r-1),i=Y(ct);for(let u=0;u<He;u++){let d=Number(e&c);e>>=i,d>gt&&(d-=o,e+=1n);let f=u*gt,h=f,x=f+Math.abs(d)-1,y=u%2!==0,p=d<0;d===0?s=s.add(Ot(y,t[h])):n=n.add(Ot(p,t[x]))}return e!==0n&&b(\"invalid wnaf\"),{p:n,f:s}};function xn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name===\"Uint8Array\"}function Se(e,t=\"\"){if(!Number.isSafeInteger(e)||e<0){let n=t&&`\"${t}\" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function J(e,t,n=\"\"){let s=xn(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`\"${n}\" `,i=o?` of length ${t}`:\"\",u=s?`length=${r}`:`type=${typeof e}`;throw new Error(c+\"expected Uint8Array\"+i+\", got \"+u)}return e}function Be(e){if(typeof e!=\"function\"||typeof e.create!=\"function\")throw new Error(\"Hash must wrapped by utils.createHasher\");Se(e.outputLen),Se(e.blockLen)}function Q(e,t=!0){if(e.destroyed)throw new Error(\"Hash instance has been destroyed\");if(t&&e.finished)throw new Error(\"Hash#digest() has already been called\")}function Ee(e,t){J(e,void 0,\"digestInto() output\");let n=t.outputLen;if(e.length<n)throw new Error('\"digestInto() output\" expected to be of length >='+n)}function X(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function at(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function _(e,t){return e<<32-t|e>>>t}function Le(e,t={}){let n=(r,o)=>e(o).update(r).digest(),s=e(void 0);return n.outputLen=s.outputLen,n.blockLen=s.blockLen,n.create=r=>e(r),Object.assign(n,t),Object.freeze(n)}var Ue=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function Ie(e,t,n){return e&t^~e&n}function ve(e,t,n){return e&t^e&n^t&n}var ut=class{constructor(t,n,s,r){l(this,\"blockLen\");l(this,\"outputLen\");l(this,\"padOffset\");l(this,\"isLE\");l(this,\"buffer\");l(this,\"view\");l(this,\"finished\",!1);l(this,\"length\",0);l(this,\"pos\",0);l(this,\"destroyed\",!1);this.blockLen=t,this.outputLen=n,this.padOffset=s,this.isLE=r,this.buffer=new Uint8Array(t),this.view=at(this.buffer)}update(t){Q(this),J(t);let{view:n,buffer:s,blockLen:r}=this,o=t.length;for(let c=0;c<o;){let i=Math.min(r-this.pos,o-c);if(i===r){let u=at(t);for(;r<=o-c;c+=r)this.process(u,c);continue}s.set(t.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Q(this),Ee(t,this),this.finished=!0;let{buffer:n,view:s,blockLen:r,isLE:o}=this,{pos:c}=this;n[c++]=128,X(this.buffer.subarray(c)),this.padOffset>r-c&&(this.process(s,0),c=0);for(let h=c;h<r;h++)n[h]=0;s.setBigUint64(r-8,BigInt(this.length*8),o),this.process(s,0);let i=at(t),u=this.outputLen;if(u%4)throw new Error(\"_sha2: outputLen must be aligned to 32bit\");let d=u/4,f=this.get();if(d>f.length)throw new Error(\"_sha2: outputLen bigger than state\");for(let h=0;h<d;h++)i.setUint32(4*h,f[h],o)}digest(){let{buffer:t,outputLen:n}=this;this.digestInto(t);let s=t.slice(0,n);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:n,buffer:s,length:r,finished:o,destroyed:c,pos:i}=this;return t.destroyed=c,t.finished=o,t.length=r,t.pos=i,r%n&&t.buffer.set(s),t}clone(){return this._cloneInto()}},F=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var bn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),O=new Uint32Array(64),Ut=class extends ut{constructor(t){super(64,t,8,!1)}get(){let{A:t,B:n,C:s,D:r,E:o,F:c,G:i,H:u}=this;return[t,n,s,r,o,c,i,u]}set(t,n,s,r,o,c,i,u){this.A=t|0,this.B=n|0,this.C=s|0,this.D=r|0,this.E=o|0,this.F=c|0,this.G=i|0,this.H=u|0}process(t,n){for(let h=0;h<16;h++,n+=4)O[h]=t.getUint32(n,!1);for(let h=16;h<64;h++){let x=O[h-15],y=O[h-2],p=_(x,7)^_(x,18)^x>>>3,g=_(y,17)^_(y,19)^y>>>10;O[h]=g+O[h-7]+p+O[h-16]|0}let{A:s,B:r,C:o,D:c,E:i,F:u,G:d,H:f}=this;for(let h=0;h<64;h++){let x=_(i,6)^_(i,11)^_(i,25),y=f+x+Ie(i,u,d)+bn[h]+O[h]|0,g=(_(s,2)^_(s,13)^_(s,22))+ve(s,r,o)|0;f=d,d=u,u=i,i=c+y|0,c=o,o=r,r=s,s=y+g|0}s=s+this.A|0,r=r+this.B|0,o=o+this.C|0,c=c+this.D|0,i=i+this.E|0,u=u+this.F|0,d=d+this.G|0,f=f+this.H|0,this.set(s,r,o,c,i,u,d,f)}roundClean(){X(O)}destroy(){this.set(0,0,0,0,0,0,0,0),X(this.buffer)}},It=class extends Ut{constructor(){super(32);l(this,\"A\",F[0]|0);l(this,\"B\",F[1]|0);l(this,\"C\",F[2]|0);l(this,\"D\",F[3]|0);l(this,\"E\",F[4]|0);l(this,\"F\",F[5]|0);l(this,\"G\",F[6]|0);l(this,\"H\",F[7]|0)}};var ht=Le(()=>new It,Ue(1));var dt=class{constructor(t,n){l(this,\"oHash\");l(this,\"iHash\");l(this,\"blockLen\");l(this,\"outputLen\");l(this,\"finished\",!1);l(this,\"destroyed\",!1);if(Be(t),J(n,void 0,\"key\"),this.iHash=t.create(),typeof this.iHash.update!=\"function\")throw new Error(\"Expected instance of class which extends utils.Hash\");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let s=this.blockLen,r=new Uint8Array(s);r.set(n.length>s?t.create().update(n).digest():n);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r),this.oHash=t.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r),X(r)}update(t){return Q(this),this.iHash.update(t),this}digestInto(t){Q(this),J(t,this.outputLen,\"output\"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:n,iHash:s,finished:r,destroyed:o,blockLen:c,outputLen:i}=this;return t=t,t.finished=r,t.destroyed=o,t.blockLen=c,t.outputLen=i,t.oHash=n._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},lt=(e,t,n)=>new dt(e,t).update(n).digest();lt.create=(e,t)=>new dt(e,t);K.sha256=ht;K.hmacSha256=(e,...t)=>{let n=new Uint8Array(t.reduce((r,o)=>r+o.length,0)),s=0;for(let r of t)n.set(r,s),s+=r.length;return lt(ht,e,n)};return Ge(yn);})();\n/*! Bundled license information:\n\n@noble/secp256k1/index.js:\n  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)\n\n@noble/hashes/utils.js:\n  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n*/\n";
/**
 * Size of the bundled code in bytes.
 */
export declare const ECC_BUNDLE_SIZE = 18327;
//# sourceMappingURL=ecc-bundle.d.ts.map