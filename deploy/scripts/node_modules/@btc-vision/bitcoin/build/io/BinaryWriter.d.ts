/**
 * Stateful binary writer with a single DataView instance.
 *
 * Zero allocations during write operations. The DataView is created once
 * in the constructor and reused for all writes.
 *
 * @packageDocumentation
 */
/**
 * High-performance binary writer for serializing binary data.
 *
 * Creates exactly ONE DataView instance that is reused for all write operations.
 * This eliminates garbage collection pressure from repeated DataView allocations.
 *
 * Methods return `this` for chaining.
 *
 * @example
 * ```typescript
 * import { BinaryWriter } from '@btc-vision/bitcoin';
 *
 * // Serialize a simple structure
 * const writer = new BinaryWriter(16);
 * writer
 *     .writeInt32LE(1)        // version
 *     .writeUInt32LE(0)       // input count
 *     .writeUInt32LE(0)       // output count
 *     .writeUInt32LE(0);      // locktime
 *
 * const bytes = writer.finish();
 * ```
 */
export declare class BinaryWriter {
    #private;
    /**
     * Creates a new BinaryWriter with a pre-allocated buffer.
     *
     * @param size - Size of the buffer in bytes
     *
     * @example
     * ```typescript
     * import { BinaryWriter } from '@btc-vision/bitcoin';
     *
     * const writer = new BinaryWriter(1024);
     * writer.writeUInt32LE(42);
     * ```
     */
    constructor(size: number);
    /**
     * Creates a new BinaryWriter wrapping an existing buffer.
     *
     * @param buffer - Existing buffer to write into
     * @param offset - Initial write position (default 0)
     *
     * @example
     * ```typescript
     * import { BinaryWriter } from '@btc-vision/bitcoin';
     *
     * const buffer = new Uint8Array(1024);
     * const writer = new BinaryWriter(buffer, 10); // Start at offset 10
     * writer.writeUInt32LE(42);
     * ```
     */
    constructor(buffer: Uint8Array, offset?: number);
    /**
     * Current write position in the buffer.
     */
    get offset(): number;
    /**
     * Sets the write position.
     *
     * @param value - New offset value
     * @throws RangeError if offset is negative or beyond buffer length
     */
    set offset(value: number);
    /**
     * Total capacity of the underlying buffer.
     */
    get capacity(): number;
    /**
     * Number of bytes remaining in the buffer.
     */
    get remaining(): number;
    /**
     * The underlying data buffer.
     */
    get data(): Uint8Array;
    /**
     * Creates a BinaryWriter with automatic capacity management.
     *
     * Initial capacity is 256 bytes, grows as needed.
     *
     * @returns A new GrowableBinaryWriter instance
     *
     * @example
     * ```typescript
     * import { BinaryWriter } from '@btc-vision/bitcoin';
     *
     * const writer = BinaryWriter.growable();
     * writer.writeUInt32LE(1);
     * writer.writeBytes(new Uint8Array(1000)); // Automatically grows
     * ```
     */
    static growable(initialCapacity?: number): GrowableBinaryWriter;
    /**
     * Writes an 8-bit unsigned integer.
     *
     * @param value - Value to write (0-255)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeUInt8(255);
     * ```
     */
    writeUInt8(value: number): this;
    /**
     * Writes an 8-bit signed integer.
     *
     * @param value - Value to write (-128 to 127)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeInt8(value: number): this;
    /**
     * Writes a 16-bit unsigned integer in little-endian format.
     *
     * @param value - Value to write (0-65535)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeUInt16LE(1); // Writes 01 00
     * ```
     */
    writeUInt16LE(value: number): this;
    /**
     * Writes a 16-bit signed integer in little-endian format.
     *
     * @param value - Value to write (-32768 to 32767)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeInt16LE(value: number): this;
    /**
     * Writes a 32-bit unsigned integer in little-endian format.
     *
     * @param value - Value to write (0 to 4294967295)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeUInt32LE(1); // Writes 01 00 00 00
     * ```
     */
    writeUInt32LE(value: number): this;
    /**
     * Writes a 32-bit signed integer in little-endian format.
     *
     * @param value - Value to write (-2147483648 to 2147483647)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeInt32LE(-1); // Writes ff ff ff ff
     * ```
     */
    writeInt32LE(value: number): this;
    /**
     * Writes a 64-bit unsigned integer in little-endian format.
     *
     * @param value - Value to write as bigint
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeUInt64LE(50000n); // Writes 50 c3 00 00 00 00 00 00
     * ```
     */
    writeUInt64LE(value: bigint): this;
    /**
     * Writes a 64-bit signed integer in little-endian format.
     *
     * @param value - Value to write as bigint
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeInt64LE(value: bigint): this;
    /**
     * Writes raw bytes.
     *
     * @param bytes - Bytes to write
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeBytes(new Uint8Array([0xde, 0xad, 0xbe, 0xef]));
     * ```
     */
    writeBytes(bytes: Uint8Array): this;
    /**
     * Writes a Bitcoin CompactSize variable-length integer.
     *
     * CompactSize encoding:
     * - 0x00-0xFC: 1 byte (value as-is)
     * - 0xFD-0xFFFF: 3 bytes (0xFD + 2-byte LE uint16)
     * - 0x10000-0xFFFFFFFF: 5 bytes (0xFE + 4-byte LE uint32)
     * - Larger: 9 bytes (0xFF + 8-byte LE uint64)
     *
     * @param value - Value to write
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeVarInt(252);    // Writes fc
     * writer.writeVarInt(253);    // Writes fd fd 00
     * writer.writeVarInt(65535);  // Writes fd ff ff
     * writer.writeVarInt(65536);  // Writes fe 00 00 01 00
     * ```
     */
    writeVarInt(value: number): this;
    /**
     * Writes a Bitcoin CompactSize variable-length integer from bigint.
     *
     * @param value - Value to write as bigint
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeVarIntBig(value: bigint): this;
    /**
     * Writes a length-prefixed byte array (VarInt length + bytes).
     *
     * @param bytes - Bytes to write
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeVarBytes(new Uint8Array([0xde, 0xad])); // Writes 02 de ad
     * ```
     */
    writeVarBytes(bytes: Uint8Array): this;
    /**
     * Writes an array of length-prefixed byte arrays.
     *
     * Format: VarInt count + (VarInt length + bytes) for each item.
     *
     * @param vector - Array of byte arrays to write
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeVector(vector: readonly Uint8Array[]): this;
    /**
     * Fills a region with a specific byte value.
     *
     * @param value - Byte value to fill with
     * @param length - Number of bytes to fill
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    fill(value: number, length: number): this;
    /**
     * Skips a specified number of bytes (leaves them unchanged).
     *
     * @param length - Number of bytes to skip
     * @returns This writer for chaining
     * @throws RangeError if skipping past end of buffer
     */
    skip(length: number): this;
    /**
     * Resets the write position to the beginning.
     *
     * @returns This writer for chaining
     */
    reset(): this;
    /**
     * Verifies the buffer was fully written and returns it.
     *
     * Unlike {@link finish}, this method throws if the writer has not
     * written exactly to the end of the buffer.
     *
     * @returns The underlying buffer
     * @throws Error if the buffer was not fully written
     *
     * @example
     * ```typescript
     * const writer = new BinaryWriter(8);
     * writer.writeUInt32LE(1);
     * writer.writeUInt32LE(2);
     * const bytes = writer.end(); // OK: wrote exactly 8 bytes
     *
     * const writer2 = new BinaryWriter(8);
     * writer2.writeUInt32LE(1);
     * writer2.end(); // throws: buffer size 8, offset 4
     * ```
     */
    end(): Uint8Array;
    /**
     * Returns the written portion of the buffer.
     *
     * If the entire buffer was written, returns the buffer directly (no copy).
     * Otherwise, returns a subarray view.
     *
     * @returns Uint8Array containing the written data
     *
     * @example
     * ```typescript
     * const writer = new BinaryWriter(100);
     * writer.writeUInt32LE(42);
     * const bytes = writer.finish(); // 4 bytes
     * ```
     */
    finish(): Uint8Array;
    /**
     * Returns the written portion as a hex string.
     *
     * @returns Hex string representation
     *
     * @example
     * ```typescript
     * const writer = new BinaryWriter(4);
     * writer.writeUInt32LE(1);
     * writer.toHex(); // '01000000'
     * ```
     */
    toHex(): string;
}
/**
 * A BinaryWriter that automatically grows its buffer as needed.
 *
 * Use when the final size is unknown.
 *
 * @example
 * ```typescript
 * const writer = BinaryWriter.growable();
 * writer.writeBytes(largeData); // Automatically grows
 * const bytes = writer.finish();
 * ```
 */
export declare class GrowableBinaryWriter {
    #private;
    /**
     * Creates a new GrowableBinaryWriter.
     *
     * @param initialCapacity - Initial buffer size (default 256)
     */
    constructor(initialCapacity?: number);
    /**
     * Current write position.
     */
    get offset(): number;
    /**
     * Sets the write position.
     *
     * @param value - New offset value
     * @throws RangeError if offset is negative
     */
    set offset(value: number);
    /**
     * Current buffer capacity.
     */
    get capacity(): number;
    writeUInt8(value: number): this;
    writeUInt16LE(value: number): this;
    writeUInt32LE(value: number): this;
    writeInt32LE(value: number): this;
    writeUInt64LE(value: bigint): this;
    writeBytes(bytes: Uint8Array): this;
    writeVarInt(value: number): this;
    writeVarBytes(bytes: Uint8Array): this;
    writeVector(vector: readonly Uint8Array[]): this;
    /**
     * Returns the written data as a new Uint8Array.
     *
     * @returns Copy of the written data
     */
    finish(): Uint8Array;
    /**
     * Returns the written data as a hex string.
     *
     * @returns Hex string representation
     */
    toHex(): string;
}
//# sourceMappingURL=BinaryWriter.d.ts.map