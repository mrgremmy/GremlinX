import { type UniversalSigner } from '@btc-vision/ecpair';
import { type Network } from '@btc-vision/bitcoin';
import { Address } from './Address.js';
import type { IP2WSHAddress } from '../transaction/mineable/IP2WSHAddress.js';
import { MLDSASecurityLevel, type QuantumBIP32Interface } from '@btc-vision/bip32';
/**
 * Wallet class for managing both classical and quantum-resistant keys
 */
export declare class Wallet implements Disposable {
    readonly network: Network;
    private readonly _keypair;
    private readonly _mldsaKeypair;
    private readonly _securityLevel;
    private readonly _chainCode;
    private readonly _p2wpkh;
    private readonly _p2tr;
    private readonly _p2wda;
    private readonly _legacy;
    private readonly _segwitLegacy;
    private readonly _bufferPubKey;
    private readonly _tweakedKey;
    private readonly _address;
    constructor(privateKeyOrWif: string, mldsaPrivateKeyOrBase58: string, network?: Network, securityLevel?: MLDSASecurityLevel, chainCode?: Uint8Array);
    get address(): Address;
    get tweakedPubKeyKey(): Uint8Array;
    get keypair(): UniversalSigner;
    get mldsaKeypair(): QuantumBIP32Interface;
    get securityLevel(): MLDSASecurityLevel;
    get chainCode(): Uint8Array;
    get p2wpkh(): string;
    get p2tr(): string;
    get p2wda(): IP2WSHAddress;
    get legacy(): string;
    get addresses(): string[];
    get segwitLegacy(): string;
    get publicKey(): Uint8Array;
    get quantumPublicKey(): Uint8Array;
    get quantumPrivateKey(): Uint8Array;
    get quantumPublicKeyHex(): string;
    get quantumPrivateKeyHex(): string;
    get xOnly(): Uint8Array;
    static fromWif(wif: string, quantumPrivateKeyHex: string, network?: Network, securityLevel?: MLDSASecurityLevel, chainCode?: Uint8Array): Wallet;
    static generate(network?: Network, securityLevel?: MLDSASecurityLevel): Wallet;
    static fromPrivateKeys(privateKeyHexOrWif: string, mldsaPrivateKeyOrBase58: string, network?: Network, securityLevel?: MLDSASecurityLevel, chainCode?: Uint8Array): Wallet;
    toWIF(): string;
    toPrivateKeyHex(): string;
    toPublicKeyHex(): string;
    toQuantumBase58(): string;
    /**
     * Best-effort zeroing of private key material held by this wallet.
     *
     * Zeros classical and quantum private key buffers and the chain code in-place.
     * This cannot guarantee all copies are erased (the JS runtime may have copied
     * buffers internally, and string representations cannot be zeroed), but it
     * eliminates the primary references.
     */
    zeroize(): void;
    [Symbol.dispose](): void;
    derivePath(path: string): Wallet;
}
//# sourceMappingURL=Wallet.d.ts.map