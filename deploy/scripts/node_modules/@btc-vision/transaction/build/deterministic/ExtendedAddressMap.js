import { Address } from '../keypair/Address.js';
import { FastMap } from './FastMap.js';
/**
 * A map implementation using Address with both MLDSA and tweaked keys.
 * Uses the tweaked public key for lookup/indexing, but stores the full Address.
 */
export class ExtendedAddressMap {
    // Store tweaked bigint -> index mapping for fast lookup
    indexMap;
    // Store actual addresses and values
    _keys = [];
    _values = [];
    constructor(iterable) {
        this.indexMap = new FastMap();
        if (iterable) {
            for (const [key, value] of iterable) {
                this.set(key, value);
            }
        }
    }
    get size() {
        return this._keys.length;
    }
    set(key, value) {
        const keyBigInt = key.tweakedToBigInt();
        const existingIndex = this.indexMap.get(keyBigInt);
        if (existingIndex !== undefined) {
            // Update existing entry
            this._values[existingIndex] = value;
        }
        else {
            // Add new entry
            const newIndex = this._keys.length;
            this._keys.push(key);
            this._values.push(value);
            this.indexMap.set(keyBigInt, newIndex);
        }
        return this;
    }
    get(key) {
        const keyBigInt = key.tweakedToBigInt();
        const index = this.indexMap.get(keyBigInt);
        if (index === undefined) {
            return undefined;
        }
        return this._values[index];
    }
    has(key) {
        return this.indexMap.has(key.tweakedToBigInt());
    }
    delete(key) {
        const keyBigInt = key.tweakedToBigInt();
        const index = this.indexMap.get(keyBigInt);
        if (index === undefined) {
            return false;
        }
        // Remove from arrays
        this._keys.splice(index, 1);
        this._values.splice(index, 1);
        // Rebuild index map (indices shifted after splice)
        this.indexMap.clear();
        for (let i = 0; i < this._keys.length; i++) {
            this.indexMap.set(this._keys[i].tweakedToBigInt(), i);
        }
        return true;
    }
    clear() {
        this.indexMap.clear();
        this._keys = [];
        this._values = [];
    }
    [Symbol.dispose]() {
        this.clear();
    }
    indexOf(address) {
        const index = this.indexMap.get(address.tweakedToBigInt());
        return index !== undefined ? index : -1;
    }
    *entries() {
        for (let i = 0; i < this._keys.length; i++) {
            yield [this._keys[i], this._values[i]];
        }
    }
    *keys() {
        for (const key of this._keys) {
            yield key;
        }
    }
    *values() {
        for (const value of this._values) {
            yield value;
        }
    }
    forEach(callback, thisArg) {
        for (let i = 0; i < this._keys.length; i++) {
            callback.call(thisArg, this._values[i], this._keys[i], this);
        }
    }
    *[Symbol.iterator]() {
        yield* this.entries();
    }
}
//# sourceMappingURL=ExtendedAddressMap.js.map