import type { Address } from '../keypair/Address.js';
import type { AddressMap } from '../deterministic/AddressMap.js';
import type { ExtendedAddressMap } from '../deterministic/ExtendedAddressMap.js';
import type { SchnorrSignature } from '../buffer/BinaryReader.js';
import { ABIDataTypes } from './ABIDataTypes.js';
/**
 * Recursive ABI type definition:
 * - Simple: ABIDataTypes enum value (e.g. ABIDataTypes.ADDRESS)
 * - Tuple: ordered array of AbiType (e.g. [ABIDataTypes.ADDRESS, ABIDataTypes.UINT8])
 * - Struct: named fields mapping to AbiType (e.g. { field1: ABIDataTypes.ADDRESS, field2: ABIDataTypes.UINT256 })
 * - Nested: any combination (e.g. [ABIDataTypes.ADDRESS, { inner: ABIDataTypes.UINT8 }])
 */
export type AbiType = ABIDataTypes | AbiType[] | {
    [field: string]: AbiType;
};
/**
 * Maps an AbiType to its corresponding TypeScript type at the type level.
 *
 * Usage with `as const`:
 * ```ts
 * const abi = { name: 'balance', type: ABIDataTypes.UINT256 } as const;
 * type Result = InferAbiType<typeof abi.type>; // bigint
 *
 * const structAbi = { name: 'status', type: { minted: ABIDataTypes.UINT256, active: ABIDataTypes.BOOL } } as const;
 * type StatusResult = InferAbiType<typeof structAbi.type>; // { minted: bigint; active: boolean }
 * ```
 */
export type InferAbiType<T extends AbiType> = T extends ABIDataTypes.UINT8 | ABIDataTypes.UINT16 | ABIDataTypes.UINT32 | ABIDataTypes.INT8 | ABIDataTypes.INT16 | ABIDataTypes.INT32 ? number : T extends ABIDataTypes.UINT64 | ABIDataTypes.UINT128 | ABIDataTypes.UINT256 | ABIDataTypes.INT64 | ABIDataTypes.INT128 ? bigint : T extends ABIDataTypes.BOOL ? boolean : T extends ABIDataTypes.STRING ? string : T extends ABIDataTypes.ADDRESS | ABIDataTypes.EXTENDED_ADDRESS ? Address : T extends ABIDataTypes.BYTES | ABIDataTypes.BYTES4 | ABIDataTypes.BYTES32 ? Uint8Array : T extends ABIDataTypes.SCHNORR_SIGNATURE ? SchnorrSignature : T extends ABIDataTypes.ADDRESS_UINT256_TUPLE ? AddressMap<bigint> : T extends ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE ? ExtendedAddressMap<bigint> : T extends ABIDataTypes.ARRAY_OF_ADDRESSES | ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES ? Address[] : T extends ABIDataTypes.ARRAY_OF_UINT256 | ABIDataTypes.ARRAY_OF_UINT128 | ABIDataTypes.ARRAY_OF_UINT64 ? bigint[] : T extends ABIDataTypes.ARRAY_OF_UINT32 | ABIDataTypes.ARRAY_OF_UINT16 | ABIDataTypes.ARRAY_OF_UINT8 ? number[] : T extends ABIDataTypes.ARRAY_OF_STRING ? string[] : T extends ABIDataTypes.ARRAY_OF_BYTES | ABIDataTypes.ARRAY_OF_BUFFERS ? Uint8Array[] : T extends Record<string, AbiType> ? {
    [K in keyof T]: T[K] extends AbiType ? InferAbiType<T[K]> : never;
} : T extends readonly [infer Single extends AbiType] ? InferAbiType<Single>[] : T extends readonly [AbiType, AbiType, ...AbiType[]] ? {
    [K in keyof T]: T[K] extends AbiType ? InferAbiType<T[K]> : T[K];
}[] : T extends readonly AbiType[] ? unknown[] : never;
/**
 * Canonical string → ABIDataTypes mapping.
 * Only includes canonical ABI-style names (not AssemblyScript aliases).
 */
export declare const StrToAbiType: {
    [key: string]: ABIDataTypes;
};
/**
 * Canonical reverse mapping: ABIDataTypes → canonical string.
 */
export declare const AbiTypeToStr: {
    [key in ABIDataTypes]: string;
};
//# sourceMappingURL=AbiTypes.d.ts.map