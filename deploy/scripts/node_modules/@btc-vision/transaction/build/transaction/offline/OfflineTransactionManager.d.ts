import { type Signer } from '@btc-vision/bitcoin';
import { type UniversalSigner } from '@btc-vision/ecpair';
import { TransactionType } from '../enums/TransactionType.js';
import { TransactionBuilder } from '../builders/TransactionBuilder.js';
import type { ISerializableTransactionState, PrecomputedData } from './interfaces/ISerializableState.js';
import { type ReconstructionOptions } from './TransactionReconstructor.js';
import type { IDeploymentParameters, IFundingTransactionParameters, IInteractionParameters, ITransactionParameters } from '../interfaces/ITransactionParameters.js';
/**
 * Export options for offline transaction signing
 */
export interface ExportOptions {
    /** The original transaction parameters */
    params: ITransactionParameters;
    /** Transaction type */
    type: TransactionType;
    /** Precomputed data from the builder */
    precomputed?: Partial<PrecomputedData>;
}
/**
 * Main entry point for offline transaction signing workflow.
 *
 * This class provides a complete API for:
 * 1. Phase 1 (Online): Building transactions and exporting state for offline signing
 * 2. Phase 2 (Offline): Importing state, providing signers, and signing transactions
 *
 * Also supports fee bumping by allowing reconstruction with new fee parameters.
 *
 * @example
 * ```typescript
 * // Phase 1 (Online environment)
 * const params: IFundingTransactionParameters = { ... };
 * const state = OfflineTransactionManager.exportFunding(params);
 * // Send state to offline environment
 *
 * // Phase 2 (Offline environment)
 * const signedTxHex = await OfflineTransactionManager.importSignAndExport(state, {
 *     signer: offlineSigner,
 * });
 * // Send signedTxHex back to online environment for broadcast
 * ```
 */
export declare class OfflineTransactionManager {
    /**
     * Export a FundingTransaction for offline signing
     * @param params - Funding transaction parameters
     * @param precomputed - Optional precomputed data
     * @returns Base64-encoded serialized state
     */
    static exportFunding(params: IFundingTransactionParameters, precomputed?: Partial<PrecomputedData>): string;
    /**
     * Export a DeploymentTransaction for offline signing
     * @param params - Deployment transaction parameters
     * @param precomputed - Required precomputed data (randomBytes, compiledTargetScript)
     * @returns Base64-encoded serialized state
     */
    static exportDeployment(params: IDeploymentParameters, precomputed: Partial<PrecomputedData> & {
        compiledTargetScript: string;
        randomBytes: string;
    }): string;
    /**
     * Export an InteractionTransaction for offline signing
     * @param params - Interaction transaction parameters
     * @param precomputed - Required precomputed data (randomBytes, compiledTargetScript)
     * @returns Base64-encoded serialized state
     */
    static exportInteraction(params: IInteractionParameters, precomputed: Partial<PrecomputedData> & {
        compiledTargetScript: string;
        randomBytes: string;
    }): string;
    /**
     * Export a MultiSignTransaction for offline signing
     * @param params - MultiSig transaction parameters
     * @param precomputed - Optional precomputed data
     * @returns Base64-encoded serialized state
     */
    static exportMultiSig(params: ITransactionParameters & {
        pubkeys: Uint8Array[];
        minimumSignatures: number;
        receiver: string;
        requestedAmount: bigint;
        refundVault: string;
        originalInputCount?: number;
        existingPsbtBase64?: string;
    }, precomputed?: Partial<PrecomputedData>): string;
    /**
     * Export a CustomScriptTransaction for offline signing
     * @param params - Custom script transaction parameters
     * @param precomputed - Optional precomputed data
     * @returns Base64-encoded serialized state
     */
    static exportCustomScript(params: ITransactionParameters & {
        scriptElements: (Uint8Array | number)[];
        witnesses: Uint8Array[];
        annex?: Uint8Array;
    }, precomputed?: Partial<PrecomputedData>): string;
    /**
     * Export a CancelTransaction for offline signing
     * @param params - Cancel transaction parameters
     * @param precomputed - Optional precomputed data
     * @returns Base64-encoded serialized state
     */
    static exportCancel(params: ITransactionParameters & {
        compiledTargetScript: Uint8Array | string;
    }, precomputed?: Partial<PrecomputedData>): string;
    /**
     * Export transaction state from a builder instance.
     * The builder must have been built but not yet signed.
     * @param builder - Transaction builder instance
     * @param params - Original construction parameters
     * @param precomputed - Precomputed data from the builder
     * @returns Base64-encoded serialized state
     */
    static exportFromBuilder<T extends TransactionType>(builder: TransactionBuilder<T>, params: ITransactionParameters, precomputed?: Partial<PrecomputedData>): string;
    /**
     * Import and reconstruct transaction for signing
     * @param serializedState - Base64-encoded state from Phase 1
     * @param options - Signer(s) and optional fee overrides
     * @returns Reconstructed transaction builder ready for signing
     */
    static importForSigning(serializedState: string, options: ReconstructionOptions): TransactionBuilder<TransactionType>;
    /**
     * Complete signing and export signed transaction
     * @param builder - Reconstructed builder from importForSigning
     * @returns Signed transaction hex ready for broadcast
     */
    static signAndExport(builder: TransactionBuilder<TransactionType>): Promise<string>;
    /**
     * Convenience: Full Phase 2 in one call - import, sign, and export
     * @param serializedState - Base64-encoded state
     * @param options - Signer(s) and optional fee overrides
     * @returns Signed transaction hex ready for broadcast
     */
    static importSignAndExport(serializedState: string, options: ReconstructionOptions): Promise<string>;
    /**
     * Rebuild transaction with new fee rate (fee bumping)
     * @param serializedState - Original state
     * @param newFeeRate - New fee rate in sat/vB
     * @returns New serialized state with updated fees (not signed yet)
     */
    static rebuildWithNewFees(serializedState: string, newFeeRate: number): string;
    /**
     * Rebuild and immediately sign with new fee rate
     * @param serializedState - Original state
     * @param newFeeRate - New fee rate in sat/vB
     * @param options - Signer options
     * @returns Signed transaction hex with new fees
     */
    static rebuildSignAndExport(serializedState: string, newFeeRate: number, options: ReconstructionOptions): Promise<string>;
    /**
     * Inspect serialized state without signing
     * @param serializedState - Base64-encoded state
     * @returns Parsed state object for inspection
     */
    static inspect(serializedState: string): ISerializableTransactionState;
    /**
     * Validate serialized state integrity
     * @param serializedState - Base64-encoded state
     * @returns True if checksum and format are valid
     */
    static validate(serializedState: string): boolean;
    /**
     * Get transaction type from serialized state
     * @param serializedState - Base64-encoded state
     * @returns Transaction type enum value
     */
    static getType(serializedState: string): TransactionType;
    /**
     * Parse base64-encoded state into state object
     * @param base64State - Base64-encoded state
     * @returns Parsed state object
     */
    static fromBase64(base64State: string): ISerializableTransactionState;
    /**
     * Serialize state object to base64
     * @param state - State object to serialize
     * @returns Base64-encoded state
     */
    static toBase64(state: ISerializableTransactionState): string;
    /**
     * Convert serialized state to hex format
     * @param serializedState - Base64-encoded state
     * @returns Hex-encoded state
     */
    static toHex(serializedState: string): string;
    /**
     * Convert hex format back to base64
     * @param hexState - Hex-encoded state
     * @returns Base64-encoded state
     */
    static fromHex(hexState: string): string;
    /**
     * Add a partial signature to a multisig transaction state.
     * This method signs the transaction with the provided signer and returns
     * updated state with the new signature included.
     *
     * @param serializedState - Base64-encoded multisig state
     * @param signer - The signer to add a signature with
     * @returns Updated state with new signature, and signing result
     */
    static multiSigAddSignature(serializedState: string, signer: Signer | UniversalSigner): Promise<{
        state: string;
        signed: boolean;
        final: boolean;
        psbtBase64: string;
    }>;
    /**
     * Check if a public key has already signed a multisig transaction
     *
     * @param serializedState - Base64-encoded multisig state
     * @param signerPubKey - Public key to check (Uint8Array or hex string)
     * @returns True if the public key has already signed
     */
    static multiSigHasSigned(serializedState: string, signerPubKey: Uint8Array | string): boolean;
    /**
     * Get the current signature count for a multisig transaction
     *
     * @param serializedState - Base64-encoded multisig state
     * @returns Object with signature count info
     */
    static multiSigGetSignatureStatus(serializedState: string): {
        required: number;
        collected: number;
        isComplete: boolean;
        signers: string[];
    };
    /**
     * Finalize a multisig transaction and extract the signed transaction hex.
     * Only call this when all required signatures have been collected.
     *
     * @param serializedState - Base64-encoded multisig state with all signatures
     * @returns Signed transaction hex ready for broadcast
     */
    static multiSigFinalize(serializedState: string): string;
    /**
     * Get the PSBT from a multisig state (for external signing tools)
     *
     * @param serializedState - Base64-encoded multisig state
     * @returns PSBT in base64 format, or null if not yet built
     */
    static multiSigGetPsbt(serializedState: string): string | null;
    /**
     * Update the PSBT in a multisig state (after external signing)
     *
     * @param serializedState - Base64-encoded multisig state
     * @param psbtBase64 - New PSBT with additional signatures
     * @returns Updated state
     */
    static multiSigUpdatePsbt(serializedState: string, psbtBase64: string): string;
}
//# sourceMappingURL=OfflineTransactionManager.d.ts.map