import { fromHex } from '@btc-vision/bitcoin';
import { TransactionType } from '../enums/TransactionType.js';
import { SharedInteractionTransaction } from './SharedInteractionTransaction.js';
import { FeaturePriority, Features } from '../../generators/Features.js';
/**
 * Class for interaction transactions
 * @class InteractionTransaction
 */
export class InteractionTransaction extends SharedInteractionTransaction {
    type = TransactionType.INTERACTION;
    compiledTargetScript;
    scriptTree;
    tapLeafScript = null;
    /**
     * Contract secret for the interaction
     * @protected
     */
    contractSecret;
    constructor(parameters) {
        super(parameters);
        if (!parameters.contract) {
            throw new Error('parameters.contract is required for interaction transaction.');
        }
        this.contractSecret = fromHex(parameters.contract.startsWith('0x') ? parameters.contract.slice(2) : parameters.contract);
        if (this.contractSecret.length !== 32) {
            throw new Error('Invalid contract secret length. Expected 32 bytes.');
        }
        if (parameters.compiledTargetScript) {
            if (parameters.compiledTargetScript instanceof Uint8Array) {
                this.compiledTargetScript = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledTargetScript = fromHex(parameters.compiledTargetScript);
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledTargetScript = this.calldataGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
        }
        this.scriptTree = this.getScriptTree();
        this.internalInit();
    }
    generateFeatures(parameters) {
        const features = [];
        if (parameters.loadedStorage) {
            features.push({
                priority: FeaturePriority.ACCESS_LIST,
                opcode: Features.ACCESS_LIST,
                data: parameters.loadedStorage,
            });
        }
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.EPOCH_SUBMISSION,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
            throw new Error('To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.');
        }
        if (parameters.linkMLDSAPublicKeyToAddress) {
            this.generateMLDSALinkRequest(parameters, features);
        }
        return features;
    }
}
//# sourceMappingURL=InteractionTransaction.js.map