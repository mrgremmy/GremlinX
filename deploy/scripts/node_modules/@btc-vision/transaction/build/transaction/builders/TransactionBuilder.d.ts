import type { Script } from '@btc-vision/bitcoin';
import { type Network, Psbt, type PsbtInputExtended, type PsbtOutputExtended, type Signer, Transaction } from '@btc-vision/bitcoin';
import type { UpdateInput } from '../interfaces/Tap.js';
import { TransactionType } from '../enums/TransactionType.js';
import type { IFundingTransactionParameters, ITransactionParameters } from '../interfaces/ITransactionParameters.js';
import type { UTXO } from '../../utxo/interfaces/IUTXO.js';
import { type UniversalSigner } from '@btc-vision/ecpair';
import { TweakedTransaction } from '../shared/TweakedTransaction.js';
import { UnisatSigner } from '../browser/extensions/UnisatSigner.js';
import type { IP2WSHAddress } from '../mineable/IP2WSHAddress.js';
import { type Feature, Features } from '../../generators/Features.js';
export declare const MINIMUM_AMOUNT_REWARD: bigint;
export declare const MINIMUM_AMOUNT_CA: bigint;
export declare const ANCHOR_SCRIPT: Uint8Array<ArrayBufferLike>;
/**
 * Allows to build a transaction like you would on Ethereum.
 * @description The transaction builder class
 * @abstract
 * @class TransactionBuilder
 */
export declare abstract class TransactionBuilder<T extends TransactionType> extends TweakedTransaction {
    static readonly MINIMUM_DUST: bigint;
    abstract readonly type: T;
    readonly logColor: string;
    debugFees: boolean;
    LOCK_LEAF_SCRIPT: Script;
    /**
     * @description The overflow fees of the transaction
     * @public
     */
    overflowFees: bigint;
    /**
     * @description Cost in satoshis of the transaction fee
     */
    transactionFee: bigint;
    /**
     * @description The estimated fees of the transaction
     */
    estimatedFees: bigint;
    /**
     * @param {ITransactionParameters} parameters - The transaction parameters
     */
    optionalOutputs: PsbtOutputExtended[] | undefined;
    /**
     * @description The transaction itself.
     */
    protected transaction: Psbt;
    /**
     * @description Inputs to update later on.
     */
    protected readonly updateInputs: UpdateInput[];
    /**
     * @description The outputs of the transaction
     */
    protected readonly outputs: PsbtOutputExtended[];
    /**
     * @description Output that will be used to pay the fees
     */
    protected feeOutput: PsbtOutputExtended | null;
    /**
     * @description The total amount of satoshis in the inputs
     */
    protected totalInputAmount: bigint;
    /**
     * @description The signer of the transaction
     */
    protected readonly signer: Signer | UniversalSigner | UnisatSigner;
    /**
     * @description The network where the transaction will be broadcasted
     */
    protected readonly network: Network;
    /**
     * @description The fee rate of the transaction
     */
    protected readonly feeRate: number;
    /**
     * @description The opnet priority fee of the transaction
     */
    protected priorityFee: bigint;
    protected gasSatFee: bigint;
    /**
     * @description The utxos used in the transaction
     */
    protected utxos: UTXO[];
    /**
     * @description The inputs of the transaction
     * @protected
     */
    protected optionalInputs: UTXO[];
    /**
     * @description The address where the transaction is sent to
     * @protected
     */
    protected to: string | undefined;
    /**
     * @description The address where the transaction is sent from
     * @protected
     */
    protected from: string;
    /**
     * @description The maximum fee rate of the transaction
     */
    protected _maximumFeeRate: number;
    /**
     * @description Is the destionation P2PK
     * @protected
     */
    protected isPubKeyDestination: boolean;
    /**
     * @description If the transaction need an anchor output
     * @protected
     */
    protected anchor: boolean;
    protected note?: Uint8Array;
    private optionalOutputsAdded;
    protected constructor(parameters: ITransactionParameters);
    static getFrom(from: string | undefined, keypair: UniversalSigner | Signer, network: Network): string;
    /**
     * @description Converts the witness stack to a script witness
     * @param {Uint8Array[]} witness - The witness stack
     * @protected
     * @returns {Uint8Array}
     */
    static witnessStackToScriptWitness(witness: Uint8Array[]): Uint8Array;
    [Symbol.dispose](): void;
    addOPReturn(buffer: Uint8Array): void;
    addAnchor(): void;
    getFundingTransactionParameters(): Promise<IFundingTransactionParameters>;
    /**
     * Set the destination address of the transaction
     * @param {string} address - The address to set
     */
    setDestinationAddress(address: string): void;
    /**
     * Set the maximum fee rate of the transaction in satoshis per byte
     * @param {number} feeRate - The fee rate to set
     * @public
     */
    setMaximumFeeRate(feeRate: number): void;
    /**
     * @description Signs the transaction
     * @public
     * @returns {Promise<Transaction>} - The signed transaction in hex format
     * @throws {Error} - If something went wrong
     */
    signTransaction(): Promise<Transaction>;
    /**
     * @description Generates the transaction minimal signatures
     * @public
     */
    generateTransactionMinimalSignatures(checkPartialSigs?: boolean): Promise<void>;
    /**
     * @description Signs the transaction
     * @public
     * @returns {Promise<Psbt>} - The signed transaction in hex format
     * @throws {Error} - If something went wrong
     */
    signPSBT(): Promise<Psbt>;
    /**
     * Add an input to the transaction.
     * @param {PsbtInputExtended} input - The input to add
     * @public
     * @returns {void}
     */
    addInput(input: PsbtInputExtended): void;
    /**
     * Add an output to the transaction.
     * @param {PsbtOutputExtended} output - The output to add
     * @param bypassMinCheck
     * @public
     * @returns {void}
     */
    addOutput(output: PsbtOutputExtended, bypassMinCheck?: boolean): void;
    /**
     * Returns the total value of all outputs added so far (excluding the fee/change output).
     * @public
     * @returns {bigint}
     */
    getTotalOutputValue(): bigint;
    /**
     * Receiver address.
     * @public
     * @returns {string} - The receiver address
     */
    toAddress(): string | undefined;
    /**
     * @description Returns the script address
     * @returns {string} - The script address
     */
    address(): string | undefined;
    /**
     * Estimates the transaction fees with accurate size calculation.
     *
     * @note The P2TR estimation is made for a 2-leaf tree with both a tapScriptSig and a tapInternalKey input, which is a common case for many transactions.
     * This provides a more accurate fee estimation for typical P2TR transactions, but may not be perfectly accurate for all possible script configurations.
     * Adjustments may be needed for more complex scripts or different leaf structures.
     *
     * @public
     * @returns {Promise<bigint>}
     */
    estimateTransactionFees(): Promise<bigint>;
    rebuildFromBase64(base64: string): Promise<Psbt>;
    setPSBT(psbt: Psbt): void;
    /**
     * Returns the inputs of the transaction.
     * @protected
     * @returns {PsbtInputExtended[]}
     */
    getInputs(): PsbtInputExtended[];
    /**
     * Returns the outputs of the transaction.
     * @protected
     * @returns {PsbtOutputExtended[]}
     */
    getOutputs(): PsbtOutputExtended[];
    getOptionalOutputValue(): bigint;
    protected addRefundOutput(amountSpent: bigint, expectRefund?: boolean): Promise<void>;
    protected defineLockScript(): Script;
    /**
     * @description Adds the value to the output
     * @param {number | bigint} value - The value to add
     * @protected
     * @returns {void}
     */
    protected addValueToToOutput(value: number | bigint): void;
    protected generateLegacySignature(): Uint8Array;
    protected generateMLDSASignature(): Uint8Array;
    protected generateMLDSALinkRequest(parameters: ITransactionParameters, features: Feature<Features>[]): void;
    /**
     * @description Returns the transaction opnet fee
     * @protected
     * @returns {bigint}
     */
    protected getTransactionOPNetFee(): bigint;
    /**
     * @description Returns the total amount of satoshis in the inputs
     * @protected
     * @returns {bigint}
     */
    protected calculateTotalUTXOAmount(): bigint;
    /**
     * @description Returns the total amount of satoshis in the outputs
     * @protected
     * @returns {bigint}
     */
    protected calculateTotalVOutAmount(): bigint;
    /**
     * @description Adds optional outputs to transaction and returns their total value in satoshi to calculate refund transaction
     * @protected
     * @returns {bigint}
     */
    protected addOptionalOutputsAndGetAmount(): bigint;
    /**
     * @description Adds the inputs from the utxos
     * @protected
     * @returns {void}
     */
    protected addInputsFromUTXO(): void;
    /**
     * Internal init.
     * @protected
     */
    protected internalInit(): void;
    /**
     * Builds the transaction.
     * @protected
     * @returns {Promise<void>}
     */
    protected abstract buildTransaction(): Promise<void>;
    /**
     * Add an input update
     * @param {UpdateInput} input - The input to update
     * @protected
     * @returns {void}
     */
    protected updateInput(input: UpdateInput): void;
    /**
     * Adds the fee to the output.
     * @param amountSpent
     * @param contractAddress
     * @param epochChallenge
     * @param addContractOutput
     * @protected
     */
    protected addFeeToOutput(amountSpent: bigint, contractAddress: string, epochChallenge: IP2WSHAddress, addContractOutput: boolean): void;
    /**
     * Returns the witness of the tap transaction.
     * @protected
     * @returns {Uint8Array}
     */
    protected getWitness(): Uint8Array;
    /**
     * Returns the tap output.
     * @protected
     * @returns {Uint8Array}
     */
    protected getTapOutput(): Uint8Array;
    /**
     * Verifies that the utxos are valid.
     * @protected
     */
    protected verifyUTXOValidity(): void;
    /**
     * Builds the transaction.
     * @param {Psbt} transaction - The transaction to build
     * @param checkPartialSigs
     * @protected
     * @returns {Promise<boolean>}
     * @throws {Error} - If something went wrong while building the transaction
     */
    protected internalBuildTransaction(transaction: Psbt, checkPartialSigs?: boolean): Promise<boolean>;
    private createChangeOutput;
}
//# sourceMappingURL=TransactionBuilder.d.ts.map