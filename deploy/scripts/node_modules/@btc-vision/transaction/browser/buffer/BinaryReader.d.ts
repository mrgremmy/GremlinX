import { AddressMap } from '../deterministic/AddressMap.js';
import { ExtendedAddressMap } from '../deterministic/ExtendedAddressMap.js';
import { Address } from '../keypair/Address.js';
import { BufferLike, i16, i32, i64, i8, Selector, u16, u32, u8 } from '../utils/types.js';
/**
 * Represents a Schnorr signature paired with the signer's Address.
 * This class bundles a 64-byte Schnorr signature with its associated
 * full Address (both MLDSA and tweaked keys), providing a complete signed data structure
 * for Bitcoin Taproot-compatible signatures.
 */
export interface SchnorrSignature {
    /** The signer's Address containing both MLDSA and tweaked public keys */
    readonly address: Address;
    /** The 64-byte Schnorr signature */
    readonly signature: Uint8Array;
}
export declare class BinaryReader {
    private buffer;
    private currentOffset;
    constructor(bytes: BufferLike);
    get byteLength(): number;
    static stringCompare(a: string, b: string): number;
    static bigintCompare(a: bigint, b: bigint): number;
    static numberCompare(a: number, b: number): number;
    setBuffer(bytes: BufferLike): void;
    length(): number;
    bytesLeft(): number;
    /**
     * Reads a single signed byte (i8).
     */
    readI8(): i8;
    /**
     * Reads a signed 16-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readI16(be?: boolean): i16;
    /**
     * Reads a signed 32-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readI32(be?: boolean): i32;
    /**
     * Reads a signed 64-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readI64(be?: boolean): i64;
    /**
     * Reads a single unsigned byte (u8).
     */
    readU8(): u8;
    /**
     * Reads an unsigned 16-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readU16(be?: boolean): u16;
    /**
     * Reads an unsigned 32-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readU32(be?: boolean): u32;
    /**
     * Reads an unsigned 64-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readU64(be?: boolean): bigint;
    /**
     * Reads a 128-bit unsigned integer. By default, read big-endian.
     * @param be - Endianness; true => big-endian (default).
     */
    readU128(be?: boolean): bigint;
    /**
     * Reads a 256-bit unsigned integer. Same approach as readU128.
     * @param be - Endianness; true => big-endian (default).
     */
    readU256(be?: boolean): bigint;
    /**
     * Reads a 128-bit signed integer. Interpret the sign bit if big-endian.
     * @param be - Endianness; true => big-endian (default).
     */
    readI128(be?: boolean): bigint;
    /**
     * Read a boolean (u8 != 0).
     */
    readBoolean(): boolean;
    /**
     * Reads 32 bits
     */
    readSelector(): Selector;
    /**
     * Reads a raw sequence of bytes (length must be known).
     * If zeroStop = true, stops if we encounter 0x00 early.
     */
    readBytes(length: u32, zeroStop?: boolean): Uint8Array;
    /**
     * Reads a string of the given length in raw bytes. By default, do NOT zero-stop
     * (matching how we wrote the raw bytes).
     */
    readString(length: u32): string;
    /**
     * Reads a string that was written as [u16 length][raw bytes].
     */
    readStringWithLength(be?: boolean): string;
    /**
     * Reads an address (32 bytes MLDSA key hash only).
     */
    readAddress(): Address;
    /**
     * Reads the tweaked public key portion (32 bytes) and returns it as a raw Uint8Array.
     * Use this when you only need the tweaked key without the full Address object.
     */
    readTweakedPublicKey(): Uint8Array;
    /**
     * Reads a full address with both MLDSA key hash and tweaked public key (64 bytes total).
     * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
     *
     * This is the equivalent of btc-runtime's readExtendedAddress().
     *
     * @returns An Address instance with both keys set
     */
    readExtendedAddress(): Address;
    /**
     * Reads a Schnorr signature with its associated full Address.
     * Format: [64 bytes full Address][64 bytes signature]
     *
     * Used for deserializing signed data where both the signer's address
     * and their Schnorr signature are stored together.
     *
     * @returns A SchnorrSignature containing the address and signature
     */
    readSchnorrSignature(): SchnorrSignature;
    /**
     * Reads bytes written as [u32 length][bytes].
     * @param maxLength if > 0, enforces an upper bound
     * @param be
     */
    readBytesWithLength(maxLength?: number, be?: boolean): Uint8Array;
    readArrayOfBuffer(be?: boolean): Uint8Array[];
    readAddressArray(be?: boolean): Address[];
    readU256Array(be?: boolean): bigint[];
    readU128Array(be?: boolean): bigint[];
    readU64Array(be?: boolean): bigint[];
    readU32Array(be?: boolean): u32[];
    readU16Array(be?: boolean): u16[];
    readU8Array(): u8[];
    readStringArray(be?: boolean): string[];
    readBytesArray(be?: boolean): Uint8Array[];
    /**
     * Reads [u16 length][ (address, u256) pairs ].
     */
    readAddressValueTuple(be?: boolean): AddressMap<bigint>;
    /**
     * Reads an array of full addresses (64 bytes each).
     * Format: [u16 length][FullAddress 0][FullAddress 1]...
     */
    readExtendedAddressArray(be?: boolean): Address[];
    /**
     * Reads a map of full Address -> u256 using the tweaked key for map lookup.
     * Format: [u16 length][FullAddress key][u256 value]...
     *
     * This is the equivalent of btc-runtime's readExtendedAddressMapU256().
     */
    readExtendedAddressMapU256(be?: boolean): ExtendedAddressMap<bigint>;
    getOffset(): u16;
    setOffset(offset: u16): void;
    /**
     * Verifies we have enough bytes in the buffer to read up to `size`.
     */
    verifyEnd(size: number): void;
    /**
     * Utility: reverses a byte array in-place or returns a reversed copy.
     */
    private reverseBytes;
    /**
     * Utility: turn bytes into a hex string without `0x` prefix.
     */
    private toHexString;
}
//# sourceMappingURL=BinaryReader.d.ts.map