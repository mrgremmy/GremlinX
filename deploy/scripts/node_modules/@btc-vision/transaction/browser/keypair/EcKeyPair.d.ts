import { BIP32API, BIP32Interface, MLDSAKeyPair, MLDSASecurityLevel } from '../../node_modules/@btc-vision/bip32/src/cjs/index.cjs';
import { Network, PrivateKey, PublicKey, Signer, XOnlyPublicKey } from '../../node_modules/@btc-vision/bitcoin/browser/index.js';
import { ECPairSigner, UniversalSigner } from '@btc-vision/ecpair';
import { IWallet } from './interfaces/IWallet.js';
/**
 * Class for handling EC key pairs
 * @class EcKeyPair
 * @module EcKeyPair
 * @typicalname EcKeyPair
 * @example import { EcKeyPair } from '@btc-vision/transaction';
 */
export declare class EcKeyPair {
    static BIP32: BIP32API;
    static ECPairSigner: typeof ECPairSigner;
    /**
     * Generate a keypair from a WIF
     * @param {string} wif - The WIF to use
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated keypair
     */
    static fromWIF(wif: string, network?: Network): UniversalSigner;
    /**
     * Generate a keypair from a private key
     * @param {Uint8Array} privateKey - The private key to use
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated keypair
     */
    static fromPrivateKey(privateKey: Uint8Array | PrivateKey, network?: Network): UniversalSigner;
    /**
     * Generate a keypair from a public key
     * @param {Uint8Array} publicKey - The public key to use
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated keypair
     */
    static fromPublicKey(publicKey: Uint8Array | PublicKey, network?: Network): UniversalSigner;
    /**
     * Generate a multi-sig address
     * @param {Uint8Array[]} pubKeys - The public keys to use
     * @param {number} minimumSignatureRequired - The minimum number of signatures required
     * @param {Network} network - The network to use
     * @returns {string} - The generated address
     * @throws {Error} - If the address cannot be generated
     */
    static generateMultiSigAddress(pubKeys: Uint8Array[] | PublicKey[], minimumSignatureRequired: number, network?: Network): string;
    /**
     * Verify public keys and return the public keys
     * @param {Uint8Array[]} pubKeys - The public keys to verify
     * @param {Network} network - The network to use
     * @returns {Uint8Array[]} - The verified public keys
     * @throws {Error} - If the key cannot be regenerated
     */
    static verifyPubKeys(pubKeys: Uint8Array[], network?: Network): Uint8Array[];
    /**
     * Get a P2WPKH address from a keypair
     * @param {UniversalSigner} keyPair - The keypair to get the address for
     * @param {Network} network - The network to use
     * @returns {string} - The address
     */
    static getP2WPKHAddress(keyPair: UniversalSigner | Signer, network?: Network): string;
    /**
     * Get the address of a tweaked public key
     * @param {string} tweakedPubKeyHex - The tweaked public key hex string
     * @param {Network} network - The network to use
     * @returns {string} - The address
     * @throws {Error} - If the address cannot be generated
     */
    static tweakedPubKeyToAddress(tweakedPubKeyHex: string, network: Network): string;
    /**
     * Get the address of a tweaked public key
     * @param {Uint8Array} tweakedPubKeyBuffer - The tweaked public key buffer
     * @param {Network} network - The network to use
     * @returns {string} - The address
     * @throws {Error} - If the address cannot be generated
     */
    static tweakedPubKeyBufferToAddress(tweakedPubKeyBuffer: XOnlyPublicKey, network: Network): string;
    /**
     * Generate a P2OP address
     * @param bytes - The bytes to use for the P2OP address
     * @param network - The network to use
     * @param deploymentVersion - The deployment version (default is 0)
     * @returns {string} - The generated P2OP address
     */
    static p2op(bytes: Uint8Array, network?: Network, deploymentVersion?: number): string;
    /**
     * Get the address of a xOnly tweaked public key
     * @param {string} tweakedPubKeyHex - The xOnly tweaked public key hex string
     * @param {Network} network - The network to use
     * @returns {string} - The address
     * @throws {Error} - If the address cannot be generated
     */
    static xOnlyTweakedPubKeyToAddress(tweakedPubKeyHex: string, network: Network): string;
    /**
     * Tweak a public key
     * @param {Uint8Array | string} pub - The public key to tweak
     * @returns {Uint8Array} - The tweaked public key
     * @throws {Error} - If the public key cannot be tweaked
     */
    static tweakPublicKey(pub: Uint8Array | string): Uint8Array;
    /**
     * Tweak a batch of public keys
     * @param {readonly Uint8Array[]} pubkeys - The public keys to tweak
     * @param {bigint} tweakScalar - The scalar to use for tweaking
     * @returns {Uint8Array[]} - The tweaked public keys
     */
    static tweakBatchSharedT(pubkeys: readonly Uint8Array[], tweakScalar: bigint): Uint8Array[];
    /**
     * Generate a random wallet with both classical and quantum keys
     *
     * @param network - The network to use
     * @param securityLevel - The ML-DSA security level for quantum keys (default: LEVEL2/44)
     * @returns An object containing both classical and quantum key information
     */
    static generateWallet(network?: Network, securityLevel?: MLDSASecurityLevel): IWallet;
    /**
     * Generate a random quantum ML-DSA keypair
     *
     * This creates a standalone quantum-resistant keypair without using BIP32 derivation.
     * The keys are generated using cryptographically secure random bytes.
     *
     * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
     * @param network - The Bitcoin network (default: bitcoin mainnet)
     * @returns A random ML-DSA keypair
     */
    static generateQuantumKeyPair(securityLevel?: MLDSASecurityLevel, network?: Network): MLDSAKeyPair;
    /**
     * Verify that a contract address is a valid p2tr address
     * @param {string} contractAddress - The contract address to verify
     * @param {Network} network - The network to use
     * @returns {boolean} - Whether the address is valid
     */
    static verifyContractAddress(contractAddress: string, network?: Network): boolean;
    /**
     * Get the legacy segwit address from a keypair
     * @param {UniversalSigner} keyPair - The keypair to get the address for
     * @param {Network} network - The network to use
     * @returns {string} - The legacy address
     */
    static getLegacySegwitAddress(keyPair: UniversalSigner, network?: Network): string;
    /**
     * Get the legacy address from a keypair
     * @param {UniversalSigner} keyPair - The keypair to get the address for
     * @param {Network} network - The network to use
     * @returns {string} - The legacy address
     */
    static getLegacyAddress(keyPair: UniversalSigner, network?: Network): string;
    /**
     * Get the legacy address from a public key
     * @param publicKey
     * @param {Network} network - The network to use
     * @returns {string} - The legacy address
     */
    static getP2PKH(publicKey: PublicKey, network?: Network): string;
    /**
     * Get the P2PK output from a keypair
     * @param {UniversalSigner} keyPair - The keypair to get the address for
     * @param {Network} network - The network to use
     * @returns {string} - The legacy address
     */
    static getP2PKAddress(keyPair: UniversalSigner, network?: Network): string;
    /**
     * Generate a random keypair
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated keypair
     */
    static generateRandomKeyPair(network?: Network): UniversalSigner;
    /**
     * Generate a BIP32 keypair from a seed
     * @param {Uint8Array} seed - The seed to generate the keypair from
     * @param {Network} network - The network to use
     * @returns {BIP32Interface} - The generated keypair
     */
    static fromSeed(seed: Uint8Array, network?: Network): BIP32Interface;
    /**
     * Get taproot address from keypair
     * @param {UniversalSigner | Signer} keyPair - The keypair to get the taproot address for
     * @param {Network} network - The network to use
     * @returns {string} - The taproot address
     */
    static getTaprootAddress(keyPair: UniversalSigner | Signer, network?: Network): string;
    /**
     * Get taproot address from address
     * @param {string} inAddr - The address to convert to taproot
     * @param {Network} network - The network to use
     * @returns {string} - The taproot address
     */
    static getTaprootAddressFromAddress(inAddr: string, network?: Network): string;
    /**
     * Get a keypair from a given seed.
     * @param {Uint8Array} seed - The seed to generate the key pair from
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated key pair
     */
    static fromSeedKeyPair(seed: Uint8Array, network?: Network): UniversalSigner;
}
//# sourceMappingURL=EcKeyPair.d.ts.map