import { o as ht, p as it, d as V, q as lt, e as J, t as de, c as Mt, u as ae, i as Kt, s as he } from "./noble-hashes.js";
const Rt = /* @__PURE__ */ BigInt(0), Bt = /* @__PURE__ */ BigInt(1);
function dt(n, t = "") {
  if (typeof n != "boolean") {
    const r = t && `"${t}" `;
    throw new Error(r + "expected boolean, got type=" + typeof n);
  }
  return n;
}
function zt(n) {
  if (typeof n == "bigint") {
    if (!ut(n))
      throw new Error("positive bigint expected, got " + n);
  } else
    it(n);
  return n;
}
function ct(n) {
  const t = zt(n).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function Ct(n) {
  if (typeof n != "string")
    throw new Error("hex string expected, got " + typeof n);
  return n === "" ? Rt : BigInt("0x" + n);
}
function wt(n) {
  return Ct(ht(n));
}
function Ht(n) {
  return Ct(ht(we(V(n)).reverse()));
}
function xt(n, t) {
  it(t), n = zt(n);
  const r = lt(n.toString(16).padStart(t * 2, "0"));
  if (r.length !== t)
    throw new Error("number too large");
  return r;
}
function Xt(n, t) {
  return xt(n, t).reverse();
}
function we(n) {
  return Uint8Array.from(n);
}
const ut = (n) => typeof n == "bigint" && Rt <= n;
function ge(n, t, r) {
  return ut(n) && ut(t) && ut(r) && t <= n && n < r;
}
function me(n, t, r, e) {
  if (!ge(t, r, e))
    throw new Error("expected valid " + n + ": " + r + " <= n < " + e + ", got " + t);
}
function be(n) {
  let t;
  for (t = 0; n > Rt; n >>= Bt, t += 1)
    ;
  return t;
}
const St = (n) => (Bt << BigInt(n)) - Bt;
function Ee(n, t, r) {
  if (it(n, "hashLen"), it(t, "qByteLen"), typeof r != "function")
    throw new Error("hmacFn must be a function");
  const e = (R) => new Uint8Array(R), o = Uint8Array.of(), s = Uint8Array.of(0), i = Uint8Array.of(1), u = 1e3;
  let c = e(n), a = e(n), w = 0;
  const S = () => {
    c.fill(1), a.fill(0), w = 0;
  }, q = (...R) => r(a, J(c, ...R)), B = (R = o) => {
    a = q(s, R), c = q(), R.length !== 0 && (a = q(i, R), c = q());
  }, v = () => {
    if (w++ >= u)
      throw new Error("drbg: tried max amount of iterations");
    let R = 0;
    const N = [];
    for (; R < t; ) {
      c = q();
      const T = c.slice();
      N.push(T), R += c.length;
    }
    return J(...N);
  };
  return (R, N) => {
    S(), B(R);
    let T;
    for (; !(T = N(v())); )
      B();
    return S(), T;
  };
}
function Ot(n, t = {}, r = {}) {
  if (!n || typeof n != "object")
    throw new Error("expected valid options object");
  function e(s, i, u) {
    const c = n[s];
    if (u && c === void 0)
      return;
    const a = typeof c;
    if (a !== i || c === null)
      throw new Error(`param "${s}" is invalid: expected ${i}, got ${a}`);
  }
  const o = (s, i) => Object.entries(s).forEach(([u, c]) => e(u, c, i));
  o(t, !1), o(r, !0);
}
function At(n) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...e) => {
    const o = t.get(r);
    if (o !== void 0)
      return o;
    const s = n(r, ...e);
    return t.set(r, s), s;
  };
}
function qt(n) {
  if (!Number.isSafeInteger(n) || n < 0 || n > 4294967295)
    throw new Error("wrong u32 integer:" + n);
  return n;
}
function Gt(n) {
  return qt(n), (n & n - 1) === 0 && n !== 0;
}
function ye(n, t) {
  qt(n);
  let r = 0;
  for (let e = 0; e < t; e++, n >>>= 1)
    r = r << 1 | n & 1;
  return r;
}
function Wt(n) {
  return qt(n), 31 - Math.clz32(n);
}
function Lt(n) {
  const t = n.length;
  if (t < 2 || !Gt(t))
    throw new Error("n must be a power of 2 and greater than 1. Got " + t);
  const r = Wt(t);
  for (let e = 0; e < t; e++) {
    const o = ye(e, r);
    if (e < o) {
      const s = n[e];
      n[e] = n[o], n[o] = s;
    }
  }
  return n;
}
const Ce = (n, t) => {
  const { N: r, roots: e, dit: o, invertButterflies: s = !1, skipStages: i = 0, brp: u = !0 } = t, c = Wt(r);
  if (!Gt(r))
    throw new Error("FFT: Polynomial size should be power of two");
  const a = o !== s;
  return (w) => {
    if (w.length !== r)
      throw new Error("FFT: wrong Polynomial length");
    o && u && Lt(w);
    for (let S = 0, q = 1; S < c - i; S++) {
      const B = o ? S + 1 + i : c - S, v = 1 << B, _ = v >> 1, R = r >> B;
      for (let N = 0; N < r; N += v)
        for (let T = 0, C = q++; T < _; T++) {
          const Y = s ? o ? r - C : C : T * R, K = N + T, M = N + T + _, F = e[Y], H = w[M], x = w[K];
          if (a) {
            const P = n.mul(H, F);
            w[K] = n.add(x, P), w[M] = n.sub(x, P);
          } else s ? (w[K] = n.add(H, x), w[M] = n.mul(n.sub(H, x), F)) : (w[K] = n.add(x, H), w[M] = n.mul(n.sub(x, H), F));
        }
    }
    return !o && u && Lt(w), w;
  };
};
const j = /* @__PURE__ */ BigInt(0), $ = /* @__PURE__ */ BigInt(1), et = /* @__PURE__ */ BigInt(2), Qt = /* @__PURE__ */ BigInt(3), Jt = /* @__PURE__ */ BigInt(4), Ft = /* @__PURE__ */ BigInt(5), Be = /* @__PURE__ */ BigInt(7), Pt = /* @__PURE__ */ BigInt(8), pe = /* @__PURE__ */ BigInt(9), te = /* @__PURE__ */ BigInt(16);
function X(n, t) {
  const r = n % t;
  return r >= j ? r : t + r;
}
function z(n, t, r) {
  let e = n;
  for (; t-- > j; )
    e *= e, e %= r;
  return e;
}
function Dt(n, t) {
  if (n === j)
    throw new Error("invert: expected non-zero number");
  if (t <= j)
    throw new Error("invert: expected positive modulus, got " + t);
  let r = X(n, t), e = t, o = j, s = $;
  for (; r !== j; ) {
    const u = e / r, c = e % r, a = o - s * u;
    e = r, r = c, o = s, s = a;
  }
  if (e !== $)
    throw new Error("invert: does not exist");
  return X(o, t);
}
function It(n, t, r) {
  if (!n.eql(n.sqr(t), r))
    throw new Error("Cannot find square root");
}
function ee(n, t) {
  const r = (n.ORDER + $) / Jt, e = n.pow(t, r);
  return It(n, e, t), e;
}
function ve(n, t) {
  const r = (n.ORDER - Ft) / Pt, e = n.mul(t, et), o = n.pow(e, r), s = n.mul(t, o), i = n.mul(n.mul(s, et), o), u = n.mul(s, n.sub(i, n.ONE));
  return It(n, u, t), u;
}
function Re(n) {
  const t = gt(n), r = ne(n), e = r(t, t.neg(t.ONE)), o = r(t, e), s = r(t, t.neg(e)), i = (n + Be) / te;
  return (u, c) => {
    let a = u.pow(c, i), w = u.mul(a, e);
    const S = u.mul(a, o), q = u.mul(a, s), B = u.eql(u.sqr(w), c), v = u.eql(u.sqr(S), c);
    a = u.cmov(a, w, B), w = u.cmov(q, S, v);
    const _ = u.eql(u.sqr(w), c), R = u.cmov(a, w, _);
    return It(u, R, c), R;
  };
}
function ne(n) {
  if (n < Qt)
    throw new Error("sqrt is not defined for small field");
  let t = n - $, r = 0;
  for (; t % et === j; )
    t /= et, r++;
  let e = et;
  const o = gt(n);
  for (; Tt(o, e) === 1; )
    if (e++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (r === 1)
    return ee;
  let s = o.pow(e, t);
  const i = (t + $) / et;
  return function(c, a) {
    if (c.is0(a))
      return a;
    if (Tt(c, a) !== 1)
      throw new Error("Cannot find square root");
    let w = r, S = c.mul(c.ONE, s), q = c.pow(a, t), B = c.pow(a, i);
    for (; !c.eql(q, c.ONE); ) {
      if (c.is0(q))
        return c.ZERO;
      let v = 1, _ = c.sqr(q);
      for (; !c.eql(_, c.ONE); )
        if (v++, _ = c.sqr(_), v === w)
          throw new Error("Cannot find square root");
      const R = $ << BigInt(w - v - 1), N = c.pow(S, R);
      w = v, S = c.sqr(N), q = c.mul(q, S), B = c.mul(B, N);
    }
    return B;
  };
}
function xe(n) {
  return n % Jt === Qt ? ee : n % Pt === Ft ? ve : n % te === pe ? Re(n) : ne(n);
}
const Se = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Oe(n) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, r = Se.reduce((e, o) => (e[o] = "function", e), t);
  return Ot(n, r), n;
}
function qe(n, t, r) {
  if (r < j)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === j)
    return n.ONE;
  if (r === $)
    return t;
  let e = n.ONE, o = t;
  for (; r > j; )
    r & $ && (e = n.mul(e, o)), o = n.sqr(o), r >>= $;
  return e;
}
function re(n, t, r = !1) {
  const e = new Array(t.length).fill(r ? n.ZERO : void 0), o = t.reduce((i, u, c) => n.is0(u) ? i : (e[c] = i, n.mul(i, u)), n.ONE), s = n.inv(o);
  return t.reduceRight((i, u, c) => n.is0(u) ? i : (e[c] = n.mul(i, e[c]), n.mul(i, u)), s), e;
}
function Tt(n, t) {
  const r = (n.ORDER - $) / et, e = n.pow(t, r), o = n.eql(e, n.ONE), s = n.eql(e, n.ZERO), i = n.eql(e, n.neg(n.ONE));
  if (!o && !s && !i)
    throw new Error("invalid Legendre symbol result");
  return o ? 1 : s ? 0 : -1;
}
function Ie(n, t) {
  t !== void 0 && it(t);
  const r = t !== void 0 ? t : n.toString(2).length, e = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: e };
}
class Ne {
  ORDER;
  BITS;
  BYTES;
  isLE;
  ZERO = j;
  ONE = $;
  _lengths;
  _sqrt;
  // cached sqrt
  _mod;
  constructor(t, r = {}) {
    if (t <= j)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let e;
    this.isLE = !1, r != null && typeof r == "object" && (typeof r.BITS == "number" && (e = r.BITS), typeof r.sqrt == "function" && (this.sqrt = r.sqrt), typeof r.isLE == "boolean" && (this.isLE = r.isLE), r.allowedLengths && (this._lengths = r.allowedLengths?.slice()), typeof r.modFromBytes == "boolean" && (this._mod = r.modFromBytes));
    const { nBitLength: o, nByteLength: s } = Ie(t, e);
    if (s > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = o, this.BYTES = s, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return X(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return j <= t && t < this.ORDER;
  }
  is0(t) {
    return t === j;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & $) === $;
  }
  neg(t) {
    return X(-t, this.ORDER);
  }
  eql(t, r) {
    return t === r;
  }
  sqr(t) {
    return X(t * t, this.ORDER);
  }
  add(t, r) {
    return X(t + r, this.ORDER);
  }
  sub(t, r) {
    return X(t - r, this.ORDER);
  }
  mul(t, r) {
    return X(t * r, this.ORDER);
  }
  pow(t, r) {
    return qe(this, t, r);
  }
  div(t, r) {
    return X(t * Dt(r, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, r) {
    return t + r;
  }
  subN(t, r) {
    return t - r;
  }
  mulN(t, r) {
    return t * r;
  }
  inv(t) {
    return Dt(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = xe(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? Xt(t, this.BYTES) : xt(t, this.BYTES);
  }
  fromBytes(t, r = !1) {
    V(t);
    const { _lengths: e, BYTES: o, isLE: s, ORDER: i, _mod: u } = this;
    if (e) {
      if (!e.includes(t.length) || t.length > o)
        throw new Error("Field.fromBytes: expected " + e + " bytes, got " + t.length);
      const a = new Uint8Array(o);
      a.set(t, s ? 0 : a.length - t.length), t = a;
    }
    if (t.length !== o)
      throw new Error("Field.fromBytes: expected " + o + " bytes, got " + t.length);
    let c = s ? Ht(t) : wt(t);
    if (u && (c = X(c, i)), !r && !this.isValid(c))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return c;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return re(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, r, e) {
    return e ? r : t;
  }
}
function gt(n, t = {}) {
  return new Ne(n, t);
}
function oe(n) {
  if (typeof n != "bigint")
    throw new Error("field order must be bigint");
  const t = n.toString(2).length;
  return Math.ceil(t / 8);
}
function ie(n) {
  const t = oe(n);
  return t + Math.ceil(t / 2);
}
function _e(n, t, r = !1) {
  V(n);
  const e = n.length, o = oe(t), s = ie(t);
  if (e < 16 || e < s || e > 1024)
    throw new Error("expected " + s + "-1024 bytes of input, got " + e);
  const i = r ? Ht(n) : wt(n), u = X(i, t - $) + $;
  return r ? Xt(u, o) : xt(u, o);
}
const ot = /* @__PURE__ */ BigInt(0), nt = /* @__PURE__ */ BigInt(1);
function at(n, t) {
  const r = t.negate();
  return n ? r : t;
}
function Ut(n, t) {
  const r = re(n.Fp, t.map((e) => e.Z));
  return t.map((e, o) => n.fromAffine(e.toAffine(r[o])));
}
function se(n, t) {
  if (!Number.isSafeInteger(n) || n <= 0 || n > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + n);
}
function mt(n, t) {
  se(n, t);
  const r = Math.ceil(t / n) + 1, e = 2 ** (n - 1), o = 2 ** n, s = St(n), i = BigInt(n);
  return { windows: r, windowSize: e, mask: s, maxNumber: o, shiftBy: i };
}
function Yt(n, t, r) {
  const { windowSize: e, mask: o, maxNumber: s, shiftBy: i } = r;
  let u = Number(n & o), c = n >> i;
  u > e && (u -= s, c += nt);
  const a = t * e, w = a + Math.abs(u) - 1, S = u === 0, q = u < 0, B = t % 2 !== 0;
  return { nextN: c, offset: w, isZero: S, isNeg: q, isNegF: B, offsetF: a };
}
const bt = /* @__PURE__ */ new WeakMap(), ce = /* @__PURE__ */ new WeakMap();
function Et(n) {
  return ce.get(n) || 1;
}
function kt(n) {
  if (n !== ot)
    throw new Error("invalid wNAF");
}
class Ze {
  BASE;
  ZERO;
  Fn;
  bits;
  // Parametrized with a given Point class (not individual point)
  constructor(t, r) {
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = r;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, r, e = this.ZERO) {
    let o = t;
    for (; r > ot; )
      r & nt && (e = e.add(o)), o = o.double(), r >>= nt;
    return e;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
   * - ùëä is the window size
   * - ùëõ is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, r) {
    const { windows: e, windowSize: o } = mt(r, this.bits), s = [];
    let i = t, u = i;
    for (let c = 0; c < e; c++) {
      u = i, s.push(u);
      for (let a = 1; a < o; a++)
        u = u.add(i), s.push(u);
      i = u.double();
    }
    return s;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, r, e) {
    if (!this.Fn.isValid(e))
      throw new Error("invalid scalar");
    let o = this.ZERO, s = this.BASE;
    const i = mt(t, this.bits);
    for (let u = 0; u < i.windows; u++) {
      const { nextN: c, offset: a, isZero: w, isNeg: S, isNegF: q, offsetF: B } = Yt(e, u, i);
      e = c, w ? s = s.add(at(q, r[B])) : o = o.add(at(S, r[a]));
    }
    return kt(e), { p: o, f: s };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, r, e, o = this.ZERO) {
    const s = mt(t, this.bits);
    for (let i = 0; i < s.windows && e !== ot; i++) {
      const { nextN: u, offset: c, isZero: a, isNeg: w } = Yt(e, i, s);
      if (e = u, !a) {
        const S = r[c];
        o = o.add(w ? S.negate() : S);
      }
    }
    return kt(e), o;
  }
  getPrecomputes(t, r, e) {
    let o = bt.get(r);
    return o || (o = this.precomputeWindow(r, t), t !== 1 && (typeof e == "function" && (o = e(o)), bt.set(r, o))), o;
  }
  cached(t, r, e) {
    const o = Et(t);
    return this.wNAF(o, this.getPrecomputes(o, t, e), r);
  }
  unsafe(t, r, e, o) {
    const s = Et(t);
    return s === 1 ? this._unsafeLadder(t, r, o) : this.wNAFUnsafe(s, this.getPrecomputes(s, t, e), r, o);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, r) {
    se(r, this.bits), ce.set(t, r), bt.delete(t);
  }
  hasCache(t) {
    return Et(t) !== 1;
  }
}
function Ae(n, t, r, e) {
  let o = t, s = n.ZERO, i = n.ZERO;
  for (; r > ot || e > ot; )
    r & nt && (s = s.add(o)), e & nt && (i = i.add(o)), o = o.double(), r >>= nt, e >>= nt;
  return { p1: s, p2: i };
}
function Vt(n, t, r) {
  if (t) {
    if (t.ORDER !== n)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Oe(t), t;
  } else
    return gt(n, { isLE: r });
}
function Le(n, t, r = {}, e) {
  if (e === void 0 && (e = n === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${n} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const a = t[c];
    if (!(typeof a == "bigint" && a > ot))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const o = Vt(t.p, r.Fp, e), s = Vt(t.n, r.Fn, e), u = ["Gx", "Gy", "a", "b"];
  for (const c of u)
    if (!o.isValid(t[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: o, Fn: s };
}
function De(n, t) {
  return function(e) {
    const o = n(e);
    return { secretKey: o, publicKey: t(o) };
  };
}
const $t = (n, t) => (n + (n >= 0 ? t : -t) / fe) / t;
function Te(n, t, r) {
  const [[e, o], [s, i]] = t, u = $t(i * n, r), c = $t(-o * n, r);
  let a = n - u * e - c * s, w = -u * o - c * i;
  const S = a < W, q = w < W;
  S && (a = -a), q && (w = -w);
  const B = St(Math.ceil(be(r) / 2)) + rt;
  if (a < W || a >= B || w < W || w >= B)
    throw new Error("splitScalar (endomorphism): failed, k=" + n);
  return { k1neg: S, k1: a, k2neg: q, k2: w };
}
function pt(n) {
  if (!["compact", "recovered", "der"].includes(n))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return n;
}
function yt(n, t) {
  const r = {};
  for (let e of Object.keys(t))
    r[e] = n[e] === void 0 ? t[e] : n[e];
  return dt(r.lowS, "lowS"), dt(r.prehash, "prehash"), r.format !== void 0 && pt(r.format), r;
}
class Ue extends Error {
  constructor(t = "") {
    super(t);
  }
}
const Q = {
  // asn.1 DER encoding utils
  Err: Ue,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (n, t) => {
      const { Err: r } = Q;
      if (n < 0 || n > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const e = t.length / 2, o = ct(e);
      if (o.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const s = e > 127 ? ct(o.length / 2 | 128) : "";
      return ct(n) + s + o + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(n, t) {
      const { Err: r } = Q;
      let e = 0;
      if (n < 0 || n > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[e++] !== n)
        throw new r("tlv.decode: wrong tlv");
      const o = t[e++], s = !!(o & 128);
      let i = 0;
      if (!s)
        i = o;
      else {
        const c = o & 127;
        if (!c)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const a = t.subarray(e, e + c);
        if (a.length !== c)
          throw new r("tlv.decode: length bytes not complete");
        if (a[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const w of a)
          i = i << 8 | w;
        if (e += c, i < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const u = t.subarray(e, e + i);
      if (u.length !== i)
        throw new r("tlv.decode: wrong value length");
      return { v: u, l: t.subarray(e + i) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(n) {
      const { Err: t } = Q;
      if (n < W)
        throw new t("integer: negative integers are not allowed");
      let r = ct(n);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(n) {
      const { Err: t } = Q;
      if (n[0] & 128)
        throw new t("invalid signature integer: negative");
      if (n[0] === 0 && !(n[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return wt(n);
    }
  },
  toSig(n) {
    const { Err: t, _int: r, _tlv: e } = Q, o = V(n, void 0, "signature"), { v: s, l: i } = e.decode(48, o);
    if (i.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: u, l: c } = e.decode(2, s), { v: a, l: w } = e.decode(2, c);
    if (w.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: r.decode(u), s: r.decode(a) };
  },
  hexFromSig(n) {
    const { _tlv: t, _int: r } = Q, e = t.encode(2, r.encode(n.r)), o = t.encode(2, r.encode(n.s)), s = e + o;
    return t.encode(48, s);
  }
}, W = BigInt(0), rt = BigInt(1), fe = BigInt(2), ft = BigInt(3), Ye = BigInt(4);
function ke(n, t = {}) {
  const r = Le("weierstrass", n, t), { Fp: e, Fn: o } = r;
  let s = r.CURVE;
  const { h: i, n: u } = s;
  Ot(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: c } = t;
  if (c && (!e.is0(s.a) || typeof c.beta != "bigint" || !Array.isArray(c.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const a = le(e, o);
  function w() {
    if (!e.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function S(I, d, l) {
    const { x: f, y: h } = d.toAffine(), m = e.toBytes(f);
    if (dt(l, "isCompressed"), l) {
      w();
      const E = !e.isOdd(h);
      return J(ue(E), m);
    } else
      return J(Uint8Array.of(4), m, e.toBytes(h));
  }
  function q(I) {
    V(I, void 0, "Point");
    const { publicKey: d, publicKeyUncompressed: l } = a, f = I.length, h = I[0], m = I.subarray(1);
    if (f === d && (h === 2 || h === 3)) {
      const E = e.fromBytes(m);
      if (!e.isValid(E))
        throw new Error("bad point: is not on curve, wrong x");
      const b = _(E);
      let g;
      try {
        g = e.sqrt(b);
      } catch (D) {
        const Z = D instanceof Error ? ": " + D.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + Z);
      }
      w();
      const y = e.isOdd(g);
      return (h & 1) === 1 !== y && (g = e.neg(g)), { x: E, y: g };
    } else if (f === l && h === 4) {
      const E = e.BYTES, b = e.fromBytes(m.subarray(0, E)), g = e.fromBytes(m.subarray(E, E * 2));
      if (!R(b, g))
        throw new Error("bad point: is not on curve");
      return { x: b, y: g };
    } else
      throw new Error(`bad point: got length ${f}, expected compressed=${d} or uncompressed=${l}`);
  }
  const B = t.toBytes || S, v = t.fromBytes || q;
  function _(I) {
    const d = e.sqr(I), l = e.mul(d, I);
    return e.add(e.add(l, e.mul(I, s.a)), s.b);
  }
  function R(I, d) {
    const l = e.sqr(d), f = _(I);
    return e.eql(l, f);
  }
  if (!R(s.Gx, s.Gy))
    throw new Error("bad curve params: generator point");
  const N = e.mul(e.pow(s.a, ft), Ye), T = e.mul(e.sqr(s.b), BigInt(27));
  if (e.is0(e.add(N, T)))
    throw new Error("bad curve params: a or b");
  function C(I, d, l = !1) {
    if (!e.isValid(d) || l && e.is0(d))
      throw new Error(`bad point coordinate ${I}`);
    return d;
  }
  function Y(I) {
    if (!(I instanceof x))
      throw new Error("Weierstrass Point expected");
  }
  function K(I) {
    if (!c || !c.basises)
      throw new Error("no endo");
    return Te(I, c.basises, o.ORDER);
  }
  const M = At((I, d) => {
    const { X: l, Y: f, Z: h } = I;
    if (e.eql(h, e.ONE))
      return { x: l, y: f };
    const m = I.is0();
    d == null && (d = m ? e.ONE : e.inv(h));
    const E = e.mul(l, d), b = e.mul(f, d), g = e.mul(h, d);
    if (m)
      return { x: e.ZERO, y: e.ZERO };
    if (!e.eql(g, e.ONE))
      throw new Error("invZ was invalid");
    return { x: E, y: b };
  }), F = At((I) => {
    if (I.is0()) {
      if (t.allowInfinityPoint && !e.is0(I.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: d, y: l } = I.toAffine();
    if (!e.isValid(d) || !e.isValid(l))
      throw new Error("bad point: x or y not field elements");
    if (!R(d, l))
      throw new Error("bad point: equation left != right");
    if (!I.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function H(I, d, l, f, h) {
    return l = new x(e.mul(l.X, I), l.Y, l.Z), d = at(f, d), l = at(h, l), d.add(l);
  }
  class x {
    // base / generator point
    static BASE = new x(s.Gx, s.Gy, e.ONE);
    // zero / infinity / identity point
    static ZERO = new x(e.ZERO, e.ONE, e.ZERO);
    // 0, 1, 0
    // math field
    static Fp = e;
    // scalar field
    static Fn = o;
    X;
    Y;
    Z;
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(d, l, f) {
      this.X = C("x", d), this.Y = C("y", l, !0), this.Z = C("z", f), Object.freeze(this);
    }
    static CURVE() {
      return s;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(d) {
      const { x: l, y: f } = d || {};
      if (!d || !e.isValid(l) || !e.isValid(f))
        throw new Error("invalid affine point");
      if (d instanceof x)
        throw new Error("projective point not allowed");
      return e.is0(l) && e.is0(f) ? x.ZERO : new x(l, f, e.ONE);
    }
    static fromBytes(d) {
      const l = x.fromAffine(v(V(d, void 0, "point")));
      return l.assertValidity(), l;
    }
    static fromHex(d) {
      return x.fromBytes(lt(d));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(d = 8, l = !0) {
      return tt.createCache(this, d), l || this.multiply(ft), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      F(this);
    }
    hasEvenY() {
      const { y: d } = this.toAffine();
      if (!e.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !e.isOdd(d);
    }
    /** Compare one point to another. */
    equals(d) {
      Y(d);
      const { X: l, Y: f, Z: h } = this, { X: m, Y: E, Z: b } = d, g = e.eql(e.mul(l, b), e.mul(m, h)), y = e.eql(e.mul(f, b), e.mul(E, h));
      return g && y;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new x(this.X, e.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: d, b: l } = s, f = e.mul(l, ft), { X: h, Y: m, Z: E } = this;
      let b = e.ZERO, g = e.ZERO, y = e.ZERO, p = e.mul(h, h), D = e.mul(m, m), Z = e.mul(E, E), O = e.mul(h, m);
      return O = e.add(O, O), y = e.mul(h, E), y = e.add(y, y), b = e.mul(d, y), g = e.mul(f, Z), g = e.add(b, g), b = e.sub(D, g), g = e.add(D, g), g = e.mul(b, g), b = e.mul(O, b), y = e.mul(f, y), Z = e.mul(d, Z), O = e.sub(p, Z), O = e.mul(d, O), O = e.add(O, y), y = e.add(p, p), p = e.add(y, p), p = e.add(p, Z), p = e.mul(p, O), g = e.add(g, p), Z = e.mul(m, E), Z = e.add(Z, Z), p = e.mul(Z, O), b = e.sub(b, p), y = e.mul(Z, D), y = e.add(y, y), y = e.add(y, y), new x(b, g, y);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(d) {
      Y(d);
      const { X: l, Y: f, Z: h } = this, { X: m, Y: E, Z: b } = d;
      let g = e.ZERO, y = e.ZERO, p = e.ZERO;
      const D = s.a, Z = e.mul(s.b, ft);
      let O = e.mul(l, m), A = e.mul(f, E), U = e.mul(h, b), G = e.add(l, f), L = e.add(m, E);
      G = e.mul(G, L), L = e.add(O, A), G = e.sub(G, L), L = e.add(l, h);
      let k = e.add(m, b);
      return L = e.mul(L, k), k = e.add(O, U), L = e.sub(L, k), k = e.add(f, h), g = e.add(E, b), k = e.mul(k, g), g = e.add(A, U), k = e.sub(k, g), p = e.mul(D, L), g = e.mul(Z, U), p = e.add(g, p), g = e.sub(A, p), p = e.add(A, p), y = e.mul(g, p), A = e.add(O, O), A = e.add(A, O), U = e.mul(D, U), L = e.mul(Z, L), A = e.add(A, U), U = e.sub(O, U), U = e.mul(D, U), L = e.add(L, U), O = e.mul(A, L), y = e.add(y, O), O = e.mul(k, L), g = e.mul(G, g), g = e.sub(g, O), O = e.mul(G, A), p = e.mul(k, p), p = e.add(p, O), new x(g, y, p);
    }
    subtract(d) {
      return this.add(d.negate());
    }
    is0() {
      return this.equals(x.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(d) {
      const { endo: l } = t;
      if (!o.isValidNot0(d))
        throw new Error("invalid scalar: out of range");
      let f, h;
      const m = (E) => tt.cached(this, E, (b) => Ut(x, b));
      if (l) {
        const { k1neg: E, k1: b, k2neg: g, k2: y } = K(d), { p, f: D } = m(b), { p: Z, f: O } = m(y);
        h = D.add(O), f = H(l.beta, p, Z, E, g);
      } else {
        const { p: E, f: b } = m(d);
        f = E, h = b;
      }
      return Ut(x, [f, h])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(d) {
      const { endo: l } = t, f = this;
      if (!o.isValid(d))
        throw new Error("invalid scalar: out of range");
      if (d === W || f.is0())
        return x.ZERO;
      if (d === rt)
        return f;
      if (tt.hasCache(this))
        return this.multiply(d);
      if (l) {
        const { k1neg: h, k1: m, k2neg: E, k2: b } = K(d), { p1: g, p2: y } = Ae(x, f, m, b);
        return H(l.beta, g, y, h, E);
      } else
        return tt.unsafe(f, d);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(d) {
      return M(this, d);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: d } = t;
      return i === rt ? !0 : d ? d(x, this) : tt.unsafe(this, u).is0();
    }
    clearCofactor() {
      const { clearCofactor: d } = t;
      return i === rt ? this : d ? d(x, this) : this.multiplyUnsafe(i);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(i).is0();
    }
    toBytes(d = !0) {
      return dt(d, "isCompressed"), this.assertValidity(), B(x, this, d);
    }
    toHex(d = !0) {
      return ht(this.toBytes(d));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const P = o.BITS, tt = new Ze(x, t.endo ? Math.ceil(P / 2) : P);
  return x.BASE.precompute(8), x;
}
function ue(n) {
  return Uint8Array.of(n ? 2 : 3);
}
function le(n, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + n.BYTES,
    publicKeyUncompressed: 1 + 2 * n.BYTES,
    publicKeyHasPrefix: !0,
    signature: 2 * t.BYTES
  };
}
function Ve(n, t = {}) {
  const { Fn: r } = n, e = t.randomBytes || Mt, o = Object.assign(le(n.Fp, r), { seed: ie(r.ORDER) });
  function s(B) {
    try {
      const v = r.fromBytes(B);
      return r.isValidNot0(v);
    } catch {
      return !1;
    }
  }
  function i(B, v) {
    const { publicKey: _, publicKeyUncompressed: R } = o;
    try {
      const N = B.length;
      return v === !0 && N !== _ || v === !1 && N !== R ? !1 : !!n.fromBytes(B);
    } catch {
      return !1;
    }
  }
  function u(B = e(o.seed)) {
    return _e(V(B, o.seed, "seed"), r.ORDER);
  }
  function c(B, v = !0) {
    return n.BASE.multiply(r.fromBytes(B)).toBytes(v);
  }
  function a(B) {
    const { secretKey: v, publicKey: _, publicKeyUncompressed: R } = o;
    if (!Kt(B) || "_lengths" in r && r._lengths || v === _)
      return;
    const N = V(B, void 0, "key").length;
    return N === _ || N === R;
  }
  function w(B, v, _ = !0) {
    if (a(B) === !0)
      throw new Error("first arg must be private key");
    if (a(v) === !1)
      throw new Error("second arg must be public key");
    const R = r.fromBytes(B);
    return n.fromBytes(v).multiply(R).toBytes(_);
  }
  const S = {
    isValidSecretKey: s,
    isValidPublicKey: i,
    randomSecretKey: u
  }, q = De(u, c);
  return Object.freeze({ getPublicKey: c, getSharedSecret: w, keygen: q, Point: n, utils: S, lengths: o });
}
function $e(n, t, r = {}) {
  de(t), Ot(r, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), r = Object.assign({}, r);
  const e = r.randomBytes || Mt, o = r.hmac || ((l, f) => ae(t, l, f)), { Fp: s, Fn: i } = n, { ORDER: u, BITS: c } = i, { keygen: a, getPublicKey: w, getSharedSecret: S, utils: q, lengths: B } = Ve(n, r), v = {
    prehash: !0,
    lowS: typeof r.lowS == "boolean" ? r.lowS : !0,
    format: "compact",
    extraEntropy: !1
  }, _ = u * fe < s.ORDER;
  function R(l) {
    const f = u >> rt;
    return l > f;
  }
  function N(l, f) {
    if (!i.isValidNot0(f))
      throw new Error(`invalid signature ${l}: out of range 1..Point.Fn.ORDER`);
    return f;
  }
  function T() {
    if (_)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function C(l, f) {
    pt(f);
    const h = B.signature, m = f === "compact" ? h : f === "recovered" ? h + 1 : void 0;
    return V(l, m);
  }
  class Y {
    r;
    s;
    recovery;
    constructor(f, h, m) {
      if (this.r = N("r", f), this.s = N("s", h), m != null) {
        if (T(), ![0, 1, 2, 3].includes(m))
          throw new Error("invalid recovery id");
        this.recovery = m;
      }
      Object.freeze(this);
    }
    static fromBytes(f, h = v.format) {
      C(f, h);
      let m;
      if (h === "der") {
        const { r: y, s: p } = Q.toSig(V(f));
        return new Y(y, p);
      }
      h === "recovered" && (m = f[0], h = "compact", f = f.subarray(1));
      const E = B.signature / 2, b = f.subarray(0, E), g = f.subarray(E, E * 2);
      return new Y(i.fromBytes(b), i.fromBytes(g), m);
    }
    static fromHex(f, h) {
      return this.fromBytes(lt(f), h);
    }
    assertRecovery() {
      const { recovery: f } = this;
      if (f == null)
        throw new Error("invalid recovery id: must be present");
      return f;
    }
    addRecoveryBit(f) {
      return new Y(this.r, this.s, f);
    }
    recoverPublicKey(f) {
      const { r: h, s: m } = this, E = this.assertRecovery(), b = E === 2 || E === 3 ? h + u : h;
      if (!s.isValid(b))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const g = s.toBytes(b), y = n.fromBytes(J(ue((E & 1) === 0), g)), p = i.inv(b), D = M(V(f, void 0, "msgHash")), Z = i.create(-D * p), O = i.create(m * p), A = n.BASE.multiplyUnsafe(Z).add(y.multiplyUnsafe(O));
      if (A.is0())
        throw new Error("invalid recovery: point at infinify");
      return A.assertValidity(), A;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return R(this.s);
    }
    toBytes(f = v.format) {
      if (pt(f), f === "der")
        return lt(Q.hexFromSig(this));
      const { r: h, s: m } = this, E = i.toBytes(h), b = i.toBytes(m);
      return f === "recovered" ? (T(), J(Uint8Array.of(this.assertRecovery()), E, b)) : J(E, b);
    }
    toHex(f) {
      return ht(this.toBytes(f));
    }
  }
  const K = r.bits2int || function(f) {
    if (f.length > 8192)
      throw new Error("input is too large");
    const h = wt(f), m = f.length * 8 - c;
    return m > 0 ? h >> BigInt(m) : h;
  }, M = r.bits2int_modN || function(f) {
    return i.create(K(f));
  }, F = St(c);
  function H(l) {
    return me("num < 2^" + c, l, W, F), i.toBytes(l);
  }
  function x(l, f) {
    return V(l, void 0, "message"), f ? V(t(l), void 0, "prehashed message") : l;
  }
  function P(l, f, h) {
    const { lowS: m, prehash: E, extraEntropy: b } = yt(h, v);
    l = x(l, E);
    const g = M(l), y = i.fromBytes(f);
    if (!i.isValidNot0(y))
      throw new Error("invalid private key");
    const p = [H(y), H(g)];
    if (b != null && b !== !1) {
      const A = b === !0 ? e(B.secretKey) : b;
      p.push(V(A, void 0, "extraEntropy"));
    }
    const D = J(...p), Z = g;
    function O(A) {
      const U = K(A);
      if (!i.isValidNot0(U))
        return;
      const G = i.inv(U), L = n.BASE.multiply(U).toAffine(), k = i.create(L.x);
      if (k === W)
        return;
      const st = i.create(G * i.create(Z + k * y));
      if (st === W)
        return;
      let _t = (L.x === k ? 0 : 2) | Number(L.y & rt), Zt = st;
      return m && R(st) && (Zt = i.neg(st), _t ^= 1), new Y(k, Zt, _ ? void 0 : _t);
    }
    return { seed: D, k2sig: O };
  }
  function tt(l, f, h = {}) {
    const { seed: m, k2sig: E } = P(l, f, h);
    return Ee(t.outputLen, i.BYTES, o)(m, E).toBytes(h.format);
  }
  function I(l, f, h, m = {}) {
    const { lowS: E, prehash: b, format: g } = yt(m, v);
    if (h = V(h, void 0, "publicKey"), f = x(f, b), !Kt(l)) {
      const y = l instanceof Y ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + y);
    }
    C(l, g);
    try {
      const y = Y.fromBytes(l, g), p = n.fromBytes(h);
      if (E && y.hasHighS())
        return !1;
      const { r: D, s: Z } = y, O = M(f), A = i.inv(Z), U = i.create(O * A), G = i.create(D * A), L = n.BASE.multiplyUnsafe(U).add(p.multiplyUnsafe(G));
      return L.is0() ? !1 : i.create(L.x) === D;
    } catch {
      return !1;
    }
  }
  function d(l, f, h = {}) {
    const { prehash: m } = yt(h, v);
    return f = x(f, m), Y.fromBytes(l, "recovered").recoverPublicKey(f).toBytes();
  }
  return Object.freeze({
    keygen: a,
    getPublicKey: w,
    getSharedSecret: S,
    utils: q,
    lengths: B,
    Point: n,
    sign: tt,
    verify: I,
    recoverPublicKey: d,
    Signature: Y,
    hash: t
  });
}
const Nt = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, je = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, jt = /* @__PURE__ */ BigInt(2);
function Me(n) {
  const t = Nt.p, r = BigInt(3), e = BigInt(6), o = BigInt(11), s = BigInt(22), i = BigInt(23), u = BigInt(44), c = BigInt(88), a = n * n * n % t, w = a * a * n % t, S = z(w, r, t) * w % t, q = z(S, r, t) * w % t, B = z(q, jt, t) * a % t, v = z(B, o, t) * B % t, _ = z(v, s, t) * v % t, R = z(_, u, t) * _ % t, N = z(R, c, t) * R % t, T = z(N, u, t) * _ % t, C = z(T, r, t) * w % t, Y = z(C, i, t) * v % t, K = z(Y, e, t) * a % t, M = z(K, jt, t);
  if (!vt.eql(vt.sqr(M), n))
    throw new Error("Cannot find square root");
  return M;
}
const vt = gt(Nt.p, { sqrt: Me }), Ke = /* @__PURE__ */ ke(Nt, {
  Fp: vt,
  endo: je
}), He = /* @__PURE__ */ $e(Ke, he);
export {
  Ce as F,
  dt as a,
  wt as b,
  X as m,
  ye as r,
  He as s
};
