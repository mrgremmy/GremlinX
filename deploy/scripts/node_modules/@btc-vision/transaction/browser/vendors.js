import { r as md, a as yd, b as vd, g as Lt, s as ys, c as wd, d as tr, e as Mn, i as _d, f as kd, h as nr, j as su, k as Ed, l as xd, m as Ad, n as Bd } from "./noble-hashes.js";
import { F as vs, r as zd, a as Sd } from "./noble-curves.js";
const Id = 4, ws = 0, _s = 1, Td = 2;
function Nt(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
const jd = 0, lu = 1, Od = 2, Rd = 3, Pd = 258, Fn = 29, pa = 256, ia = pa + 1 + Fn, It = 30, $n = 19, cu = 2 * ia + 1, nt = 15, xi = 16, Ud = 7, Kn = 256, uu = 16, fu = 17, du = 18, fn = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), Ca = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), Cd = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), hu = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Ld = 512, Ur = new Array((ia + 2) * 2);
Nt(Ur);
const ea = new Array(It * 2);
Nt(ea);
const oa = new Array(Ld);
Nt(oa);
const na = new Array(Pd - Rd + 1);
Nt(na);
const Hn = new Array(Fn);
Nt(Hn);
const Va = new Array(It);
Nt(Va);
function Ai(e, t, r, a, i) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = a, this.max_length = i, this.has_stree = e && e.length;
}
let pu, gu, bu;
function Bi(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
const mu = (e) => e < 256 ? oa[e] : oa[256 + (e >>> 7)], sa = (e, t) => {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
}, Ye = (e, t, r) => {
  e.bi_valid > xi - r ? (e.bi_buf |= t << e.bi_valid & 65535, sa(e, e.bi_buf), e.bi_buf = t >> xi - e.bi_valid, e.bi_valid += r - xi) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r);
}, Er = (e, t, r) => {
  Ye(
    e,
    r[t * 2],
    r[t * 2 + 1]
    /*.Len*/
  );
}, yu = (e, t) => {
  let r = 0;
  do
    r |= e & 1, e >>>= 1, r <<= 1;
  while (--t > 0);
  return r >>> 1;
}, Nd = (e) => {
  e.bi_valid === 16 ? (sa(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, qd = (e, t) => {
  const r = t.dyn_tree, a = t.max_code, i = t.stat_desc.static_tree, o = t.stat_desc.has_stree, s = t.stat_desc.extra_bits, n = t.stat_desc.extra_base, p = t.stat_desc.max_length;
  let d, u, w, y, k, A, E = 0;
  for (y = 0; y <= nt; y++)
    e.bl_count[y] = 0;
  for (r[e.heap[e.heap_max] * 2 + 1] = 0, d = e.heap_max + 1; d < cu; d++)
    u = e.heap[d], y = r[r[u * 2 + 1] * 2 + 1] + 1, y > p && (y = p, E++), r[u * 2 + 1] = y, !(u > a) && (e.bl_count[y]++, k = 0, u >= n && (k = s[u - n]), A = r[u * 2], e.opt_len += A * (y + k), o && (e.static_len += A * (i[u * 2 + 1] + k)));
  if (E !== 0) {
    do {
      for (y = p - 1; e.bl_count[y] === 0; )
        y--;
      e.bl_count[y]--, e.bl_count[y + 1] += 2, e.bl_count[p]--, E -= 2;
    } while (E > 0);
    for (y = p; y !== 0; y--)
      for (u = e.bl_count[y]; u !== 0; )
        w = e.heap[--d], !(w > a) && (r[w * 2 + 1] !== y && (e.opt_len += (y - r[w * 2 + 1]) * r[w * 2], r[w * 2 + 1] = y), u--);
  }
}, vu = (e, t, r) => {
  const a = new Array(nt + 1);
  let i = 0, o, s;
  for (o = 1; o <= nt; o++)
    i = i + r[o - 1] << 1, a[o] = i;
  for (s = 0; s <= t; s++) {
    let n = e[s * 2 + 1];
    n !== 0 && (e[s * 2] = yu(a[n]++, n));
  }
}, Dd = () => {
  let e, t, r, a, i;
  const o = new Array(nt + 1);
  for (r = 0, a = 0; a < Fn - 1; a++)
    for (Hn[a] = r, e = 0; e < 1 << fn[a]; e++)
      na[r++] = a;
  for (na[r - 1] = a, i = 0, a = 0; a < 16; a++)
    for (Va[a] = i, e = 0; e < 1 << Ca[a]; e++)
      oa[i++] = a;
  for (i >>= 7; a < It; a++)
    for (Va[a] = i << 7, e = 0; e < 1 << Ca[a] - 7; e++)
      oa[256 + i++] = a;
  for (t = 0; t <= nt; t++)
    o[t] = 0;
  for (e = 0; e <= 143; )
    Ur[e * 2 + 1] = 8, e++, o[8]++;
  for (; e <= 255; )
    Ur[e * 2 + 1] = 9, e++, o[9]++;
  for (; e <= 279; )
    Ur[e * 2 + 1] = 7, e++, o[7]++;
  for (; e <= 287; )
    Ur[e * 2 + 1] = 8, e++, o[8]++;
  for (vu(Ur, ia + 1, o), e = 0; e < It; e++)
    ea[e * 2 + 1] = 5, ea[e * 2] = yu(e, 5);
  pu = new Ai(Ur, fn, pa + 1, ia, nt), gu = new Ai(ea, Ca, 0, It, nt), bu = new Ai(new Array(0), Cd, 0, $n, Ud);
}, wu = (e) => {
  let t;
  for (t = 0; t < ia; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < It; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < $n; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[Kn * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, _u = (e) => {
  e.bi_valid > 8 ? sa(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, ks = (e, t, r, a) => {
  const i = t * 2, o = r * 2;
  return e[i] < e[o] || e[i] === e[o] && a[t] <= a[r];
}, zi = (e, t, r) => {
  const a = e.heap[r];
  let i = r << 1;
  for (; i <= e.heap_len && (i < e.heap_len && ks(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !ks(t, a, e.heap[i], e.depth)); )
    e.heap[r] = e.heap[i], r = i, i <<= 1;
  e.heap[r] = a;
}, Es = (e, t, r) => {
  let a, i, o = 0, s, n;
  if (e.sym_next !== 0)
    do
      a = e.pending_buf[e.sym_buf + o++] & 255, a += (e.pending_buf[e.sym_buf + o++] & 255) << 8, i = e.pending_buf[e.sym_buf + o++], a === 0 ? Er(e, i, t) : (s = na[i], Er(e, s + pa + 1, t), n = fn[s], n !== 0 && (i -= Hn[s], Ye(e, i, n)), a--, s = mu(a), Er(e, s, r), n = Ca[s], n !== 0 && (a -= Va[s], Ye(e, a, n)));
    while (o < e.sym_next);
  Er(e, Kn, t);
}, dn = (e, t) => {
  const r = t.dyn_tree, a = t.stat_desc.static_tree, i = t.stat_desc.has_stree, o = t.stat_desc.elems;
  let s, n, p = -1, d;
  for (e.heap_len = 0, e.heap_max = cu, s = 0; s < o; s++)
    r[s * 2] !== 0 ? (e.heap[++e.heap_len] = p = s, e.depth[s] = 0) : r[s * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    d = e.heap[++e.heap_len] = p < 2 ? ++p : 0, r[d * 2] = 1, e.depth[d] = 0, e.opt_len--, i && (e.static_len -= a[d * 2 + 1]);
  for (t.max_code = p, s = e.heap_len >> 1; s >= 1; s--)
    zi(e, r, s);
  d = o;
  do
    s = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], zi(
      e,
      r,
      1
      /*SMALLEST*/
    ), n = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = s, e.heap[--e.heap_max] = n, r[d * 2] = r[s * 2] + r[n * 2], e.depth[d] = (e.depth[s] >= e.depth[n] ? e.depth[s] : e.depth[n]) + 1, r[s * 2 + 1] = r[n * 2 + 1] = d, e.heap[
      1
      /*SMALLEST*/
    ] = d++, zi(
      e,
      r,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], qd(e, t), vu(r, p, e.bl_count);
}, xs = (e, t, r) => {
  let a, i = -1, o, s = t[1], n = 0, p = 7, d = 4;
  for (s === 0 && (p = 138, d = 3), t[(r + 1) * 2 + 1] = 65535, a = 0; a <= r; a++)
    o = s, s = t[(a + 1) * 2 + 1], !(++n < p && o === s) && (n < d ? e.bl_tree[o * 2] += n : o !== 0 ? (o !== i && e.bl_tree[o * 2]++, e.bl_tree[uu * 2]++) : n <= 10 ? e.bl_tree[fu * 2]++ : e.bl_tree[du * 2]++, n = 0, i = o, s === 0 ? (p = 138, d = 3) : o === s ? (p = 6, d = 3) : (p = 7, d = 4));
}, As = (e, t, r) => {
  let a, i = -1, o, s = t[1], n = 0, p = 7, d = 4;
  for (s === 0 && (p = 138, d = 3), a = 0; a <= r; a++)
    if (o = s, s = t[(a + 1) * 2 + 1], !(++n < p && o === s)) {
      if (n < d)
        do
          Er(e, o, e.bl_tree);
        while (--n !== 0);
      else o !== 0 ? (o !== i && (Er(e, o, e.bl_tree), n--), Er(e, uu, e.bl_tree), Ye(e, n - 3, 2)) : n <= 10 ? (Er(e, fu, e.bl_tree), Ye(e, n - 3, 3)) : (Er(e, du, e.bl_tree), Ye(e, n - 11, 7));
      n = 0, i = o, s === 0 ? (p = 138, d = 3) : o === s ? (p = 6, d = 3) : (p = 7, d = 4);
    }
}, Md = (e) => {
  let t;
  for (xs(e, e.dyn_ltree, e.l_desc.max_code), xs(e, e.dyn_dtree, e.d_desc.max_code), dn(e, e.bl_desc), t = $n - 1; t >= 3 && e.bl_tree[hu[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}, Fd = (e, t, r, a) => {
  let i;
  for (Ye(e, t - 257, 5), Ye(e, r - 1, 5), Ye(e, a - 4, 4), i = 0; i < a; i++)
    Ye(e, e.bl_tree[hu[i] * 2 + 1], 3);
  As(e, e.dyn_ltree, t - 1), As(e, e.dyn_dtree, r - 1);
}, $d = (e) => {
  let t = 4093624447, r;
  for (r = 0; r <= 31; r++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[r * 2] !== 0)
      return ws;
  if (e.dyn_ltree[18] !== 0 || e.dyn_ltree[20] !== 0 || e.dyn_ltree[26] !== 0)
    return _s;
  for (r = 32; r < pa; r++)
    if (e.dyn_ltree[r * 2] !== 0)
      return _s;
  return ws;
};
let Bs = !1;
const Kd = (e) => {
  Bs || (Dd(), Bs = !0), e.l_desc = new Bi(e.dyn_ltree, pu), e.d_desc = new Bi(e.dyn_dtree, gu), e.bl_desc = new Bi(e.bl_tree, bu), e.bi_buf = 0, e.bi_valid = 0, wu(e);
}, ku = (e, t, r, a) => {
  Ye(e, (jd << 1) + (a ? 1 : 0), 3), _u(e), sa(e, r), sa(e, ~r), r && e.pending_buf.set(e.window.subarray(t, t + r), e.pending), e.pending += r;
}, Hd = (e) => {
  Ye(e, lu << 1, 3), Er(e, Kn, Ur), Nd(e);
}, Zd = (e, t, r, a) => {
  let i, o, s = 0;
  e.level > 0 ? (e.strm.data_type === Td && (e.strm.data_type = $d(e)), dn(e, e.l_desc), dn(e, e.d_desc), s = Md(e), i = e.opt_len + 3 + 7 >>> 3, o = e.static_len + 3 + 7 >>> 3, o <= i && (i = o)) : i = o = r + 5, r + 4 <= i && t !== -1 ? ku(e, t, r, a) : e.strategy === Id || o === i ? (Ye(e, (lu << 1) + (a ? 1 : 0), 3), Es(e, Ur, ea)) : (Ye(e, (Od << 1) + (a ? 1 : 0), 3), Fd(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1), Es(e, e.dyn_ltree, e.dyn_dtree)), wu(e), a && _u(e);
}, Gd = (e, t, r) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = r, t === 0 ? e.dyn_ltree[r * 2]++ : (e.matches++, t--, e.dyn_ltree[(na[r] + pa + 1) * 2]++, e.dyn_dtree[mu(t) * 2]++), e.sym_next === e.sym_end);
var Vd = Kd, Wd = ku, Yd = Zd, Xd = Gd, Jd = Hd, Qd = {
  _tr_init: Vd,
  _tr_stored_block: Wd,
  _tr_flush_block: Yd,
  _tr_tally: Xd,
  _tr_align: Jd
};
const eh = (e, t, r, a) => {
  let i = e & 65535 | 0, o = e >>> 16 & 65535 | 0, s = 0;
  for (; r !== 0; ) {
    s = r > 2e3 ? 2e3 : r, r -= s;
    do
      i = i + t[a++] | 0, o = o + i | 0;
    while (--s);
    i %= 65521, o %= 65521;
  }
  return i | o << 16 | 0;
};
var la = eh;
const rh = () => {
  let e, t = [];
  for (var r = 0; r < 256; r++) {
    e = r;
    for (var a = 0; a < 8; a++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[r] = e;
  }
  return t;
}, th = new Uint32Array(rh()), ah = (e, t, r, a) => {
  const i = th, o = a + r;
  e ^= -1;
  for (let s = a; s < o; s++)
    e = e >>> 8 ^ i[(e ^ t[s]) & 255];
  return e ^ -1;
};
var Fe = ah, pt = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, ga = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: ih, _tr_stored_block: hn, _tr_flush_block: oh, _tr_tally: Xr, _tr_align: nh } = Qd, {
  Z_NO_FLUSH: Jr,
  Z_PARTIAL_FLUSH: sh,
  Z_FULL_FLUSH: lh,
  Z_FINISH: lr,
  Z_BLOCK: zs,
  Z_OK: Ke,
  Z_STREAM_END: Ss,
  Z_STREAM_ERROR: Br,
  Z_DATA_ERROR: ch,
  Z_BUF_ERROR: Si,
  Z_DEFAULT_COMPRESSION: uh,
  Z_FILTERED: fh,
  Z_HUFFMAN_ONLY: xa,
  Z_RLE: dh,
  Z_FIXED: hh,
  Z_DEFAULT_STRATEGY: ph,
  Z_UNKNOWN: gh,
  Z_DEFLATED: ui
} = ga, bh = 9, mh = 15, yh = 8, vh = 29, wh = 256, pn = wh + 1 + vh, _h = 30, kh = 19, Eh = 2 * pn + 1, xh = 15, _e = 3, Wr = 258, zr = Wr + _e + 1, Ah = 32, Ot = 42, Zn = 57, gn = 69, bn = 73, mn = 91, yn = 103, st = 113, Wt = 666, Ve = 1, qt = 2, gt = 3, Dt = 4, Bh = 3, lt = (e, t) => (e.msg = pt[t], t), Is = (e) => e * 2 - (e > 4 ? 9 : 0), Vr = (e) => {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}, zh = (e) => {
  let t, r, a, i = e.w_size;
  t = e.hash_size, a = t;
  do
    r = e.head[--a], e.head[a] = r >= i ? r - i : 0;
  while (--t);
  t = i, a = t;
  do
    r = e.prev[--a], e.prev[a] = r >= i ? r - i : 0;
  while (--t);
};
let Sh = (e, t, r) => (t << e.hash_shift ^ r) & e.hash_mask, Qr = Sh;
const Je = (e) => {
  const t = e.state;
  let r = t.pending;
  r > e.avail_out && (r = e.avail_out), r !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + r), e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, t.pending === 0 && (t.pending_out = 0));
}, rr = (e, t) => {
  oh(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, Je(e.strm);
}, Ee = (e, t) => {
  e.pending_buf[e.pending++] = t;
}, Ht = (e, t) => {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
}, vn = (e, t, r, a) => {
  let i = e.avail_in;
  return i > a && (i = a), i === 0 ? 0 : (e.avail_in -= i, t.set(e.input.subarray(e.next_in, e.next_in + i), r), e.state.wrap === 1 ? e.adler = la(e.adler, t, i, r) : e.state.wrap === 2 && (e.adler = Fe(e.adler, t, i, r)), e.next_in += i, e.total_in += i, i);
}, Eu = (e, t) => {
  let r = e.max_chain_length, a = e.strstart, i, o, s = e.prev_length, n = e.nice_match;
  const p = e.strstart > e.w_size - zr ? e.strstart - (e.w_size - zr) : 0, d = e.window, u = e.w_mask, w = e.prev, y = e.strstart + Wr;
  let k = d[a + s - 1], A = d[a + s];
  e.prev_length >= e.good_match && (r >>= 2), n > e.lookahead && (n = e.lookahead);
  do
    if (i = t, !(d[i + s] !== A || d[i + s - 1] !== k || d[i] !== d[a] || d[++i] !== d[a + 1])) {
      a += 2, i++;
      do
        ;
      while (d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && d[++a] === d[++i] && a < y);
      if (o = Wr - (y - a), a = y - Wr, o > s) {
        if (e.match_start = t, s = o, o >= n)
          break;
        k = d[a + s - 1], A = d[a + s];
      }
    }
  while ((t = w[t & u]) > p && --r !== 0);
  return s <= e.lookahead ? s : e.lookahead;
}, Rt = (e) => {
  const t = e.w_size;
  let r, a, i;
  do {
    if (a = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - zr) && (e.window.set(e.window.subarray(t, t + t - a), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), zh(e), a += t), e.strm.avail_in === 0)
      break;
    if (r = vn(e.strm, e.window, e.strstart + e.lookahead, a), e.lookahead += r, e.lookahead + e.insert >= _e)
      for (i = e.strstart - e.insert, e.ins_h = e.window[i], e.ins_h = Qr(e, e.ins_h, e.window[i + 1]); e.insert && (e.ins_h = Qr(e, e.ins_h, e.window[i + _e - 1]), e.prev[i & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = i, i++, e.insert--, !(e.lookahead + e.insert < _e)); )
        ;
  } while (e.lookahead < zr && e.strm.avail_in !== 0);
}, xu = (e, t) => {
  let r = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, a, i, o, s = 0, n = e.strm.avail_in;
  do {
    if (a = 65535, o = e.bi_valid + 42 >> 3, e.strm.avail_out < o || (o = e.strm.avail_out - o, i = e.strstart - e.block_start, a > i + e.strm.avail_in && (a = i + e.strm.avail_in), a > o && (a = o), a < r && (a === 0 && t !== lr || t === Jr || a !== i + e.strm.avail_in)))
      break;
    s = t === lr && a === i + e.strm.avail_in ? 1 : 0, hn(e, 0, 0, s), e.pending_buf[e.pending - 4] = a, e.pending_buf[e.pending - 3] = a >> 8, e.pending_buf[e.pending - 2] = ~a, e.pending_buf[e.pending - 1] = ~a >> 8, Je(e.strm), i && (i > a && (i = a), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + i), e.strm.next_out), e.strm.next_out += i, e.strm.avail_out -= i, e.strm.total_out += i, e.block_start += i, a -= i), a && (vn(e.strm, e.strm.output, e.strm.next_out, a), e.strm.next_out += a, e.strm.avail_out -= a, e.strm.total_out += a);
  } while (s === 0);
  return n -= e.strm.avail_in, n && (n >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= n && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - n, e.strm.next_in), e.strstart), e.strstart += n, e.insert += n > e.w_size - e.insert ? e.w_size - e.insert : n), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), s ? Dt : t !== Jr && t !== lr && e.strm.avail_in === 0 && e.strstart === e.block_start ? qt : (o = e.window_size - e.strstart, e.strm.avail_in > o && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, o += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), o > e.strm.avail_in && (o = e.strm.avail_in), o && (vn(e.strm, e.window, e.strstart, o), e.strstart += o, e.insert += o > e.w_size - e.insert ? e.w_size - e.insert : o), e.high_water < e.strstart && (e.high_water = e.strstart), o = e.bi_valid + 42 >> 3, o = e.pending_buf_size - o > 65535 ? 65535 : e.pending_buf_size - o, r = o > e.w_size ? e.w_size : o, i = e.strstart - e.block_start, (i >= r || (i || t === lr) && t !== Jr && e.strm.avail_in === 0 && i <= o) && (a = i > o ? o : i, s = t === lr && e.strm.avail_in === 0 && a === i ? 1 : 0, hn(e, e.block_start, a, s), e.block_start += a, Je(e.strm)), s ? gt : Ve);
}, Ii = (e, t) => {
  let r, a;
  for (; ; ) {
    if (e.lookahead < zr) {
      if (Rt(e), e.lookahead < zr && t === Jr)
        return Ve;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= _e && (e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + _e - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), r !== 0 && e.strstart - r <= e.w_size - zr && (e.match_length = Eu(e, r)), e.match_length >= _e)
      if (a = Xr(e, e.strstart - e.match_start, e.match_length - _e), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= _e) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + _e - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + 1]);
    else
      a = Xr(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (a && (rr(e, !1), e.strm.avail_out === 0))
      return Ve;
  }
  return e.insert = e.strstart < _e - 1 ? e.strstart : _e - 1, t === lr ? (rr(e, !0), e.strm.avail_out === 0 ? gt : Dt) : e.sym_next && (rr(e, !1), e.strm.avail_out === 0) ? Ve : qt;
}, _t = (e, t) => {
  let r, a, i;
  for (; ; ) {
    if (e.lookahead < zr) {
      if (Rt(e), e.lookahead < zr && t === Jr)
        return Ve;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= _e && (e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + _e - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = _e - 1, r !== 0 && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - zr && (e.match_length = Eu(e, r), e.match_length <= 5 && (e.strategy === fh || e.match_length === _e && e.strstart - e.match_start > 4096) && (e.match_length = _e - 1)), e.prev_length >= _e && e.match_length <= e.prev_length) {
      i = e.strstart + e.lookahead - _e, a = Xr(e, e.strstart - 1 - e.prev_match, e.prev_length - _e), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= i && (e.ins_h = Qr(e, e.ins_h, e.window[e.strstart + _e - 1]), r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = _e - 1, e.strstart++, a && (rr(e, !1), e.strm.avail_out === 0))
        return Ve;
    } else if (e.match_available) {
      if (a = Xr(e, 0, e.window[e.strstart - 1]), a && rr(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return Ve;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (a = Xr(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < _e - 1 ? e.strstart : _e - 1, t === lr ? (rr(e, !0), e.strm.avail_out === 0 ? gt : Dt) : e.sym_next && (rr(e, !1), e.strm.avail_out === 0) ? Ve : qt;
}, Ih = (e, t) => {
  let r, a, i, o;
  const s = e.window;
  for (; ; ) {
    if (e.lookahead <= Wr) {
      if (Rt(e), e.lookahead <= Wr && t === Jr)
        return Ve;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= _e && e.strstart > 0 && (i = e.strstart - 1, a = s[i], a === s[++i] && a === s[++i] && a === s[++i])) {
      o = e.strstart + Wr;
      do
        ;
      while (a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && a === s[++i] && i < o);
      e.match_length = Wr - (o - i), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= _e ? (r = Xr(e, 1, e.match_length - _e), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = Xr(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (rr(e, !1), e.strm.avail_out === 0))
      return Ve;
  }
  return e.insert = 0, t === lr ? (rr(e, !0), e.strm.avail_out === 0 ? gt : Dt) : e.sym_next && (rr(e, !1), e.strm.avail_out === 0) ? Ve : qt;
}, Th = (e, t) => {
  let r;
  for (; ; ) {
    if (e.lookahead === 0 && (Rt(e), e.lookahead === 0)) {
      if (t === Jr)
        return Ve;
      break;
    }
    if (e.match_length = 0, r = Xr(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (rr(e, !1), e.strm.avail_out === 0))
      return Ve;
  }
  return e.insert = 0, t === lr ? (rr(e, !0), e.strm.avail_out === 0 ? gt : Dt) : e.sym_next && (rr(e, !1), e.strm.avail_out === 0) ? Ve : qt;
};
function pr(e, t, r, a, i) {
  this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = a, this.func = i;
}
const Yt = [
  /*      good lazy nice chain */
  new pr(0, 0, 0, 0, xu),
  /* 0 store only */
  new pr(4, 4, 8, 4, Ii),
  /* 1 max speed, no lazy matches */
  new pr(4, 5, 16, 8, Ii),
  /* 2 */
  new pr(4, 6, 32, 32, Ii),
  /* 3 */
  new pr(4, 4, 16, 16, _t),
  /* 4 lazy matches */
  new pr(8, 16, 32, 32, _t),
  /* 5 */
  new pr(8, 16, 128, 128, _t),
  /* 6 */
  new pr(8, 32, 128, 256, _t),
  /* 7 */
  new pr(32, 128, 258, 1024, _t),
  /* 8 */
  new pr(32, 258, 258, 4096, _t)
  /* 9 max compression */
], jh = (e) => {
  e.window_size = 2 * e.w_size, Vr(e.head), e.max_lazy_match = Yt[e.level].max_lazy, e.good_match = Yt[e.level].good_length, e.nice_match = Yt[e.level].nice_length, e.max_chain_length = Yt[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = _e - 1, e.match_available = 0, e.ins_h = 0;
};
function Oh() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = ui, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Eh * 2), this.dyn_dtree = new Uint16Array((2 * _h + 1) * 2), this.bl_tree = new Uint16Array((2 * kh + 1) * 2), Vr(this.dyn_ltree), Vr(this.dyn_dtree), Vr(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(xh + 1), this.heap = new Uint16Array(2 * pn + 1), Vr(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * pn + 1), Vr(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const ba = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.status !== Ot && //#ifdef GZIP
  t.status !== Zn && //#endif
  t.status !== gn && t.status !== bn && t.status !== mn && t.status !== yn && t.status !== st && t.status !== Wt ? 1 : 0;
}, Au = (e) => {
  if (ba(e))
    return lt(e, Br);
  e.total_in = e.total_out = 0, e.data_type = gh;
  const t = e.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = //#ifdef GZIP
  t.wrap === 2 ? Zn : (
    //#endif
    t.wrap ? Ot : st
  ), e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, ih(t), Ke;
}, Bu = (e) => {
  const t = Au(e);
  return t === Ke && jh(e.state), t;
}, Rh = (e, t) => ba(e) || e.state.wrap !== 2 ? Br : (e.state.gzhead = t, Ke), zu = (e, t, r, a, i, o) => {
  if (!e)
    return Br;
  let s = 1;
  if (t === uh && (t = 6), a < 0 ? (s = 0, a = -a) : a > 15 && (s = 2, a -= 16), i < 1 || i > bh || r !== ui || a < 8 || a > 15 || t < 0 || t > 9 || o < 0 || o > hh || a === 8 && s !== 1)
    return lt(e, Br);
  a === 8 && (a = 9);
  const n = new Oh();
  return e.state = n, n.strm = e, n.status = Ot, n.wrap = s, n.gzhead = null, n.w_bits = a, n.w_size = 1 << n.w_bits, n.w_mask = n.w_size - 1, n.hash_bits = i + 7, n.hash_size = 1 << n.hash_bits, n.hash_mask = n.hash_size - 1, n.hash_shift = ~~((n.hash_bits + _e - 1) / _e), n.window = new Uint8Array(n.w_size * 2), n.head = new Uint16Array(n.hash_size), n.prev = new Uint16Array(n.w_size), n.lit_bufsize = 1 << i + 6, n.pending_buf_size = n.lit_bufsize * 4, n.pending_buf = new Uint8Array(n.pending_buf_size), n.sym_buf = n.lit_bufsize, n.sym_end = (n.lit_bufsize - 1) * 3, n.level = t, n.strategy = o, n.method = r, Bu(e);
}, Ph = (e, t) => zu(e, t, ui, mh, yh, ph), Uh = (e, t) => {
  if (ba(e) || t > zs || t < 0)
    return e ? lt(e, Br) : Br;
  const r = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || r.status === Wt && t !== lr)
    return lt(e, e.avail_out === 0 ? Si : Br);
  const a = r.last_flush;
  if (r.last_flush = t, r.pending !== 0) {
    if (Je(e), e.avail_out === 0)
      return r.last_flush = -1, Ke;
  } else if (e.avail_in === 0 && Is(t) <= Is(a) && t !== lr)
    return lt(e, Si);
  if (r.status === Wt && e.avail_in !== 0)
    return lt(e, Si);
  if (r.status === Ot && r.wrap === 0 && (r.status = st), r.status === Ot) {
    let i = ui + (r.w_bits - 8 << 4) << 8, o = -1;
    if (r.strategy >= xa || r.level < 2 ? o = 0 : r.level < 6 ? o = 1 : r.level === 6 ? o = 2 : o = 3, i |= o << 6, r.strstart !== 0 && (i |= Ah), i += 31 - i % 31, Ht(r, i), r.strstart !== 0 && (Ht(r, e.adler >>> 16), Ht(r, e.adler & 65535)), e.adler = 1, r.status = st, Je(e), r.pending !== 0)
      return r.last_flush = -1, Ke;
  }
  if (r.status === Zn) {
    if (e.adler = 0, Ee(r, 31), Ee(r, 139), Ee(r, 8), r.gzhead)
      Ee(
        r,
        (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)
      ), Ee(r, r.gzhead.time & 255), Ee(r, r.gzhead.time >> 8 & 255), Ee(r, r.gzhead.time >> 16 & 255), Ee(r, r.gzhead.time >> 24 & 255), Ee(r, r.level === 9 ? 2 : r.strategy >= xa || r.level < 2 ? 4 : 0), Ee(r, r.gzhead.os & 255), r.gzhead.extra && r.gzhead.extra.length && (Ee(r, r.gzhead.extra.length & 255), Ee(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (e.adler = Fe(e.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = gn;
    else if (Ee(r, 0), Ee(r, 0), Ee(r, 0), Ee(r, 0), Ee(r, 0), Ee(r, r.level === 9 ? 2 : r.strategy >= xa || r.level < 2 ? 4 : 0), Ee(r, Bh), r.status = st, Je(e), r.pending !== 0)
      return r.last_flush = -1, Ke;
  }
  if (r.status === gn) {
    if (r.gzhead.extra) {
      let i = r.pending, o = (r.gzhead.extra.length & 65535) - r.gzindex;
      for (; r.pending + o > r.pending_buf_size; ) {
        let n = r.pending_buf_size - r.pending;
        if (r.pending_buf.set(r.gzhead.extra.subarray(r.gzindex, r.gzindex + n), r.pending), r.pending = r.pending_buf_size, r.gzhead.hcrc && r.pending > i && (e.adler = Fe(e.adler, r.pending_buf, r.pending - i, i)), r.gzindex += n, Je(e), r.pending !== 0)
          return r.last_flush = -1, Ke;
        i = 0, o -= n;
      }
      let s = new Uint8Array(r.gzhead.extra);
      r.pending_buf.set(s.subarray(r.gzindex, r.gzindex + o), r.pending), r.pending += o, r.gzhead.hcrc && r.pending > i && (e.adler = Fe(e.adler, r.pending_buf, r.pending - i, i)), r.gzindex = 0;
    }
    r.status = bn;
  }
  if (r.status === bn) {
    if (r.gzhead.name) {
      let i = r.pending, o;
      do {
        if (r.pending === r.pending_buf_size) {
          if (r.gzhead.hcrc && r.pending > i && (e.adler = Fe(e.adler, r.pending_buf, r.pending - i, i)), Je(e), r.pending !== 0)
            return r.last_flush = -1, Ke;
          i = 0;
        }
        r.gzindex < r.gzhead.name.length ? o = r.gzhead.name.charCodeAt(r.gzindex++) & 255 : o = 0, Ee(r, o);
      } while (o !== 0);
      r.gzhead.hcrc && r.pending > i && (e.adler = Fe(e.adler, r.pending_buf, r.pending - i, i)), r.gzindex = 0;
    }
    r.status = mn;
  }
  if (r.status === mn) {
    if (r.gzhead.comment) {
      let i = r.pending, o;
      do {
        if (r.pending === r.pending_buf_size) {
          if (r.gzhead.hcrc && r.pending > i && (e.adler = Fe(e.adler, r.pending_buf, r.pending - i, i)), Je(e), r.pending !== 0)
            return r.last_flush = -1, Ke;
          i = 0;
        }
        r.gzindex < r.gzhead.comment.length ? o = r.gzhead.comment.charCodeAt(r.gzindex++) & 255 : o = 0, Ee(r, o);
      } while (o !== 0);
      r.gzhead.hcrc && r.pending > i && (e.adler = Fe(e.adler, r.pending_buf, r.pending - i, i));
    }
    r.status = yn;
  }
  if (r.status === yn) {
    if (r.gzhead.hcrc) {
      if (r.pending + 2 > r.pending_buf_size && (Je(e), r.pending !== 0))
        return r.last_flush = -1, Ke;
      Ee(r, e.adler & 255), Ee(r, e.adler >> 8 & 255), e.adler = 0;
    }
    if (r.status = st, Je(e), r.pending !== 0)
      return r.last_flush = -1, Ke;
  }
  if (e.avail_in !== 0 || r.lookahead !== 0 || t !== Jr && r.status !== Wt) {
    let i = r.level === 0 ? xu(r, t) : r.strategy === xa ? Th(r, t) : r.strategy === dh ? Ih(r, t) : Yt[r.level].func(r, t);
    if ((i === gt || i === Dt) && (r.status = Wt), i === Ve || i === gt)
      return e.avail_out === 0 && (r.last_flush = -1), Ke;
    if (i === qt && (t === sh ? nh(r) : t !== zs && (hn(r, 0, 0, !1), t === lh && (Vr(r.head), r.lookahead === 0 && (r.strstart = 0, r.block_start = 0, r.insert = 0))), Je(e), e.avail_out === 0))
      return r.last_flush = -1, Ke;
  }
  return t !== lr ? Ke : r.wrap <= 0 ? Ss : (r.wrap === 2 ? (Ee(r, e.adler & 255), Ee(r, e.adler >> 8 & 255), Ee(r, e.adler >> 16 & 255), Ee(r, e.adler >> 24 & 255), Ee(r, e.total_in & 255), Ee(r, e.total_in >> 8 & 255), Ee(r, e.total_in >> 16 & 255), Ee(r, e.total_in >> 24 & 255)) : (Ht(r, e.adler >>> 16), Ht(r, e.adler & 65535)), Je(e), r.wrap > 0 && (r.wrap = -r.wrap), r.pending !== 0 ? Ke : Ss);
}, Ch = (e) => {
  if (ba(e))
    return Br;
  const t = e.state.status;
  return e.state = null, t === st ? lt(e, ch) : Ke;
}, Lh = (e, t) => {
  let r = t.length;
  if (ba(e))
    return Br;
  const a = e.state, i = a.wrap;
  if (i === 2 || i === 1 && a.status !== Ot || a.lookahead)
    return Br;
  if (i === 1 && (e.adler = la(e.adler, t, r, 0)), a.wrap = 0, r >= a.w_size) {
    i === 0 && (Vr(a.head), a.strstart = 0, a.block_start = 0, a.insert = 0);
    let p = new Uint8Array(a.w_size);
    p.set(t.subarray(r - a.w_size, r), 0), t = p, r = a.w_size;
  }
  const o = e.avail_in, s = e.next_in, n = e.input;
  for (e.avail_in = r, e.next_in = 0, e.input = t, Rt(a); a.lookahead >= _e; ) {
    let p = a.strstart, d = a.lookahead - (_e - 1);
    do
      a.ins_h = Qr(a, a.ins_h, a.window[p + _e - 1]), a.prev[p & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = p, p++;
    while (--d);
    a.strstart = p, a.lookahead = _e - 1, Rt(a);
  }
  return a.strstart += a.lookahead, a.block_start = a.strstart, a.insert = a.lookahead, a.lookahead = 0, a.match_length = a.prev_length = _e - 1, a.match_available = 0, e.next_in = s, e.input = n, e.avail_in = o, a.wrap = i, Ke;
};
var Nh = Ph, qh = zu, Dh = Bu, Mh = Au, Fh = Rh, $h = Uh, Kh = Ch, Hh = Lh, Zh = "pako deflate (from Nodeca project)", ra = {
  deflateInit: Nh,
  deflateInit2: qh,
  deflateReset: Dh,
  deflateResetKeep: Mh,
  deflateSetHeader: Fh,
  deflate: $h,
  deflateEnd: Kh,
  deflateSetDictionary: Hh,
  deflateInfo: Zh
};
const Gh = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var Vh = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const r = t.shift();
    if (r) {
      if (typeof r != "object")
        throw new TypeError(r + "must be non-object");
      for (const a in r)
        Gh(r, a) && (e[a] = r[a]);
    }
  }
  return e;
}, Wh = (e) => {
  let t = 0;
  for (let a = 0, i = e.length; a < i; a++)
    t += e[a].length;
  const r = new Uint8Array(t);
  for (let a = 0, i = 0, o = e.length; a < o; a++) {
    let s = e[a];
    r.set(s, i), i += s.length;
  }
  return r;
}, fi = {
  assign: Vh,
  flattenChunks: Wh
};
let Su = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  Su = !1;
}
const ca = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  ca[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
ca[254] = ca[254] = 1;
var Yh = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let t, r, a, i, o, s = e.length, n = 0;
  for (i = 0; i < s; i++)
    r = e.charCodeAt(i), (r & 64512) === 55296 && i + 1 < s && (a = e.charCodeAt(i + 1), (a & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (a - 56320), i++)), n += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
  for (t = new Uint8Array(n), o = 0, i = 0; o < n; i++)
    r = e.charCodeAt(i), (r & 64512) === 55296 && i + 1 < s && (a = e.charCodeAt(i + 1), (a & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (a - 56320), i++)), r < 128 ? t[o++] = r : r < 2048 ? (t[o++] = 192 | r >>> 6, t[o++] = 128 | r & 63) : r < 65536 ? (t[o++] = 224 | r >>> 12, t[o++] = 128 | r >>> 6 & 63, t[o++] = 128 | r & 63) : (t[o++] = 240 | r >>> 18, t[o++] = 128 | r >>> 12 & 63, t[o++] = 128 | r >>> 6 & 63, t[o++] = 128 | r & 63);
  return t;
};
const Xh = (e, t) => {
  if (t < 65534 && e.subarray && Su)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let r = "";
  for (let a = 0; a < t; a++)
    r += String.fromCharCode(e[a]);
  return r;
};
var Jh = (e, t) => {
  const r = t || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, t));
  let a, i;
  const o = new Array(r * 2);
  for (i = 0, a = 0; a < r; ) {
    let s = e[a++];
    if (s < 128) {
      o[i++] = s;
      continue;
    }
    let n = ca[s];
    if (n > 4) {
      o[i++] = 65533, a += n - 1;
      continue;
    }
    for (s &= n === 2 ? 31 : n === 3 ? 15 : 7; n > 1 && a < r; )
      s = s << 6 | e[a++] & 63, n--;
    if (n > 1) {
      o[i++] = 65533;
      continue;
    }
    s < 65536 ? o[i++] = s : (s -= 65536, o[i++] = 55296 | s >> 10 & 1023, o[i++] = 56320 | s & 1023);
  }
  return Xh(o, i);
}, Qh = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let r = t - 1;
  for (; r >= 0 && (e[r] & 192) === 128; )
    r--;
  return r < 0 || r === 0 ? t : r + ca[e[r]] > t ? r : t;
}, ua = {
  string2buf: Yh,
  buf2string: Jh,
  utf8border: Qh
};
function ep() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var Iu = ep;
const Tu = Object.prototype.toString, {
  Z_NO_FLUSH: rp,
  Z_SYNC_FLUSH: tp,
  Z_FULL_FLUSH: ap,
  Z_FINISH: ip,
  Z_OK: Wa,
  Z_STREAM_END: op,
  Z_DEFAULT_COMPRESSION: np,
  Z_DEFAULT_STRATEGY: sp,
  Z_DEFLATED: lp
} = ga;
function ma(e) {
  this.options = fi.assign({
    level: np,
    method: lp,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: sp
  }, e || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Iu(), this.strm.avail_out = 0;
  let r = ra.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (r !== Wa)
    throw new Error(pt[r]);
  if (t.header && ra.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let a;
    if (typeof t.dictionary == "string" ? a = ua.string2buf(t.dictionary) : Tu.call(t.dictionary) === "[object ArrayBuffer]" ? a = new Uint8Array(t.dictionary) : a = t.dictionary, r = ra.deflateSetDictionary(this.strm, a), r !== Wa)
      throw new Error(pt[r]);
    this._dict_set = !0;
  }
}
ma.prototype.push = function(e, t) {
  const r = this.strm, a = this.options.chunkSize;
  let i, o;
  if (this.ended)
    return !1;
  for (t === ~~t ? o = t : o = t === !0 ? ip : rp, typeof e == "string" ? r.input = ua.string2buf(e) : Tu.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length; ; ) {
    if (r.avail_out === 0 && (r.output = new Uint8Array(a), r.next_out = 0, r.avail_out = a), (o === tp || o === ap) && r.avail_out <= 6) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue;
    }
    if (i = ra.deflate(r, o), i === op)
      return r.next_out > 0 && this.onData(r.output.subarray(0, r.next_out)), i = ra.deflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === Wa;
    if (r.avail_out === 0) {
      this.onData(r.output);
      continue;
    }
    if (o > 0 && r.next_out > 0) {
      this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
      continue;
    }
    if (r.avail_in === 0) break;
  }
  return !0;
};
ma.prototype.onData = function(e) {
  this.chunks.push(e);
};
ma.prototype.onEnd = function(e) {
  e === Wa && (this.result = fi.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Gn(e, t) {
  const r = new ma(t);
  if (r.push(e, !0), r.err)
    throw r.msg || pt[r.err];
  return r.result;
}
function cp(e, t) {
  return t = t || {}, t.raw = !0, Gn(e, t);
}
function up(e, t) {
  return t = t || {}, t.gzip = !0, Gn(e, t);
}
var fp = ma, dp = Gn, hp = cp, pp = up, gp = {
  Deflate: fp,
  deflate: dp,
  deflateRaw: hp,
  gzip: pp
};
const Aa = 16209, bp = 16191;
var mp = function(t, r) {
  let a, i, o, s, n, p, d, u, w, y, k, A, E, x, I, B, z, O, F, N, j, q, S, D;
  const $ = t.state;
  a = t.next_in, S = t.input, i = a + (t.avail_in - 5), o = t.next_out, D = t.output, s = o - (r - t.avail_out), n = o + (t.avail_out - 257), p = $.dmax, d = $.wsize, u = $.whave, w = $.wnext, y = $.window, k = $.hold, A = $.bits, E = $.lencode, x = $.distcode, I = (1 << $.lenbits) - 1, B = (1 << $.distbits) - 1;
  e:
    do {
      A < 15 && (k += S[a++] << A, A += 8, k += S[a++] << A, A += 8), z = E[k & I];
      r:
        for (; ; ) {
          if (O = z >>> 24, k >>>= O, A -= O, O = z >>> 16 & 255, O === 0)
            D[o++] = z & 65535;
          else if (O & 16) {
            F = z & 65535, O &= 15, O && (A < O && (k += S[a++] << A, A += 8), F += k & (1 << O) - 1, k >>>= O, A -= O), A < 15 && (k += S[a++] << A, A += 8, k += S[a++] << A, A += 8), z = x[k & B];
            t:
              for (; ; ) {
                if (O = z >>> 24, k >>>= O, A -= O, O = z >>> 16 & 255, O & 16) {
                  if (N = z & 65535, O &= 15, A < O && (k += S[a++] << A, A += 8, A < O && (k += S[a++] << A, A += 8)), N += k & (1 << O) - 1, N > p) {
                    t.msg = "invalid distance too far back", $.mode = Aa;
                    break e;
                  }
                  if (k >>>= O, A -= O, O = o - s, N > O) {
                    if (O = N - O, O > u && $.sane) {
                      t.msg = "invalid distance too far back", $.mode = Aa;
                      break e;
                    }
                    if (j = 0, q = y, w === 0) {
                      if (j += d - O, O < F) {
                        F -= O;
                        do
                          D[o++] = y[j++];
                        while (--O);
                        j = o - N, q = D;
                      }
                    } else if (w < O) {
                      if (j += d + w - O, O -= w, O < F) {
                        F -= O;
                        do
                          D[o++] = y[j++];
                        while (--O);
                        if (j = 0, w < F) {
                          O = w, F -= O;
                          do
                            D[o++] = y[j++];
                          while (--O);
                          j = o - N, q = D;
                        }
                      }
                    } else if (j += w - O, O < F) {
                      F -= O;
                      do
                        D[o++] = y[j++];
                      while (--O);
                      j = o - N, q = D;
                    }
                    for (; F > 2; )
                      D[o++] = q[j++], D[o++] = q[j++], D[o++] = q[j++], F -= 3;
                    F && (D[o++] = q[j++], F > 1 && (D[o++] = q[j++]));
                  } else {
                    j = o - N;
                    do
                      D[o++] = D[j++], D[o++] = D[j++], D[o++] = D[j++], F -= 3;
                    while (F > 2);
                    F && (D[o++] = D[j++], F > 1 && (D[o++] = D[j++]));
                  }
                } else if ((O & 64) === 0) {
                  z = x[(z & 65535) + (k & (1 << O) - 1)];
                  continue t;
                } else {
                  t.msg = "invalid distance code", $.mode = Aa;
                  break e;
                }
                break;
              }
          } else if ((O & 64) === 0) {
            z = E[(z & 65535) + (k & (1 << O) - 1)];
            continue r;
          } else if (O & 32) {
            $.mode = bp;
            break e;
          } else {
            t.msg = "invalid literal/length code", $.mode = Aa;
            break e;
          }
          break;
        }
    } while (a < i && o < n);
  F = A >> 3, a -= F, A -= F << 3, k &= (1 << A) - 1, t.next_in = a, t.next_out = o, t.avail_in = a < i ? 5 + (i - a) : 5 - (a - i), t.avail_out = o < n ? 257 + (n - o) : 257 - (o - n), $.hold = k, $.bits = A;
};
const kt = 15, Ts = 852, js = 592, Os = 0, Ti = 1, Rs = 2, yp = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), vp = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), wp = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), _p = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), kp = (e, t, r, a, i, o, s, n) => {
  const p = n.bits;
  let d = 0, u = 0, w = 0, y = 0, k = 0, A = 0, E = 0, x = 0, I = 0, B = 0, z, O, F, N, j, q = null, S;
  const D = new Uint16Array(kt + 1), $ = new Uint16Array(kt + 1);
  let m = null, U, C, M;
  for (d = 0; d <= kt; d++)
    D[d] = 0;
  for (u = 0; u < a; u++)
    D[t[r + u]]++;
  for (k = p, y = kt; y >= 1 && D[y] === 0; y--)
    ;
  if (k > y && (k = y), y === 0)
    return i[o++] = 1 << 24 | 64 << 16 | 0, i[o++] = 1 << 24 | 64 << 16 | 0, n.bits = 1, 0;
  for (w = 1; w < y && D[w] === 0; w++)
    ;
  for (k < w && (k = w), x = 1, d = 1; d <= kt; d++)
    if (x <<= 1, x -= D[d], x < 0)
      return -1;
  if (x > 0 && (e === Os || y !== 1))
    return -1;
  for ($[1] = 0, d = 1; d < kt; d++)
    $[d + 1] = $[d] + D[d];
  for (u = 0; u < a; u++)
    t[r + u] !== 0 && (s[$[t[r + u]]++] = u);
  if (e === Os ? (q = m = s, S = 20) : e === Ti ? (q = yp, m = vp, S = 257) : (q = wp, m = _p, S = 0), B = 0, u = 0, d = w, j = o, A = k, E = 0, F = -1, I = 1 << k, N = I - 1, e === Ti && I > Ts || e === Rs && I > js)
    return 1;
  for (; ; ) {
    U = d - E, s[u] + 1 < S ? (C = 0, M = s[u]) : s[u] >= S ? (C = m[s[u] - S], M = q[s[u] - S]) : (C = 96, M = 0), z = 1 << d - E, O = 1 << A, w = O;
    do
      O -= z, i[j + (B >> E) + O] = U << 24 | C << 16 | M | 0;
    while (O !== 0);
    for (z = 1 << d - 1; B & z; )
      z >>= 1;
    if (z !== 0 ? (B &= z - 1, B += z) : B = 0, u++, --D[d] === 0) {
      if (d === y)
        break;
      d = t[r + s[u]];
    }
    if (d > k && (B & N) !== F) {
      for (E === 0 && (E = k), j += w, A = d - E, x = 1 << A; A + E < y && (x -= D[A + E], !(x <= 0)); )
        A++, x <<= 1;
      if (I += 1 << A, e === Ti && I > Ts || e === Rs && I > js)
        return 1;
      F = B & N, i[F] = k << 24 | A << 16 | j - o | 0;
    }
  }
  return B !== 0 && (i[j + B] = d - E << 24 | 64 << 16 | 0), n.bits = k, 0;
};
var ta = kp;
const Ep = 0, ju = 1, Ou = 2, {
  Z_FINISH: Ps,
  Z_BLOCK: xp,
  Z_TREES: Ba,
  Z_OK: bt,
  Z_STREAM_END: Ap,
  Z_NEED_DICT: Bp,
  Z_STREAM_ERROR: cr,
  Z_DATA_ERROR: Ru,
  Z_MEM_ERROR: Pu,
  Z_BUF_ERROR: zp,
  Z_DEFLATED: Us
} = ga, di = 16180, Cs = 16181, Ls = 16182, Ns = 16183, qs = 16184, Ds = 16185, Ms = 16186, Fs = 16187, $s = 16188, Ks = 16189, Ya = 16190, Ir = 16191, ji = 16192, Hs = 16193, Oi = 16194, Zs = 16195, Gs = 16196, Vs = 16197, Ws = 16198, za = 16199, Sa = 16200, Ys = 16201, Xs = 16202, Js = 16203, Qs = 16204, el = 16205, Ri = 16206, rl = 16207, tl = 16208, Ue = 16209, Uu = 16210, Cu = 16211, Sp = 852, Ip = 592, Tp = 15, jp = Tp, al = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function Op() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const yt = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.mode < di || t.mode > Cu ? 1 : 0;
}, Lu = (e) => {
  if (yt(e))
    return cr;
  const t = e.state;
  return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = di, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(Sp), t.distcode = t.distdyn = new Int32Array(Ip), t.sane = 1, t.back = -1, bt;
}, Nu = (e) => {
  if (yt(e))
    return cr;
  const t = e.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, Lu(e);
}, qu = (e, t) => {
  let r;
  if (yt(e))
    return cr;
  const a = e.state;
  return t < 0 ? (r = 0, t = -t) : (r = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? cr : (a.window !== null && a.wbits !== t && (a.window = null), a.wrap = r, a.wbits = t, Nu(e));
}, Du = (e, t) => {
  if (!e)
    return cr;
  const r = new Op();
  e.state = r, r.strm = e, r.window = null, r.mode = di;
  const a = qu(e, t);
  return a !== bt && (e.state = null), a;
}, Rp = (e) => Du(e, jp);
let il = !0, Pi, Ui;
const Pp = (e) => {
  if (il) {
    Pi = new Int32Array(512), Ui = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (ta(ju, e.lens, 0, 288, Pi, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    ta(Ou, e.lens, 0, 32, Ui, 0, e.work, { bits: 5 }), il = !1;
  }
  e.lencode = Pi, e.lenbits = 9, e.distcode = Ui, e.distbits = 5;
}, Mu = (e, t, r, a) => {
  let i;
  const o = e.state;
  return o.window === null && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new Uint8Array(o.wsize)), a >= o.wsize ? (o.window.set(t.subarray(r - o.wsize, r), 0), o.wnext = 0, o.whave = o.wsize) : (i = o.wsize - o.wnext, i > a && (i = a), o.window.set(t.subarray(r - a, r - a + i), o.wnext), a -= i, a ? (o.window.set(t.subarray(r - a, r), 0), o.wnext = a, o.whave = o.wsize) : (o.wnext += i, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += i))), 0;
}, Up = (e, t) => {
  let r, a, i, o, s, n, p, d, u, w, y, k, A, E, x = 0, I, B, z, O, F, N, j, q;
  const S = new Uint8Array(4);
  let D, $;
  const m = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (yt(e) || !e.output || !e.input && e.avail_in !== 0)
    return cr;
  r = e.state, r.mode === Ir && (r.mode = ji), s = e.next_out, i = e.output, p = e.avail_out, o = e.next_in, a = e.input, n = e.avail_in, d = r.hold, u = r.bits, w = n, y = p, q = bt;
  e:
    for (; ; )
      switch (r.mode) {
        case di:
          if (r.wrap === 0) {
            r.mode = ji;
            break;
          }
          for (; u < 16; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if (r.wrap & 2 && d === 35615) {
            r.wbits === 0 && (r.wbits = 15), r.check = 0, S[0] = d & 255, S[1] = d >>> 8 & 255, r.check = Fe(r.check, S, 2, 0), d = 0, u = 0, r.mode = Cs;
            break;
          }
          if (r.head && (r.head.done = !1), !(r.wrap & 1) || /* check if zlib header allowed */
          (((d & 255) << 8) + (d >> 8)) % 31) {
            e.msg = "incorrect header check", r.mode = Ue;
            break;
          }
          if ((d & 15) !== Us) {
            e.msg = "unknown compression method", r.mode = Ue;
            break;
          }
          if (d >>>= 4, u -= 4, j = (d & 15) + 8, r.wbits === 0 && (r.wbits = j), j > 15 || j > r.wbits) {
            e.msg = "invalid window size", r.mode = Ue;
            break;
          }
          r.dmax = 1 << r.wbits, r.flags = 0, e.adler = r.check = 1, r.mode = d & 512 ? Ks : Ir, d = 0, u = 0;
          break;
        case Cs:
          for (; u < 16; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if (r.flags = d, (r.flags & 255) !== Us) {
            e.msg = "unknown compression method", r.mode = Ue;
            break;
          }
          if (r.flags & 57344) {
            e.msg = "unknown header flags set", r.mode = Ue;
            break;
          }
          r.head && (r.head.text = d >> 8 & 1), r.flags & 512 && r.wrap & 4 && (S[0] = d & 255, S[1] = d >>> 8 & 255, r.check = Fe(r.check, S, 2, 0)), d = 0, u = 0, r.mode = Ls;
        /* falls through */
        case Ls:
          for (; u < 32; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          r.head && (r.head.time = d), r.flags & 512 && r.wrap & 4 && (S[0] = d & 255, S[1] = d >>> 8 & 255, S[2] = d >>> 16 & 255, S[3] = d >>> 24 & 255, r.check = Fe(r.check, S, 4, 0)), d = 0, u = 0, r.mode = Ns;
        /* falls through */
        case Ns:
          for (; u < 16; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          r.head && (r.head.xflags = d & 255, r.head.os = d >> 8), r.flags & 512 && r.wrap & 4 && (S[0] = d & 255, S[1] = d >>> 8 & 255, r.check = Fe(r.check, S, 2, 0)), d = 0, u = 0, r.mode = qs;
        /* falls through */
        case qs:
          if (r.flags & 1024) {
            for (; u < 16; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            r.length = d, r.head && (r.head.extra_len = d), r.flags & 512 && r.wrap & 4 && (S[0] = d & 255, S[1] = d >>> 8 & 255, r.check = Fe(r.check, S, 2, 0)), d = 0, u = 0;
          } else r.head && (r.head.extra = null);
          r.mode = Ds;
        /* falls through */
        case Ds:
          if (r.flags & 1024 && (k = r.length, k > n && (k = n), k && (r.head && (j = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(
            a.subarray(
              o,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              o + k
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            j
          )), r.flags & 512 && r.wrap & 4 && (r.check = Fe(r.check, a, k, o)), n -= k, o += k, r.length -= k), r.length))
            break e;
          r.length = 0, r.mode = Ms;
        /* falls through */
        case Ms:
          if (r.flags & 2048) {
            if (n === 0)
              break e;
            k = 0;
            do
              j = a[o + k++], r.head && j && r.length < 65536 && (r.head.name += String.fromCharCode(j));
            while (j && k < n);
            if (r.flags & 512 && r.wrap & 4 && (r.check = Fe(r.check, a, k, o)), n -= k, o += k, j)
              break e;
          } else r.head && (r.head.name = null);
          r.length = 0, r.mode = Fs;
        /* falls through */
        case Fs:
          if (r.flags & 4096) {
            if (n === 0)
              break e;
            k = 0;
            do
              j = a[o + k++], r.head && j && r.length < 65536 && (r.head.comment += String.fromCharCode(j));
            while (j && k < n);
            if (r.flags & 512 && r.wrap & 4 && (r.check = Fe(r.check, a, k, o)), n -= k, o += k, j)
              break e;
          } else r.head && (r.head.comment = null);
          r.mode = $s;
        /* falls through */
        case $s:
          if (r.flags & 512) {
            for (; u < 16; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            if (r.wrap & 4 && d !== (r.check & 65535)) {
              e.msg = "header crc mismatch", r.mode = Ue;
              break;
            }
            d = 0, u = 0;
          }
          r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = Ir;
          break;
        case Ks:
          for (; u < 32; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          e.adler = r.check = al(d), d = 0, u = 0, r.mode = Ya;
        /* falls through */
        case Ya:
          if (r.havedict === 0)
            return e.next_out = s, e.avail_out = p, e.next_in = o, e.avail_in = n, r.hold = d, r.bits = u, Bp;
          e.adler = r.check = 1, r.mode = Ir;
        /* falls through */
        case Ir:
          if (t === xp || t === Ba)
            break e;
        /* falls through */
        case ji:
          if (r.last) {
            d >>>= u & 7, u -= u & 7, r.mode = Ri;
            break;
          }
          for (; u < 3; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          switch (r.last = d & 1, d >>>= 1, u -= 1, d & 3) {
            case 0:
              r.mode = Hs;
              break;
            case 1:
              if (Pp(r), r.mode = za, t === Ba) {
                d >>>= 2, u -= 2;
                break e;
              }
              break;
            case 2:
              r.mode = Gs;
              break;
            case 3:
              e.msg = "invalid block type", r.mode = Ue;
          }
          d >>>= 2, u -= 2;
          break;
        case Hs:
          for (d >>>= u & 7, u -= u & 7; u < 32; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if ((d & 65535) !== (d >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", r.mode = Ue;
            break;
          }
          if (r.length = d & 65535, d = 0, u = 0, r.mode = Oi, t === Ba)
            break e;
        /* falls through */
        case Oi:
          r.mode = Zs;
        /* falls through */
        case Zs:
          if (k = r.length, k) {
            if (k > n && (k = n), k > p && (k = p), k === 0)
              break e;
            i.set(a.subarray(o, o + k), s), n -= k, o += k, p -= k, s += k, r.length -= k;
            break;
          }
          r.mode = Ir;
          break;
        case Gs:
          for (; u < 14; ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if (r.nlen = (d & 31) + 257, d >>>= 5, u -= 5, r.ndist = (d & 31) + 1, d >>>= 5, u -= 5, r.ncode = (d & 15) + 4, d >>>= 4, u -= 4, r.nlen > 286 || r.ndist > 30) {
            e.msg = "too many length or distance symbols", r.mode = Ue;
            break;
          }
          r.have = 0, r.mode = Vs;
        /* falls through */
        case Vs:
          for (; r.have < r.ncode; ) {
            for (; u < 3; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            r.lens[m[r.have++]] = d & 7, d >>>= 3, u -= 3;
          }
          for (; r.have < 19; )
            r.lens[m[r.have++]] = 0;
          if (r.lencode = r.lendyn, r.lenbits = 7, D = { bits: r.lenbits }, q = ta(Ep, r.lens, 0, 19, r.lencode, 0, r.work, D), r.lenbits = D.bits, q) {
            e.msg = "invalid code lengths set", r.mode = Ue;
            break;
          }
          r.have = 0, r.mode = Ws;
        /* falls through */
        case Ws:
          for (; r.have < r.nlen + r.ndist; ) {
            for (; x = r.lencode[d & (1 << r.lenbits) - 1], I = x >>> 24, B = x >>> 16 & 255, z = x & 65535, !(I <= u); ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            if (z < 16)
              d >>>= I, u -= I, r.lens[r.have++] = z;
            else {
              if (z === 16) {
                for ($ = I + 2; u < $; ) {
                  if (n === 0)
                    break e;
                  n--, d += a[o++] << u, u += 8;
                }
                if (d >>>= I, u -= I, r.have === 0) {
                  e.msg = "invalid bit length repeat", r.mode = Ue;
                  break;
                }
                j = r.lens[r.have - 1], k = 3 + (d & 3), d >>>= 2, u -= 2;
              } else if (z === 17) {
                for ($ = I + 3; u < $; ) {
                  if (n === 0)
                    break e;
                  n--, d += a[o++] << u, u += 8;
                }
                d >>>= I, u -= I, j = 0, k = 3 + (d & 7), d >>>= 3, u -= 3;
              } else {
                for ($ = I + 7; u < $; ) {
                  if (n === 0)
                    break e;
                  n--, d += a[o++] << u, u += 8;
                }
                d >>>= I, u -= I, j = 0, k = 11 + (d & 127), d >>>= 7, u -= 7;
              }
              if (r.have + k > r.nlen + r.ndist) {
                e.msg = "invalid bit length repeat", r.mode = Ue;
                break;
              }
              for (; k--; )
                r.lens[r.have++] = j;
            }
          }
          if (r.mode === Ue)
            break;
          if (r.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", r.mode = Ue;
            break;
          }
          if (r.lenbits = 9, D = { bits: r.lenbits }, q = ta(ju, r.lens, 0, r.nlen, r.lencode, 0, r.work, D), r.lenbits = D.bits, q) {
            e.msg = "invalid literal/lengths set", r.mode = Ue;
            break;
          }
          if (r.distbits = 6, r.distcode = r.distdyn, D = { bits: r.distbits }, q = ta(Ou, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, D), r.distbits = D.bits, q) {
            e.msg = "invalid distances set", r.mode = Ue;
            break;
          }
          if (r.mode = za, t === Ba)
            break e;
        /* falls through */
        case za:
          r.mode = Sa;
        /* falls through */
        case Sa:
          if (n >= 6 && p >= 258) {
            e.next_out = s, e.avail_out = p, e.next_in = o, e.avail_in = n, r.hold = d, r.bits = u, mp(e, y), s = e.next_out, i = e.output, p = e.avail_out, o = e.next_in, a = e.input, n = e.avail_in, d = r.hold, u = r.bits, r.mode === Ir && (r.back = -1);
            break;
          }
          for (r.back = 0; x = r.lencode[d & (1 << r.lenbits) - 1], I = x >>> 24, B = x >>> 16 & 255, z = x & 65535, !(I <= u); ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if (B && (B & 240) === 0) {
            for (O = I, F = B, N = z; x = r.lencode[N + ((d & (1 << O + F) - 1) >> O)], I = x >>> 24, B = x >>> 16 & 255, z = x & 65535, !(O + I <= u); ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            d >>>= O, u -= O, r.back += O;
          }
          if (d >>>= I, u -= I, r.back += I, r.length = z, B === 0) {
            r.mode = el;
            break;
          }
          if (B & 32) {
            r.back = -1, r.mode = Ir;
            break;
          }
          if (B & 64) {
            e.msg = "invalid literal/length code", r.mode = Ue;
            break;
          }
          r.extra = B & 15, r.mode = Ys;
        /* falls through */
        case Ys:
          if (r.extra) {
            for ($ = r.extra; u < $; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            r.length += d & (1 << r.extra) - 1, d >>>= r.extra, u -= r.extra, r.back += r.extra;
          }
          r.was = r.length, r.mode = Xs;
        /* falls through */
        case Xs:
          for (; x = r.distcode[d & (1 << r.distbits) - 1], I = x >>> 24, B = x >>> 16 & 255, z = x & 65535, !(I <= u); ) {
            if (n === 0)
              break e;
            n--, d += a[o++] << u, u += 8;
          }
          if ((B & 240) === 0) {
            for (O = I, F = B, N = z; x = r.distcode[N + ((d & (1 << O + F) - 1) >> O)], I = x >>> 24, B = x >>> 16 & 255, z = x & 65535, !(O + I <= u); ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            d >>>= O, u -= O, r.back += O;
          }
          if (d >>>= I, u -= I, r.back += I, B & 64) {
            e.msg = "invalid distance code", r.mode = Ue;
            break;
          }
          r.offset = z, r.extra = B & 15, r.mode = Js;
        /* falls through */
        case Js:
          if (r.extra) {
            for ($ = r.extra; u < $; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            r.offset += d & (1 << r.extra) - 1, d >>>= r.extra, u -= r.extra, r.back += r.extra;
          }
          if (r.offset > r.dmax) {
            e.msg = "invalid distance too far back", r.mode = Ue;
            break;
          }
          r.mode = Qs;
        /* falls through */
        case Qs:
          if (p === 0)
            break e;
          if (k = y - p, r.offset > k) {
            if (k = r.offset - k, k > r.whave && r.sane) {
              e.msg = "invalid distance too far back", r.mode = Ue;
              break;
            }
            k > r.wnext ? (k -= r.wnext, A = r.wsize - k) : A = r.wnext - k, k > r.length && (k = r.length), E = r.window;
          } else
            E = i, A = s - r.offset, k = r.length;
          k > p && (k = p), p -= k, r.length -= k;
          do
            i[s++] = E[A++];
          while (--k);
          r.length === 0 && (r.mode = Sa);
          break;
        case el:
          if (p === 0)
            break e;
          i[s++] = r.length, p--, r.mode = Sa;
          break;
        case Ri:
          if (r.wrap) {
            for (; u < 32; ) {
              if (n === 0)
                break e;
              n--, d |= a[o++] << u, u += 8;
            }
            if (y -= p, e.total_out += y, r.total += y, r.wrap & 4 && y && (e.adler = r.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            r.flags ? Fe(r.check, i, y, s - y) : la(r.check, i, y, s - y)), y = p, r.wrap & 4 && (r.flags ? d : al(d)) !== r.check) {
              e.msg = "incorrect data check", r.mode = Ue;
              break;
            }
            d = 0, u = 0;
          }
          r.mode = rl;
        /* falls through */
        case rl:
          if (r.wrap && r.flags) {
            for (; u < 32; ) {
              if (n === 0)
                break e;
              n--, d += a[o++] << u, u += 8;
            }
            if (r.wrap & 4 && d !== (r.total & 4294967295)) {
              e.msg = "incorrect length check", r.mode = Ue;
              break;
            }
            d = 0, u = 0;
          }
          r.mode = tl;
        /* falls through */
        case tl:
          q = Ap;
          break e;
        case Ue:
          q = Ru;
          break e;
        case Uu:
          return Pu;
        case Cu:
        /* falls through */
        default:
          return cr;
      }
  return e.next_out = s, e.avail_out = p, e.next_in = o, e.avail_in = n, r.hold = d, r.bits = u, (r.wsize || y !== e.avail_out && r.mode < Ue && (r.mode < Ri || t !== Ps)) && Mu(e, e.output, e.next_out, y - e.avail_out), w -= e.avail_in, y -= e.avail_out, e.total_in += w, e.total_out += y, r.total += y, r.wrap & 4 && y && (e.adler = r.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  r.flags ? Fe(r.check, i, y, e.next_out - y) : la(r.check, i, y, e.next_out - y)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === Ir ? 128 : 0) + (r.mode === za || r.mode === Oi ? 256 : 0), (w === 0 && y === 0 || t === Ps) && q === bt && (q = zp), q;
}, Cp = (e) => {
  if (yt(e))
    return cr;
  let t = e.state;
  return t.window && (t.window = null), e.state = null, bt;
}, Lp = (e, t) => {
  if (yt(e))
    return cr;
  const r = e.state;
  return (r.wrap & 2) === 0 ? cr : (r.head = t, t.done = !1, bt);
}, Np = (e, t) => {
  const r = t.length;
  let a, i, o;
  return yt(e) || (a = e.state, a.wrap !== 0 && a.mode !== Ya) ? cr : a.mode === Ya && (i = 1, i = la(i, t, r, 0), i !== a.check) ? Ru : (o = Mu(e, t, r, r), o ? (a.mode = Uu, Pu) : (a.havedict = 1, bt));
};
var qp = Nu, Dp = qu, Mp = Lu, Fp = Rp, $p = Du, Kp = Up, Hp = Cp, Zp = Lp, Gp = Np, Vp = "pako inflate (from Nodeca project)", Cr = {
  inflateReset: qp,
  inflateReset2: Dp,
  inflateResetKeep: Mp,
  inflateInit: Fp,
  inflateInit2: $p,
  inflate: Kp,
  inflateEnd: Hp,
  inflateGetHeader: Zp,
  inflateSetDictionary: Gp,
  inflateInfo: Vp
};
function Wp() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var Yp = Wp;
const Fu = Object.prototype.toString, {
  Z_NO_FLUSH: Xp,
  Z_FINISH: Jp,
  Z_OK: fa,
  Z_STREAM_END: Ci,
  Z_NEED_DICT: Li,
  Z_STREAM_ERROR: Qp,
  Z_DATA_ERROR: ol,
  Z_MEM_ERROR: e0
} = ga;
function ya(e) {
  this.options = fi.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15) === 0 && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Iu(), this.strm.avail_out = 0;
  let r = Cr.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (r !== fa)
    throw new Error(pt[r]);
  if (this.header = new Yp(), Cr.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = ua.string2buf(t.dictionary) : Fu.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (r = Cr.inflateSetDictionary(this.strm, t.dictionary), r !== fa)))
    throw new Error(pt[r]);
}
ya.prototype.push = function(e, t) {
  const r = this.strm, a = this.options.chunkSize, i = this.options.dictionary;
  let o, s, n;
  if (this.ended) return !1;
  for (t === ~~t ? s = t : s = t === !0 ? Jp : Xp, Fu.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length; ; ) {
    for (r.avail_out === 0 && (r.output = new Uint8Array(a), r.next_out = 0, r.avail_out = a), o = Cr.inflate(r, s), o === Li && i && (o = Cr.inflateSetDictionary(r, i), o === fa ? o = Cr.inflate(r, s) : o === ol && (o = Li)); r.avail_in > 0 && o === Ci && r.state.wrap > 0 && e[r.next_in] !== 0; )
      Cr.inflateReset(r), o = Cr.inflate(r, s);
    switch (o) {
      case Qp:
      case ol:
      case Li:
      case e0:
        return this.onEnd(o), this.ended = !0, !1;
    }
    if (n = r.avail_out, r.next_out && (r.avail_out === 0 || o === Ci))
      if (this.options.to === "string") {
        let p = ua.utf8border(r.output, r.next_out), d = r.next_out - p, u = ua.buf2string(r.output, p);
        r.next_out = d, r.avail_out = a - d, d && r.output.set(r.output.subarray(p, p + d), 0), this.onData(u);
      } else
        this.onData(r.output.length === r.next_out ? r.output : r.output.subarray(0, r.next_out));
    if (!(o === fa && n === 0)) {
      if (o === Ci)
        return o = Cr.inflateEnd(this.strm), this.onEnd(o), this.ended = !0, !0;
      if (r.avail_in === 0) break;
    }
  }
  return !0;
};
ya.prototype.onData = function(e) {
  this.chunks.push(e);
};
ya.prototype.onEnd = function(e) {
  e === fa && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = fi.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function Vn(e, t) {
  const r = new ya(t);
  if (r.push(e), r.err) throw r.msg || pt[r.err];
  return r.result;
}
function r0(e, t) {
  return t = t || {}, t.raw = !0, Vn(e, t);
}
var t0 = ya, a0 = Vn, i0 = r0, o0 = Vn, n0 = {
  Inflate: t0,
  inflate: a0,
  inflateRaw: i0,
  ungzip: o0
};
const { Deflate: s0, deflate: l0, deflateRaw: c0, gzip: u0 } = gp, { Inflate: f0, inflate: d0, inflateRaw: h0, ungzip: p0 } = n0;
var g0 = s0, b0 = l0, m0 = c0, y0 = u0, v0 = f0, w0 = d0, _0 = h0, k0 = p0, E0 = ga, wy = {
  Deflate: g0,
  deflate: b0,
  deflateRaw: m0,
  gzip: y0,
  Inflate: v0,
  inflate: w0,
  inflateRaw: _0,
  ungzip: k0,
  constants: E0
};
function $u(e) {
  const t = e.length;
  if (t % 2 !== 0) throw new TypeError("fromHexInternal: odd-length hex string");
  const r = new Uint8Array(t / 2);
  for (let a = 0; a < t; a += 2) {
    const i = nl(e.charCodeAt(a)), o = nl(e.charCodeAt(a + 1));
    if (i === -1 || o === -1) throw new TypeError("fromHexInternal: invalid hex character");
    r[a >> 1] = i << 4 | o;
  }
  return r;
}
function nl(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function va(e) {
  for (let t = 0; t < e.length; t++)
    if (e[t] !== 0) return !1;
  return !0;
}
function x0(e, t) {
  const r = Math.min(e.length, t.length);
  for (let a = 0; a < r; a++) {
    const i = e[a], o = t[a];
    if (i < o) return -1;
    if (i > o) return 1;
  }
  return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
}
function Ge(e, t) {
  if (e.length !== t.length) return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r]) return !1;
  return !0;
}
function Bt(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function Ku(...e) {
  let t = 0;
  for (const i of e) t += i.length;
  const r = new Uint8Array(t);
  let a = 0;
  for (const i of e)
    r.set(i, a), a += i.length;
  return r;
}
const hi = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n, A0 = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, Wn = 21n * 10n ** 14n;
function Hu(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
function B0(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function z0(e) {
  return e instanceof Uint8Array && e.length === 20;
}
function S0(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 || va(e) ? !1 : Hu(e) < hi;
}
function Zu(e) {
  if (!(e instanceof Uint8Array)) return !1;
  const t = e[0];
  return e.length === 33 && (t === 2 || t === 3) || e.length === 65 && (t === 4 || t === 6 || t === 7);
}
function I0(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 ? !1 : !va(e);
}
function Gu(e) {
  return e instanceof Uint8Array && e.length >= 8 && e.length <= 73;
}
function Vu(e) {
  return e instanceof Uint8Array && e.length === 64;
}
function T0(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function Wu(e) {
  return typeof e == "bigint" && e >= 0n && e <= Wn;
}
function Yn(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertBytes32: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertBytes32: expected 32 bytes, got ${e.length} bytes`);
}
function Yu(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPrivateKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertPrivateKey: expected 32 bytes, got ${e.length} bytes`);
  if (va(e))
    throw new TypeError("assertPrivateKey: key is zero");
  if (Hu(e) >= hi)
    throw new TypeError("assertPrivateKey: key not in range [1, n)");
}
function Xu(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPublicKey: expected Uint8Array");
  if (!Zu(e))
    throw new TypeError(
      `assertPublicKey: invalid SEC1 public key (length=${e.length}, prefix=0x${(e[0] ?? 0).toString(16).padStart(2, "0")})`
    );
}
function Ju(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertXOnlyPublicKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertXOnlyPublicKey: expected 32 bytes, got ${e.length} bytes`);
  if (va(e))
    throw new TypeError("assertXOnlyPublicKey: key is zero");
}
function Qu(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertMessageHash: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertMessageHash: expected 32 bytes, got ${e.length} bytes`);
}
function j0(e) {
  return Yn(e), e;
}
function O0(e) {
  if (!(e instanceof Uint8Array) || e.length !== 20)
    throw new TypeError("createBytes20: expected 20 bytes Uint8Array");
  return e;
}
function Xa(e) {
  return Yu(e), e;
}
function ef(e) {
  return Xu(e), e;
}
function rf(e) {
  return Ju(e), e;
}
function R0(e) {
  if (!Gu(e))
    throw new TypeError(`createSignature: expected 8-73 bytes, got ${e.length} bytes`);
  return e;
}
function P0(e) {
  if (!Vu(e))
    throw new TypeError(`createSchnorrSignature: expected 64 bytes, got ${e.length} bytes`);
  return e;
}
function U0(e) {
  return Qu(e), e;
}
function C0(e) {
  if (!Wu(e))
    throw new TypeError(`createSatoshi: value out of range [0, ${Wn}]`);
  return e;
}
const at = {
  /** Can produce ECDSA signatures (requires a private key). */
  EcdsaSign: 1,
  /** Can verify ECDSA signatures. */
  EcdsaVerify: 2,
  /** Can produce BIP-340 Schnorr signatures (requires a private key and backend support). */
  SchnorrSign: 4,
  /** Can verify BIP-340 Schnorr signatures (requires backend support). */
  SchnorrVerify: 8,
  /** Can export the raw private key bytes. */
  PrivateKeyExport: 16,
  /** Can derive a tweaked child key via Taproot-style tweaking. */
  PublicKeyTweak: 32,
  /** Supports BIP-32 hierarchical deterministic derivation. */
  HdDerivation: 64
};
function Xn(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function mt(e, t = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const r = t && `"${t}" `;
    throw new Error(`${r}expected integer >= 0, got ${e}`);
  }
}
function Te(e, t, r = "") {
  const a = Xn(e), i = e?.length, o = t !== void 0;
  if (!a || o && i !== t) {
    const s = r && `"${r}" `, n = o ? ` of length ${t}` : "", p = a ? `length=${i}` : `type=${typeof e}`;
    throw new Error(s + "expected Uint8Array" + n + ", got " + p);
  }
  return e;
}
function tf(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  mt(e.outputLen), mt(e.blockLen);
}
function Ja(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function L0(e, t) {
  Te(e, void 0, "digestInto() output");
  const r = t.outputLen;
  if (e.length < r)
    throw new Error('"digestInto() output" expected to be of length >=' + r);
}
function Qa(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function Ni(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function gr(e, t) {
  return e << 32 - t | e >>> t;
}
const af = (
  /* @ts-ignore */
  typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
), N0 = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function pi(e) {
  if (Te(e), af)
    return e.toHex();
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += N0[e[r]];
  return t;
}
const Tr = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function sl(e) {
  if (e >= Tr._0 && e <= Tr._9)
    return e - Tr._0;
  if (e >= Tr.A && e <= Tr.F)
    return e - (Tr.A - 10);
  if (e >= Tr.a && e <= Tr.f)
    return e - (Tr.a - 10);
}
function ei(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (af)
    return Uint8Array.fromHex(e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const a = new Uint8Array(r);
  for (let i = 0, o = 0; i < r; i++, o += 2) {
    const s = sl(e.charCodeAt(o)), n = sl(e.charCodeAt(o + 1));
    if (s === void 0 || n === void 0) {
      const p = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + p + '" at index ' + o);
    }
    a[i] = s * 16 + n;
  }
  return a;
}
function Ar(...e) {
  let t = 0;
  for (let a = 0; a < e.length; a++) {
    const i = e[a];
    Te(i), t += i.length;
  }
  const r = new Uint8Array(t);
  for (let a = 0, i = 0; a < e.length; a++) {
    const o = e[a];
    r.set(o, i), i += o.length;
  }
  return r;
}
function q0(e, t = {}) {
  const r = (i, o) => e(o).update(i).digest(), a = e(void 0);
  return r.outputLen = a.outputLen, r.blockLen = a.blockLen, r.create = (i) => e(i), Object.assign(r, t), Object.freeze(r);
}
function gi(e = 32) {
  const t = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof t?.getRandomValues != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t.getRandomValues(new Uint8Array(e));
}
const D0 = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function M0(e, t, r) {
  return e & t ^ ~e & r;
}
function F0(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
class $0 {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(t, r, a, i) {
    this.blockLen = t, this.outputLen = r, this.padOffset = a, this.isLE = i, this.buffer = new Uint8Array(t), this.view = Ni(this.buffer);
  }
  update(t) {
    Ja(this), Te(t);
    const { view: r, buffer: a, blockLen: i } = this, o = t.length;
    for (let s = 0; s < o; ) {
      const n = Math.min(i - this.pos, o - s);
      if (n === i) {
        const p = Ni(t);
        for (; i <= o - s; s += i)
          this.process(p, s);
        continue;
      }
      a.set(t.subarray(s, s + n), this.pos), this.pos += n, s += n, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    Ja(this), L0(t, this), this.finished = !0;
    const { buffer: r, view: a, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, Qa(this.buffer.subarray(s)), this.padOffset > i - s && (this.process(a, 0), s = 0);
    for (let w = s; w < i; w++)
      r[w] = 0;
    a.setBigUint64(i - 8, BigInt(this.length * 8), o), this.process(a, 0);
    const n = Ni(t), p = this.outputLen;
    if (p % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const d = p / 4, u = this.get();
    if (d > u.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let w = 0; w < d; w++)
      n.setUint32(4 * w, u[w], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const a = t.slice(0, r);
    return this.destroy(), a;
  }
  _cloneInto(t) {
    t ||= new this.constructor(), t.set(...this.get());
    const { blockLen: r, buffer: a, length: i, finished: o, destroyed: s, pos: n } = this;
    return t.destroyed = s, t.finished = o, t.length = i, t.pos = n, i % r && t.buffer.set(a), t;
  }
  clone() {
    return this._cloneInto();
  }
}
const Mr = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), K0 = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Fr = /* @__PURE__ */ new Uint32Array(64);
class H0 extends $0 {
  constructor(t) {
    super(64, t, 8, !1);
  }
  get() {
    const { A: t, B: r, C: a, D: i, E: o, F: s, G: n, H: p } = this;
    return [t, r, a, i, o, s, n, p];
  }
  // prettier-ignore
  set(t, r, a, i, o, s, n, p) {
    this.A = t | 0, this.B = r | 0, this.C = a | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = n | 0, this.H = p | 0;
  }
  process(t, r) {
    for (let w = 0; w < 16; w++, r += 4)
      Fr[w] = t.getUint32(r, !1);
    for (let w = 16; w < 64; w++) {
      const y = Fr[w - 15], k = Fr[w - 2], A = gr(y, 7) ^ gr(y, 18) ^ y >>> 3, E = gr(k, 17) ^ gr(k, 19) ^ k >>> 10;
      Fr[w] = E + Fr[w - 7] + A + Fr[w - 16] | 0;
    }
    let { A: a, B: i, C: o, D: s, E: n, F: p, G: d, H: u } = this;
    for (let w = 0; w < 64; w++) {
      const y = gr(n, 6) ^ gr(n, 11) ^ gr(n, 25), k = u + y + M0(n, p, d) + K0[w] + Fr[w] | 0, A = (gr(a, 2) ^ gr(a, 13) ^ gr(a, 22)) + F0(a, i, o) | 0;
      u = d, d = p, p = n, n = s + k | 0, s = o, o = i, i = a, a = k + A | 0;
    }
    a = a + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, n = n + this.E | 0, p = p + this.F | 0, d = d + this.G | 0, u = u + this.H | 0, this.set(a, i, o, s, n, p, d, u);
  }
  roundClean() {
    Qa(Fr);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Qa(this.buffer);
  }
}
class Z0 extends H0 {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = Mr[0] | 0;
  B = Mr[1] | 0;
  C = Mr[2] | 0;
  D = Mr[3] | 0;
  E = Mr[4] | 0;
  F = Mr[5] | 0;
  G = Mr[6] | 0;
  H = Mr[7] | 0;
  constructor() {
    super(32);
  }
}
const da = /* @__PURE__ */ q0(
  () => new Z0(),
  /* @__PURE__ */ D0(1)
);
function G0(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let d = 0; d < t.length; d++)
    t[d] = 255;
  for (let d = 0; d < e.length; d++) {
    const u = e.charAt(d), w = u.charCodeAt(0);
    if (t[w] !== 255)
      throw new TypeError(u + " is ambiguous");
    t[w] = d;
  }
  const r = e.length, a = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function s(d) {
    if (d instanceof Uint8Array || (ArrayBuffer.isView(d) ? d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength) : Array.isArray(d) && (d = Uint8Array.from(d))), !(d instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (d.length === 0)
      return "";
    let u = 0, w = 0, y = 0;
    const k = d.length;
    for (; y !== k && d[y] === 0; )
      y++, u++;
    const A = (k - y) * o + 1 >>> 0, E = new Uint8Array(A);
    for (; y !== k; ) {
      let B = d[y], z = 0;
      for (let O = A - 1; (B !== 0 || z < w) && O !== -1; O--, z++)
        B += 256 * E[O] >>> 0, E[O] = B % r >>> 0, B = B / r >>> 0;
      if (B !== 0)
        throw new Error("Non-zero carry");
      w = z, y++;
    }
    let x = A - w;
    for (; x !== A && E[x] === 0; )
      x++;
    let I = a.repeat(u);
    for (; x < A; ++x)
      I += e.charAt(E[x]);
    return I;
  }
  function n(d) {
    if (typeof d != "string")
      throw new TypeError("Expected String");
    if (d.length === 0)
      return new Uint8Array();
    let u = 0, w = 0, y = 0;
    for (; d[u] === a; )
      w++, u++;
    const k = (d.length - u) * i + 1 >>> 0, A = new Uint8Array(k);
    for (; u < d.length; ) {
      const B = d.charCodeAt(u);
      if (B > 255)
        return;
      let z = t[B];
      if (z === 255)
        return;
      let O = 0;
      for (let F = k - 1; (z !== 0 || O < y) && F !== -1; F--, O++)
        z += r * A[F] >>> 0, A[F] = z % 256 >>> 0, z = z / 256 >>> 0;
      if (z !== 0)
        throw new Error("Non-zero carry");
      y = O, u++;
    }
    let E = k - y;
    for (; E !== k && A[E] === 0; )
      E++;
    const x = new Uint8Array(w + (k - E));
    let I = w;
    for (; E !== k; )
      x[I++] = A[E++];
    return x;
  }
  function p(d) {
    const u = n(d);
    if (u)
      return u;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: n,
    decode: p
  };
}
var V0 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const qi = G0(V0);
function W0(e) {
  function t(o) {
    const s = e(o), n = o.length + 4, p = new Uint8Array(n);
    return p.set(o, 0), p.set(s.subarray(0, 4), o.length), qi.encode(p);
  }
  function r(o) {
    const s = o.slice(0, -4), n = o.slice(-4), p = e(s);
    if (!(n[0] ^ p[0] | n[1] ^ p[1] | n[2] ^ p[2] | n[3] ^ p[3]))
      return s;
  }
  function a(o) {
    const s = qi.decodeUnsafe(o);
    if (s !== void 0)
      return r(s);
  }
  function i(o) {
    const s = qi.decode(o), n = r(s);
    if (n === void 0)
      throw new Error("Invalid checksum");
    return n;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: a
  };
}
function Y0(e) {
  return da(da(e));
}
const { encode: X0, decode: J0, decodeUnsafe: Q0 } = W0(Y0), of = { encode: X0, decode: J0, decodeUnsafe: Q0 };
function eg(e, t) {
  if (e.length === 33)
    return {
      version: e[0],
      privateKey: e.slice(1, 33),
      compressed: !1
    };
  if (e.length !== 34)
    throw new Error("Invalid WIF length");
  if (e[33] !== 1)
    throw new Error("Invalid compression flag");
  return {
    version: e[0],
    privateKey: e.slice(1, 33),
    compressed: !0
  };
}
function rg(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  const a = new Uint8Array(r ? 34 : 33);
  return new DataView(a.buffer).setUint8(0, e), a.set(t, 1), r && (a[33] = 1), a;
}
function tg(e, t) {
  return eg(of.decode(e));
}
function ag(e) {
  return of.encode(rg(e.version, e.privateKey, e.compressed));
}
function nf(e, t, r) {
  return ag({
    version: r.wif,
    privateKey: e,
    compressed: t
  });
}
function sf(e, t) {
  const r = tg(e), a = r.version;
  if (Array.isArray(t)) {
    const o = t.find((s) => s.wif === a);
    if (!o) throw new Error("Unknown network version");
    return {
      privateKey: Xa(r.privateKey),
      compressed: r.compressed,
      network: o
    };
  }
  const i = t;
  if (a !== i.wif)
    throw new Error("Invalid network version");
  return {
    privateKey: Xa(r.privateKey),
    compressed: r.compressed,
    network: i
  };
}
function ig(e) {
  return e[0] === 3 ? !0 : e[0] === 4 && e.length === 65 ? (e[64] & 1) === 1 : !1;
}
function og(e) {
  const t = e.length === 32 ? e : e.subarray(1, 33);
  return rf(t);
}
const Di = 48;
function ng(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
function sg(e) {
  const t = new Uint8Array(32);
  for (let r = 31; r >= 0; r--)
    t[r] = Number(e & 0xffn), e >>= 8n;
  return t;
}
class Zr {
  #e;
  #r;
  #a;
  #t;
  #i;
  #o;
  #n;
  constructor(t, r, a, i, o) {
    if (o?.compressed !== void 0 && typeof o.compressed != "boolean")
      throw new TypeError(
        `Expected boolean for compressed, got ${typeof o.compressed}`
      );
    this.#e = t, this.#r = r, this.#t = o?.compressed ?? !0, this.#a = i, a !== void 0 && (this.#i = t.pointCompress(a, this.#t));
  }
  /** Raw private key bytes, or `undefined` for public-key-only signers. */
  get privateKey() {
    return this.#r;
  }
  /**
   * SEC1-encoded public key.  Lazily derived from the private key when
   * the signer was created via {@link fromPrivateKey} or {@link fromWIF}.
   *
   * @throws If neither a private nor public key is available (should never happen).
   */
  get publicKey() {
    if (this.#i === void 0) {
      const t = this.#r;
      if (t === void 0)
        throw new Error("Missing both private and public key");
      const r = this.#e.pointFromScalar(t, this.#t);
      if (r === null)
        throw new Error("Failed to derive public key from private key");
      this.#i = r;
    }
    return this.#i;
  }
  /** 32-byte BIP-340 x-only public key (lazily derived and cached). */
  get xOnlyPublicKey() {
    return this.#o === void 0 && (this.#o = og(this.publicKey)), this.#o;
  }
  /** Network this signer is bound to. */
  get network() {
    return this.#a;
  }
  /** Whether the public key is in compressed SEC1 form. */
  get compressed() {
    return this.#t;
  }
  /**
   * Bitmask of {@link SignerCapability} flags representing the operations
   * this signer can perform.  Lazily computed and cached.
   */
  get capabilities() {
    if (this.#n === void 0) {
      let t = at.EcdsaVerify | at.PublicKeyTweak;
      this.#r !== void 0 && (t |= at.EcdsaSign | at.PrivateKeyExport), this.#e.signSchnorr && this.#r !== void 0 && (t |= at.SchnorrSign), this.#e.verifySchnorr && (t |= at.SchnorrVerify), this.#n = t;
    }
    return this.#n;
  }
  /**
   * Creates a signer from a raw private key.
   *
   * @param backend - Cryptographic backend to use.
   * @param privateKey - 32-byte secp256k1 private key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws {TypeError} If the private key is not in the valid range `[1, n)`.
   */
  static fromPrivateKey(t, r, a, i) {
    if (!t.isPrivate(r))
      throw new TypeError("Private key not in range [1, n)");
    return new Zr(t, r, void 0, a, i);
  }
  /**
   * Creates a public-key-only signer (cannot sign, export WIF, etc.).
   *
   * @param backend - Cryptographic backend to use.
   * @param publicKey - SEC1-encoded public key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws If the public key is not a valid curve point.
   */
  static fromPublicKey(t, r, a, i) {
    if (!t.isPoint(r))
      throw new Error("Point not on the curve");
    return new Zr(t, void 0, r, a, i);
  }
  /**
   * Imports a signer from a WIF-encoded private key string.
   *
   * @param backend - Cryptographic backend to use.
   * @param wifString - Base58Check WIF string.
   * @param network - One or more candidate networks whose WIF version byte is matched.
   * @throws If no network matches the decoded version byte.
   */
  static fromWIF(t, r, a) {
    const i = sf(r, a);
    return Zr.fromPrivateKey(t, i.privateKey, i.network, {
      compressed: i.compressed
    });
  }
  /**
   * Generates a new signer with a random private key.
   *
   * Uses FIPS 186-5 B.4.2 / RFC 9380 modular reduction:
   * 48 bytes of entropy are reduced via `(seed mod (n  1)) + 1`,
   * producing a key in `[1, n)` with negligible bias (< 2^128).
   *
   * @param backend - Cryptographic backend to use.
   * @param network - Target network.
   * @param options - Optional settings (rng, compressed).
   */
  static makeRandom(t, r, a) {
    const i = (a?.rng ?? ((n) => crypto.getRandomValues(new Uint8Array(n))))(Di);
    if (i.length !== Di)
      throw new TypeError(
        `Expected ${Di} bytes from rng, got ${i.length} bytes`
      );
    const o = ng(i) % (hi - 1n) + 1n, s = sg(o);
    return Zr.fromPrivateKey(
      t,
      Xa(s),
      r,
      a
    );
  }
  /**
   * Tests whether this signer has a specific capability.
   * @param cap - {@link SignerCapability} flag to test.
   */
  hasCapability(t) {
    return (this.capabilities & t) !== 0;
  }
  /**
   * Produces a compact ECDSA signature.
   *
   * When `lowR` is `true`, grinds the nonce until the R value's first
   * byte is `<= 0x7f`, producing a smaller DER encoding.
   *
   * @param hash - 32-byte message digest.
   * @param lowR - Enable low-R grinding.  Defaults to `false`.
   * @throws If this is a public-key-only signer.
   */
  sign(t, r) {
    if (this.#r === void 0) throw new Error("Missing private key");
    if (!r)
      return this.#e.sign(t, this.#r);
    let a = this.#e.sign(t, this.#r);
    const i = new Uint8Array(32), o = new DataView(i.buffer, i.byteOffset, i.byteLength);
    let s = 0;
    for (; ; ) {
      const n = a[0];
      if (n === void 0) throw new Error("Backend returned invalid signature");
      if (n <= 127) break;
      s++, o.setUint32(0, s, !0), a = this.#e.sign(t, this.#r, i);
    }
    return a;
  }
  /**
   * Produces a 64-byte BIP-340 Schnorr signature.
   *
   * @param hash - 32-byte message digest.
   * @throws If this is a public-key-only signer.
   * @throws If the backend does not support Schnorr signing.
   */
  signSchnorr(t) {
    if (this.#r === void 0) throw new Error("Missing private key");
    if (!this.#e.signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return this.#e.signSchnorr(t, this.#r);
  }
  /**
   * Verifies a compact ECDSA signature against this signer's public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - Compact ECDSA signature.
   */
  verify(t, r) {
    return this.#e.verify(t, this.publicKey, r);
  }
  /**
   * Verifies a BIP-340 Schnorr signature against this signer's x-only public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - 64-byte Schnorr signature.
   * @throws If the backend does not support Schnorr verification.
   */
  verifySchnorr(t, r) {
    if (!this.#e.verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return this.#e.verifySchnorr(t, this.xOnlyPublicKey, r);
  }
  /**
   * Derives a new signer by applying a Taproot-style scalar tweak.
   *
   * When a private key is available the tweak is applied to the scalar
   * (negating first if the public key has odd Y).  Otherwise, only the
   * public key is tweaked via x-only point addition.
   *
   * @param t - 32-byte tweak scalar.
   * @throws If the tweaked key is invalid (e.g. lands on the point at infinity).
   */
  tweak(t) {
    return Yn(t), this.#r !== void 0 ? this.#s(t) : this.#l(t);
  }
  /**
   * Exports the private key as a WIF string using this signer's network.
   *
   * @throws If this is a public-key-only signer.
   */
  toWIF() {
    if (this.#r === void 0) throw new Error("Missing private key");
    return nf(this.#r, this.#t, this.#a);
  }
  #s(t) {
    const r = this.publicKey, a = this.#r;
    if (a === void 0)
      throw new Error("Missing private key");
    const i = ig(r) ? this.#e.privateNegate(a) : a, o = this.#e.privateAdd(i, t);
    if (o === null) throw new Error("Invalid tweaked private key!");
    return Zr.fromPrivateKey(this.#e, o, this.#a, {
      compressed: this.#t
    });
  }
  #l(t) {
    const r = this.xOnlyPublicKey, a = this.#e.xOnlyPointAddTweak(r, t);
    if (a === null || a.xOnlyPubkey === null)
      throw new Error("Cannot tweak public key!");
    const i = new Uint8Array([a.parity === 0 ? 2 : 3]), o = Ku(i, a.xOnlyPubkey);
    return Zr.fromPublicKey(this.#e, ef(o), this.#a, {
      compressed: this.#t
    });
  }
}
const Jn = /* @__PURE__ */ BigInt(0), wn = /* @__PURE__ */ BigInt(1);
function ri(e, t = "") {
  if (typeof e != "boolean") {
    const r = t && `"${t}" `;
    throw new Error(r + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function lf(e) {
  if (typeof e == "bigint") {
    if (!La(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    mt(e);
  return e;
}
function Ia(e) {
  const t = lf(e).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function cf(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? Jn : BigInt("0x" + e);
}
function wa(e) {
  return cf(pi(e));
}
function uf(e) {
  return cf(pi(lg(Te(e)).reverse()));
}
function Qn(e, t) {
  mt(t), e = lf(e);
  const r = ei(e.toString(16).padStart(t * 2, "0"));
  if (r.length !== t)
    throw new Error("number too large");
  return r;
}
function ff(e, t) {
  return Qn(e, t).reverse();
}
function lg(e) {
  return Uint8Array.from(e);
}
function cg(e) {
  return Uint8Array.from(e, (t, r) => {
    const a = t.charCodeAt(0);
    if (t.length !== 1 || a > 127)
      throw new Error(`string contains non-ASCII character "${e[r]}" with code ${a} at position ${r}`);
    return a;
  });
}
const La = (e) => typeof e == "bigint" && Jn <= e;
function ug(e, t, r) {
  return La(e) && La(t) && La(r) && t <= e && e < r;
}
function fg(e, t, r, a) {
  if (!ug(t, r, a))
    throw new Error("expected valid " + e + ": " + r + " <= n < " + a + ", got " + t);
}
function dg(e) {
  let t;
  for (t = 0; e > Jn; e >>= wn, t += 1)
    ;
  return t;
}
const es = (e) => (wn << BigInt(e)) - wn;
function hg(e, t, r) {
  if (mt(e, "hashLen"), mt(t, "qByteLen"), typeof r != "function")
    throw new Error("hmacFn must be a function");
  const a = (E) => new Uint8Array(E), i = Uint8Array.of(), o = Uint8Array.of(0), s = Uint8Array.of(1), n = 1e3;
  let p = a(e), d = a(e), u = 0;
  const w = () => {
    p.fill(1), d.fill(0), u = 0;
  }, y = (...E) => r(d, Ar(p, ...E)), k = (E = i) => {
    d = y(o, E), p = y(), E.length !== 0 && (d = y(s, E), p = y());
  }, A = () => {
    if (u++ >= n)
      throw new Error("drbg: tried max amount of iterations");
    let E = 0;
    const x = [];
    for (; E < t; ) {
      p = y();
      const I = p.slice();
      x.push(I), E += p.length;
    }
    return Ar(...x);
  };
  return (E, x) => {
    w(), k(E);
    let I;
    for (; !(I = x(A())); )
      k();
    return w(), I;
  };
}
function rs(e, t = {}, r = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function a(o, s, n) {
    const p = e[o];
    if (n && p === void 0)
      return;
    const d = typeof p;
    if (d !== s || p === null)
      throw new Error(`param "${o}" is invalid: expected ${s}, got ${d}`);
  }
  const i = (o, s) => Object.entries(o).forEach(([n, p]) => a(n, p, s));
  i(t, !1), i(r, !0);
}
function ll(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...a) => {
    const i = t.get(r);
    if (i !== void 0)
      return i;
    const o = e(r, ...a);
    return t.set(r, o), o;
  };
}
const Xe = /* @__PURE__ */ BigInt(0), We = /* @__PURE__ */ BigInt(1), ct = /* @__PURE__ */ BigInt(2), df = /* @__PURE__ */ BigInt(3), hf = /* @__PURE__ */ BigInt(4), pf = /* @__PURE__ */ BigInt(5), pg = /* @__PURE__ */ BigInt(7), gf = /* @__PURE__ */ BigInt(8), gg = /* @__PURE__ */ BigInt(9), bf = /* @__PURE__ */ BigInt(16);
function er(e, t) {
  const r = e % t;
  return r >= Xe ? r : t + r;
}
function ir(e, t, r) {
  let a = e;
  for (; t-- > Xe; )
    a *= a, a %= r;
  return a;
}
function cl(e, t) {
  if (e === Xe)
    throw new Error("invert: expected non-zero number");
  if (t <= Xe)
    throw new Error("invert: expected positive modulus, got " + t);
  let r = er(e, t), a = t, i = Xe, o = We;
  for (; r !== Xe; ) {
    const s = a / r, n = a % r, p = i - o * s;
    a = r, r = n, i = o, o = p;
  }
  if (a !== We)
    throw new Error("invert: does not exist");
  return er(i, t);
}
function ts(e, t, r) {
  if (!e.eql(e.sqr(t), r))
    throw new Error("Cannot find square root");
}
function mf(e, t) {
  const r = (e.ORDER + We) / hf, a = e.pow(t, r);
  return ts(e, a, t), a;
}
function bg(e, t) {
  const r = (e.ORDER - pf) / gf, a = e.mul(t, ct), i = e.pow(a, r), o = e.mul(t, i), s = e.mul(e.mul(o, ct), i), n = e.mul(o, e.sub(s, e.ONE));
  return ts(e, n, t), n;
}
function mg(e) {
  const t = bi(e), r = yf(e), a = r(t, t.neg(t.ONE)), i = r(t, a), o = r(t, t.neg(a)), s = (e + pg) / bf;
  return (n, p) => {
    let d = n.pow(p, s), u = n.mul(d, a);
    const w = n.mul(d, i), y = n.mul(d, o), k = n.eql(n.sqr(u), p), A = n.eql(n.sqr(w), p);
    d = n.cmov(d, u, k), u = n.cmov(y, w, A);
    const E = n.eql(n.sqr(u), p), x = n.cmov(d, u, E);
    return ts(n, x, p), x;
  };
}
function yf(e) {
  if (e < df)
    throw new Error("sqrt is not defined for small field");
  let t = e - We, r = 0;
  for (; t % ct === Xe; )
    t /= ct, r++;
  let a = ct;
  const i = bi(e);
  for (; ul(i, a) === 1; )
    if (a++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (r === 1)
    return mf;
  let o = i.pow(a, t);
  const s = (t + We) / ct;
  return function(n, p) {
    if (n.is0(p))
      return p;
    if (ul(n, p) !== 1)
      throw new Error("Cannot find square root");
    let d = r, u = n.mul(n.ONE, o), w = n.pow(p, t), y = n.pow(p, s);
    for (; !n.eql(w, n.ONE); ) {
      if (n.is0(w))
        return n.ZERO;
      let k = 1, A = n.sqr(w);
      for (; !n.eql(A, n.ONE); )
        if (k++, A = n.sqr(A), k === d)
          throw new Error("Cannot find square root");
      const E = We << BigInt(d - k - 1), x = n.pow(u, E);
      d = k, u = n.sqr(x), w = n.mul(w, u), y = n.mul(y, x);
    }
    return y;
  };
}
function yg(e) {
  return e % hf === df ? mf : e % gf === pf ? bg : e % bf === gg ? mg(e) : yf(e);
}
const vg = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function wg(e) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, r = vg.reduce((a, i) => (a[i] = "function", a), t);
  return rs(e, r), e;
}
function _g(e, t, r) {
  if (r < Xe)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === Xe)
    return e.ONE;
  if (r === We)
    return t;
  let a = e.ONE, i = t;
  for (; r > Xe; )
    r & We && (a = e.mul(a, i)), i = e.sqr(i), r >>= We;
  return a;
}
function vf(e, t, r = !1) {
  const a = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((s, n, p) => e.is0(n) ? s : (a[p] = s, e.mul(s, n)), e.ONE), o = e.inv(i);
  return t.reduceRight((s, n, p) => e.is0(n) ? s : (a[p] = e.mul(s, a[p]), e.mul(s, n)), o), a;
}
function ul(e, t) {
  const r = (e.ORDER - We) / ct, a = e.pow(t, r), i = e.eql(a, e.ONE), o = e.eql(a, e.ZERO), s = e.eql(a, e.neg(e.ONE));
  if (!i && !o && !s)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : o ? 0 : -1;
}
function kg(e, t) {
  t !== void 0 && mt(t);
  const r = t !== void 0 ? t : e.toString(2).length, a = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: a };
}
class Eg {
  ORDER;
  BITS;
  BYTES;
  isLE;
  ZERO = Xe;
  ONE = We;
  _lengths;
  _sqrt;
  // cached sqrt
  _mod;
  constructor(t, r = {}) {
    if (t <= Xe)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let a;
    this.isLE = !1, r != null && typeof r == "object" && (typeof r.BITS == "number" && (a = r.BITS), typeof r.sqrt == "function" && (this.sqrt = r.sqrt), typeof r.isLE == "boolean" && (this.isLE = r.isLE), r.allowedLengths && (this._lengths = r.allowedLengths?.slice()), typeof r.modFromBytes == "boolean" && (this._mod = r.modFromBytes));
    const { nBitLength: i, nByteLength: o } = kg(t, a);
    if (o > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = i, this.BYTES = o, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return er(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return Xe <= t && t < this.ORDER;
  }
  is0(t) {
    return t === Xe;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & We) === We;
  }
  neg(t) {
    return er(-t, this.ORDER);
  }
  eql(t, r) {
    return t === r;
  }
  sqr(t) {
    return er(t * t, this.ORDER);
  }
  add(t, r) {
    return er(t + r, this.ORDER);
  }
  sub(t, r) {
    return er(t - r, this.ORDER);
  }
  mul(t, r) {
    return er(t * r, this.ORDER);
  }
  pow(t, r) {
    return _g(this, t, r);
  }
  div(t, r) {
    return er(t * cl(r, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, r) {
    return t + r;
  }
  subN(t, r) {
    return t - r;
  }
  mulN(t, r) {
    return t * r;
  }
  inv(t) {
    return cl(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = yg(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? ff(t, this.BYTES) : Qn(t, this.BYTES);
  }
  fromBytes(t, r = !1) {
    Te(t);
    const { _lengths: a, BYTES: i, isLE: o, ORDER: s, _mod: n } = this;
    if (a) {
      if (!a.includes(t.length) || t.length > i)
        throw new Error("Field.fromBytes: expected " + a + " bytes, got " + t.length);
      const d = new Uint8Array(i);
      d.set(t, o ? 0 : d.length - t.length), t = d;
    }
    if (t.length !== i)
      throw new Error("Field.fromBytes: expected " + i + " bytes, got " + t.length);
    let p = o ? uf(t) : wa(t);
    if (n && (p = er(p, s)), !r && !this.isValid(p))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return p;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return vf(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, r, a) {
    return a ? r : t;
  }
}
function bi(e, t = {}) {
  return new Eg(e, t);
}
function wf(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function _f(e) {
  const t = wf(e);
  return t + Math.ceil(t / 2);
}
function kf(e, t, r = !1) {
  Te(e);
  const a = e.length, i = wf(t), o = _f(t);
  if (a < 16 || a < o || a > 1024)
    throw new Error("expected " + o + "-1024 bytes of input, got " + a);
  const s = r ? uf(e) : wa(e), n = er(s, t - We) + We;
  return r ? ff(n, i) : Qn(n, i);
}
const Pt = /* @__PURE__ */ BigInt(0), ut = /* @__PURE__ */ BigInt(1);
function ti(e, t) {
  const r = t.negate();
  return e ? r : t;
}
function fl(e, t) {
  const r = vf(e.Fp, t.map((a) => a.Z));
  return t.map((a, i) => e.fromAffine(a.toAffine(r[i])));
}
function Ef(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function Mi(e, t) {
  Ef(e, t);
  const r = Math.ceil(t / e) + 1, a = 2 ** (e - 1), i = 2 ** e, o = es(e), s = BigInt(e);
  return { windows: r, windowSize: a, mask: o, maxNumber: i, shiftBy: s };
}
function dl(e, t, r) {
  const { windowSize: a, mask: i, maxNumber: o, shiftBy: s } = r;
  let n = Number(e & i), p = e >> s;
  n > a && (n -= o, p += ut);
  const d = t * a, u = d + Math.abs(n) - 1, w = n === 0, y = n < 0, k = t % 2 !== 0;
  return { nextN: p, offset: u, isZero: w, isNeg: y, isNegF: k, offsetF: d };
}
const Fi = /* @__PURE__ */ new WeakMap(), xf = /* @__PURE__ */ new WeakMap();
function $i(e) {
  return xf.get(e) || 1;
}
function hl(e) {
  if (e !== Pt)
    throw new Error("invalid wNAF");
}
class xg {
  BASE;
  ZERO;
  Fn;
  bits;
  // Parametrized with a given Point class (not individual point)
  constructor(t, r) {
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = r;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, r, a = this.ZERO) {
    let i = t;
    for (; r > Pt; )
      r & ut && (a = a.add(i)), i = i.double(), r >>= ut;
    return a;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(1) * (Math.ceil( / ) + 1), where:
   * -  is the window size
   * -  is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, r) {
    const { windows: a, windowSize: i } = Mi(r, this.bits), o = [];
    let s = t, n = s;
    for (let p = 0; p < a; p++) {
      n = s, o.push(n);
      for (let d = 1; d < i; d++)
        n = n.add(s), o.push(n);
      s = n.double();
    }
    return o;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, r, a) {
    if (!this.Fn.isValid(a))
      throw new Error("invalid scalar");
    let i = this.ZERO, o = this.BASE;
    const s = Mi(t, this.bits);
    for (let n = 0; n < s.windows; n++) {
      const { nextN: p, offset: d, isZero: u, isNeg: w, isNegF: y, offsetF: k } = dl(a, n, s);
      a = p, u ? o = o.add(ti(y, r[k])) : i = i.add(ti(w, r[d]));
    }
    return hl(a), { p: i, f: o };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, r, a, i = this.ZERO) {
    const o = Mi(t, this.bits);
    for (let s = 0; s < o.windows && a !== Pt; s++) {
      const { nextN: n, offset: p, isZero: d, isNeg: u } = dl(a, s, o);
      if (a = n, !d) {
        const w = r[p];
        i = i.add(u ? w.negate() : w);
      }
    }
    return hl(a), i;
  }
  getPrecomputes(t, r, a) {
    let i = Fi.get(r);
    return i || (i = this.precomputeWindow(r, t), t !== 1 && (typeof a == "function" && (i = a(i)), Fi.set(r, i))), i;
  }
  cached(t, r, a) {
    const i = $i(t);
    return this.wNAF(i, this.getPrecomputes(i, t, a), r);
  }
  unsafe(t, r, a, i) {
    const o = $i(t);
    return o === 1 ? this._unsafeLadder(t, r, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, a), r, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, r) {
    Ef(r, this.bits), xf.set(t, r), Fi.delete(t);
  }
  hasCache(t) {
    return $i(t) !== 1;
  }
}
function Ag(e, t, r, a) {
  let i = t, o = e.ZERO, s = e.ZERO;
  for (; r > Pt || a > Pt; )
    r & ut && (o = o.add(i)), a & ut && (s = s.add(i)), i = i.double(), r >>= ut, a >>= ut;
  return { p1: o, p2: s };
}
function pl(e, t, r) {
  if (t) {
    if (t.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return wg(t), t;
  } else
    return bi(e, { isLE: r });
}
function Bg(e, t, r = {}, a) {
  if (a === void 0 && (a = e === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const n of ["p", "n", "h"]) {
    const p = t[n];
    if (!(typeof p == "bigint" && p > Pt))
      throw new Error(`CURVE.${n} must be positive bigint`);
  }
  const i = pl(t.p, r.Fp, a), o = pl(t.n, r.Fn, a), s = ["Gx", "Gy", "a", "b"];
  for (const n of s)
    if (!i.isValid(t[n]))
      throw new Error(`CURVE.${n} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: i, Fn: o };
}
function Af(e, t) {
  return function(r) {
    const a = e(r);
    return { secretKey: a, publicKey: t(a) };
  };
}
class Bf {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = !1;
  destroyed = !1;
  constructor(t, r) {
    if (tf(t), Te(r, void 0, "key"), this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const a = this.blockLen, i = new Uint8Array(a);
    i.set(r.length > a ? t.create().update(r).digest() : r);
    for (let o = 0; o < i.length; o++)
      i[o] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let o = 0; o < i.length; o++)
      i[o] ^= 106;
    this.oHash.update(i), Qa(i);
  }
  update(t) {
    return Ja(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    Ja(this), Te(t, this.outputLen, "output"), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash: r, iHash: a, finished: i, destroyed: o, blockLen: s, outputLen: n } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = n, t.oHash = r._cloneInto(t.oHash), t.iHash = a._cloneInto(t.iHash), t;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const zf = (e, t, r) => new Bf(e, t).update(r).digest();
zf.create = (e, t) => new Bf(e, t);
const gl = (e, t) => (e + (e >= 0 ? t : -t) / Sf) / t;
function zg(e, t, r) {
  const [[a, i], [o, s]] = t, n = gl(s * e, r), p = gl(-i * e, r);
  let d = e - n * a - p * o, u = -n * i - p * s;
  const w = d < Lr, y = u < Lr;
  w && (d = -d), y && (u = -u);
  const k = es(Math.ceil(dg(r) / 2)) + Tt;
  if (d < Lr || d >= k || u < Lr || u >= k)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: w, k1: d, k2neg: y, k2: u };
}
function _n(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function Ki(e, t) {
  const r = {};
  for (let a of Object.keys(t))
    r[a] = e[a] === void 0 ? t[a] : e[a];
  return ri(r.lowS, "lowS"), ri(r.prehash, "prehash"), r.format !== void 0 && _n(r.format), r;
}
class Sg extends Error {
  constructor(t = "") {
    super(t);
  }
}
const Gr = {
  // asn.1 DER encoding utils
  Err: Sg,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = Gr;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const a = t.length / 2, i = Ia(a);
      if (i.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const o = a > 127 ? Ia(i.length / 2 | 128) : "";
      return Ia(e) + o + i + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = Gr;
      let a = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[a++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const i = t[a++], o = !!(i & 128);
      let s = 0;
      if (!o)
        s = i;
      else {
        const p = i & 127;
        if (!p)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (p > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const d = t.subarray(a, a + p);
        if (d.length !== p)
          throw new r("tlv.decode: length bytes not complete");
        if (d[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const u of d)
          s = s << 8 | u;
        if (a += p, s < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const n = t.subarray(a, a + s);
      if (n.length !== s)
        throw new r("tlv.decode: wrong value length");
      return { v: n, l: t.subarray(a + s) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = Gr;
      if (e < Lr)
        throw new t("integer: negative integers are not allowed");
      let r = Ia(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(e) {
      const { Err: t } = Gr;
      if (e[0] & 128)
        throw new t("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return wa(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: a } = Gr, i = Te(e, void 0, "signature"), { v: o, l: s } = a.decode(48, i);
    if (s.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: n, l: p } = a.decode(2, o), { v: d, l: u } = a.decode(2, p);
    if (u.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: r.decode(n), s: r.decode(d) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = Gr, a = t.encode(2, r.encode(e.r)), i = t.encode(2, r.encode(e.s)), o = a + i;
    return t.encode(48, o);
  }
}, Lr = BigInt(0), Tt = BigInt(1), Sf = BigInt(2), Ta = BigInt(3), Ig = BigInt(4);
function Tg(e, t = {}) {
  const r = Bg("weierstrass", e, t), { Fp: a, Fn: i } = r;
  let o = r.CURVE;
  const { h: s, n } = o;
  rs(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: p } = t;
  if (p && (!a.is0(o.a) || typeof p.beta != "bigint" || !Array.isArray(p.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const d = Tf(a, i);
  function u() {
    if (!a.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function w(m, U, C) {
    const { x: M, y: V } = U.toAffine(), te = a.toBytes(M);
    if (ri(C, "isCompressed"), C) {
      u();
      const ie = !a.isOdd(V);
      return Ar(If(ie), te);
    } else
      return Ar(Uint8Array.of(4), te, a.toBytes(V));
  }
  function y(m) {
    Te(m, void 0, "Point");
    const { publicKey: U, publicKeyUncompressed: C } = d, M = m.length, V = m[0], te = m.subarray(1);
    if (M === U && (V === 2 || V === 3)) {
      const ie = a.fromBytes(te);
      if (!a.isValid(ie))
        throw new Error("bad point: is not on curve, wrong x");
      const oe = E(ie);
      let ne;
      try {
        ne = a.sqrt(oe);
      } catch (P) {
        const Z = P instanceof Error ? ": " + P.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + Z);
      }
      u();
      const le = a.isOdd(ne);
      return (V & 1) === 1 !== le && (ne = a.neg(ne)), { x: ie, y: ne };
    } else if (M === C && V === 4) {
      const ie = a.BYTES, oe = a.fromBytes(te.subarray(0, ie)), ne = a.fromBytes(te.subarray(ie, ie * 2));
      if (!x(oe, ne))
        throw new Error("bad point: is not on curve");
      return { x: oe, y: ne };
    } else
      throw new Error(`bad point: got length ${M}, expected compressed=${U} or uncompressed=${C}`);
  }
  const k = t.toBytes || w, A = t.fromBytes || y;
  function E(m) {
    const U = a.sqr(m), C = a.mul(U, m);
    return a.add(a.add(C, a.mul(m, o.a)), o.b);
  }
  function x(m, U) {
    const C = a.sqr(U), M = E(m);
    return a.eql(C, M);
  }
  if (!x(o.Gx, o.Gy))
    throw new Error("bad curve params: generator point");
  const I = a.mul(a.pow(o.a, Ta), Ig), B = a.mul(a.sqr(o.b), BigInt(27));
  if (a.is0(a.add(I, B)))
    throw new Error("bad curve params: a or b");
  function z(m, U, C = !1) {
    if (!a.isValid(U) || C && a.is0(U))
      throw new Error(`bad point coordinate ${m}`);
    return U;
  }
  function O(m) {
    if (!(m instanceof S))
      throw new Error("Weierstrass Point expected");
  }
  function F(m) {
    if (!p || !p.basises)
      throw new Error("no endo");
    return zg(m, p.basises, i.ORDER);
  }
  const N = ll((m, U) => {
    const { X: C, Y: M, Z: V } = m;
    if (a.eql(V, a.ONE))
      return { x: C, y: M };
    const te = m.is0();
    U == null && (U = te ? a.ONE : a.inv(V));
    const ie = a.mul(C, U), oe = a.mul(M, U), ne = a.mul(V, U);
    if (te)
      return { x: a.ZERO, y: a.ZERO };
    if (!a.eql(ne, a.ONE))
      throw new Error("invZ was invalid");
    return { x: ie, y: oe };
  }), j = ll((m) => {
    if (m.is0()) {
      if (t.allowInfinityPoint && !a.is0(m.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: U, y: C } = m.toAffine();
    if (!a.isValid(U) || !a.isValid(C))
      throw new Error("bad point: x or y not field elements");
    if (!x(U, C))
      throw new Error("bad point: equation left != right");
    if (!m.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function q(m, U, C, M, V) {
    return C = new S(a.mul(C.X, m), C.Y, C.Z), U = ti(M, U), C = ti(V, C), U.add(C);
  }
  class S {
    // base / generator point
    static BASE = new S(o.Gx, o.Gy, a.ONE);
    // zero / infinity / identity point
    static ZERO = new S(a.ZERO, a.ONE, a.ZERO);
    // 0, 1, 0
    // math field
    static Fp = a;
    // scalar field
    static Fn = i;
    X;
    Y;
    Z;
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(U, C, M) {
      this.X = z("x", U), this.Y = z("y", C, !0), this.Z = z("z", M), Object.freeze(this);
    }
    static CURVE() {
      return o;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(U) {
      const { x: C, y: M } = U || {};
      if (!U || !a.isValid(C) || !a.isValid(M))
        throw new Error("invalid affine point");
      if (U instanceof S)
        throw new Error("projective point not allowed");
      return a.is0(C) && a.is0(M) ? S.ZERO : new S(C, M, a.ONE);
    }
    static fromBytes(U) {
      const C = S.fromAffine(A(Te(U, void 0, "point")));
      return C.assertValidity(), C;
    }
    static fromHex(U) {
      return S.fromBytes(ei(U));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(U = 8, C = !0) {
      return $.createCache(this, U), C || this.multiply(Ta), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      j(this);
    }
    hasEvenY() {
      const { y: U } = this.toAffine();
      if (!a.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !a.isOdd(U);
    }
    /** Compare one point to another. */
    equals(U) {
      O(U);
      const { X: C, Y: M, Z: V } = this, { X: te, Y: ie, Z: oe } = U, ne = a.eql(a.mul(C, oe), a.mul(te, V)), le = a.eql(a.mul(M, oe), a.mul(ie, V));
      return ne && le;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new S(this.X, a.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: U, b: C } = o, M = a.mul(C, Ta), { X: V, Y: te, Z: ie } = this;
      let oe = a.ZERO, ne = a.ZERO, le = a.ZERO, P = a.mul(V, V), Z = a.mul(te, te), T = a.mul(ie, ie), K = a.mul(V, te);
      return K = a.add(K, K), le = a.mul(V, ie), le = a.add(le, le), oe = a.mul(U, le), ne = a.mul(M, T), ne = a.add(oe, ne), oe = a.sub(Z, ne), ne = a.add(Z, ne), ne = a.mul(oe, ne), oe = a.mul(K, oe), le = a.mul(M, le), T = a.mul(U, T), K = a.sub(P, T), K = a.mul(U, K), K = a.add(K, le), le = a.add(P, P), P = a.add(le, P), P = a.add(P, T), P = a.mul(P, K), ne = a.add(ne, P), T = a.mul(te, ie), T = a.add(T, T), P = a.mul(T, K), oe = a.sub(oe, P), le = a.mul(T, Z), le = a.add(le, le), le = a.add(le, le), new S(oe, ne, le);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(U) {
      O(U);
      const { X: C, Y: M, Z: V } = this, { X: te, Y: ie, Z: oe } = U;
      let ne = a.ZERO, le = a.ZERO, P = a.ZERO;
      const Z = o.a, T = a.mul(o.b, Ta);
      let K = a.mul(C, te), W = a.mul(M, ie), X = a.mul(V, oe), re = a.add(C, M), Q = a.add(te, ie);
      re = a.mul(re, Q), Q = a.add(K, W), re = a.sub(re, Q), Q = a.add(C, V);
      let ae = a.add(te, oe);
      return Q = a.mul(Q, ae), ae = a.add(K, X), Q = a.sub(Q, ae), ae = a.add(M, V), ne = a.add(ie, oe), ae = a.mul(ae, ne), ne = a.add(W, X), ae = a.sub(ae, ne), P = a.mul(Z, Q), ne = a.mul(T, X), P = a.add(ne, P), ne = a.sub(W, P), P = a.add(W, P), le = a.mul(ne, P), W = a.add(K, K), W = a.add(W, K), X = a.mul(Z, X), Q = a.mul(T, Q), W = a.add(W, X), X = a.sub(K, X), X = a.mul(Z, X), Q = a.add(Q, X), K = a.mul(W, Q), le = a.add(le, K), K = a.mul(ae, Q), ne = a.mul(re, ne), ne = a.sub(ne, K), K = a.mul(re, W), P = a.mul(ae, P), P = a.add(P, K), new S(ne, le, P);
    }
    subtract(U) {
      return this.add(U.negate());
    }
    is0() {
      return this.equals(S.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(U) {
      const { endo: C } = t;
      if (!i.isValidNot0(U))
        throw new Error("invalid scalar: out of range");
      let M, V;
      const te = (ie) => $.cached(this, ie, (oe) => fl(S, oe));
      if (C) {
        const { k1neg: ie, k1: oe, k2neg: ne, k2: le } = F(U), { p: P, f: Z } = te(oe), { p: T, f: K } = te(le);
        V = Z.add(K), M = q(C.beta, P, T, ie, ne);
      } else {
        const { p: ie, f: oe } = te(U);
        M = ie, V = oe;
      }
      return fl(S, [M, V])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(U) {
      const { endo: C } = t, M = this;
      if (!i.isValid(U))
        throw new Error("invalid scalar: out of range");
      if (U === Lr || M.is0())
        return S.ZERO;
      if (U === Tt)
        return M;
      if ($.hasCache(this))
        return this.multiply(U);
      if (C) {
        const { k1neg: V, k1: te, k2neg: ie, k2: oe } = F(U), { p1: ne, p2: le } = Ag(S, M, te, oe);
        return q(C.beta, ne, le, V, ie);
      } else
        return $.unsafe(M, U);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(U) {
      return N(this, U);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: U } = t;
      return s === Tt ? !0 : U ? U(S, this) : $.unsafe(this, n).is0();
    }
    clearCofactor() {
      const { clearCofactor: U } = t;
      return s === Tt ? this : U ? U(S, this) : this.multiplyUnsafe(s);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(s).is0();
    }
    toBytes(U = !0) {
      return ri(U, "isCompressed"), this.assertValidity(), k(S, this, U);
    }
    toHex(U = !0) {
      return pi(this.toBytes(U));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const D = i.BITS, $ = new xg(S, t.endo ? Math.ceil(D / 2) : D);
  return S.BASE.precompute(8), S;
}
function If(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function Tf(e, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: !0,
    signature: 2 * t.BYTES
  };
}
function jg(e, t = {}) {
  const { Fn: r } = e, a = t.randomBytes || gi, i = Object.assign(Tf(e.Fp, r), { seed: _f(r.ORDER) });
  function o(k) {
    try {
      const A = r.fromBytes(k);
      return r.isValidNot0(A);
    } catch {
      return !1;
    }
  }
  function s(k, A) {
    const { publicKey: E, publicKeyUncompressed: x } = i;
    try {
      const I = k.length;
      return A === !0 && I !== E || A === !1 && I !== x ? !1 : !!e.fromBytes(k);
    } catch {
      return !1;
    }
  }
  function n(k = a(i.seed)) {
    return kf(Te(k, i.seed, "seed"), r.ORDER);
  }
  function p(k, A = !0) {
    return e.BASE.multiply(r.fromBytes(k)).toBytes(A);
  }
  function d(k) {
    const { secretKey: A, publicKey: E, publicKeyUncompressed: x } = i;
    if (!Xn(k) || "_lengths" in r && r._lengths || A === E)
      return;
    const I = Te(k, void 0, "key").length;
    return I === E || I === x;
  }
  function u(k, A, E = !0) {
    if (d(k) === !0)
      throw new Error("first arg must be private key");
    if (d(A) === !1)
      throw new Error("second arg must be public key");
    const x = r.fromBytes(k);
    return e.fromBytes(A).multiply(x).toBytes(E);
  }
  const w = {
    isValidSecretKey: o,
    isValidPublicKey: s,
    randomSecretKey: n
  }, y = Af(n, p);
  return Object.freeze({ getPublicKey: p, getSharedSecret: u, keygen: y, Point: e, utils: w, lengths: i });
}
function Og(e, t, r = {}) {
  tf(t), rs(r, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), r = Object.assign({}, r);
  const a = r.randomBytes || gi, i = r.hmac || ((C, M) => zf(t, C, M)), { Fp: o, Fn: s } = e, { ORDER: n, BITS: p } = s, { keygen: d, getPublicKey: u, getSharedSecret: w, utils: y, lengths: k } = jg(e, r), A = {
    prehash: !0,
    lowS: typeof r.lowS == "boolean" ? r.lowS : !0,
    format: "compact",
    extraEntropy: !1
  }, E = n * Sf < o.ORDER;
  function x(C) {
    const M = n >> Tt;
    return C > M;
  }
  function I(C, M) {
    if (!s.isValidNot0(M))
      throw new Error(`invalid signature ${C}: out of range 1..Point.Fn.ORDER`);
    return M;
  }
  function B() {
    if (E)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function z(C, M) {
    _n(M);
    const V = k.signature, te = M === "compact" ? V : M === "recovered" ? V + 1 : void 0;
    return Te(C, te);
  }
  class O {
    r;
    s;
    recovery;
    constructor(M, V, te) {
      if (this.r = I("r", M), this.s = I("s", V), te != null) {
        if (B(), ![0, 1, 2, 3].includes(te))
          throw new Error("invalid recovery id");
        this.recovery = te;
      }
      Object.freeze(this);
    }
    static fromBytes(M, V = A.format) {
      z(M, V);
      let te;
      if (V === "der") {
        const { r: le, s: P } = Gr.toSig(Te(M));
        return new O(le, P);
      }
      V === "recovered" && (te = M[0], V = "compact", M = M.subarray(1));
      const ie = k.signature / 2, oe = M.subarray(0, ie), ne = M.subarray(ie, ie * 2);
      return new O(s.fromBytes(oe), s.fromBytes(ne), te);
    }
    static fromHex(M, V) {
      return this.fromBytes(ei(M), V);
    }
    assertRecovery() {
      const { recovery: M } = this;
      if (M == null)
        throw new Error("invalid recovery id: must be present");
      return M;
    }
    addRecoveryBit(M) {
      return new O(this.r, this.s, M);
    }
    recoverPublicKey(M) {
      const { r: V, s: te } = this, ie = this.assertRecovery(), oe = ie === 2 || ie === 3 ? V + n : V;
      if (!o.isValid(oe))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const ne = o.toBytes(oe), le = e.fromBytes(Ar(If((ie & 1) === 0), ne)), P = s.inv(oe), Z = N(Te(M, void 0, "msgHash")), T = s.create(-Z * P), K = s.create(te * P), W = e.BASE.multiplyUnsafe(T).add(le.multiplyUnsafe(K));
      if (W.is0())
        throw new Error("invalid recovery: point at infinify");
      return W.assertValidity(), W;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return x(this.s);
    }
    toBytes(M = A.format) {
      if (_n(M), M === "der")
        return ei(Gr.hexFromSig(this));
      const { r: V, s: te } = this, ie = s.toBytes(V), oe = s.toBytes(te);
      return M === "recovered" ? (B(), Ar(Uint8Array.of(this.assertRecovery()), ie, oe)) : Ar(ie, oe);
    }
    toHex(M) {
      return pi(this.toBytes(M));
    }
  }
  const F = r.bits2int || function(C) {
    if (C.length > 8192)
      throw new Error("input is too large");
    const M = wa(C), V = C.length * 8 - p;
    return V > 0 ? M >> BigInt(V) : M;
  }, N = r.bits2int_modN || function(C) {
    return s.create(F(C));
  }, j = es(p);
  function q(C) {
    return fg("num < 2^" + p, C, Lr, j), s.toBytes(C);
  }
  function S(C, M) {
    return Te(C, void 0, "message"), M ? Te(t(C), void 0, "prehashed message") : C;
  }
  function D(C, M, V) {
    const { lowS: te, prehash: ie, extraEntropy: oe } = Ki(V, A);
    C = S(C, ie);
    const ne = N(C), le = s.fromBytes(M);
    if (!s.isValidNot0(le))
      throw new Error("invalid private key");
    const P = [q(le), q(ne)];
    if (oe != null && oe !== !1) {
      const W = oe === !0 ? a(k.secretKey) : oe;
      P.push(Te(W, void 0, "extraEntropy"));
    }
    const Z = Ar(...P), T = ne;
    function K(W) {
      const X = F(W);
      if (!s.isValidNot0(X))
        return;
      const re = s.inv(X), Q = e.BASE.multiply(X).toAffine(), ae = s.create(Q.x);
      if (ae === Lr)
        return;
      const ce = s.create(re * s.create(T + ae * le));
      if (ce === Lr)
        return;
      let ue = (Q.x === ae ? 0 : 2) | Number(Q.y & Tt), de = ce;
      return te && x(ce) && (de = s.neg(ce), ue ^= 1), new O(ae, de, E ? void 0 : ue);
    }
    return { seed: Z, k2sig: K };
  }
  function $(C, M, V = {}) {
    const { seed: te, k2sig: ie } = D(C, M, V);
    return hg(t.outputLen, s.BYTES, i)(te, ie).toBytes(V.format);
  }
  function m(C, M, V, te = {}) {
    const { lowS: ie, prehash: oe, format: ne } = Ki(te, A);
    if (V = Te(V, void 0, "publicKey"), M = S(M, oe), !Xn(C)) {
      const le = C instanceof O ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + le);
    }
    z(C, ne);
    try {
      const le = O.fromBytes(C, ne), P = e.fromBytes(V);
      if (ie && le.hasHighS())
        return !1;
      const { r: Z, s: T } = le, K = N(M), W = s.inv(T), X = s.create(K * W), re = s.create(Z * W), Q = e.BASE.multiplyUnsafe(X).add(P.multiplyUnsafe(re));
      return Q.is0() ? !1 : s.create(Q.x) === Z;
    } catch {
      return !1;
    }
  }
  function U(C, M, V = {}) {
    const { prehash: te } = Ki(V, A);
    return M = S(M, te), O.fromBytes(C, "recovered").recoverPublicKey(M).toBytes();
  }
  return Object.freeze({
    keygen: d,
    getPublicKey: u,
    getSharedSecret: w,
    utils: y,
    lengths: k,
    Point: e,
    sign: $,
    verify: m,
    recoverPublicKey: U,
    Signature: O,
    hash: t
  });
}
const mi = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, Rg = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, Pg = /* @__PURE__ */ BigInt(0), kn = /* @__PURE__ */ BigInt(2);
function Ug(e) {
  const t = mi.p, r = BigInt(3), a = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), n = BigInt(44), p = BigInt(88), d = e * e * e % t, u = d * d * e % t, w = ir(u, r, t) * u % t, y = ir(w, r, t) * u % t, k = ir(y, kn, t) * d % t, A = ir(k, i, t) * k % t, E = ir(A, o, t) * A % t, x = ir(E, n, t) * E % t, I = ir(x, p, t) * x % t, B = ir(I, n, t) * E % t, z = ir(B, r, t) * u % t, O = ir(z, s, t) * A % t, F = ir(O, a, t) * d % t, N = ir(F, kn, t);
  if (!ai.eql(ai.sqr(N), e))
    throw new Error("Cannot find square root");
  return N;
}
const ai = bi(mi.p, { sqrt: Ug }), vt = /* @__PURE__ */ Tg(mi, {
  Fp: ai,
  endo: Rg
}), it = /* @__PURE__ */ Og(vt, da), bl = {};
function ii(e, ...t) {
  let r = bl[e];
  if (r === void 0) {
    const a = da(cg(e));
    r = Ar(a, a), bl[e] = r;
  }
  return da(Ar(r, ...t));
}
const as = (e) => e.toBytes(!0).slice(1), is = (e) => e % kn === Pg;
function En(e) {
  const { Fn: t, BASE: r } = vt, a = t.fromBytes(e), i = r.multiply(a);
  return { scalar: is(i.y) ? a : t.neg(a), bytes: as(i) };
}
function jf(e) {
  const t = ai;
  if (!t.isValidNot0(e))
    throw new Error("invalid x: Fail if x  p");
  const r = t.create(e * e), a = t.create(r * e + BigInt(7));
  let i = t.sqrt(a);
  is(i) || (i = t.neg(i));
  const o = vt.fromAffine({ x: e, y: i });
  return o.assertValidity(), o;
}
const aa = wa;
function Of(...e) {
  return vt.Fn.create(aa(ii("BIP0340/challenge", ...e)));
}
function ml(e) {
  return En(e).bytes;
}
function Cg(e, t, r = gi(32)) {
  const { Fn: a } = vt, i = Te(e, void 0, "message"), { bytes: o, scalar: s } = En(t), n = Te(r, 32, "auxRand"), p = a.toBytes(s ^ aa(ii("BIP0340/aux", n))), d = ii("BIP0340/nonce", p, o, i), { bytes: u, scalar: w } = En(d), y = Of(u, o, i), k = new Uint8Array(64);
  if (k.set(u, 0), k.set(a.toBytes(a.create(w + y * s)), 32), !Rf(k, i, o))
    throw new Error("sign: Invalid signature produced");
  return k;
}
function Rf(e, t, r) {
  const { Fp: a, Fn: i, BASE: o } = vt, s = Te(e, 64, "signature"), n = Te(t, void 0, "message"), p = Te(r, 32, "publicKey");
  try {
    const d = jf(aa(p)), u = aa(s.subarray(0, 32));
    if (!a.isValidNot0(u))
      return !1;
    const w = aa(s.subarray(32, 64));
    if (!i.isValidNot0(w))
      return !1;
    const y = Of(i.toBytes(u), as(d), n), k = o.multiplyUnsafe(w).add(d.multiplyUnsafe(i.neg(y))), { x: A, y: E } = k.toAffine();
    return !(k.is0() || !is(E) || A !== u);
  } catch {
    return !1;
  }
}
const Zt = /* @__PURE__ */ (() => {
  const e = (t = gi(48)) => kf(t, mi.n);
  return {
    keygen: Af(e, ml),
    getPublicKey: ml,
    sign: Cg,
    verify: Rf,
    Point: vt,
    utils: {
      randomSecretKey: e,
      taggedHash: ii,
      lift_x: jf,
      pointToBytes: as
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: !1,
      signature: 64,
      seed: 48
    }
  };
})(), zt = it.Point, ja = zt.Fn.ORDER;
function yl(e) {
  const t = e.toString(16).padStart(64, "0"), r = new Uint8Array(32);
  for (let a = 0; a < 32; a++)
    r[a] = parseInt(t.slice(a * 2, a * 2 + 2), 16);
  return r;
}
function rt(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
class Pf {
  /** @inheritDoc */
  isPrivate(t) {
    return it.utils.isValidSecretKey(t);
  }
  /** @inheritDoc */
  isPoint(t) {
    try {
      return zt.fromHex(Bt(t)), !0;
    } catch {
      return !1;
    }
  }
  /** @inheritDoc */
  isXOnlyPoint(t) {
    if (t.length !== 32) return !1;
    try {
      return Zt.utils.lift_x(rt(t)), !0;
    } catch {
      return !1;
    }
  }
  /** @inheritDoc */
  pointFromScalar(t, r) {
    try {
      return it.getPublicKey(t, r ?? !0);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  pointCompress(t, r) {
    return zt.fromHex(Bt(t)).toBytes(r ?? !0);
  }
  /** @inheritDoc */
  pointAddScalar(t, r, a) {
    try {
      const i = zt.fromHex(Bt(t));
      if (rt(r) === 0n)
        return i.toBytes(a ?? !0);
      const o = it.getPublicKey(r, !0), s = zt.fromHex(Bt(o));
      return i.add(s).toBytes(a ?? !0);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t, r) {
    try {
      const a = Zt.utils.lift_x(rt(t));
      if (rt(r) >= ja) return null;
      const i = it.getPublicKey(r, !0), o = zt.fromHex(Bt(i)), s = a.add(o), n = Zt.utils.pointToBytes(s);
      return {
        parity: Number(s.y & 1n),
        xOnlyPubkey: n
      };
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  privateAdd(t, r) {
    const a = rt(t), i = rt(r), o = er(a + i, ja);
    return o === 0n ? null : yl(o);
  }
  /** @inheritDoc */
  privateNegate(t) {
    const r = rt(t), a = er(ja - r, ja);
    return yl(a);
  }
  /** @inheritDoc */
  sign(t, r, a) {
    return it.sign(t, r, {
      prehash: !1,
      lowS: !0,
      extraEntropy: a ?? !1
    });
  }
  /** @inheritDoc */
  verify(t, r, a) {
    return it.verify(a, t, r, {
      prehash: !1,
      lowS: !0
    });
  }
  /** @inheritDoc */
  signSchnorr(t, r, a) {
    return Zt.sign(t, r, a);
  }
  /** @inheritDoc */
  verifySchnorr(t, r, a) {
    return Zt.verify(a, t, r);
  }
}
function Lg() {
  return new Pf();
}
class Uf {
  #e;
  /**
   * @param ecc - Object implementing the {@link TinySecp256k1Interface}.
   */
  constructor(t) {
    this.#e = t;
  }
  /** `true` when the underlying library supports Schnorr signing. */
  get hasSchnorrSign() {
    return typeof this.#e.signSchnorr == "function";
  }
  /** `true` when the underlying library supports Schnorr verification. */
  get hasSchnorrVerify() {
    return typeof this.#e.verifySchnorr == "function";
  }
  /** @inheritDoc */
  isPrivate(t) {
    return this.#e.isPrivate(t);
  }
  /** @inheritDoc */
  isPoint(t) {
    return this.#e.isPoint(t);
  }
  /** @inheritDoc */
  isXOnlyPoint(t) {
    if (t.length !== 32) return !1;
    const r = new Uint8Array(33);
    return r[0] = 2, r.set(t, 1), this.#e.isPoint(r);
  }
  /** @inheritDoc */
  pointFromScalar(t, r) {
    return this.#e.pointFromScalar(t, r);
  }
  /** @inheritDoc */
  pointCompress(t, r) {
    return this.#e.pointCompress(t, r);
  }
  /** @inheritDoc */
  pointAddScalar(t, r, a) {
    return this.#e.pointAddScalar(t, r, a);
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t, r) {
    const a = this.#e.xOnlyPointAddTweak(t, r);
    return a === null ? null : {
      parity: a.parity,
      xOnlyPubkey: a.xOnlyPubkey
    };
  }
  /** @inheritDoc */
  privateAdd(t, r) {
    return this.#e.privateAdd(t, r);
  }
  /** @inheritDoc */
  privateNegate(t) {
    return this.#e.privateNegate(t);
  }
  /** @inheritDoc */
  sign(t, r, a) {
    return this.#e.sign(t, r, a);
  }
  /** @inheritDoc */
  verify(t, r, a) {
    return this.#e.verify(t, r, a);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `signSchnorr`.
   */
  signSchnorr(t, r, a) {
    if (!this.#e.signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return this.#e.signSchnorr(t, r, a);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `verifySchnorr`.
   */
  verifySchnorr(t, r, a) {
    if (!this.#e.verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return this.#e.verifySchnorr(t, r, a);
  }
}
function Ng(e) {
  return new Uf(e);
}
function fe(e) {
  return $u(e);
}
function Ae(e, t) {
  if (!e) throw new Error(`verifyCryptoBackend: ${t}`);
}
function qg(e) {
  Ae(
    e.isPoint(fe("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPoint should accept generator point"
  ), Ae(
    !e.isPoint(fe("030000000000000000000000000000000000000000000000000000000000000005")),
    "isPoint should reject invalid point"
  ), Ae(
    e.isXOnlyPoint(
      fe("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "isXOnlyPoint should accept generator x-coordinate"
  ), Ae(
    !e.isXOnlyPoint(
      fe("0000000000000000000000000000000000000000000000000000000000000005")
    ),
    "isXOnlyPoint should reject x-coordinate not on curve"
  ), Ae(
    !e.isXOnlyPoint(
      fe("0000000000000000000000000000000000000000000000000000000000000000")
    ),
    "isXOnlyPoint should reject zero"
  ), Ae(
    !e.isXOnlyPoint(fe("79be667ef9dcbbac55a06295ce870b07")),
    "isXOnlyPoint should reject wrong length"
  ), Ae(
    e.isPrivate(fe("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPrivate should accept valid scalar"
  ), Ae(
    e.isPrivate(fe("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")),
    "isPrivate should accept n-1"
  ), Ae(
    !e.isPrivate(fe("0000000000000000000000000000000000000000000000000000000000000000")),
    "isPrivate should reject zero"
  ), Ae(
    !e.isPrivate(fe("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")),
    "isPrivate should reject n"
  ), Ae(
    !e.isPrivate(fe("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")),
    "isPrivate should reject n+1"
  );
  const t = e.privateAdd(
    fe("0000000000000000000000000000000000000000000000000000000000000001"),
    fe("0000000000000000000000000000000000000000000000000000000000000000")
  );
  Ae(
    t !== null && Ge(
      t,
      fe("0000000000000000000000000000000000000000000000000000000000000001")
    ),
    "privateAdd: 1 + 0 should equal 1"
  ), Ae(
    e.privateAdd(
      fe("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      fe("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null,
    "privateAdd: (n-3) + 3 should return null (result is zero mod n)"
  );
  const r = e.privateAdd(
    fe("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
    fe("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
  );
  Ae(
    r !== null && Ge(
      r,
      fe("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    ),
    "privateAdd: known vector failed"
  ), Ae(
    Ge(
      e.privateNegate(
        fe("0000000000000000000000000000000000000000000000000000000000000001")
      ),
      fe("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ),
    "privateNegate(1) should equal n-1"
  ), Ae(
    Ge(
      e.privateNegate(
        fe("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      ),
      fe("0000000000000000000000000000000000000000000000000000000000000003")
    ),
    "privateNegate(n-3) should equal 3"
  ), Ae(
    Ge(
      e.privateNegate(
        fe("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      ),
      fe("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    ),
    "privateNegate known vector failed"
  ), Ae(
    Ge(
      e.pointCompress(
        fe(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !0
      ),
      fe("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress uncompressed->compressed failed"
  ), Ae(
    Ge(
      e.pointCompress(
        fe(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !1
      ),
      fe(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress uncompressed->uncompressed failed"
  ), Ae(
    Ge(
      e.pointCompress(
        fe(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        !0
      ),
      fe("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress compressed->compressed failed"
  ), Ae(
    Ge(
      e.pointCompress(
        fe(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        !1
      ),
      fe(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress compressed->uncompressed failed"
  );
  const a = e.pointFromScalar(
    fe("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
  );
  Ae(
    a !== null && Ge(
      a,
      fe("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    ),
    "pointFromScalar known vector failed"
  ), Ae(
    e.xOnlyPointAddTweak(
      fe("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      fe("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null,
    "xOnlyPointAddTweak should return null for infinity result"
  );
  let i = e.xOnlyPointAddTweak(
    fe("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    fe("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  Ae(
    i !== null && Ge(
      i.xOnlyPubkey,
      fe("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && i.parity === 1,
    "xOnlyPointAddTweak parity=1 case failed"
  ), i = e.xOnlyPointAddTweak(
    fe("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    fe("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), Ae(
    i !== null && Ge(
      i.xOnlyPubkey,
      fe("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && i.parity === 0,
    "xOnlyPointAddTweak parity=0 case failed"
  );
  const o = e.sign(
    fe("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
    fe("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
  );
  if (Ae(
    Ge(
      o,
      fe(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    ),
    "sign known vector failed"
  ), Ae(
    e.verify(
      fe("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      fe("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      o
    ),
    "verify known vector failed"
  ), e.signSchnorr) {
    const s = e.signSchnorr(
      fe("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      fe("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
      fe("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
    );
    Ae(
      Ge(
        s,
        fe(
          "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
        )
      ),
      "signSchnorr known vector failed"
    );
  }
  e.verifySchnorr && Ae(
    e.verifySchnorr(
      fe(
        "7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"
      ),
      fe(
        "dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"
      ),
      fe(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    ),
    "verifySchnorr known vector failed"
  );
}
const Dg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ECPairSigner: Zr,
  EC_N: hi,
  EC_P: A0,
  LegacyBackend: Uf,
  NobleBackend: Pf,
  SATOSHI_MAX: Wn,
  SignerCapability: at,
  assertBytes32: Yn,
  assertMessageHash: Qu,
  assertPrivateKey: Yu,
  assertPublicKey: Xu,
  assertXOnlyPublicKey: Ju,
  bytesEqual: Ge,
  compareBytes: x0,
  concatBytes: Ku,
  createBytes20: O0,
  createBytes32: j0,
  createLegacyBackend: Ng,
  createMessageHash: U0,
  createNobleBackend: Lg,
  createPrivateKey: Xa,
  createPublicKey: ef,
  createSatoshi: C0,
  createSchnorrSignature: P0,
  createSignature: R0,
  createXOnlyPublicKey: rf,
  decodeWIF: sf,
  encodeWIF: nf,
  fromHexInternal: $u,
  isBytes20: z0,
  isBytes32: B0,
  isMessageHash: T0,
  isPrivateKey: S0,
  isPublicKey: Zu,
  isSatoshi: Wu,
  isSchnorrSignature: Vu,
  isSignature: Gu,
  isXOnlyPublicKey: I0,
  isZeroBytes: va,
  toHex: Bt,
  verifyCryptoBackend: qg
}, Symbol.toStringTag, { value: "Module" }));
var Hi = {}, br = {}, Et = {}, vl;
function Cf() {
  if (vl) return Et;
  vl = 1, Object.defineProperty(Et, "__esModule", { value: !0 }), Et.hash160 = a, Et.hash256 = i, Et.hmacSHA512 = o;
  const e = vd, t = md, r = yd;
  function a(s) {
    return (0, t.ripemd160)((0, r.sha256)(s));
  }
  function i(s) {
    return (0, r.sha256)(s);
  }
  function o(s, n) {
    return (0, e.hmac)(r.sha512, s, n);
  }
  return Et;
}
var mr = {};
const oi = "0123456789abcdefABCDEF", ni = oi.split("").map((e) => e.codePointAt(0)), si = Array(256).fill(!0).map((e, t) => {
  const r = String.fromCodePoint(t), a = oi.indexOf(r);
  return a < 0 ? void 0 : a < 16 ? a : a - 6;
}), Lf = new TextEncoder(), Nf = new TextDecoder();
function Mg(e) {
  return Nf.decode(e);
}
function Fg(e) {
  return Lf.encode(e);
}
function $g(e) {
  const t = e.reduce((i, o) => i + o.length, 0), r = new Uint8Array(t);
  let a = 0;
  for (const i of e)
    r.set(i, a), a += i.length;
  return r;
}
function Kg(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? Zg(t) : Hg(t);
}
function Hg(e) {
  let t = "";
  for (let r = 0; r < e.length; ++r)
    t += oi[si[ni[e[r] >> 4]]], t += oi[si[ni[e[r] & 15]]];
  return t;
}
function Zg(e) {
  const t = new Uint8Array(e.length * 2);
  for (let r = 0; r < e.length; ++r)
    t[r * 2] = ni[e[r] >> 4], t[r * 2 + 1] = ni[e[r] & 15];
  return Nf.decode(t);
}
function Gg(e) {
  const t = Lf.encode(e || ""), r = new Uint8Array(Math.floor(t.length / 2));
  let a;
  for (a = 0; a < r.length; a++) {
    const i = si[t[a * 2]], o = si[t[a * 2 + 1]];
    if (i === void 0 || o === void 0)
      break;
    r[a] = i << 4 | o;
  }
  return a === r.length ? r : r.slice(0, a);
}
function Vg(e) {
  return btoa(String.fromCharCode(...e));
}
function Wg(e) {
  const t = atob(e), r = new Uint8Array(t.length);
  for (let a = 0; a < t.length; a++)
    r[a] = t.charCodeAt(a);
  return r;
}
function Yg(e, t) {
  const r = Math.min(e.length, t.length);
  for (let a = 0; a < r; ++a)
    if (e[a] !== t[a])
      return e[a] < t[a] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function Xg(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 255)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 255. Received ${r}`);
  return e[t] = r, t + 1;
}
function Jg(e, t, r, a) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (a = a.toUpperCase(), r > 65535)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= 65535. Received ${r}`);
  return a === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function Qg(e, t, r, a) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (a = a.toUpperCase(), r > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${r}`);
  return a === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function eb(e, t, r, a) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (a = a.toUpperCase(), r > 0xffffffffffffffffn)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${r}`);
  return a === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function rb(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function tb(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let a = 0;
    return a = (a << 8) + e[t + 1], a = (a << 8) + e[t], a;
  } else {
    let a = 0;
    return a = (a << 8) + e[t], a = (a << 8) + e[t + 1], a;
  }
}
function ab(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let a = 0;
    return a = (a << 8) + e[t + 3] >>> 0, a = (a << 8) + e[t + 2] >>> 0, a = (a << 8) + e[t + 1] >>> 0, a = (a << 8) + e[t] >>> 0, a;
  } else {
    let a = 0;
    return a = (a << 8) + e[t] >>> 0, a = (a << 8) + e[t + 1] >>> 0, a = (a << 8) + e[t + 2] >>> 0, a = (a << 8) + e[t + 3] >>> 0, a;
  }
}
function ib(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    let a = 0n;
    return a = (a << 8n) + BigInt(e[t + 7]), a = (a << 8n) + BigInt(e[t + 6]), a = (a << 8n) + BigInt(e[t + 5]), a = (a << 8n) + BigInt(e[t + 4]), a = (a << 8n) + BigInt(e[t + 3]), a = (a << 8n) + BigInt(e[t + 2]), a = (a << 8n) + BigInt(e[t + 1]), a = (a << 8n) + BigInt(e[t]), a;
  } else {
    let a = 0n;
    return a = (a << 8n) + BigInt(e[t]), a = (a << 8n) + BigInt(e[t + 1]), a = (a << 8n) + BigInt(e[t + 2]), a = (a << 8n) + BigInt(e[t + 3]), a = (a << 8n) + BigInt(e[t + 4]), a = (a << 8n) + BigInt(e[t + 5]), a = (a << 8n) + BigInt(e[t + 6]), a = (a << 8n) + BigInt(e[t + 7]), a;
  }
}
function ob(e, t, r) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 127 || r < -128)
    throw new Error(`The value of "value" is out of range. It must be >= -128 and <= 127. Received ${r}`);
  return e[t] = r, t + 1;
}
function nb(e, t, r, a) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 32767 || r < -32768)
    throw new Error(`The value of "value" is out of range. It must be >= -32768 and <= 32767. Received ${r}`);
  return a = a.toUpperCase(), a === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255) : (e[t] = r >> 8 & 255, e[t + 1] = r & 255), t + 2;
}
function sb(e, t, r, a) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 2147483647 || r < -2147483648)
    throw new Error(`The value of "value" is out of range. It must be >= -2147483648 and <= 2147483647. Received ${r}`);
  return a = a.toUpperCase(), a === "LE" ? (e[t] = r & 255, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255) : (e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r & 255), t + 4;
}
function lb(e, t, r, a) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r > 0x7fffffffffffffffn || r < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${r}`);
  return a = a.toUpperCase(), a === "LE" ? (e[t] = Number(r & 0xffn), e[t + 1] = Number(r >> 8n & 0xffn), e[t + 2] = Number(r >> 16n & 0xffn), e[t + 3] = Number(r >> 24n & 0xffn), e[t + 4] = Number(r >> 32n & 0xffn), e[t + 5] = Number(r >> 40n & 0xffn), e[t + 6] = Number(r >> 48n & 0xffn), e[t + 7] = Number(r >> 56n & 0xffn)) : (e[t] = Number(r >> 56n & 0xffn), e[t + 1] = Number(r >> 48n & 0xffn), e[t + 2] = Number(r >> 40n & 0xffn), e[t + 3] = Number(r >> 32n & 0xffn), e[t + 4] = Number(r >> 24n & 0xffn), e[t + 5] = Number(r >> 16n & 0xffn), e[t + 6] = Number(r >> 8n & 0xffn), e[t + 7] = Number(r & 0xffn)), t + 8;
}
function cb(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  const r = e[t];
  return r <= 127 ? r : r - 256;
}
function ub(e, t, r) {
  if (t + 2 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const a = e[t] + (e[t + 1] << 8);
    return e[t + 1] <= 127 ? a : a - 65536;
  } else {
    const a = (e[t] << 8) + e[t + 1];
    return e[t] <= 127 ? a : a - 65536;
  }
}
function fb(e, t, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), r === "LE") {
    const a = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24 >>> 0);
    return e[t + 3] <= 127 ? a : a - 4294967296;
  } else {
    const a = (e[t] << 24 >>> 0) + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];
    return e[t] <= 127 ? a : a - 4294967296;
  }
}
function db(e, t, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  r = r.toUpperCase();
  let a = 0n;
  if (r === "LE")
    return a = (a << 8n) + BigInt(e[t + 7]), a = (a << 8n) + BigInt(e[t + 6]), a = (a << 8n) + BigInt(e[t + 5]), a = (a << 8n) + BigInt(e[t + 4]), a = (a << 8n) + BigInt(e[t + 3]), a = (a << 8n) + BigInt(e[t + 2]), a = (a << 8n) + BigInt(e[t + 1]), a = (a << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? a : a - 0x10000000000000000n;
  {
    let i = 0n;
    return i = (i << 8n) + BigInt(e[t]), i = (i << 8n) + BigInt(e[t + 1]), i = (i << 8n) + BigInt(e[t + 2]), i = (i << 8n) + BigInt(e[t + 3]), i = (i << 8n) + BigInt(e[t + 4]), i = (i << 8n) + BigInt(e[t + 5]), i = (i << 8n) + BigInt(e[t + 6]), i = (i << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? i : i - 0x10000000000000000n;
  }
}
const hb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: Yg,
  concat: $g,
  fromBase64: Wg,
  fromHex: Gg,
  fromUtf8: Fg,
  readInt16: ub,
  readInt32: fb,
  readInt64: db,
  readInt8: cb,
  readUInt16: tb,
  readUInt32: ab,
  readUInt64: ib,
  readUInt8: rb,
  toBase64: Vg,
  toHex: Kg,
  toUtf8: Mg,
  writeInt16: nb,
  writeInt32: sb,
  writeInt64: lb,
  writeInt8: ob,
  writeUInt16: Jg,
  writeUInt32: Qg,
  writeUInt64: eb,
  writeUInt8: Xg
}, Symbol.toStringTag, { value: "Module" })), os = /* @__PURE__ */ Lt(hb);
var wl;
function pb() {
  if (wl) return mr;
  wl = 1;
  var e = mr && mr.__createBinding || (Object.create ? (function(n, p, d, u) {
    u === void 0 && (u = d);
    var w = Object.getOwnPropertyDescriptor(p, d);
    (!w || ("get" in w ? !p.__esModule : w.writable || w.configurable)) && (w = { enumerable: !0, get: function() {
      return p[d];
    } }), Object.defineProperty(n, u, w);
  }) : (function(n, p, d, u) {
    u === void 0 && (u = d), n[u] = p[d];
  })), t = mr && mr.__setModuleDefault || (Object.create ? (function(n, p) {
    Object.defineProperty(n, "default", { enumerable: !0, value: p });
  }) : function(n, p) {
    n.default = p;
  }), r = mr && mr.__importStar || /* @__PURE__ */ (function() {
    var n = function(p) {
      return n = Object.getOwnPropertyNames || function(d) {
        var u = [];
        for (var w in d) Object.prototype.hasOwnProperty.call(d, w) && (u[u.length] = w);
        return u;
      }, n(p);
    };
    return function(p) {
      if (p && p.__esModule) return p;
      var d = {};
      if (p != null) for (var u = n(p), w = 0; w < u.length; w++) u[w] !== "default" && e(d, p, u[w]);
      return t(d, p), d;
    };
  })();
  Object.defineProperty(mr, "__esModule", { value: !0 }), mr.testEcc = o;
  const a = r(os), i = (n) => a.fromHex(n);
  function o(n) {
    if (s(n.isPoint(i("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), s(!n.isPoint(i("030000000000000000000000000000000000000000000000000000000000000005"))), s(n.isPrivate(i("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"))), s(n.isPrivate(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))), s(!n.isPrivate(i("0000000000000000000000000000000000000000000000000000000000000000"))), s(!n.isPrivate(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"))), s(!n.isPrivate(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142"))), s(a.compare(n.pointFromScalar(i("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), i("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")) === 0), n.xOnlyPointAddTweak) {
      s(n.xOnlyPointAddTweak(i("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
      let p = n.xOnlyPointAddTweak(i("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), i("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
      s(a.compare(p.xOnlyPubkey, i("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) === 0 && p.parity === 1), p = n.xOnlyPointAddTweak(i("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), i("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
    }
    s(a.compare(n.pointAddScalar(i("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), i("0000000000000000000000000000000000000000000000000000000000000003")), i("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")) === 0), s(a.compare(n.privateAdd(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), i("0000000000000000000000000000000000000000000000000000000000000002")), i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), n.privateNegate && (s(a.compare(n.privateNegate(i("0000000000000000000000000000000000000000000000000000000000000001")), i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === 0), s(a.compare(n.privateNegate(i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")), i("0000000000000000000000000000000000000000000000000000000000000003")) === 0), s(a.compare(n.privateNegate(i("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")), i("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")) === 0)), s(a.compare(n.sign(i("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), i("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")), i("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")) === 0), s(n.verify(i("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), i("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), i("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"))), n.signSchnorr && s(a.compare(n.signSchnorr(i("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), i("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), i("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")), i("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")) === 0), n.verifySchnorr && s(n.verifySchnorr(i("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), i("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), i("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
  }
  function s(n) {
    if (!n)
      throw new Error("ecc library invalid");
  }
  return mr;
}
function gb(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let d = 0; d < t.length; d++)
    t[d] = 255;
  for (let d = 0; d < e.length; d++) {
    const u = e.charAt(d), w = u.charCodeAt(0);
    if (t[w] !== 255)
      throw new TypeError(u + " is ambiguous");
    t[w] = d;
  }
  const r = e.length, a = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function s(d) {
    if (d instanceof Uint8Array || (ArrayBuffer.isView(d) ? d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength) : Array.isArray(d) && (d = Uint8Array.from(d))), !(d instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (d.length === 0)
      return "";
    let u = 0, w = 0, y = 0;
    const k = d.length;
    for (; y !== k && d[y] === 0; )
      y++, u++;
    const A = (k - y) * o + 1 >>> 0, E = new Uint8Array(A);
    for (; y !== k; ) {
      let B = d[y], z = 0;
      for (let O = A - 1; (B !== 0 || z < w) && O !== -1; O--, z++)
        B += 256 * E[O] >>> 0, E[O] = B % r >>> 0, B = B / r >>> 0;
      if (B !== 0)
        throw new Error("Non-zero carry");
      w = z, y++;
    }
    let x = A - w;
    for (; x !== A && E[x] === 0; )
      x++;
    let I = a.repeat(u);
    for (; x < A; ++x)
      I += e.charAt(E[x]);
    return I;
  }
  function n(d) {
    if (typeof d != "string")
      throw new TypeError("Expected String");
    if (d.length === 0)
      return new Uint8Array();
    let u = 0, w = 0, y = 0;
    for (; d[u] === a; )
      w++, u++;
    const k = (d.length - u) * i + 1 >>> 0, A = new Uint8Array(k);
    for (; u < d.length; ) {
      const B = d.charCodeAt(u);
      if (B > 255)
        return;
      let z = t[B];
      if (z === 255)
        return;
      let O = 0;
      for (let F = k - 1; (z !== 0 || O < y) && F !== -1; F--, O++)
        z += r * A[F] >>> 0, A[F] = z % 256 >>> 0, z = z / 256 >>> 0;
      if (z !== 0)
        throw new Error("Non-zero carry");
      y = O, u++;
    }
    let E = k - y;
    for (; E !== k && A[E] === 0; )
      E++;
    const x = new Uint8Array(w + (k - E));
    let I = w;
    for (; E !== k; )
      x[I++] = A[E++];
    return x;
  }
  function p(d) {
    const u = n(d);
    if (u)
      return u;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: n,
    decode: p
  };
}
var bb = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const Zi = gb(bb);
function qf(e) {
  function t(o) {
    const s = e(o), n = o.length + 4, p = new Uint8Array(n);
    return p.set(o, 0), p.set(s.subarray(0, 4), o.length), Zi.encode(p);
  }
  function r(o) {
    const s = o.slice(0, -4), n = o.slice(-4), p = e(s);
    if (!(n[0] ^ p[0] | n[1] ^ p[1] | n[2] ^ p[2] | n[3] ^ p[3]))
      return s;
  }
  function a(o) {
    const s = Zi.decodeUnsafe(o);
    if (s !== void 0)
      return r(s);
  }
  function i(o) {
    const s = Zi.decode(o), n = r(s);
    if (n === void 0)
      throw new Error("Invalid checksum");
    return n;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: a
  };
}
function mb(e) {
  return ys(ys(e));
}
const { encode: Df, decode: Mf, decodeUnsafe: Ff } = qf(mb), ns = { encode: Df, decode: Mf, decodeUnsafe: Ff }, yb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bs58checkBase: qf,
  decode: Mf,
  decodeUnsafe: Ff,
  default: ns,
  encode: Df
}, Symbol.toStringTag, { value: "Module" })), $f = /* @__PURE__ */ Lt(yb);
var xt = {}, _l;
function Kf() {
  if (_l) return xt;
  _l = 1, Object.defineProperty(xt, "__esModule", { value: !0 }), xt.validateBip32Path = t, xt.validateBytes32 = r, xt.validateBytes33 = a;
  const e = /^(m\/)?(\d+'?\/)*\d+'?$/;
  function t(i) {
    if (typeof i != "string" || !e.test(i))
      throw new TypeError("Expected BIP32 derivation path");
  }
  function r(i) {
    if (!(i instanceof Uint8Array) || i.length !== 32)
      throw new TypeError("Expected Uint8Array of length 32");
  }
  function a(i) {
    if (!(i instanceof Uint8Array) || i.length !== 33)
      throw new TypeError("Expected Uint8Array of length 33");
  }
  return xt;
}
function Hf(e, t) {
  if (t !== void 0 && e[0] !== t)
    throw new Error("Invalid network version");
  if (e.length === 33)
    return {
      version: e[0],
      privateKey: e.slice(1, 33),
      compressed: !1
    };
  if (e.length !== 34)
    throw new Error("Invalid WIF length");
  if (e[33] !== 1)
    throw new Error("Invalid compression flag");
  return {
    version: e[0],
    privateKey: e.slice(1, 33),
    compressed: !0
  };
}
function Zf(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  const a = new Uint8Array(r ? 34 : 33);
  return new DataView(a.buffer).setUint8(0, e), a.set(t, 1), r && (a[33] = 1), a;
}
function vb(e, t) {
  return Hf(ns.decode(e), t);
}
function wb(e) {
  return ns.encode(Zf(e.version, e.privateKey, e.compressed));
}
const _b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: vb,
  decodeRaw: Hf,
  encode: wb,
  encodeRaw: Zf
}, Symbol.toStringTag, { value: "Module" })), kb = /* @__PURE__ */ Lt(_b);
var jr = {}, kl;
function yi() {
  return kl || (kl = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.REGTEST = jr.TESTNET = jr.BITCOIN = void 0, jr.BITCOIN = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bc",
    bip32: {
      public: 76067358,
      private: 76066276
    },
    pubKeyHash: 0,
    scriptHash: 5,
    wif: 128
  }, jr.TESTNET = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "tb",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  }, jr.REGTEST = {
    messagePrefix: `Bitcoin Signed Message:
`,
    bech32: "bcrt",
    bip32: {
      public: 70617039,
      private: 70615956
    },
    pubKeyHash: 111,
    scriptHash: 196,
    wif: 239
  }), jr;
}
const Eb = /* @__PURE__ */ Lt(Dg);
var El;
function xb() {
  if (El) return br;
  El = 1;
  var e = br && br.__createBinding || (Object.create ? (function(A, E, x, I) {
    I === void 0 && (I = x);
    var B = Object.getOwnPropertyDescriptor(E, x);
    (!B || ("get" in B ? !E.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return E[x];
    } }), Object.defineProperty(A, I, B);
  }) : (function(A, E, x, I) {
    I === void 0 && (I = x), A[I] = E[x];
  })), t = br && br.__setModuleDefault || (Object.create ? (function(A, E) {
    Object.defineProperty(A, "default", { enumerable: !0, value: E });
  }) : function(A, E) {
    A.default = E;
  }), r = br && br.__importStar || /* @__PURE__ */ (function() {
    var A = function(E) {
      return A = Object.getOwnPropertyNames || function(x) {
        var I = [];
        for (var B in x) Object.prototype.hasOwnProperty.call(x, B) && (I[I.length] = B);
        return I;
      }, A(E);
    };
    return function(E) {
      if (E && E.__esModule) return E;
      var x = {};
      if (E != null) for (var I = A(E), B = 0; B < I.length; B++) I[B] !== "default" && e(x, E, I[B]);
      return t(x, E), x;
    };
  })();
  Object.defineProperty(br, "__esModule", { value: !0 }), br.BIP32Factory = k;
  const a = r(Cf()), i = pb(), o = r($f), s = Kf(), n = r(kb), p = r(os), d = yi(), u = Eb, w = p.fromUtf8("Bitcoin seed"), y = /* @__PURE__ */ new WeakSet();
  function k(A) {
    const E = A;
    y.has(E) || ((0, i.testEcc)(E), y.add(E));
    const x = 2147483648;
    function I($) {
      return $.length === 32 ? $ : $.slice(1, 33);
    }
    class B {
      __D;
      __Q;
      network;
      lowR = !1;
      constructor(m, U, C) {
        this.__D = m, this.__Q = U, this.network = C;
      }
      get publicKey() {
        return this.__Q === void 0 && (this.__Q = E.pointFromScalar(this.__D, !0)), this.__Q;
      }
      get xOnlyPublicKey() {
        return I(this.publicKey);
      }
      get privateKey() {
        return this.__D;
      }
      get compressed() {
        return !0;
      }
      get capabilities() {
        let m = u.SignerCapability.EcdsaVerify | u.SignerCapability.PublicKeyTweak;
        return this.__D !== void 0 && (m |= u.SignerCapability.EcdsaSign | u.SignerCapability.PrivateKeyExport), E.signSchnorr && this.__D !== void 0 && (m |= u.SignerCapability.SchnorrSign), E.verifySchnorr && (m |= u.SignerCapability.SchnorrVerify), m;
      }
      hasCapability(m) {
        return (this.capabilities & m) !== 0;
      }
      sign(m, U) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (U === void 0 && (U = this.lowR), U) {
          let C = E.sign(m, this.privateKey);
          const M = new Uint8Array(32);
          let V = 0;
          for (; C[0] > 127; )
            V++, p.writeUInt32(M, 0, V, "LE"), C = E.sign(m, this.privateKey, M);
          return C;
        } else
          return E.sign(m, this.privateKey);
      }
      signSchnorr(m) {
        if (!this.privateKey)
          throw new Error("Missing private key");
        if (!E.signSchnorr)
          throw new Error("signSchnorr not supported by ecc library");
        return E.signSchnorr(m, this.privateKey);
      }
      verify(m, U) {
        return E.verify(m, this.publicKey, U);
      }
      verifySchnorr(m, U) {
        if (!E.verifySchnorr)
          throw new Error("verifySchnorr not supported by ecc library");
        return E.verifySchnorr(m, this.publicKey.subarray(1, 33), U);
      }
      tweak(m) {
        return this.privateKey ? this.tweakFromPrivateKey(m) : this.tweakFromPublicKey(m);
      }
      toWIF() {
        if (!this.privateKey)
          throw new TypeError("Missing private key");
        return n.encode({
          version: this.network.wif,
          privateKey: this.privateKey,
          compressed: !0
        });
      }
      tweakFromPublicKey(m) {
        const U = I(this.publicKey), C = E.xOnlyPointAddTweak;
        if (!C)
          throw new Error("xOnlyPointAddTweak not supported by ecc library");
        const M = C(U, m);
        if (!M || M.xOnlyPubkey === null)
          throw new Error("Cannot tweak public key!");
        const V = Uint8Array.from([
          M.parity === 0 ? 2 : 3
        ]), te = p.concat([
          V,
          M.xOnlyPubkey
        ]);
        return new B(void 0, te, this.network);
      }
      tweakFromPrivateKey(m) {
        const U = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1, C = (() => {
          if (U) {
            if (E.privateNegate)
              return E.privateNegate(this.privateKey);
            throw new Error("privateNegate not supported by ecc library");
          } else return this.privateKey;
        })(), M = E.privateAdd(C, m);
        if (!M)
          throw new Error("Invalid tweaked private key!");
        return new B(M, void 0, this.network);
      }
    }
    class z extends B {
      chainCode;
      __DEPTH;
      __INDEX;
      __PARENT_FINGERPRINT;
      constructor(m, U, C, M, V = 0, te = 0, ie = 0) {
        super(m, U, M), this.chainCode = C, this.__DEPTH = V, this.__INDEX = te, this.__PARENT_FINGERPRINT = ie;
      }
      #e;
      get capabilities() {
        return super.capabilities | u.SignerCapability.HdDerivation;
      }
      get depth() {
        return this.__DEPTH;
      }
      get index() {
        return this.__INDEX;
      }
      get parentFingerprint() {
        return this.__PARENT_FINGERPRINT;
      }
      get identifier() {
        return this.#e === void 0 && (this.#e = a.hash160(this.publicKey)), this.#e;
      }
      get fingerprint() {
        return this.identifier.subarray(0, 4);
      }
      // Private === not neutered
      // Public === neutered
      isNeutered() {
        return this.__D === void 0;
      }
      neutered() {
        return new z(void 0, this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
      }
      toBase58() {
        const m = this.network, U = this.isNeutered() ? m.bip32.public : m.bip32.private, C = new Uint8Array(78);
        return p.writeUInt32(C, 0, U, "BE"), p.writeUInt8(C, 4, this.depth), p.writeUInt32(C, 5, this.parentFingerprint, "BE"), p.writeUInt32(C, 9, this.index, "BE"), C.set(this.chainCode, 13), this.isNeutered() ? C.set(this.publicKey, 45) : (p.writeUInt8(C, 45, 0), C.set(this.privateKey, 46)), o.encode(C);
      }
      // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
      derive(m) {
        if (m !== m >>> 0)
          throw new TypeError("Expected UInt32, got " + m);
        const U = m >= x, C = new Uint8Array(37);
        if (U) {
          if (this.isNeutered())
            throw new TypeError("Missing private key for hardened child key");
          C[0] = 0, C.set(this.privateKey, 1), p.writeUInt32(C, 33, m, "BE");
        } else
          C.set(this.publicKey, 0), p.writeUInt32(C, 33, m, "BE");
        const M = a.hmacSHA512(this.chainCode, C), V = M.slice(0, 32), te = M.slice(32);
        if (!E.isPrivate(V))
          return this.derive(m + 1);
        const ie = p.readUInt32(this.fingerprint, 0, "BE"), oe = this.depth + 1;
        if (this.isNeutered()) {
          const ne = E.pointAddScalar(this.publicKey, V, !0);
          return ne === null ? this.derive(m + 1) : new z(void 0, ne, te, this.network, oe, m, ie);
        } else {
          const ne = E.privateAdd(this.privateKey, V);
          return ne == null ? this.derive(m + 1) : new z(ne, void 0, te, this.network, oe, m, ie);
        }
      }
      deriveHardened(m) {
        if (!Number.isInteger(m) || m < 0 || m > 2147483647)
          throw new TypeError("Expected UInt31, got " + m);
        return this.derive(m + x);
      }
      derivePath(m) {
        (0, s.validateBip32Path)(m);
        let U = m.split("/");
        if (U[0] === "m") {
          if (this.parentFingerprint)
            throw new TypeError("Expected master, got child");
          U = U.slice(1);
        }
        return U.reduce((C, M) => {
          let V;
          return M.slice(-1) === "'" ? (V = parseInt(M.slice(0, -1), 10), C.deriveHardened(V)) : (V = parseInt(M, 10), C.derive(V));
        }, this);
      }
    }
    function O($, m) {
      const U = o.decode($);
      if (U.length !== 78)
        throw new TypeError("Invalid buffer length");
      m = m || d.BITCOIN;
      const C = p.readUInt32(U, 0, "BE");
      if (C !== m.bip32.private && C !== m.bip32.public)
        throw new TypeError("Invalid network version");
      const M = U[4], V = p.readUInt32(U, 5, "BE");
      if (M === 0 && V !== 0)
        throw new TypeError("Invalid parent fingerprint");
      const te = p.readUInt32(U, 9, "BE");
      if (M === 0 && te !== 0)
        throw new TypeError("Invalid index");
      const ie = U.slice(13, 45);
      let oe;
      if (C === m.bip32.private) {
        if (U[45] !== 0)
          throw new TypeError("Invalid private key");
        const ne = U.slice(46, 78);
        oe = N(ne, ie, m, M, te, V);
      } else {
        const ne = U.slice(45, 78);
        oe = q(ne, ie, m, M, te, V);
      }
      return oe;
    }
    function F($, m, U) {
      return N($, m, U);
    }
    function N($, m, U, C, M, V) {
      if ((0, s.validateBytes32)($), (0, s.validateBytes32)(m), U = U || d.BITCOIN, !E.isPrivate($))
        throw new TypeError("Private key not in range [1, n)");
      return new z($, void 0, m, U, C, M, V);
    }
    function j($, m, U) {
      return q($, m, U);
    }
    function q($, m, U, C, M, V) {
      if ((0, s.validateBytes33)($), (0, s.validateBytes32)(m), U = U || d.BITCOIN, !E.isPoint($))
        throw new TypeError("Point is not on the curve");
      return new z(void 0, $, m, U, C, M, V);
    }
    function S($, m) {
      if (!($ instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if ($.length < 16)
        throw new TypeError("Seed should be at least 128 bits");
      if ($.length > 64)
        throw new TypeError("Seed should be at most 512 bits");
      m = m || d.BITCOIN;
      const U = a.hmacSHA512(w, $), C = U.slice(0, 32), M = U.slice(32);
      return F(C, M, m);
    }
    function D($, m, U, C, M, V, te) {
      return new z($, m, U, te || d.BITCOIN, C, M, V);
    }
    return {
      fromSeed: S,
      fromBase58: O,
      fromPublicKey: j,
      fromPrivateKey: F,
      fromPrecomputed: D
    };
  }
  return br;
}
var Gi = {}, fr = {};
const xn = wd;
function ss(e, t) {
  if (e.length !== t.length)
    return !1;
  let r = 0;
  for (let a = 0; a < e.length; a++)
    r |= e[a] ^ t[a];
  return r === 0;
}
function Ab(e) {
  return Uint8Array.from(e);
}
function ls(e) {
  if (typeof e != "object" || e === null || _d(e))
    throw new Error("expected opts to be an object");
}
function li(e) {
  ls(e), e.context !== void 0 && tr(e.context, void 0, "opts.context");
}
function Na(e) {
  li(e), e.extraEntropy !== !1 && e.extraEntropy !== void 0 && tr(e.extraEntropy, void 0, "opts.extraEntropy");
}
function Xt(e, ...t) {
  const r = (i) => typeof i == "number" ? i : i.bytesLen, a = t.reduce((i, o) => i + r(o), 0);
  return {
    bytesLen: a,
    encode: (i) => {
      const o = new Uint8Array(a);
      for (let s = 0, n = 0; s < t.length; s++) {
        const p = t[s], d = r(p), u = typeof p == "number" ? i[s] : p.encode(i[s]);
        tr(u, d, e), o.set(u, n), typeof p != "number" && u.fill(0), n += d;
      }
      return o;
    },
    decode: (i) => {
      tr(i, a, e);
      const o = [];
      for (const s of t) {
        const n = r(s), p = i.subarray(0, n);
        o.push(typeof s == "number" ? p : s.decode(p)), i = i.subarray(n);
      }
      return o;
    }
  };
}
function ot(e, t) {
  const r = t * e.bytesLen;
  return {
    bytesLen: r,
    encode: (a) => {
      if (a.length !== t)
        throw new Error(`vecCoder.encode: wrong length=${a.length}. Expected: ${t}`);
      const i = new Uint8Array(r);
      for (let o = 0, s = 0; o < a.length; o++) {
        const n = e.encode(a[o]);
        i.set(n, s), n.fill(0), s += n.length;
      }
      return i;
    },
    decode: (a) => {
      tr(a, r);
      const i = [];
      for (let o = 0; o < a.length; o += e.bytesLen)
        i.push(e.decode(a.subarray(o, o + e.bytesLen)));
      return i;
    }
  };
}
function Pr(...e) {
  for (const t of e)
    if (Array.isArray(t))
      for (const r of t)
        r.fill(0);
    else
      t.fill(0);
}
function An(e) {
  return (1 << e) - 1;
}
const cs = Uint8Array.of();
function Bn(e, t = cs) {
  if (tr(e), tr(t), t.length > 255)
    throw new Error("context should be less than 255 bytes");
  return Mn(new Uint8Array([0, t.length]), t, e);
}
const Bb = /* @__PURE__ */ Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2]);
function Gf(e, t = 0) {
  if (!e.oid || !ss(e.oid.subarray(0, 10), Bb))
    throw new Error("hash.oid is invalid: expected NIST hash");
  const r = e.outputLen * 8 / 2;
  if (t > r)
    throw new Error("Pre-hash security strength too low: " + r + ", required: " + t);
}
function zn(e, t, r = cs) {
  if (tr(t), tr(r), r.length > 255)
    throw new Error("context should be less than 255 bytes");
  const a = e(t);
  return Mn(new Uint8Array([1, r.length]), r, e.oid, a);
}
const zb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EMPTY: cs,
  abytes: tr,
  checkHash: Gf,
  cleanBytes: Pr,
  concatBytes: Mn,
  copyBytes: Ab,
  equalBytes: ss,
  getMask: An,
  getMessage: Bn,
  getMessagePrehash: zn,
  randomBytes: xn,
  splitCoder: Xt,
  validateOpts: ls,
  validateSigOpts: Na,
  validateVerOpts: li,
  vecCoder: ot
}, Symbol.toStringTag, { value: "Module" })), Sb = /* @__PURE__ */ Lt(zb);
var Or = {};
const Ib = (e) => {
  const { newPoly: t, N: r, Q: a, F: i, ROOT_OF_UNITY: o, brvBits: s } = e, n = (I, B = a) => {
    const z = I % B | 0;
    return (z >= 0 ? z | 0 : B + z | 0) | 0;
  }, p = (I, B = a) => {
    const z = n(I, B) | 0;
    return (z > B >> 1 ? z - B | 0 : z) | 0;
  };
  function d() {
    const I = t(r);
    for (let B = 0; B < r; B++) {
      const z = zd(B, s), O = BigInt(o) ** BigInt(z) % BigInt(a);
      I[B] = Number(O) | 0;
    }
    return I;
  }
  const u = d(), w = {
    add: (I, B) => n((I | 0) + (B | 0)) | 0,
    sub: (I, B) => n((I | 0) - (B | 0)) | 0,
    mul: (I, B) => n((I | 0) * (B | 0)) | 0,
    inv: (I) => {
      throw new Error("not implemented");
    }
  }, y = {
    N: r,
    roots: u,
    invertButterflies: !0,
    skipStages: 0,
    brp: !1
  }, k = vs(w, { dit: !1, ...y }), A = vs(w, { dit: !0, ...y });
  return { mod: n, smod: p, nttZetas: u, NTT: {
    encode: (I) => k(I),
    decode: (I) => {
      A(I);
      for (let B = 0; B < I.length; B++)
        I[B] = n(i * I[B]);
      return I;
    }
  }, bitsCoder: (I, B) => {
    const z = An(I), O = I * (r / 8);
    return {
      bytesLen: O,
      encode: (F) => {
        const N = new Uint8Array(O);
        for (let j = 0, q = 0, S = 0, D = 0; j < F.length; j++)
          for (q |= (B.encode(F[j]) & z) << S, S += I; S >= 8; S -= 8, q >>= 8)
            N[D++] = q & An(S);
        return N;
      },
      decode: (F) => {
        const N = t(r);
        for (let j = 0, q = 0, S = 0, D = 0; j < F.length; j++)
          for (q |= F[j] << S, S += 8; S >= I; S -= I, q >>= I)
            N[D++] = B.decode(q & z);
        return N;
      }
    };
  } };
}, Vf = (e) => (t, r) => {
  r || (r = e.blockLen);
  const a = new Uint8Array(t.length + 2);
  a.set(t);
  const i = t.length, o = new Uint8Array(r);
  let s = e.create({}), n = 0, p = 0;
  return {
    stats: () => ({ calls: n, xofs: p }),
    get: (d, u) => (a[i + 0] = d, a[i + 1] = u, s.destroy(), s = e.create({}).update(a), n++, () => (p++, s.xofInto(o))),
    clean: () => {
      s.destroy(), Pr(o, a);
    }
  };
}, us = /* @__PURE__ */ Vf(kd), fs = /* @__PURE__ */ Vf(nr);
function xl(e) {
  ls(e), e.externalMu !== void 0 && Sd(e.externalMu, "opts.externalMu");
}
const je = 256, Yr = 8380417, Tb = 1753, jb = 8347681, ht = 13, Sn = Math.floor((Yr - 1) / 88) | 0, In = Math.floor((Yr - 1) / 32) | 0, vi = {
  2: { K: 4, L: 4, D: ht, GAMMA1: 2 ** 17, GAMMA2: Sn, TAU: 39, ETA: 2, OMEGA: 80 },
  3: { K: 6, L: 5, D: ht, GAMMA1: 2 ** 19, GAMMA2: In, TAU: 49, ETA: 4, OMEGA: 55 },
  5: { K: 8, L: 7, D: ht, GAMMA1: 2 ** 19, GAMMA2: In, TAU: 60, ETA: 2, OMEGA: 75 }
}, Qe = (e) => new Int32Array(e), { mod: ft, smod: qa, NTT: $e, bitsCoder: Ob } = Ib({
  N: je,
  Q: Yr,
  F: jb,
  ROOT_OF_UNITY: Tb,
  newPoly: Qe,
  brvBits: 8
}), Al = (e) => e, Gt = (e, t = Al, r = Al) => Ob(e, {
  encode: (a) => t(r(a)),
  decode: (a) => r(t(a))
}), $r = (e, t) => {
  for (let r = 0; r < e.length; r++)
    e[r] = ft(e[r] + t[r]);
  return e;
}, Bl = (e, t) => {
  for (let r = 0; r < e.length; r++)
    e[r] = ft(e[r] - t[r]);
  return e;
}, Rb = (e) => {
  for (let t = 0; t < je; t++)
    e[t] <<= ht;
  return e;
}, Vt = (e, t) => {
  for (let r = 0; r < je; r++)
    if (Math.abs(qa(e[r])) >= t)
      return !0;
  return !1;
}, Kr = (e, t) => {
  const r = Qe(je);
  for (let a = 0; a < e.length; a++)
    r[a] = ft(e[a] * t[a]);
  return r;
};
function Oa(e) {
  const t = Qe(je);
  for (let r = 0; r < je; ) {
    const a = e();
    if (a.length % 3)
      throw new Error("RejNTTPoly: unaligned block");
    for (let i = 0; r < je && i <= a.length - 3; i += 3) {
      const o = (a[i + 0] | a[i + 1] << 8 | a[i + 2] << 16) & 8388607;
      o < Yr && (t[r++] = o);
    }
  }
  return t;
}
function ds(e) {
  const { K: t, L: r, GAMMA1: a, GAMMA2: i, TAU: o, ETA: s, OMEGA: n } = e, { CRH_BYTES: p, TR_BYTES: d, C_TILDE_BYTES: u, XOF128: w, XOF256: y, securityLevel: k } = e;
  if (![2, 4].includes(s))
    throw new Error("Wrong ETA");
  if (![1 << 17, 1 << 19].includes(a))
    throw new Error("Wrong GAMMA1");
  if (![Sn, In].includes(i))
    throw new Error("Wrong GAMMA2");
  const A = o * s, E = (T) => {
    const K = ft(T), W = qa(K, 2 * i) | 0;
    return K - W === Yr - 1 ? { r1: 0, r0: W - 1 | 0 } : { r1: Math.floor((K - W) / (2 * i)) | 0, r0: W };
  }, x = (T) => E(T).r1, I = (T) => E(T).r0, B = (T, K) => T <= i || T > Yr - i || T === Yr - i && K === 0 ? 0 : 1, z = (T, K) => {
    const W = Math.floor((Yr - 1) / (2 * i)), { r1: X, r0: re } = E(K);
    return T === 1 ? re > 0 ? ft(X + 1, W) | 0 : ft(X - 1, W) | 0 : X | 0;
  }, O = (T) => {
    const K = ft(T), W = qa(K, 2 ** ht) | 0;
    return { r1: Math.floor((K - W) / 2 ** ht) | 0, r0: W };
  }, F = {
    bytesLen: n + t,
    encode: (T) => {
      if (T === !1)
        throw new Error("hint.encode: hint is false");
      const K = new Uint8Array(n + t);
      for (let W = 0, X = 0; W < t; W++) {
        for (let re = 0; re < je; re++)
          T[W][re] !== 0 && (K[X++] = re);
        K[n + W] = X;
      }
      return K;
    },
    decode: (T) => {
      const K = [];
      let W = 0;
      for (let X = 0; X < t; X++) {
        const re = Qe(je);
        if (T[n + X] < W || T[n + X] > n)
          return !1;
        for (let Q = W; Q < T[n + X]; Q++) {
          if (Q > W && T[Q] <= T[Q - 1])
            return !1;
          re[T[Q]] = 1;
        }
        W = T[n + X], K.push(re);
      }
      for (let X = W; X < n; X++)
        if (T[X] !== 0)
          return !1;
      return K;
    }
  }, N = Gt(s === 2 ? 3 : 4, (T) => s - T, (T) => {
    if (!(-s <= T && T <= s))
      throw new Error(`malformed key s1/s3 ${T} outside of ETA range [${-s}, ${s}]`);
    return T;
  }), j = Gt(13, (T) => (1 << ht - 1) - T), q = Gt(10), S = Gt(a === 1 << 17 ? 18 : 20, (T) => qa(a - T)), D = Gt(i === Sn ? 6 : 4), $ = ot(D, t), m = Xt("publicKey", 32, ot(q, t)), U = Xt("secretKey", 32, 32, d, ot(N, r), ot(N, t), ot(j, t)), C = Xt("signature", u, ot(S, r), F), M = s === 2 ? (T) => T < 15 ? 2 - T % 5 : !1 : (T) => T < 9 ? 4 - T : !1;
  function V(T) {
    const K = Qe(je);
    for (let W = 0; W < je; ) {
      const X = T();
      for (let re = 0; W < je && re < X.length; re += 1) {
        const Q = M(X[re] & 15), ae = M(X[re] >> 4 & 15);
        Q !== !1 && (K[W++] = Q), W < je && ae !== !1 && (K[W++] = ae);
      }
    }
    return K;
  }
  const te = (T) => {
    const K = Qe(je), W = nr.create({}).update(T), X = new Uint8Array(nr.blockLen);
    W.xofInto(X);
    const re = X.slice(0, 8);
    for (let Q = je - o, ae = 8, ce = 0, ue = 0; Q < je; Q++) {
      let de = Q + 1;
      for (; de > Q; )
        de = X[ae++], !(ae < nr.blockLen) && (W.xofInto(X), ae = 0);
      K[Q] = K[de], K[de] = 1 - ((re[ce] >> ue++ & 1) << 1), ue >= 8 && (ce++, ue = 0);
    }
    return K;
  }, ie = (T) => {
    const K = Qe(je), W = Qe(je);
    for (let X = 0; X < T.length; X++) {
      const { r0: re, r1: Q } = O(T[X]);
      K[X] = re, W[X] = Q;
    }
    return { r0: K, r1: W };
  }, oe = (T, K) => {
    for (let W = 0; W < je; W++)
      T[W] = z(K[W], T[W]);
    return T;
  }, ne = (T, K) => {
    const W = Qe(je);
    let X = 0;
    for (let re = 0; re < je; re++) {
      const Q = B(T[re], K[re]);
      W[re] = Q, X += Q;
    }
    return { v: W, cnt: X };
  }, le = 32, P = Xt("seed", 32, 64, 32), Z = {
    info: { type: "internal-ml-dsa" },
    lengths: {
      secretKey: U.bytesLen,
      publicKey: m.bytesLen,
      seed: 32,
      signature: C.bytesLen,
      signRand: le
    },
    keygen: (T) => {
      const K = new Uint8Array(34), W = T === void 0;
      W && (T = xn(32)), tr(T, 32, "seed"), K.set(T), W && Pr(T), K[32] = t, K[33] = r;
      const [X, re, Q] = P.decode(nr(K, { dkLen: P.bytesLen })), ae = y(re), ce = [];
      for (let se = 0; se < r; se++)
        ce.push(V(ae.get(se & 255, se >> 8 & 255)));
      const ue = [];
      for (let se = r; se < r + t; se++)
        ue.push(V(ae.get(se & 255, se >> 8 & 255)));
      const de = ce.map((se) => $e.encode(se.slice())), pe = [], ve = [], ge = w(X), ke = Qe(je);
      for (let se = 0; se < t; se++) {
        Pr(ke);
        for (let Be = 0; Be < r; Be++) {
          const Oe = Oa(ge.get(Be, se));
          $r(ke, Kr(Oe, de[Be]));
        }
        $e.decode(ke);
        const { r0: he, r1: be } = ie($r(ke, ue[se]));
        pe.push(he), ve.push(be);
      }
      const Le = m.encode([X, ve]), Y = nr(Le, { dkLen: d }), Ne = U.encode([X, Q, Y, ce, ue, pe]);
      return ge.clean(), ae.clean(), Pr(X, re, Q, ce, ue, de, ke, pe, ve, Y, K), { publicKey: Le, secretKey: Ne };
    },
    getPublicKey: (T) => {
      const [K, W, X, re, Q, ae] = U.decode(T), ce = w(K), ue = re.map((ve) => $e.encode(ve.slice())), de = [], pe = Qe(je);
      for (let ve = 0; ve < t; ve++) {
        pe.fill(0);
        for (let ke = 0; ke < r; ke++) {
          const Le = Oa(ce.get(ke, ve));
          $r(pe, Kr(Le, ue[ke]));
        }
        $e.decode(pe), $r(pe, Q[ve]);
        const { r1: ge } = ie(pe);
        de.push(ge);
      }
      return ce.clean(), Pr(pe, ue, ae, re, Q), m.encode([K, de]);
    },
    // NOTE: random is optional.
    sign: (T, K, W = {}) => {
      Na(W), xl(W);
      let { extraEntropy: X, externalMu: re = !1 } = W;
      const [Q, ae, ce, ue, de, pe] = U.decode(K), ve = [], ge = w(Q);
      for (let se = 0; se < t; se++) {
        const he = [];
        for (let be = 0; be < r; be++)
          he.push(Oa(ge.get(be, se)));
        ve.push(he);
      }
      ge.clean();
      for (let se = 0; se < r; se++)
        $e.encode(ue[se]);
      for (let se = 0; se < t; se++)
        $e.encode(de[se]), $e.encode(pe[se]);
      const ke = re ? T : nr.create({ dkLen: p }).update(ce).update(T).digest(), Le = X === !1 ? new Uint8Array(32) : X === void 0 ? xn(le) : X;
      tr(Le, 32, "extraEntropy");
      const Y = nr.create({ dkLen: p }).update(ae).update(Le).update(ke).digest();
      tr(Y, p);
      const Ne = y(Y, S.bytesLen);
      e: for (let se = 0; ; ) {
        const he = [];
        for (let f = 0; f < r; f++, se++)
          he.push(S.decode(Ne.get(se & 255, se >> 8)()));
        const be = he.map((f) => $e.encode(f.slice())), Be = [];
        for (let f = 0; f < t; f++) {
          const v = Qe(je);
          for (let R = 0; R < r; R++)
            $r(v, Kr(ve[f][R], be[R]));
          $e.decode(v), Be.push(v);
        }
        const Oe = Be.map((f) => f.map(x)), ar = nr.create({ dkLen: u }).update(ke).update($.encode(Oe)).digest(), Sr = $e.encode(te(ar)), He = ue.map((f) => Kr(f, Sr));
        for (let f = 0; f < r; f++)
          if ($r($e.decode(He[f]), he[f]), Vt(He[f], a - A))
            continue e;
        let ur = 0;
        const g = [];
        for (let f = 0; f < t; f++) {
          const v = $e.decode(Kr(de[f], Sr)), R = Bl(Be[f], v).map(I);
          if (Vt(R, i - A))
            continue e;
          const H = $e.decode(Kr(pe[f], Sr));
          if (Vt(H, i))
            continue e;
          $r(R, H);
          const J = ne(R, Oe[f]);
          g.push(J.v), ur += J.cnt;
        }
        if (ur > n)
          continue;
        Ne.clean();
        const l = C.encode([ar, He, g]);
        return Pr(ar, He, g, Sr, Oe, Be, be, he, Y, ke, ue, de, pe, ...ve), l;
      }
      throw new Error("Unreachable code path reached, report this error");
    },
    verify: (T, K, W, X = {}) => {
      xl(X);
      const { externalMu: re = !1 } = X, [Q, ae] = m.decode(W), ce = nr(W, { dkLen: d });
      if (T.length !== C.bytesLen)
        return !1;
      const [ue, de, pe] = C.decode(T);
      if (pe === !1)
        return !1;
      for (let se = 0; se < r; se++)
        if (Vt(de[se], a - A))
          return !1;
      const ve = re ? K : nr.create({ dkLen: p }).update(ce).update(K).digest(), ge = $e.encode(te(ue)), ke = de.map((se) => se.slice());
      for (let se = 0; se < r; se++)
        $e.encode(ke[se]);
      const Le = [], Y = w(Q);
      for (let se = 0; se < t; se++) {
        const he = Kr($e.encode(Rb(ae[se])), ge), be = Qe(je);
        for (let Oe = 0; Oe < r; Oe++) {
          const ar = Oa(Y.get(Oe, se));
          $r(be, Kr(ar, ke[Oe]));
        }
        const Be = $e.decode(Bl(be, he));
        Le.push(oe(Be, pe[se]));
      }
      Y.clean();
      const Ne = nr.create({ dkLen: u }).update(ve).update($.encode(Le)).digest();
      for (const se of pe)
        if (!(se.reduce((be, Be) => be + Be, 0) <= n))
          return !1;
      for (const se of de)
        if (Vt(se, a - A))
          return !1;
      return ss(ue, Ne);
    }
  };
  return {
    info: { type: "ml-dsa" },
    internal: Z,
    securityLevel: k,
    keygen: Z.keygen,
    lengths: Z.lengths,
    getPublicKey: Z.getPublicKey,
    sign: (T, K, W = {}) => {
      Na(W);
      const X = Bn(T, W.context), re = Z.sign(X, K, W);
      return Pr(X), re;
    },
    verify: (T, K, W, X = {}) => (li(X), Z.verify(T, Bn(K, X.context), W)),
    prehash: (T) => (Gf(T, k), {
      info: { type: "hashml-dsa" },
      securityLevel: k,
      lengths: Z.lengths,
      keygen: Z.keygen,
      getPublicKey: Z.getPublicKey,
      sign: (K, W, X = {}) => {
        Na(X);
        const re = zn(T, K, X.context), Q = Z.sign(re, W, X);
        return Pr(re), Q;
      },
      verify: (K, W, X, re = {}) => (li(re), Z.verify(K, zn(T, W, re.context), X))
    })
  };
}
const Pb = /* @__PURE__ */ ds({
  ...vi[2],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 32,
  XOF128: us,
  XOF256: fs,
  securityLevel: 128
}), Ub = /* @__PURE__ */ ds({
  ...vi[3],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 48,
  XOF128: us,
  XOF256: fs,
  securityLevel: 192
}), Cb = /* @__PURE__ */ ds({
  ...vi[5],
  CRH_BYTES: 64,
  TR_BYTES: 64,
  C_TILDE_BYTES: 64,
  XOF128: us,
  XOF256: fs,
  securityLevel: 256
}), Lb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PARAMS: vi,
  ml_dsa44: Pb,
  ml_dsa65: Ub,
  ml_dsa87: Cb
}, Symbol.toStringTag, { value: "Module" })), Nb = /* @__PURE__ */ Lt(Lb);
var zl;
function Wf() {
  if (zl) return Or;
  zl = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.DEFAULT_SECURITY_LEVEL = Or.MLDSASecurityLevel = void 0, Or.getMLDSAConfig = i, Or.findNetworkByVersion = o;
  const e = Nb, t = yi();
  var r;
  (function(s) {
    s[s.LEVEL2 = 44] = "LEVEL2", s[s.LEVEL3 = 65] = "LEVEL3", s[s.LEVEL5 = 87] = "LEVEL5";
  })(r || (Or.MLDSASecurityLevel = r = {}));
  const a = {
    [r.LEVEL2]: {
      level: r.LEVEL2,
      privateKeySize: 2560,
      publicKeySize: 1312,
      signatureSize: 2420,
      algorithm: e.ml_dsa44
    },
    [r.LEVEL3]: {
      level: r.LEVEL3,
      privateKeySize: 4032,
      publicKeySize: 1952,
      signatureSize: 3309,
      algorithm: e.ml_dsa65
    },
    [r.LEVEL5]: {
      level: r.LEVEL5,
      privateKeySize: 4896,
      publicKeySize: 2592,
      signatureSize: 4627,
      algorithm: e.ml_dsa87
    }
  };
  Or.DEFAULT_SECURITY_LEVEL = r.LEVEL2;
  function i(s, n) {
    const p = a[s];
    if (!p)
      throw new TypeError(`Invalid ML-DSA security level: ${s}. Must be MLDSASecurityLevel.LEVEL2 (44), LEVEL3 (65), or LEVEL5 (87)`);
    return {
      ...p,
      network: n
    };
  }
  function o(s) {
    const n = [t.BITCOIN, t.TESTNET, t.REGTEST];
    for (const p of n) {
      if (s === p.bip32.private)
        return { network: p, isPrivate: !0 };
      if (s === p.bip32.public)
        return { network: p, isPrivate: !1 };
    }
    return null;
  }
  return Or;
}
var Sl;
function qb() {
  if (Sl) return fr;
  Sl = 1;
  var e = fr && fr.__createBinding || (Object.create ? (function(F, N, j, q) {
    q === void 0 && (q = j);
    var S = Object.getOwnPropertyDescriptor(N, j);
    (!S || ("get" in S ? !N.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return N[j];
    } }), Object.defineProperty(F, q, S);
  }) : (function(F, N, j, q) {
    q === void 0 && (q = j), F[q] = N[j];
  })), t = fr && fr.__setModuleDefault || (Object.create ? (function(F, N) {
    Object.defineProperty(F, "default", { enumerable: !0, value: N });
  }) : function(F, N) {
    F.default = N;
  }), r = fr && fr.__importStar || /* @__PURE__ */ (function() {
    var F = function(N) {
      return F = Object.getOwnPropertyNames || function(j) {
        var q = [];
        for (var S in j) Object.prototype.hasOwnProperty.call(j, S) && (q[q.length] = S);
        return q;
      }, F(N);
    };
    return function(N) {
      if (N && N.__esModule) return N;
      var j = {};
      if (N != null) for (var q = F(N), S = 0; S < q.length; S++) q[S] !== "default" && e(j, N, q[S]);
      return t(j, N), j;
    };
  })();
  Object.defineProperty(fr, "__esModule", { value: !0 }), fr.QuantumBIP32Factory = void 0;
  const a = Sb, i = r(Cf()), o = r(os), s = Kf(), n = r($f), p = Wf(), d = yi(), u = 32, w = 2147483648, y = o.fromUtf8("Bitcoin seed");
  class k {
    _privateKey;
    _publicKey;
    config;
    constructor(N, j, q) {
      this._privateKey = N, this._publicKey = j, this.config = q;
    }
    get publicKey() {
      if (!this._publicKey)
        throw new Error("Public key not available");
      return this._publicKey;
    }
    get privateKey() {
      return this._privateKey;
    }
    sign(N) {
      if (!this._privateKey)
        throw new Error("Missing private key");
      return this.config.algorithm.sign(N, this._privateKey, {
        extraEntropy: (0, a.randomBytes)(32)
      });
    }
    verify(N, j) {
      return this.config.algorithm.verify(j, N, this._publicKey);
    }
  }
  class A extends k {
    chainCode;
    _depth;
    _index;
    _parentFingerprint;
    constructor(N, j, q, S, D = 0, $ = 0, m = 0) {
      super(N, j, S), this.chainCode = q, this._depth = D, this._index = $, this._parentFingerprint = m;
    }
    get depth() {
      return this._depth;
    }
    get index() {
      return this._index;
    }
    get parentFingerprint() {
      return this._parentFingerprint;
    }
    #e;
    get identifier() {
      return this.#e === void 0 && (this.#e = i.hash160(this.publicKey)), this.#e;
    }
    get fingerprint() {
      return this.identifier.subarray(0, 4);
    }
    get securityLevel() {
      return this.config.level;
    }
    get network() {
      return this.config.network;
    }
    isNeutered() {
      return this._privateKey === void 0;
    }
    neutered() {
      return new A(void 0, this.publicKey, this.chainCode, this.config, this.depth, this.index, this.parentFingerprint);
    }
    toBase58() {
      const N = this.isNeutered() ? this.config.network.bip32.public : this.config.network.bip32.private, j = !this.isNeutered(), S = 45 + (j ? this.config.privateKeySize : this.config.publicKeySize), D = new Uint8Array(S);
      let $ = 0;
      return o.writeUInt32(D, $, N, "BE"), $ += 4, o.writeUInt8(D, $, this.depth), $ += 1, o.writeUInt32(D, $, this.parentFingerprint, "BE"), $ += 4, o.writeUInt32(D, $, this.index, "BE"), $ += 4, D.set(this.chainCode, $), $ += 32, j ? D.set(this._privateKey, $) : D.set(this._publicKey, $), n.encode(D);
    }
    /**
     * Derive a child key using BIP32 HMAC chain for seed derivation,
     * then ML-DSA for key generation
     */
    derive(N) {
      if (N !== N >>> 0)
        throw new TypeError("Expected UInt32, got " + N);
      if (this.isNeutered())
        throw new TypeError("Cannot derive child keys without private key");
      const j = N >= w;
      let q;
      if (j) {
        const C = i.hash256(this._privateKey);
        q = new Uint8Array(37), q[0] = 0, q.set(C, 1), o.writeUInt32(q, 33, N, "BE");
      } else {
        const C = i.hash256(this._privateKey);
        q = new Uint8Array(36), q.set(C, 0), o.writeUInt32(q, 32, N, "BE");
      }
      const S = i.hmacSHA512(this.chainCode, q), D = S.slice(0, 32), $ = S.slice(32), { secretKey: m, publicKey: U } = this.config.algorithm.keygen(D);
      return new A(m, U, $, this.config, this.depth + 1, N, o.readUInt32(this.fingerprint, 0, "BE"));
    }
    deriveHardened(N) {
      if (!Number.isInteger(N) || N < 0 || N > 2147483647)
        throw new TypeError("Expected UInt31, got " + N);
      return this.derive(N + w);
    }
    derivePath(N) {
      (0, s.validateBip32Path)(N);
      let j = N.split("/");
      if (j[0] === "m") {
        if (this.parentFingerprint)
          throw new TypeError("Expected master, got child");
        j = j.slice(1);
      }
      return j.reduce((q, S) => {
        let D;
        return S.slice(-1) === "'" ? (D = parseInt(S.slice(0, -1), 10), q.deriveHardened(D)) : (D = parseInt(S, 10), q.derive(D));
      }, this);
    }
  }
  function E(F, N, j) {
    if (!(F instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (F.length < 16)
      throw new TypeError("Seed should be at least 128 bits");
    if (F.length > 64)
      throw new TypeError("Seed should be at most 512 bits");
    const q = (0, p.getMLDSAConfig)(j || p.MLDSASecurityLevel.LEVEL2, N || d.BITCOIN), S = i.hmacSHA512(y, F), D = S.slice(0, 32), $ = S.slice(32), { secretKey: m, publicKey: U } = q.algorithm.keygen(D);
    return new A(
      m,
      U,
      $,
      // Chain code
      q,
      0,
      // depth
      0,
      // index
      0
    );
  }
  function x(F) {
    const N = n.decode(F), j = o.readUInt32(N, 0, "BE"), q = (0, p.findNetworkByVersion)(j);
    if (!q)
      throw new TypeError("Unknown network version");
    const { network: S, isPrivate: D } = q, m = N.length - 45;
    let U;
    if (D)
      if (m === 2560)
        U = p.MLDSASecurityLevel.LEVEL2;
      else if (m === 4032)
        U = p.MLDSASecurityLevel.LEVEL3;
      else if (m === 4896)
        U = p.MLDSASecurityLevel.LEVEL5;
      else
        throw new TypeError(`Invalid private key size: ${m}`);
    else if (m === 1312)
      U = p.MLDSASecurityLevel.LEVEL2;
    else if (m === 1952)
      U = p.MLDSASecurityLevel.LEVEL3;
    else if (m === 2592)
      U = p.MLDSASecurityLevel.LEVEL5;
    else
      throw new TypeError(`Invalid public key size: ${m}`);
    const C = (0, p.getMLDSAConfig)(U, S), M = D ? 45 + C.privateKeySize : 45 + C.publicKeySize;
    if (N.length !== M)
      throw new TypeError(`Invalid buffer length: expected ${M}, got ${N.length}`);
    let V = 4;
    const te = N[V];
    V += 1;
    const ie = o.readUInt32(N, V, "BE");
    if (te === 0 && ie !== 0)
      throw new TypeError("Invalid parent fingerprint");
    V += 4;
    const oe = o.readUInt32(N, V, "BE");
    if (te === 0 && oe !== 0)
      throw new TypeError("Invalid index");
    V += 4;
    const ne = N.slice(V, V + 32);
    if (V += 32, D) {
      const le = N.slice(V, V + C.privateKeySize), P = C.algorithm.getPublicKey(le);
      return new A(le, P, ne, C, te, oe, ie);
    } else {
      const le = N.slice(V, V + C.publicKeySize);
      return new A(void 0, le, ne, C, te, oe, ie);
    }
  }
  function I(F, N, j, q) {
    const S = (0, p.getMLDSAConfig)(q || p.MLDSASecurityLevel.LEVEL2, j || d.BITCOIN);
    if (F.length !== S.publicKeySize)
      throw new TypeError(`Invalid public key length for ML-DSA-${q}: expected ${S.publicKeySize}, got ${F.length}`);
    if (N.length !== u)
      throw new TypeError(`Invalid chain code length: expected ${u}, got ${N.length}`);
    return new A(void 0, F, N, S, 0, 0, 0);
  }
  function B(F, N, j, q) {
    const S = (0, p.getMLDSAConfig)(q || p.MLDSASecurityLevel.LEVEL2, j || d.BITCOIN);
    if (F.length !== S.privateKeySize)
      throw new TypeError(`Invalid private key length for ML-DSA-${q}: expected ${S.privateKeySize}, got ${F.length}`);
    if (N.length !== u)
      throw new TypeError(`Invalid chain code length: expected ${u}, got ${N.length}`);
    const D = S.algorithm.getPublicKey(F);
    return new A(F, D, N, S, 0, 0, 0);
  }
  function z(F, N, j, q, S) {
    const D = (0, p.getMLDSAConfig)(S || p.MLDSASecurityLevel.LEVEL2, q || d.BITCOIN);
    if (F.length !== D.privateKeySize)
      throw new TypeError(`Invalid private key length for ML-DSA-${S}: expected ${D.privateKeySize}, got ${F.length}`);
    if (N.length !== D.publicKeySize)
      throw new TypeError(`Invalid public key length for ML-DSA-${S}: expected ${D.publicKeySize}, got ${N.length}`);
    if (j.length !== u)
      throw new TypeError(`Invalid chain code length: expected ${u}, got ${j.length}`);
    return new A(F, N, j, D, 0, 0, 0);
  }
  function O(F, N, j, q, S, D, $, m) {
    const U = (0, p.getMLDSAConfig)(m || p.MLDSASecurityLevel.LEVEL2, $ || d.BITCOIN);
    return new A(F, N, j, U, q, S, D);
  }
  return fr.QuantumBIP32Factory = {
    fromSeed: E,
    fromBase58: x,
    fromPublicKey: I,
    fromPrivateKey: B,
    fromKeyPair: z,
    fromPrecomputed: O
  }, fr;
}
var Il;
function Db() {
  return Il || (Il = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getMLDSAConfig = e.DEFAULT_SECURITY_LEVEL = e.MLDSASecurityLevel = e.QuantumBIP32Factory = void 0;
    var t = qb();
    Object.defineProperty(e, "QuantumBIP32Factory", { enumerable: !0, get: function() {
      return t.QuantumBIP32Factory;
    } });
    var r = Wf();
    Object.defineProperty(e, "MLDSASecurityLevel", { enumerable: !0, get: function() {
      return r.MLDSASecurityLevel;
    } }), Object.defineProperty(e, "DEFAULT_SECURITY_LEVEL", { enumerable: !0, get: function() {
      return r.DEFAULT_SECURITY_LEVEL;
    } }), Object.defineProperty(e, "getMLDSAConfig", { enumerable: !0, get: function() {
      return r.getMLDSAConfig;
    } });
  })(Gi)), Gi;
}
var Rr = {}, Tl;
function Mb() {
  if (Tl) return Rr;
  Tl = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.QuantumDerivationPath = Rr.DerivationPath = void 0, Rr.getQuantumPath = r, Rr.getBitcoinPath = a;
  var e;
  (function(i) {
    i.BIP44 = "m/44'/0'/0'/0/0", i.BIP49 = "m/49'/0'/0'/0/0", i.BIP84 = "m/84'/0'/0'/0/0", i.BIP86 = "m/86'/0'/0'/0/0", i.BIP360 = "m/360'/0'/0'/0/0";
  })(e || (Rr.DerivationPath = e = {}));
  var t;
  (function(i) {
    i.STANDARD = "m/360'/0'/0'/0/0", i.CHANGE = "m/360'/0'/0'/1/0", i.ACCOUNT_0_ADDRESS_0 = "m/360'/0'/0'/0/0", i.ACCOUNT_0_ADDRESS_1 = "m/360'/0'/0'/0/1", i.ACCOUNT_1_ADDRESS_0 = "m/360'/1'/0'/0/0";
  })(t || (Rr.QuantumDerivationPath = t = {}));
  function r(i = 0, o = 0, s = !1) {
    return `m/360'/${i}'/${s ? 1 : 0}'/${o}`;
  }
  function a(i, o = 0, s = 0, n = !1) {
    return `m/${i}'/0'/${o}'/${n ? 1 : 0}/${s}`;
  }
  return Rr;
}
var jl;
function Fb() {
  return jl || (jl = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getBitcoinPath = e.getQuantumPath = e.QuantumDerivationPath = e.DerivationPath = e.getMLDSAConfig = e.DEFAULT_SECURITY_LEVEL = e.MLDSASecurityLevel = e.QuantumBIP32Factory = e.REGTEST = e.TESTNET = e.BITCOIN = e.BIP32Factory = e.default = void 0;
    var t = xb();
    Object.defineProperty(e, "default", { enumerable: !0, get: function() {
      return t.BIP32Factory;
    } }), Object.defineProperty(e, "BIP32Factory", { enumerable: !0, get: function() {
      return t.BIP32Factory;
    } });
    var r = yi();
    Object.defineProperty(e, "BITCOIN", { enumerable: !0, get: function() {
      return r.BITCOIN;
    } }), Object.defineProperty(e, "TESTNET", { enumerable: !0, get: function() {
      return r.TESTNET;
    } }), Object.defineProperty(e, "REGTEST", { enumerable: !0, get: function() {
      return r.REGTEST;
    } });
    var a = Db();
    Object.defineProperty(e, "QuantumBIP32Factory", { enumerable: !0, get: function() {
      return a.QuantumBIP32Factory;
    } }), Object.defineProperty(e, "MLDSASecurityLevel", { enumerable: !0, get: function() {
      return a.MLDSASecurityLevel;
    } }), Object.defineProperty(e, "DEFAULT_SECURITY_LEVEL", { enumerable: !0, get: function() {
      return a.DEFAULT_SECURITY_LEVEL;
    } }), Object.defineProperty(e, "getMLDSAConfig", { enumerable: !0, get: function() {
      return a.getMLDSAConfig;
    } });
    var i = Mb();
    Object.defineProperty(e, "DerivationPath", { enumerable: !0, get: function() {
      return i.DerivationPath;
    } }), Object.defineProperty(e, "QuantumDerivationPath", { enumerable: !0, get: function() {
      return i.QuantumDerivationPath;
    } }), Object.defineProperty(e, "getQuantumPath", { enumerable: !0, get: function() {
      return i.getQuantumPath;
    } }), Object.defineProperty(e, "getBitcoinPath", { enumerable: !0, get: function() {
      return i.getBitcoinPath;
    } });
  })(Hi)), Hi;
}
var $b = Fb();
const _y = /* @__PURE__ */ su($b);
function yr(e, t) {
  e = e.replace("#", "");
  const r = parseInt(e, 16), a = Math.round(2.55 * t), i = (r >> 16) + a, o = (r >> 8 & 255) + a, s = (r & 255) + a;
  return (16777216 + (i < 255 ? i < 1 ? 0 : i : 255) * 65536 + (o < 255 ? o < 1 ? 0 : o : 255) * 256 + (s < 255 ? s < 1 ? 0 : s : 255)).toString(16).slice(1);
}
const Vi = 10, Ol = (e = 0) => (t) => `\x1B[${t + e}m`, Rl = (e = 0) => (t) => `\x1B[${38 + e};5;${t}m`, Pl = (e = 0) => (t, r, a) => `\x1B[${38 + e};2;${t};${r};${a}m`, Ce = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
Object.keys(Ce.modifier);
const Kb = Object.keys(Ce.color), Hb = Object.keys(Ce.bgColor);
[...Kb, ...Hb];
function Zb() {
  const e = /* @__PURE__ */ new Map();
  for (const [t, r] of Object.entries(Ce)) {
    for (const [a, i] of Object.entries(r))
      Ce[a] = {
        open: `\x1B[${i[0]}m`,
        close: `\x1B[${i[1]}m`
      }, r[a] = Ce[a], e.set(i[0], i[1]);
    Object.defineProperty(Ce, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(Ce, "codes", {
    value: e,
    enumerable: !1
  }), Ce.color.close = "\x1B[39m", Ce.bgColor.close = "\x1B[49m", Ce.color.ansi = Ol(), Ce.color.ansi256 = Rl(), Ce.color.ansi16m = Pl(), Ce.bgColor.ansi = Ol(Vi), Ce.bgColor.ansi256 = Rl(Vi), Ce.bgColor.ansi16m = Pl(Vi), Object.defineProperties(Ce, {
    rgbToAnsi256: {
      value(t, r, a) {
        return t === r && r === a ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(a / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(t) {
        const r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [a] = r;
        a.length === 3 && (a = [...a].map((o) => o + o).join(""));
        const i = Number.parseInt(a, 16);
        return [
          /* eslint-disable no-bitwise */
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (t) => Ce.rgbToAnsi256(...Ce.hexToRgb(t)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(t) {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, a, i;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, a = r, i = r;
        else {
          t -= 16;
          const n = t % 36;
          r = Math.floor(t / 36) / 5, a = Math.floor(n / 6) / 5, i = n % 6 / 5;
        }
        const o = Math.max(r, a, i) * 2;
        if (o === 0)
          return 30;
        let s = 30 + (Math.round(i) << 2 | Math.round(a) << 1 | Math.round(r));
        return o === 2 && (s += 60), s;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (t, r, a) => Ce.ansi256ToAnsi(Ce.rgbToAnsi256(t, r, a)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (t) => Ce.ansi256ToAnsi(Ce.hexToAnsi256(t)),
      enumerable: !1
    }
  }), Ce;
}
const wr = Zb(), Ul = (() => {
  if (!("navigator" in globalThis))
    return 0;
  if (globalThis.navigator.userAgentData) {
    const e = navigator.userAgentData.brands.find(({ brand: t }) => t === "Chromium");
    if (e && e.version > 93)
      return 3;
  }
  return /\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent) ? 1 : 0;
})(), Cl = Ul !== 0 && {
  level: Ul
}, Gb = {
  stdout: Cl,
  stderr: Cl
};
function Vb(e, t, r) {
  let a = e.indexOf(t);
  if (a === -1)
    return e;
  const i = t.length;
  let o = 0, s = "";
  do
    s += e.slice(o, a) + t + r, o = a + i, a = e.indexOf(t, o);
  while (a !== -1);
  return s += e.slice(o), s;
}
function Wb(e, t, r, a) {
  let i = 0, o = "";
  do {
    const s = e[a - 1] === "\r";
    o += e.slice(i, s ? a - 1 : a) + t + (s ? `\r
` : `
`) + r, i = a + 1, a = e.indexOf(`
`, i);
  } while (a !== -1);
  return o += e.slice(i), o;
}
const { stdout: Ll, stderr: Nl } = Gb, Tn = /* @__PURE__ */ Symbol("GENERATOR"), Ut = /* @__PURE__ */ Symbol("STYLER"), ha = /* @__PURE__ */ Symbol("IS_EMPTY"), ql = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], Ct = /* @__PURE__ */ Object.create(null), Yb = (e, t = {}) => {
  if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  const r = Ll ? Ll.level : 0;
  e.level = t.level === void 0 ? r : t.level;
};
class Xb {
  constructor(t) {
    return Yf(t);
  }
}
const Yf = (e) => {
  const t = (...r) => r.join(" ");
  return Yb(t, e), Object.setPrototypeOf(t, _a.prototype), t;
};
function _a(e) {
  return Yf(e);
}
Object.setPrototypeOf(_a.prototype, Function.prototype);
for (const [e, t] of Object.entries(wr))
  Ct[e] = {
    get() {
      const r = ci(this, On(t.open, t.close, this[Ut]), this[ha]);
      return Object.defineProperty(this, e, { value: r }), r;
    }
  };
Ct.visible = {
  get() {
    const e = ci(this, this[Ut], !0);
    return Object.defineProperty(this, "visible", { value: e }), e;
  }
};
const jn = (e, t, r, ...a) => e === "rgb" ? t === "ansi16m" ? wr[r].ansi16m(...a) : t === "ansi256" ? wr[r].ansi256(wr.rgbToAnsi256(...a)) : wr[r].ansi(wr.rgbToAnsi(...a)) : e === "hex" ? jn("rgb", t, r, ...wr.hexToRgb(...a)) : wr[r][e](...a), Jb = ["rgb", "hex", "ansi256"];
for (const e of Jb) {
  Ct[e] = {
    get() {
      const { level: r } = this;
      return function(...a) {
        const i = On(jn(e, ql[r], "color", ...a), wr.color.close, this[Ut]);
        return ci(this, i, this[ha]);
      };
    }
  };
  const t = "bg" + e[0].toUpperCase() + e.slice(1);
  Ct[t] = {
    get() {
      const { level: r } = this;
      return function(...a) {
        const i = On(jn(e, ql[r], "bgColor", ...a), wr.bgColor.close, this[Ut]);
        return ci(this, i, this[ha]);
      };
    }
  };
}
const Qb = Object.defineProperties(() => {
}, {
  ...Ct,
  level: {
    enumerable: !0,
    get() {
      return this[Tn].level;
    },
    set(e) {
      this[Tn].level = e;
    }
  }
}), On = (e, t, r) => {
  let a, i;
  return r === void 0 ? (a = e, i = t) : (a = r.openAll + e, i = t + r.closeAll), {
    open: e,
    close: t,
    openAll: a,
    closeAll: i,
    parent: r
  };
}, ci = (e, t, r) => {
  const a = (...i) => em(a, i.length === 1 ? "" + i[0] : i.join(" "));
  return Object.setPrototypeOf(a, Qb), a[Tn] = e, a[Ut] = t, a[ha] = r, a;
}, em = (e, t) => {
  if (e.level <= 0 || !t)
    return e[ha] ? "" : t;
  let r = e[Ut];
  if (r === void 0)
    return t;
  const { openAll: a, closeAll: i } = r;
  if (t.includes("\x1B"))
    for (; r !== void 0; )
      t = Vb(t, r.close, r.open), r = r.parent;
  const o = t.indexOf(`
`);
  return o !== -1 && (t = Wb(t, i, a, o)), a + t + i;
};
Object.defineProperties(_a.prototype, Ct);
_a();
_a({ level: Nl ? Nl.level : 0 });
var we = function(e, t, r, a) {
  if (r === "a" && !a) throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !a : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return r === "m" ? a : r === "a" ? a.call(e) : a ? a.value : t.get(e);
}, St, Rn, Da, Ma, Pn, Fa, Un, $a, Cn, Ka, Jt, Qt, Ha, Hr, Ln, Za, Nn;
class rm {
  constructor(t = new Xb()) {
    this.chalk = t, this.moduleName = "", this.logColor = "#00bfff", this.enableLogs = !0, this.hideLogs = !1, St.set(this, "#ff00ff"), Rn.set(this, yr(we(this, St, "f"), 75)), Da.set(this, "#9400d3"), Ma.set(this, yr(we(this, Da, "f"), 15)), Pn.set(this, yr(we(this, Ma, "f"), 15)), Fa.set(this, "#7cfc00"), Un.set(this, yr(we(this, Fa, "f"), 15)), $a.set(this, "#ffdead"), Cn.set(this, yr(we(this, $a, "f"), 15)), Ka.set(this, "#ff8c00"), Jt.set(this, yr(we(this, Ka, "f"), 15)), Qt.set(this, "#ff4500"), Ha.set(this, yr(we(this, Qt, "f"), 15)), Hr.set(this, "#ffffff"), Ln.set(this, yr(we(this, Hr, "f"), 15)), Za.set(this, "#8b0000"), Nn.set(this, yr(we(this, Za, "f"), 15)), this.prefix = "", this.moduleName = this.constructor.name;
  }
  setLogPrefix(t) {
    this.prefix = t;
  }
  getStartPrefix() {
    return this.prefix;
  }
  disable() {
    this.enableLogs = !1;
  }
  enable() {
    this.enableLogs = !0;
  }
  fancyLog(t, r, a, i, o) {
    this.enableLogs && console.log(this.chalk.hex(we(this, St, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) + this.chalk.hex(we(this, Hr, "f"))(t) + " " + this.chalk.hex(we(this, Jt, "f"))(r) + " " + this.chalk.hex(we(this, Hr, "f"))(a) + " " + this.chalk.hex(we(this, Pn, "f"))(i) + " " + this.chalk.hex(we(this, Hr, "f"))(o));
  }
  log(...t) {
    if (this.enableLogs && !this.hideLogs) {
      const r = yr(this.logColor, 15);
      console.log(this.chalk.hex(this.logColor)(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(r)(...t));
    }
  }
  lightOrangeLog(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we(this, Jt, "f"))(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(we(this, Hr, "f"))(...t)));
  }
  error(...t) {
    this.enableLogs && console.log(this.chalk.hex(we(this, Qt, "f"))(`${this.getStartPrefix()}[${this.moduleName} ERROR]: `) + this.chalk.hex(we(this, Ha, "f"))(...t));
  }
  warn(...t) {
    this.enableLogs && console.log(this.chalk.hex(we(this, Ka, "f"))(`${this.getStartPrefix()}[${this.moduleName} WARN]: `) + this.chalk.hex(we(this, Jt, "f"))(...t));
  }
  debug(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we(this, $a, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(we(this, Cn, "f"))(...t)));
  }
  success(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we(this, Fa, "f"))(`${this.getStartPrefix()}[${this.moduleName} SUCCESS]: `) + this.chalk.hex(we(this, Un, "f"))(...t)));
  }
  fail(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we(this, Qt, "f"))(`${this.getStartPrefix()}[${this.moduleName} FAIL]: `) + this.chalk.hex(we(this, Ha, "f"))(...t)));
  }
  debugBright(...t) {
    this.enableLogs && (this.hideLogs || console.log(this.chalk.hex(we(this, Da, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(we(this, Ma, "f"))(...t)));
  }
  important(...t) {
    this.enableLogs && console.log(this.chalk.hex(we(this, St, "f"))(`${this.getStartPrefix()}[${this.moduleName} IMPORTANT]: `) + this.chalk.hex(we(this, Rn, "f"))(...t));
  }
  panic(...t) {
    this.enableLogs && console.log(this.chalk.hex(we(this, Za, "f"))(`${this.getStartPrefix()}[${this.moduleName} HELP PANIC]: `) + this.chalk.hex(we(this, Nn, "f"))(...t));
  }
  info(...t) {
    this.enableLogs && console.log(this.chalk.hex(we(this, St, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) + this.chalk.hex(we(this, Hr, "f"))(...t));
  }
  securityNotice(...t) {
    this.enableLogs && console.log(this.chalk.hex("#22d8e6")(`${this.getStartPrefix()}[${this.moduleName} SECURITY NOTICE]: `) + this.chalk.hex("#22e3e6")(...t));
  }
  traceLog(...t) {
    this.enableLogs && console.log(this.chalk.hex("#ffffff")(`${this.getStartPrefix()}[${this.moduleName} TRACE LOG]: `) + this.chalk.hex(we(this, Ln, "f"))(...t));
  }
}
St = /* @__PURE__ */ new WeakMap(), Rn = /* @__PURE__ */ new WeakMap(), Da = /* @__PURE__ */ new WeakMap(), Ma = /* @__PURE__ */ new WeakMap(), Pn = /* @__PURE__ */ new WeakMap(), Fa = /* @__PURE__ */ new WeakMap(), Un = /* @__PURE__ */ new WeakMap(), $a = /* @__PURE__ */ new WeakMap(), Cn = /* @__PURE__ */ new WeakMap(), Ka = /* @__PURE__ */ new WeakMap(), Jt = /* @__PURE__ */ new WeakMap(), Qt = /* @__PURE__ */ new WeakMap(), Ha = /* @__PURE__ */ new WeakMap(), Hr = /* @__PURE__ */ new WeakMap(), Ln = /* @__PURE__ */ new WeakMap(), Za = /* @__PURE__ */ new WeakMap(), Nn = /* @__PURE__ */ new WeakMap();
class ky extends rm {
  constructor() {
    super();
  }
}
var Dl;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.ERROR = 1] = "ERROR", e[e.WARN = 2] = "WARN", e[e.INFO = 3] = "INFO", e[e.DEBUG = 4] = "DEBUG", e[e.TRACE = 5] = "TRACE", e[e.ALL = 6] = "ALL";
})(Dl || (Dl = {}));
var tt = {}, Ml;
function tm() {
  if (Ml) return tt;
  Ml = 1, Object.defineProperty(tt, "__esModule", { value: !0 }), tt.bech32m = tt.bech32 = void 0;
  const e = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", t = {};
  for (let d = 0; d < e.length; d++) {
    const u = e.charAt(d);
    t[u] = d;
  }
  function r(d) {
    const u = d >> 25;
    return (d & 33554431) << 5 ^ -(u >> 0 & 1) & 996825010 ^ -(u >> 1 & 1) & 642813549 ^ -(u >> 2 & 1) & 513874426 ^ -(u >> 3 & 1) & 1027748829 ^ -(u >> 4 & 1) & 705979059;
  }
  function a(d) {
    let u = 1;
    for (let w = 0; w < d.length; ++w) {
      const y = d.charCodeAt(w);
      if (y < 33 || y > 126)
        return "Invalid prefix (" + d + ")";
      u = r(u) ^ y >> 5;
    }
    u = r(u);
    for (let w = 0; w < d.length; ++w) {
      const y = d.charCodeAt(w);
      u = r(u) ^ y & 31;
    }
    return u;
  }
  function i(d, u, w, y) {
    let k = 0, A = 0;
    const E = (1 << w) - 1, x = [];
    for (let I = 0; I < d.length; ++I)
      for (k = k << u | d[I], A += u; A >= w; )
        A -= w, x.push(k >> A & E);
    if (y)
      A > 0 && x.push(k << w - A & E);
    else {
      if (A >= u)
        return "Excess padding";
      if (k << w - A & E)
        return "Non-zero padding";
    }
    return x;
  }
  function o(d) {
    return i(d, 8, 5, !0);
  }
  function s(d) {
    const u = i(d, 5, 8, !1);
    if (Array.isArray(u))
      return u;
  }
  function n(d) {
    const u = i(d, 5, 8, !1);
    if (Array.isArray(u))
      return u;
    throw new Error(u);
  }
  function p(d) {
    let u;
    d === "bech32" ? u = 1 : u = 734539939;
    function w(E, x, I) {
      if (I = I || 90, E.length + 7 + x.length > I)
        throw new TypeError("Exceeds length limit");
      E = E.toLowerCase();
      let B = a(E);
      if (typeof B == "string")
        throw new Error(B);
      let z = E + "1";
      for (let O = 0; O < x.length; ++O) {
        const F = x[O];
        if (F >> 5 !== 0)
          throw new Error("Non 5-bit word");
        B = r(B) ^ F, z += e.charAt(F);
      }
      for (let O = 0; O < 6; ++O)
        B = r(B);
      B ^= u;
      for (let O = 0; O < 6; ++O) {
        const F = B >> (5 - O) * 5 & 31;
        z += e.charAt(F);
      }
      return z;
    }
    function y(E, x) {
      if (x = x || 90, E.length < 8)
        return E + " too short";
      if (E.length > x)
        return "Exceeds length limit";
      const I = E.toLowerCase(), B = E.toUpperCase();
      if (E !== I && E !== B)
        return "Mixed-case string " + E;
      E = I;
      const z = E.lastIndexOf("1");
      if (z === -1)
        return "No separator character for " + E;
      if (z === 0)
        return "Missing prefix for " + E;
      const O = E.slice(0, z), F = E.slice(z + 1);
      if (F.length < 6)
        return "Data too short";
      let N = a(O);
      if (typeof N == "string")
        return N;
      const j = [];
      for (let q = 0; q < F.length; ++q) {
        const S = F.charAt(q), D = t[S];
        if (D === void 0)
          return "Unknown character " + S;
        N = r(N) ^ D, !(q + 6 >= F.length) && j.push(D);
      }
      return N !== u ? "Invalid checksum for " + E : { prefix: O, words: j };
    }
    function k(E, x) {
      const I = y(E, x);
      if (typeof I == "object")
        return I;
    }
    function A(E, x) {
      const I = y(E, x);
      if (typeof I == "object")
        return I;
      throw new Error(I);
    }
    return {
      decodeUnsafe: k,
      decode: A,
      encode: w,
      toWords: o,
      fromWordsUnsafe: s,
      fromWords: n
    };
  }
  return tt.bech32 = p("bech32"), tt.bech32m = p("bech32m"), tt;
}
var Ey = tm(), Xf = {}, wi = {};
wi.byteLength = om;
wi.toByteArray = sm;
wi.fromByteArray = um;
var xr = [], sr = [], am = typeof Uint8Array < "u" ? Uint8Array : Array, Wi = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var At = 0, im = Wi.length; At < im; ++At)
  xr[At] = Wi[At], sr[Wi.charCodeAt(At)] = At;
sr[45] = 62;
sr[95] = 63;
function Jf(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var a = r === t ? 0 : 4 - r % 4;
  return [r, a];
}
function om(e) {
  var t = Jf(e), r = t[0], a = t[1];
  return (r + a) * 3 / 4 - a;
}
function nm(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function sm(e) {
  var t, r = Jf(e), a = r[0], i = r[1], o = new am(nm(e, a, i)), s = 0, n = i > 0 ? a - 4 : a, p;
  for (p = 0; p < n; p += 4)
    t = sr[e.charCodeAt(p)] << 18 | sr[e.charCodeAt(p + 1)] << 12 | sr[e.charCodeAt(p + 2)] << 6 | sr[e.charCodeAt(p + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
  return i === 2 && (t = sr[e.charCodeAt(p)] << 2 | sr[e.charCodeAt(p + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = sr[e.charCodeAt(p)] << 10 | sr[e.charCodeAt(p + 1)] << 4 | sr[e.charCodeAt(p + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
}
function lm(e) {
  return xr[e >> 18 & 63] + xr[e >> 12 & 63] + xr[e >> 6 & 63] + xr[e & 63];
}
function cm(e, t, r) {
  for (var a, i = [], o = t; o < r; o += 3)
    a = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(lm(a));
  return i.join("");
}
function um(e) {
  for (var t, r = e.length, a = r % 3, i = [], o = 16383, s = 0, n = r - a; s < n; s += o)
    i.push(cm(e, s, s + o > n ? n : s + o));
  return a === 1 ? (t = e[r - 1], i.push(
    xr[t >> 2] + xr[t << 4 & 63] + "=="
  )) : a === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(
    xr[t >> 10] + xr[t >> 4 & 63] + xr[t << 2 & 63] + "="
  )), i.join("");
}
var hs = {};
hs.read = function(e, t, r, a, i) {
  var o, s, n = i * 8 - a - 1, p = (1 << n) - 1, d = p >> 1, u = -7, w = r ? i - 1 : 0, y = r ? -1 : 1, k = e[t + w];
  for (w += y, o = k & (1 << -u) - 1, k >>= -u, u += n; u > 0; o = o * 256 + e[t + w], w += y, u -= 8)
    ;
  for (s = o & (1 << -u) - 1, o >>= -u, u += a; u > 0; s = s * 256 + e[t + w], w += y, u -= 8)
    ;
  if (o === 0)
    o = 1 - d;
  else {
    if (o === p)
      return s ? NaN : (k ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, a), o = o - d;
  }
  return (k ? -1 : 1) * s * Math.pow(2, o - a);
};
hs.write = function(e, t, r, a, i, o) {
  var s, n, p, d = o * 8 - i - 1, u = (1 << d) - 1, w = u >> 1, y = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, k = a ? 0 : o - 1, A = a ? 1 : -1, E = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (n = isNaN(t) ? 1 : 0, s = u) : (s = Math.floor(Math.log(t) / Math.LN2), t * (p = Math.pow(2, -s)) < 1 && (s--, p *= 2), s + w >= 1 ? t += y / p : t += y * Math.pow(2, 1 - w), t * p >= 2 && (s++, p /= 2), s + w >= u ? (n = 0, s = u) : s + w >= 1 ? (n = (t * p - 1) * Math.pow(2, i), s = s + w) : (n = t * Math.pow(2, w - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + k] = n & 255, k += A, n /= 256, i -= 8)
    ;
  for (s = s << i | n, d += i; d > 0; e[r + k] = s & 255, k += A, s /= 256, d -= 8)
    ;
  e[r + k - A] |= E * 128;
};
(function(e) {
  const t = wi, r = hs, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = F, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i;
  const { Uint8Array: o, ArrayBuffer: s, SharedArrayBuffer: n } = globalThis;
  u.TYPED_ARRAY_SUPPORT = p(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function p() {
    try {
      const g = new o(1), l = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(l, o.prototype), Object.setPrototypeOf(g, l), g.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function d(g) {
    if (g > i)
      throw new RangeError('The value "' + g + '" is invalid for option "size"');
    const l = new o(g);
    return Object.setPrototypeOf(l, u.prototype), l;
  }
  function u(g, l, f) {
    if (typeof g == "number") {
      if (typeof l == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return A(g);
    }
    return w(g, l, f);
  }
  u.poolSize = 8192;
  function w(g, l, f) {
    if (typeof g == "string")
      return E(g, l);
    if (s.isView(g))
      return I(g);
    if (g == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g
      );
    if (Oe(g, s) || g && Oe(g.buffer, s) || typeof n < "u" && (Oe(g, n) || g && Oe(g.buffer, n)))
      return B(g, l, f);
    if (typeof g == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const v = g.valueOf && g.valueOf();
    if (v != null && v !== g)
      return u.from(v, l, f);
    const R = z(g);
    if (R) return R;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof g[Symbol.toPrimitive] == "function")
      return u.from(g[Symbol.toPrimitive]("string"), l, f);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g
    );
  }
  u.from = function(g, l, f) {
    return w(g, l, f);
  }, Object.setPrototypeOf(u.prototype, o.prototype), Object.setPrototypeOf(u, o);
  function y(g) {
    if (typeof g != "number")
      throw new TypeError('"size" argument must be of type number');
    if (g < 0)
      throw new RangeError('The value "' + g + '" is invalid for option "size"');
  }
  function k(g, l, f) {
    return y(g), g <= 0 ? d(g) : l !== void 0 ? typeof f == "string" ? d(g).fill(l, f) : d(g).fill(l) : d(g);
  }
  u.alloc = function(g, l, f) {
    return k(g, l, f);
  };
  function A(g) {
    return y(g), d(g < 0 ? 0 : O(g) | 0);
  }
  u.allocUnsafe = function(g) {
    return A(g);
  }, u.allocUnsafeSlow = function(g) {
    return A(g);
  };
  function E(g, l) {
    if ((typeof l != "string" || l === "") && (l = "utf8"), !u.isEncoding(l))
      throw new TypeError("Unknown encoding: " + l);
    const f = N(g, l) | 0;
    let v = d(f);
    const R = v.write(g, l);
    return R !== f && (v = v.slice(0, R)), v;
  }
  function x(g) {
    const l = g.length < 0 ? 0 : O(g.length) | 0, f = d(l);
    for (let v = 0; v < l; v += 1)
      f[v] = g[v] & 255;
    return f;
  }
  function I(g) {
    if (Oe(g, o)) {
      const l = new o(g);
      return B(l.buffer, l.byteOffset, l.byteLength);
    }
    return x(g);
  }
  function B(g, l, f) {
    if (l < 0 || g.byteLength < l)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (g.byteLength < l + (f || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let v;
    return l === void 0 && f === void 0 ? v = new o(g) : f === void 0 ? v = new o(g, l) : v = new o(g, l, f), Object.setPrototypeOf(v, u.prototype), v;
  }
  function z(g) {
    if (u.isBuffer(g)) {
      const l = O(g.length) | 0, f = d(l);
      return f.length === 0 || g.copy(f, 0, 0, l), f;
    }
    if (g.length !== void 0)
      return typeof g.length != "number" || ar(g.length) ? d(0) : x(g);
    if (g.type === "Buffer" && Array.isArray(g.data))
      return x(g.data);
  }
  function O(g) {
    if (g >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return g | 0;
  }
  function F(g) {
    return +g != g && (g = 0), u.alloc(+g);
  }
  u.isBuffer = function(l) {
    return l != null && l._isBuffer === !0 && l !== u.prototype;
  }, u.compare = function(l, f) {
    if (Oe(l, o) && (l = u.from(l, l.offset, l.byteLength)), Oe(f, o) && (f = u.from(f, f.offset, f.byteLength)), !u.isBuffer(l) || !u.isBuffer(f))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (l === f) return 0;
    let v = l.length, R = f.length;
    for (let H = 0, J = Math.min(v, R); H < J; ++H)
      if (l[H] !== f[H]) {
        v = l[H], R = f[H];
        break;
      }
    return v < R ? -1 : R < v ? 1 : 0;
  }, u.isEncoding = function(l) {
    switch (String(l).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(l, f) {
    if (!Array.isArray(l))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (l.length === 0)
      return u.alloc(0);
    let v;
    if (f === void 0)
      for (f = 0, v = 0; v < l.length; ++v)
        f += l[v].length;
    const R = u.allocUnsafe(f);
    let H = 0;
    for (v = 0; v < l.length; ++v) {
      let J = l[v];
      if (Oe(J, o))
        H + J.length > R.length ? (u.isBuffer(J) || (J = u.from(J)), J.copy(R, H)) : o.prototype.set.call(
          R,
          J,
          H
        );
      else if (u.isBuffer(J))
        J.copy(R, H);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      H += J.length;
    }
    return R;
  };
  function N(g, l) {
    if (u.isBuffer(g))
      return g.length;
    if (s.isView(g) || Oe(g, s))
      return g.byteLength;
    if (typeof g != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof g
      );
    const f = g.length, v = arguments.length > 2 && arguments[2] === !0;
    if (!v && f === 0) return 0;
    let R = !1;
    for (; ; )
      switch (l) {
        case "ascii":
        case "latin1":
        case "binary":
          return f;
        case "utf8":
        case "utf-8":
          return Ne(g).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return f * 2;
        case "hex":
          return f >>> 1;
        case "base64":
          return be(g).length;
        default:
          if (R)
            return v ? -1 : Ne(g).length;
          l = ("" + l).toLowerCase(), R = !0;
      }
  }
  u.byteLength = N;
  function j(g, l, f) {
    let v = !1;
    if ((l === void 0 || l < 0) && (l = 0), l > this.length || ((f === void 0 || f > this.length) && (f = this.length), f <= 0) || (f >>>= 0, l >>>= 0, f <= l))
      return "";
    for (g || (g = "utf8"); ; )
      switch (g) {
        case "hex":
          return P(this, l, f);
        case "utf8":
        case "utf-8":
          return te(this, l, f);
        case "ascii":
          return ne(this, l, f);
        case "latin1":
        case "binary":
          return le(this, l, f);
        case "base64":
          return V(this, l, f);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Z(this, l, f);
        default:
          if (v) throw new TypeError("Unknown encoding: " + g);
          g = (g + "").toLowerCase(), v = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function q(g, l, f) {
    const v = g[l];
    g[l] = g[f], g[f] = v;
  }
  u.prototype.swap16 = function() {
    const l = this.length;
    if (l % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let f = 0; f < l; f += 2)
      q(this, f, f + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const l = this.length;
    if (l % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let f = 0; f < l; f += 4)
      q(this, f, f + 3), q(this, f + 1, f + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const l = this.length;
    if (l % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let f = 0; f < l; f += 8)
      q(this, f, f + 7), q(this, f + 1, f + 6), q(this, f + 2, f + 5), q(this, f + 3, f + 4);
    return this;
  }, u.prototype.toString = function() {
    const l = this.length;
    return l === 0 ? "" : arguments.length === 0 ? te(this, 0, l) : j.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(l) {
    if (!u.isBuffer(l)) throw new TypeError("Argument must be a Buffer");
    return this === l ? !0 : u.compare(this, l) === 0;
  }, u.prototype.inspect = function() {
    let l = "";
    const f = e.INSPECT_MAX_BYTES;
    return l = this.toString("hex", 0, f).replace(/(.{2})/g, "$1 ").trim(), this.length > f && (l += " ... "), "<Buffer " + l + ">";
  }, a && (u.prototype[a] = u.prototype.inspect), u.prototype.compare = function(l, f, v, R, H) {
    if (Oe(l, o) && (l = u.from(l, l.offset, l.byteLength)), !u.isBuffer(l))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l
      );
    if (f === void 0 && (f = 0), v === void 0 && (v = l ? l.length : 0), R === void 0 && (R = 0), H === void 0 && (H = this.length), f < 0 || v > l.length || R < 0 || H > this.length)
      throw new RangeError("out of range index");
    if (R >= H && f >= v)
      return 0;
    if (R >= H)
      return -1;
    if (f >= v)
      return 1;
    if (f >>>= 0, v >>>= 0, R >>>= 0, H >>>= 0, this === l) return 0;
    let J = H - R, me = v - f;
    const Se = Math.min(J, me), Ie = this.slice(R, H), Re = l.slice(f, v);
    for (let xe = 0; xe < Se; ++xe)
      if (Ie[xe] !== Re[xe]) {
        J = Ie[xe], me = Re[xe];
        break;
      }
    return J < me ? -1 : me < J ? 1 : 0;
  };
  function S(g, l, f, v, R) {
    if (g.length === 0) return -1;
    if (typeof f == "string" ? (v = f, f = 0) : f > 2147483647 ? f = 2147483647 : f < -2147483648 && (f = -2147483648), f = +f, ar(f) && (f = R ? 0 : g.length - 1), f < 0 && (f = g.length + f), f >= g.length) {
      if (R) return -1;
      f = g.length - 1;
    } else if (f < 0)
      if (R) f = 0;
      else return -1;
    if (typeof l == "string" && (l = u.from(l, v)), u.isBuffer(l))
      return l.length === 0 ? -1 : D(g, l, f, v, R);
    if (typeof l == "number")
      return l = l & 255, typeof o.prototype.indexOf == "function" ? R ? o.prototype.indexOf.call(g, l, f) : o.prototype.lastIndexOf.call(g, l, f) : D(g, [l], f, v, R);
    throw new TypeError("val must be string, number or Buffer");
  }
  function D(g, l, f, v, R) {
    let H = 1, J = g.length, me = l.length;
    if (v !== void 0 && (v = String(v).toLowerCase(), v === "ucs2" || v === "ucs-2" || v === "utf16le" || v === "utf-16le")) {
      if (g.length < 2 || l.length < 2)
        return -1;
      H = 2, J /= 2, me /= 2, f /= 2;
    }
    function Se(Re, xe) {
      return H === 1 ? Re[xe] : Re.readUInt16BE(xe * H);
    }
    let Ie;
    if (R) {
      let Re = -1;
      for (Ie = f; Ie < J; Ie++)
        if (Se(g, Ie) === Se(l, Re === -1 ? 0 : Ie - Re)) {
          if (Re === -1 && (Re = Ie), Ie - Re + 1 === me) return Re * H;
        } else
          Re !== -1 && (Ie -= Ie - Re), Re = -1;
    } else
      for (f + me > J && (f = J - me), Ie = f; Ie >= 0; Ie--) {
        let Re = !0;
        for (let xe = 0; xe < me; xe++)
          if (Se(g, Ie + xe) !== Se(l, xe)) {
            Re = !1;
            break;
          }
        if (Re) return Ie;
      }
    return -1;
  }
  u.prototype.includes = function(l, f, v) {
    return this.indexOf(l, f, v) !== -1;
  }, u.prototype.indexOf = function(l, f, v) {
    return S(this, l, f, v, !0);
  }, u.prototype.lastIndexOf = function(l, f, v) {
    return S(this, l, f, v, !1);
  };
  function $(g, l, f, v) {
    f = Number(f) || 0;
    const R = g.length - f;
    v ? (v = Number(v), v > R && (v = R)) : v = R;
    const H = l.length;
    v > H / 2 && (v = H / 2);
    let J;
    for (J = 0; J < v; ++J) {
      const me = parseInt(l.substr(J * 2, 2), 16);
      if (ar(me)) return J;
      g[f + J] = me;
    }
    return J;
  }
  function m(g, l, f, v) {
    return Be(Ne(l, g.length - f), g, f, v);
  }
  function U(g, l, f, v) {
    return Be(se(l), g, f, v);
  }
  function C(g, l, f, v) {
    return Be(be(l), g, f, v);
  }
  function M(g, l, f, v) {
    return Be(he(l, g.length - f), g, f, v);
  }
  u.prototype.write = function(l, f, v, R) {
    if (f === void 0)
      R = "utf8", v = this.length, f = 0;
    else if (v === void 0 && typeof f == "string")
      R = f, v = this.length, f = 0;
    else if (isFinite(f))
      f = f >>> 0, isFinite(v) ? (v = v >>> 0, R === void 0 && (R = "utf8")) : (R = v, v = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const H = this.length - f;
    if ((v === void 0 || v > H) && (v = H), l.length > 0 && (v < 0 || f < 0) || f > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    R || (R = "utf8");
    let J = !1;
    for (; ; )
      switch (R) {
        case "hex":
          return $(this, l, f, v);
        case "utf8":
        case "utf-8":
          return m(this, l, f, v);
        case "ascii":
        case "latin1":
        case "binary":
          return U(this, l, f, v);
        case "base64":
          return C(this, l, f, v);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return M(this, l, f, v);
        default:
          if (J) throw new TypeError("Unknown encoding: " + R);
          R = ("" + R).toLowerCase(), J = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function V(g, l, f) {
    return l === 0 && f === g.length ? t.fromByteArray(g) : t.fromByteArray(g.slice(l, f));
  }
  function te(g, l, f) {
    f = Math.min(g.length, f);
    const v = [];
    let R = l;
    for (; R < f; ) {
      const H = g[R];
      let J = null, me = H > 239 ? 4 : H > 223 ? 3 : H > 191 ? 2 : 1;
      if (R + me <= f) {
        let Se, Ie, Re, xe;
        switch (me) {
          case 1:
            H < 128 && (J = H);
            break;
          case 2:
            Se = g[R + 1], (Se & 192) === 128 && (xe = (H & 31) << 6 | Se & 63, xe > 127 && (J = xe));
            break;
          case 3:
            Se = g[R + 1], Ie = g[R + 2], (Se & 192) === 128 && (Ie & 192) === 128 && (xe = (H & 15) << 12 | (Se & 63) << 6 | Ie & 63, xe > 2047 && (xe < 55296 || xe > 57343) && (J = xe));
            break;
          case 4:
            Se = g[R + 1], Ie = g[R + 2], Re = g[R + 3], (Se & 192) === 128 && (Ie & 192) === 128 && (Re & 192) === 128 && (xe = (H & 15) << 18 | (Se & 63) << 12 | (Ie & 63) << 6 | Re & 63, xe > 65535 && xe < 1114112 && (J = xe));
        }
      }
      J === null ? (J = 65533, me = 1) : J > 65535 && (J -= 65536, v.push(J >>> 10 & 1023 | 55296), J = 56320 | J & 1023), v.push(J), R += me;
    }
    return oe(v);
  }
  const ie = 4096;
  function oe(g) {
    const l = g.length;
    if (l <= ie)
      return String.fromCharCode.apply(String, g);
    let f = "", v = 0;
    for (; v < l; )
      f += String.fromCharCode.apply(
        String,
        g.slice(v, v += ie)
      );
    return f;
  }
  function ne(g, l, f) {
    let v = "";
    f = Math.min(g.length, f);
    for (let R = l; R < f; ++R)
      v += String.fromCharCode(g[R] & 127);
    return v;
  }
  function le(g, l, f) {
    let v = "";
    f = Math.min(g.length, f);
    for (let R = l; R < f; ++R)
      v += String.fromCharCode(g[R]);
    return v;
  }
  function P(g, l, f) {
    const v = g.length;
    (!l || l < 0) && (l = 0), (!f || f < 0 || f > v) && (f = v);
    let R = "";
    for (let H = l; H < f; ++H)
      R += Sr[g[H]];
    return R;
  }
  function Z(g, l, f) {
    const v = g.slice(l, f);
    let R = "";
    for (let H = 0; H < v.length - 1; H += 2)
      R += String.fromCharCode(v[H] + v[H + 1] * 256);
    return R;
  }
  u.prototype.slice = function(l, f) {
    const v = this.length;
    l = ~~l, f = f === void 0 ? v : ~~f, l < 0 ? (l += v, l < 0 && (l = 0)) : l > v && (l = v), f < 0 ? (f += v, f < 0 && (f = 0)) : f > v && (f = v), f < l && (f = l);
    const R = this.subarray(l, f);
    return Object.setPrototypeOf(R, u.prototype), R;
  };
  function T(g, l, f) {
    if (g % 1 !== 0 || g < 0) throw new RangeError("offset is not uint");
    if (g + l > f) throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(l, f, v) {
    l = l >>> 0, f = f >>> 0, v || T(l, f, this.length);
    let R = this[l], H = 1, J = 0;
    for (; ++J < f && (H *= 256); )
      R += this[l + J] * H;
    return R;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(l, f, v) {
    l = l >>> 0, f = f >>> 0, v || T(l, f, this.length);
    let R = this[l + --f], H = 1;
    for (; f > 0 && (H *= 256); )
      R += this[l + --f] * H;
    return R;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(l, f) {
    return l = l >>> 0, f || T(l, 1, this.length), this[l];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(l, f) {
    return l = l >>> 0, f || T(l, 2, this.length), this[l] | this[l + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(l, f) {
    return l = l >>> 0, f || T(l, 2, this.length), this[l] << 8 | this[l + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + this[l + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), this[l] * 16777216 + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
  }, u.prototype.readBigUInt64LE = He(function(l) {
    l = l >>> 0, ge(l, "offset");
    const f = this[l], v = this[l + 7];
    (f === void 0 || v === void 0) && ke(l, this.length - 8);
    const R = f + this[++l] * 2 ** 8 + this[++l] * 2 ** 16 + this[++l] * 2 ** 24, H = this[++l] + this[++l] * 2 ** 8 + this[++l] * 2 ** 16 + v * 2 ** 24;
    return BigInt(R) + (BigInt(H) << BigInt(32));
  }), u.prototype.readBigUInt64BE = He(function(l) {
    l = l >>> 0, ge(l, "offset");
    const f = this[l], v = this[l + 7];
    (f === void 0 || v === void 0) && ke(l, this.length - 8);
    const R = f * 2 ** 24 + this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + this[++l], H = this[++l] * 2 ** 24 + this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + v;
    return (BigInt(R) << BigInt(32)) + BigInt(H);
  }), u.prototype.readIntLE = function(l, f, v) {
    l = l >>> 0, f = f >>> 0, v || T(l, f, this.length);
    let R = this[l], H = 1, J = 0;
    for (; ++J < f && (H *= 256); )
      R += this[l + J] * H;
    return H *= 128, R >= H && (R -= Math.pow(2, 8 * f)), R;
  }, u.prototype.readIntBE = function(l, f, v) {
    l = l >>> 0, f = f >>> 0, v || T(l, f, this.length);
    let R = f, H = 1, J = this[l + --R];
    for (; R > 0 && (H *= 256); )
      J += this[l + --R] * H;
    return H *= 128, J >= H && (J -= Math.pow(2, 8 * f)), J;
  }, u.prototype.readInt8 = function(l, f) {
    return l = l >>> 0, f || T(l, 1, this.length), this[l] & 128 ? (255 - this[l] + 1) * -1 : this[l];
  }, u.prototype.readInt16LE = function(l, f) {
    l = l >>> 0, f || T(l, 2, this.length);
    const v = this[l] | this[l + 1] << 8;
    return v & 32768 ? v | 4294901760 : v;
  }, u.prototype.readInt16BE = function(l, f) {
    l = l >>> 0, f || T(l, 2, this.length);
    const v = this[l + 1] | this[l] << 8;
    return v & 32768 ? v | 4294901760 : v;
  }, u.prototype.readInt32LE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
  }, u.prototype.readInt32BE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
  }, u.prototype.readBigInt64LE = He(function(l) {
    l = l >>> 0, ge(l, "offset");
    const f = this[l], v = this[l + 7];
    (f === void 0 || v === void 0) && ke(l, this.length - 8);
    const R = this[l + 4] + this[l + 5] * 2 ** 8 + this[l + 6] * 2 ** 16 + (v << 24);
    return (BigInt(R) << BigInt(32)) + BigInt(f + this[++l] * 2 ** 8 + this[++l] * 2 ** 16 + this[++l] * 2 ** 24);
  }), u.prototype.readBigInt64BE = He(function(l) {
    l = l >>> 0, ge(l, "offset");
    const f = this[l], v = this[l + 7];
    (f === void 0 || v === void 0) && ke(l, this.length - 8);
    const R = (f << 24) + // Overflow
    this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + this[++l];
    return (BigInt(R) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + this[++l] * 2 ** 16 + this[++l] * 2 ** 8 + v);
  }), u.prototype.readFloatLE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), r.read(this, l, !0, 23, 4);
  }, u.prototype.readFloatBE = function(l, f) {
    return l = l >>> 0, f || T(l, 4, this.length), r.read(this, l, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(l, f) {
    return l = l >>> 0, f || T(l, 8, this.length), r.read(this, l, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(l, f) {
    return l = l >>> 0, f || T(l, 8, this.length), r.read(this, l, !1, 52, 8);
  };
  function K(g, l, f, v, R, H) {
    if (!u.isBuffer(g)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (l > R || l < H) throw new RangeError('"value" argument is out of bounds');
    if (f + v > g.length) throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(l, f, v, R) {
    if (l = +l, f = f >>> 0, v = v >>> 0, !R) {
      const me = Math.pow(2, 8 * v) - 1;
      K(this, l, f, v, me, 0);
    }
    let H = 1, J = 0;
    for (this[f] = l & 255; ++J < v && (H *= 256); )
      this[f + J] = l / H & 255;
    return f + v;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(l, f, v, R) {
    if (l = +l, f = f >>> 0, v = v >>> 0, !R) {
      const me = Math.pow(2, 8 * v) - 1;
      K(this, l, f, v, me, 0);
    }
    let H = v - 1, J = 1;
    for (this[f + H] = l & 255; --H >= 0 && (J *= 256); )
      this[f + H] = l / J & 255;
    return f + v;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 1, 255, 0), this[f] = l & 255, f + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 2, 65535, 0), this[f] = l & 255, this[f + 1] = l >>> 8, f + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 2, 65535, 0), this[f] = l >>> 8, this[f + 1] = l & 255, f + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 4, 4294967295, 0), this[f + 3] = l >>> 24, this[f + 2] = l >>> 16, this[f + 1] = l >>> 8, this[f] = l & 255, f + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 4, 4294967295, 0), this[f] = l >>> 24, this[f + 1] = l >>> 16, this[f + 2] = l >>> 8, this[f + 3] = l & 255, f + 4;
  };
  function W(g, l, f, v, R) {
    ve(l, v, R, g, f, 7);
    let H = Number(l & BigInt(4294967295));
    g[f++] = H, H = H >> 8, g[f++] = H, H = H >> 8, g[f++] = H, H = H >> 8, g[f++] = H;
    let J = Number(l >> BigInt(32) & BigInt(4294967295));
    return g[f++] = J, J = J >> 8, g[f++] = J, J = J >> 8, g[f++] = J, J = J >> 8, g[f++] = J, f;
  }
  function X(g, l, f, v, R) {
    ve(l, v, R, g, f, 7);
    let H = Number(l & BigInt(4294967295));
    g[f + 7] = H, H = H >> 8, g[f + 6] = H, H = H >> 8, g[f + 5] = H, H = H >> 8, g[f + 4] = H;
    let J = Number(l >> BigInt(32) & BigInt(4294967295));
    return g[f + 3] = J, J = J >> 8, g[f + 2] = J, J = J >> 8, g[f + 1] = J, J = J >> 8, g[f] = J, f + 8;
  }
  u.prototype.writeBigUInt64LE = He(function(l, f = 0) {
    return W(this, l, f, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = He(function(l, f = 0) {
    return X(this, l, f, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(l, f, v, R) {
    if (l = +l, f = f >>> 0, !R) {
      const Se = Math.pow(2, 8 * v - 1);
      K(this, l, f, v, Se - 1, -Se);
    }
    let H = 0, J = 1, me = 0;
    for (this[f] = l & 255; ++H < v && (J *= 256); )
      l < 0 && me === 0 && this[f + H - 1] !== 0 && (me = 1), this[f + H] = (l / J >> 0) - me & 255;
    return f + v;
  }, u.prototype.writeIntBE = function(l, f, v, R) {
    if (l = +l, f = f >>> 0, !R) {
      const Se = Math.pow(2, 8 * v - 1);
      K(this, l, f, v, Se - 1, -Se);
    }
    let H = v - 1, J = 1, me = 0;
    for (this[f + H] = l & 255; --H >= 0 && (J *= 256); )
      l < 0 && me === 0 && this[f + H + 1] !== 0 && (me = 1), this[f + H] = (l / J >> 0) - me & 255;
    return f + v;
  }, u.prototype.writeInt8 = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[f] = l & 255, f + 1;
  }, u.prototype.writeInt16LE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 2, 32767, -32768), this[f] = l & 255, this[f + 1] = l >>> 8, f + 2;
  }, u.prototype.writeInt16BE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 2, 32767, -32768), this[f] = l >>> 8, this[f + 1] = l & 255, f + 2;
  }, u.prototype.writeInt32LE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 4, 2147483647, -2147483648), this[f] = l & 255, this[f + 1] = l >>> 8, this[f + 2] = l >>> 16, this[f + 3] = l >>> 24, f + 4;
  }, u.prototype.writeInt32BE = function(l, f, v) {
    return l = +l, f = f >>> 0, v || K(this, l, f, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[f] = l >>> 24, this[f + 1] = l >>> 16, this[f + 2] = l >>> 8, this[f + 3] = l & 255, f + 4;
  }, u.prototype.writeBigInt64LE = He(function(l, f = 0) {
    return W(this, l, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = He(function(l, f = 0) {
    return X(this, l, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function re(g, l, f, v, R, H) {
    if (f + v > g.length) throw new RangeError("Index out of range");
    if (f < 0) throw new RangeError("Index out of range");
  }
  function Q(g, l, f, v, R) {
    return l = +l, f = f >>> 0, R || re(g, l, f, 4), r.write(g, l, f, v, 23, 4), f + 4;
  }
  u.prototype.writeFloatLE = function(l, f, v) {
    return Q(this, l, f, !0, v);
  }, u.prototype.writeFloatBE = function(l, f, v) {
    return Q(this, l, f, !1, v);
  };
  function ae(g, l, f, v, R) {
    return l = +l, f = f >>> 0, R || re(g, l, f, 8), r.write(g, l, f, v, 52, 8), f + 8;
  }
  u.prototype.writeDoubleLE = function(l, f, v) {
    return ae(this, l, f, !0, v);
  }, u.prototype.writeDoubleBE = function(l, f, v) {
    return ae(this, l, f, !1, v);
  }, u.prototype.copy = function(l, f, v, R) {
    if (!u.isBuffer(l)) throw new TypeError("argument should be a Buffer");
    if (v || (v = 0), !R && R !== 0 && (R = this.length), f >= l.length && (f = l.length), f || (f = 0), R > 0 && R < v && (R = v), R === v || l.length === 0 || this.length === 0) return 0;
    if (f < 0)
      throw new RangeError("targetStart out of bounds");
    if (v < 0 || v >= this.length) throw new RangeError("Index out of range");
    if (R < 0) throw new RangeError("sourceEnd out of bounds");
    R > this.length && (R = this.length), l.length - f < R - v && (R = l.length - f + v);
    const H = R - v;
    return this === l && typeof o.prototype.copyWithin == "function" ? this.copyWithin(f, v, R) : o.prototype.set.call(
      l,
      this.subarray(v, R),
      f
    ), H;
  }, u.prototype.fill = function(l, f, v, R) {
    if (typeof l == "string") {
      if (typeof f == "string" ? (R = f, f = 0, v = this.length) : typeof v == "string" && (R = v, v = this.length), R !== void 0 && typeof R != "string")
        throw new TypeError("encoding must be a string");
      if (typeof R == "string" && !u.isEncoding(R))
        throw new TypeError("Unknown encoding: " + R);
      if (l.length === 1) {
        const J = l.charCodeAt(0);
        (R === "utf8" && J < 128 || R === "latin1") && (l = J);
      }
    } else typeof l == "number" ? l = l & 255 : typeof l == "boolean" && (l = Number(l));
    if (f < 0 || this.length < f || this.length < v)
      throw new RangeError("Out of range index");
    if (v <= f)
      return this;
    f = f >>> 0, v = v === void 0 ? this.length : v >>> 0, l || (l = 0);
    let H;
    if (typeof l == "number")
      for (H = f; H < v; ++H)
        this[H] = l;
    else {
      const J = u.isBuffer(l) ? l : u.from(l, R), me = J.length;
      if (me === 0)
        throw new TypeError('The value "' + l + '" is invalid for argument "value"');
      for (H = 0; H < v - f; ++H)
        this[H + f] = J[H % me];
    }
    return this;
  };
  const ce = {};
  function ue(g, l, f) {
    ce[g] = class extends f {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: l.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${g}]`, this.stack, delete this.name;
      }
      get code() {
        return g;
      }
      set code(R) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: R,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${g}]: ${this.message}`;
      }
    };
  }
  ue(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(g) {
      return g ? `${g} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), ue(
    "ERR_INVALID_ARG_TYPE",
    function(g, l) {
      return `The "${g}" argument must be of type number. Received type ${typeof l}`;
    },
    TypeError
  ), ue(
    "ERR_OUT_OF_RANGE",
    function(g, l, f) {
      let v = `The value of "${g}" is out of range.`, R = f;
      return Number.isInteger(f) && Math.abs(f) > 2 ** 32 ? R = de(String(f)) : typeof f == "bigint" && (R = String(f), (f > BigInt(2) ** BigInt(32) || f < -(BigInt(2) ** BigInt(32))) && (R = de(R)), R += "n"), v += ` It must be ${l}. Received ${R}`, v;
    },
    RangeError
  );
  function de(g) {
    let l = "", f = g.length;
    const v = g[0] === "-" ? 1 : 0;
    for (; f >= v + 4; f -= 3)
      l = `_${g.slice(f - 3, f)}${l}`;
    return `${g.slice(0, f)}${l}`;
  }
  function pe(g, l, f) {
    ge(l, "offset"), (g[l] === void 0 || g[l + f] === void 0) && ke(l, g.length - (f + 1));
  }
  function ve(g, l, f, v, R, H) {
    if (g > f || g < l) {
      const J = typeof l == "bigint" ? "n" : "";
      let me;
      throw l === 0 || l === BigInt(0) ? me = `>= 0${J} and < 2${J} ** ${(H + 1) * 8}${J}` : me = `>= -(2${J} ** ${(H + 1) * 8 - 1}${J}) and < 2 ** ${(H + 1) * 8 - 1}${J}`, new ce.ERR_OUT_OF_RANGE("value", me, g);
    }
    pe(v, R, H);
  }
  function ge(g, l) {
    if (typeof g != "number")
      throw new ce.ERR_INVALID_ARG_TYPE(l, "number", g);
  }
  function ke(g, l, f) {
    throw Math.floor(g) !== g ? (ge(g, f), new ce.ERR_OUT_OF_RANGE("offset", "an integer", g)) : l < 0 ? new ce.ERR_BUFFER_OUT_OF_BOUNDS() : new ce.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${l}`,
      g
    );
  }
  const Le = /[^+/0-9A-Za-z-_]/g;
  function Y(g) {
    if (g = g.split("=")[0], g = g.trim().replace(Le, ""), g.length < 2) return "";
    for (; g.length % 4 !== 0; )
      g = g + "=";
    return g;
  }
  function Ne(g, l) {
    l = l || 1 / 0;
    let f;
    const v = g.length;
    let R = null;
    const H = [];
    for (let J = 0; J < v; ++J) {
      if (f = g.charCodeAt(J), f > 55295 && f < 57344) {
        if (!R) {
          if (f > 56319) {
            (l -= 3) > -1 && H.push(239, 191, 189);
            continue;
          } else if (J + 1 === v) {
            (l -= 3) > -1 && H.push(239, 191, 189);
            continue;
          }
          R = f;
          continue;
        }
        if (f < 56320) {
          (l -= 3) > -1 && H.push(239, 191, 189), R = f;
          continue;
        }
        f = (R - 55296 << 10 | f - 56320) + 65536;
      } else R && (l -= 3) > -1 && H.push(239, 191, 189);
      if (R = null, f < 128) {
        if ((l -= 1) < 0) break;
        H.push(f);
      } else if (f < 2048) {
        if ((l -= 2) < 0) break;
        H.push(
          f >> 6 | 192,
          f & 63 | 128
        );
      } else if (f < 65536) {
        if ((l -= 3) < 0) break;
        H.push(
          f >> 12 | 224,
          f >> 6 & 63 | 128,
          f & 63 | 128
        );
      } else if (f < 1114112) {
        if ((l -= 4) < 0) break;
        H.push(
          f >> 18 | 240,
          f >> 12 & 63 | 128,
          f >> 6 & 63 | 128,
          f & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return H;
  }
  function se(g) {
    const l = [];
    for (let f = 0; f < g.length; ++f)
      l.push(g.charCodeAt(f) & 255);
    return l;
  }
  function he(g, l) {
    let f, v, R;
    const H = [];
    for (let J = 0; J < g.length && !((l -= 2) < 0); ++J)
      f = g.charCodeAt(J), v = f >> 8, R = f % 256, H.push(R), H.push(v);
    return H;
  }
  function be(g) {
    return t.toByteArray(Y(g));
  }
  function Be(g, l, f, v) {
    let R;
    for (R = 0; R < v && !(R + f >= l.length || R >= g.length); ++R)
      l[R + f] = g[R];
    return R;
  }
  function Oe(g, l) {
    return g instanceof l || g != null && g.constructor != null && g.constructor.name != null && g.constructor.name === l.name;
  }
  function ar(g) {
    return g !== g;
  }
  const Sr = (function() {
    const g = "0123456789abcdef", l = new Array(256);
    for (let f = 0; f < 16; ++f) {
      const v = f * 16;
      for (let R = 0; R < 16; ++R)
        l[v + R] = g[f] + g[R];
    }
    return l;
  })();
  function He(g) {
    return typeof BigInt > "u" ? ur : g;
  }
  function ur() {
    throw new Error("BigInt not supported");
  }
})(Xf);
const dr = Xf.Buffer;
var or = {}, Ze = {};
const fm = /* @__PURE__ */ JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]'), dm = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]'), hm = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]'), pm = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]'), gm = /* @__PURE__ */ JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","academie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquerir","acronyme","acteur","actif","actuel","adepte","adequat","adhesif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aerer","aeronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agreable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algebre","algue","aliener","aliment","alleger","alliage","allouer","allumer","alourdir","alpaga","altesse","alveole","amateur","ambigu","ambre","amenager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","aneantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","aperitif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","arteriel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","banniere","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","belier","belote","benefice","berceau","berger","berline","bermuda","besace","besogne","betail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","breche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","cafeine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","camera","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cedille","ceinture","celeste","cellule","cendrier","censurer","central","cercle","cerebral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chequier","chercher","cheval","chien","chiffre","chignon","chimere","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinema","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohesion","coiffer","coincer","colere","colibri","colline","colmater","colonel","combat","comedie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortege","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","creature","crediter","cremeux","creuser","crevette","cribler","crier","cristal","critere","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillere","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","debattre","debiter","deborder","debrider","debutant","decaler","decembre","dechirer","decider","declarer","decorer","decrire","decupler","dedale","deductif","deesse","defensif","defiler","defrayer","degager","degivrer","deglutir","degrafer","dejeuner","delice","deloger","demander","demeurer","demolir","denicher","denouer","dentelle","denuder","depart","depenser","dephaser","deplacer","deposer","deranger","derober","desastre","descente","desert","designer","desobeir","dessiner","destrier","detacher","detester","detourer","detresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","differer","digerer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","eblouir","ecarter","echarpe","echelle","eclairer","eclipse","eclore","ecluse","ecole","economie","ecorce","ecouter","ecraser","ecremer","ecrivain","ecrou","ecume","ecureuil","edifier","eduquer","effacer","effectif","effigie","effort","effrayer","effusion","egaliser","egarer","ejecter","elaborer","elargir","electron","elegant","elephant","eleve","eligible","elitisme","eloge","elucider","eluder","emballer","embellir","embryon","emeraude","emission","emmener","emotion","emouvoir","empereur","employer","emporter","emprise","emulsion","encadrer","enchere","enclave","encoche","endiguer","endosser","endroit","enduire","energie","enfance","enfermer","enfouir","engager","engin","englober","enigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","enumerer","envahir","enviable","envoyer","enzyme","eolien","epaissir","epargne","epatant","epaule","epicerie","epidemie","epier","epilogue","epine","episode","epitaphe","epoque","epreuve","eprouver","epuisant","equerre","equipe","eriger","erosion","erreur","eruption","escalier","espadon","espece","espiegle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","etagere","etaler","etanche","etatique","eteindre","etendoir","eternel","ethanol","ethique","ethnie","etirer","etoffer","etoile","etonnant","etourdir","etrange","etroit","etude","euphorie","evaluer","evasion","eventail","evidence","eviter","evolutif","evoquer","exact","exagerer","exaucer","exceller","excitant","exclusif","excuse","executer","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expedier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","febrile","feconder","federer","felin","femme","femur","fendoir","feodal","fermer","feroce","ferveur","festival","feuille","feutre","fevrier","fiasco","ficeler","fictif","fidele","figure","filature","filetage","filiere","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fleau","fleche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougere","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","fregate","freiner","frelon","fremir","frenesie","frere","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","geant","gelatine","gelule","gendarme","general","genie","genou","gentil","geologie","geometre","geranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyere","guepard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","helium","hematome","herbe","herisson","hermine","heron","hesiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogene","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiene","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","imperial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inedit","ineptie","inexact","infini","infliger","informer","infusion","ingerer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irreel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvenile","kayak","kimono","kiosque","label","labial","labourer","lacerer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","legal","leger","legume","lessive","lettre","levier","lexique","lezard","liasse","liberer","libre","licence","licorne","liege","lievre","ligature","ligoter","ligue","limer","limite","limonade","limpide","lineaire","lingot","lionceau","liquide","lisiere","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumiere","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","malefice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","materiel","matiere","matraque","maudire","maussade","mauve","maximal","mechant","meconnu","medaille","medecin","mediter","meduse","meilleur","melange","melodie","membre","memoire","menacer","mener","menhir","mensonge","mentor","mercredi","merite","merle","messager","mesure","metal","meteore","methode","metier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","mineral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murene","murmure","muscle","museum","musicien","mutation","muter","mutuel","myriade","myrtille","mystere","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nebuleux","nectar","nefaste","negation","negliger","negocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numero","nuptial","nuque","nutritif","obeir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","ocean","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onereux","onirique","opale","opaque","operer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygene","ozone","paisible","palace","palmares","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pasteque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pelican","pelle","pelouse","peluche","pendule","penetrer","penible","pensif","penurie","pepite","peplum","perdrix","perforer","periode","permuter","perplexe","persil","perte","peser","petale","petit","petrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","piece","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poesie","poete","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","ponderer","poney","portique","position","posseder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","precieux","predire","prefixe","prelude","prenom","presence","pretexte","prevoir","primitif","prince","prison","priver","probleme","proceder","prodige","profond","progres","proie","projeter","prologue","promener","propre","prospere","proteger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quietude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","reactif","reagir","realiser","reanimer","recevoir","reciter","reclamer","recolter","recruter","reculer","recycler","rediger","redouter","refaire","reflexe","reformer","refrain","refuge","regalien","region","reglage","regulier","reiterer","rejeter","rejouer","relatif","relever","relief","remarque","remede","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","reserve","resineux","resoudre","respect","rester","resultat","retablir","retenir","reticule","retomber","retracer","reunion","reussir","revanche","revivre","revolte","revulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","riviere","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scelerat","scenario","sceptre","schema","science","scinder","score","scrutin","sculpter","seance","secable","secher","secouer","secreter","sedatif","seduire","seigneur","sejour","selectif","semaine","sembler","semence","seminal","senateur","sensible","sentence","separer","sequence","serein","sergent","serieux","serrure","serum","service","sesame","sevir","sevrage","sextuple","sideral","siecle","sieger","siffler","sigle","signal","silence","silicium","simple","sincere","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","special","sphere","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succes","sucre","suffixe","suggerer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symetrie","synapse","syntaxe","systeme","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","temoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tetine","texte","theme","theorie","therapie","thorax","tibia","tiede","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolerant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trefle","tremper","tresor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","vegetal","vehicule","veinard","veloce","vendredi","venerer","venger","venimeux","ventouse","verdure","verin","vernir","verrou","verser","vertu","veston","veteran","vetuste","vexant","vexer","viaduc","viande","victoire","vidange","video","vignette","vigueur","vilain","village","vinaigre","violon","vipere","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xenon","yacht","zebre","zenith","zeste","zoologie"]'), bm = /* @__PURE__ */ JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]'), mm = /* @__PURE__ */ JSON.parse('["abaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","accion","aceite","acelga","acento","aceptar","acido","aclarar","acne","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aereo","afectar","aficion","afinar","afirmar","agil","agitar","agonia","agosto","agotar","agregar","agrio","agua","agudo","aguila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacran","alambre","alarma","alba","album","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodon","aliado","aliento","alivio","alma","almeja","almibar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ambar","ambito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","anden","anemia","angulo","anillo","animo","anis","anotar","antena","antiguo","antojo","anual","anular","anuncio","anadir","anejo","ano","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","arana","arar","arbitro","arbol","arbusto","archivo","arco","arder","ardilla","arduo","area","arido","aries","armonia","arnes","aroma","arpa","arpon","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","aspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","atico","atleta","atomo","atraer","atroz","atun","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avion","aviso","ayer","ayuda","ayuno","azafran","azar","azote","azucar","azufre","azul","baba","babor","bache","bahia","baile","bajar","balanza","balcon","balde","bambu","banco","banda","bano","barba","barco","barniz","barro","bascula","baston","basura","batalla","bateria","batir","batuta","baul","bazar","bebe","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsai","borde","borrar","bosque","bote","botin","boveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufon","buho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzon","caballo","cabeza","cabina","cabra","cacao","cadaver","cadena","caer","cafe","caida","caiman","caja","cajon","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cancer","candil","canela","canguro","canica","canto","cana","canon","caoba","caos","capaz","capitan","capote","captar","capucha","cara","carbon","carcel","careta","carga","carino","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","celebre","celoso","celula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","cesped","cetro","chacal","chaleco","champu","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclon","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","cipres","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clinica","cobre","coccion","cochino","cocina","coco","codigo","codo","cofre","coger","cohete","cojin","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","comodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazon","corbata","corcho","cordon","corona","correr","coser","cosmos","costa","craneo","crater","crear","crecer","creido","crema","cria","crimen","cripta","crisis","cromo","cronica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupon","cupula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","datil","deber","debil","decada","decir","dedo","defensa","definir","dejar","delfin","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvio","detalle","detener","deuda","dia","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","dificil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseno","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragon","droga","ducha","duda","duelo","dueno","dulce","duo","duque","durar","dureza","duro","ebano","ebrio","echar","eco","ecuador","edad","edicion","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","elite","elixir","elogio","eludir","embudo","emitir","emocion","empate","empeno","empleo","empresa","enano","encargo","enchufe","encia","enemigo","enero","enfado","enfermo","engano","enigma","enlace","enorme","enredo","ensayo","ensenar","entero","entrar","envase","envio","epoca","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espia","esposa","espuma","esqui","estar","este","estilo","estufa","etapa","eterno","etica","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","exito","experto","explicar","exponer","extremo","fabrica","fabula","fachada","facil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraon","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fertil","fervor","festin","fiable","fianza","fiar","fibra","ficcion","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","fluor","fobia","foca","fogata","fogon","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","fragil","franja","frase","fraude","freir","freno","fresa","frio","frito","fruta","fuego","fuente","fuerza","fuga","fumar","funcion","funda","furgon","furia","fusil","futbol","futuro","gacela","gafas","gaita","gajo","gala","galeria","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilan","gemelo","gemir","gen","genero","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","grafico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grua","grueso","grumo","grupo","guante","guapo","guardia","guerra","guia","guino","guion","guiso","guitarra","gusano","gustar","haber","habil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazana","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","heroe","hervir","hielo","hierro","higado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","humedo","humilde","humo","hundir","huracan","hurto","icono","ideal","idioma","idolo","iglesia","iglu","igual","ilegal","ilusion","imagen","iman","imitar","impar","imperio","imponer","impulso","incapaz","indice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interes","intimo","intuir","inutil","invierno","ira","iris","ironia","isla","islote","jabali","jabon","jamon","jarabe","jardin","jarra","jaula","jazmin","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","jupiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladron","lagarto","lagrima","laguna","laico","lamer","lamina","lampara","lana","lancha","langosta","lanza","lapiz","largo","larva","lastima","lata","latex","latir","laurel","lavar","lazo","leal","leccion","leche","lector","leer","legion","legumbre","lejano","lengua","lento","lena","leon","leopardo","lesion","letal","letra","leve","leyenda","libertad","libro","licor","lider","lidiar","lienzo","liga","ligero","lima","limite","limon","limpio","lince","lindo","linea","lingote","lino","linterna","liquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","locion","loco","locura","logica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maiz","maldad","maleta","malla","malo","mama","mambo","mamut","manco","mando","manejar","manga","maniqui","manjar","mano","manso","manta","manana","mapa","maquina","mar","marco","marea","marfil","margen","marido","marmol","marron","martes","marzo","masa","mascara","masivo","matar","materia","matiz","matriz","maximo","mayor","mazorca","mecha","medalla","medio","medula","mejilla","mejor","melena","melon","memoria","menor","mensaje","mente","menu","mercado","merengue","merito","mes","meson","meta","meter","metodo","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millon","mimo","mina","minero","minimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","mocion","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","mono","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","movil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muneca","mural","muro","musculo","museo","musgo","musica","muslo","nacar","nacion","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","nausea","naval","nave","navidad","necio","nectar","negar","negocio","negro","neon","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","ninez","nino","nitido","nivel","nobleza","noche","nomina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","nucleo","nudillo","nudo","nuera","nueve","nuez","nulo","numero","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","oceano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oido","oir","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opcion","opera","opinar","oponer","optar","optica","opuesto","oracion","orador","oral","orbita","orca","orden","oreja","organo","orgia","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadia","oscuro","osezno","oso","ostra","otono","otro","oveja","ovulo","oxido","oxigeno","oyente","ozono","pacto","padre","paella","pagina","pago","pais","pajaro","palabra","palco","paleta","palido","palma","paloma","palpar","pan","panal","panico","pantera","panuelo","papa","papel","papilla","paquete","parar","parcela","pared","parir","paro","parpado","parque","parrafo","parte","pasar","paseo","pasion","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peaton","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldano","pelea","peligro","pellejo","pelo","peluca","pena","pensar","penon","peon","peor","pepino","pequeno","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pesimo","pestana","petalo","petroleo","pez","pezuna","picar","pichon","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","pina","piojo","pipa","pirata","pisar","piscina","piso","pista","piton","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesia","poeta","polen","policia","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porcion","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","principe","prision","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","proximo","prueba","publico","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmon","pulpo","pulso","puma","punto","punal","puno","pupa","pupila","pure","quedar","queja","quemar","querer","queso","quieto","quimica","quince","quitar","rabano","rabia","rabo","racion","radical","raiz","rama","rampa","rancho","rango","rapaz","rapido","rapto","rasgo","raspa","rato","rayo","raza","razon","reaccion","realidad","rebano","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refran","refugio","regalo","regir","regla","regreso","rehen","reino","reir","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","reves","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rigido","rigor","rincon","rinon","rio","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubi","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sabado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmon","salon","salsa","salto","salud","salvar","samba","sancion","sandia","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sarten","sastre","satan","sauna","saxofon","seccion","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","senal","senor","separar","sepia","sequia","ser","serie","sermon","servir","sesenta","sesion","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","silaba","silbar","silencio","silla","simbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","solido","soltar","solucion","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sosten","sotano","suave","subir","suceso","sudor","suegra","suelo","sueno","suerte","sufrir","sujeto","sultan","sumar","superar","suplir","suponer","supremo","sur","surco","sureno","surgir","susto","sutil","tabaco","tabique","tabla","tabu","taco","tacto","tajo","talar","talco","talento","talla","talon","tamano","tambor","tango","tanque","tapa","tapete","tapia","tapon","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazon","teatro","techo","tecla","tecnica","tejado","tejer","tejido","tela","telefono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoria","terapia","terco","termino","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburon","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","timido","timo","tinta","tio","tipico","tipo","tira","tiron","titan","titere","titulo","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","torax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","toxico","trabajo","tractor","traer","trafico","trago","traje","tramo","trance","trato","trauma","trazar","trebol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tuberia","tubo","tuerto","tumba","tumor","tunel","tunica","turbina","turismo","turno","tutor","ubicar","ulcera","umbral","unidad","unir","universo","uno","untar","una","urbano","urbe","urgente","urna","usar","usuario","util","utopia","uva","vaca","vacio","vacuna","vagar","vago","vaina","vajilla","vale","valido","valle","valor","valvula","vampiro","vara","variar","varon","vaso","vecino","vector","vehiculo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","via","viaje","vibrar","vicio","victima","vida","video","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","vinedo","violin","viral","virgo","virtud","visor","vispera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcan","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]'), ym = /* @__PURE__ */ JSON.parse('["","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""]'), vm = /* @__PURE__ */ JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]'), wm = /* @__PURE__ */ JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]');
var Fl;
function $l() {
  if (Fl) return Ze;
  Fl = 1, Object.defineProperty(Ze, "__esModule", { value: !0 });
  const e = {};
  Ze.wordlists = e;
  let t;
  Ze._default = t;
  try {
    Ze._default = t = fm, e.czech = t;
  } catch {
  }
  try {
    Ze._default = t = dm, e.chinese_simplified = t;
  } catch {
  }
  try {
    Ze._default = t = hm, e.chinese_traditional = t;
  } catch {
  }
  try {
    Ze._default = t = pm, e.korean = t;
  } catch {
  }
  try {
    Ze._default = t = gm, e.french = t;
  } catch {
  }
  try {
    Ze._default = t = bm, e.italian = t;
  } catch {
  }
  try {
    Ze._default = t = mm, e.spanish = t;
  } catch {
  }
  try {
    Ze._default = t = ym, e.japanese = t, e.JA = t;
  } catch {
  }
  try {
    Ze._default = t = vm, e.portuguese = t;
  } catch {
  }
  try {
    Ze._default = t = wm, e.english = t, e.EN = t;
  } catch {
  }
  return Ze;
}
var Kl;
function _m() {
  if (Kl) return or;
  Kl = 1, Object.defineProperty(or, "__esModule", { value: !0 });
  const e = /* @__PURE__ */ Ad(), t = /* @__PURE__ */ xd(), r = /* @__PURE__ */ Ed(), a = /* @__PURE__ */ Bd(), i = $l();
  let o = i._default;
  const s = "Invalid mnemonic", n = "Invalid entropy", p = "Invalid mnemonic checksum", d = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
  function u(S) {
    return (S || "").normalize("NFKD");
  }
  function w(S, D, $) {
    for (; S.length < $; )
      S = D + S;
    return S;
  }
  function y(S) {
    return parseInt(S, 2);
  }
  function k(S) {
    return S.map((D) => w(D.toString(2), "0", 8)).join("");
  }
  function A(S) {
    const $ = S.length * 8 / 32, m = e.sha256(Uint8Array.from(S));
    return k(Array.from(m)).slice(0, $);
  }
  function E(S) {
    return "mnemonic" + (S || "");
  }
  function x(S, D) {
    const $ = Uint8Array.from(dr.from(u(S), "utf8")), m = Uint8Array.from(dr.from(E(u(D)), "utf8")), U = r.pbkdf2(t.sha512, $, m, {
      c: 2048,
      dkLen: 64
    });
    return dr.from(U);
  }
  or.mnemonicToSeedSync = x;
  function I(S, D) {
    const $ = Uint8Array.from(dr.from(u(S), "utf8")), m = Uint8Array.from(dr.from(E(u(D)), "utf8"));
    return r.pbkdf2Async(t.sha512, $, m, {
      c: 2048,
      dkLen: 64
    }).then((U) => dr.from(U));
  }
  or.mnemonicToSeed = I;
  function B(S, D) {
    if (D = D || o, !D)
      throw new Error(d);
    const $ = u(S).split(" ");
    if ($.length % 3 !== 0)
      throw new Error(s);
    const m = $.map((oe) => {
      const ne = D.indexOf(oe);
      if (ne === -1)
        throw new Error(s);
      return w(ne.toString(2), "0", 11);
    }).join(""), U = Math.floor(m.length / 33) * 32, C = m.slice(0, U), M = m.slice(U), V = C.match(/(.{1,8})/g).map(y);
    if (V.length < 16)
      throw new Error(n);
    if (V.length > 32)
      throw new Error(n);
    if (V.length % 4 !== 0)
      throw new Error(n);
    const te = dr.from(V);
    if (A(te) !== M)
      throw new Error(p);
    return te.toString("hex");
  }
  or.mnemonicToEntropy = B;
  function z(S, D) {
    if (dr.isBuffer(S) || (S = dr.from(S, "hex")), D = D || o, !D)
      throw new Error(d);
    if (S.length < 16)
      throw new TypeError(n);
    if (S.length > 32)
      throw new TypeError(n);
    if (S.length % 4 !== 0)
      throw new TypeError(n);
    const $ = k(Array.from(S)), m = A(S), M = ($ + m).match(/(.{1,11})/g).map((V) => {
      const te = y(V);
      return D[te];
    });
    return D[0] === "" ? M.join("") : M.join(" ");
  }
  or.entropyToMnemonic = z;
  function O(S, D, $) {
    if (S = S || 128, S % 32 !== 0)
      throw new TypeError(n);
    return D = D || ((m) => dr.from(a.randomBytes(m))), z(D(S / 8), $);
  }
  or.generateMnemonic = O;
  function F(S, D) {
    try {
      B(S, D);
    } catch {
      return !1;
    }
    return !0;
  }
  or.validateMnemonic = F;
  function N(S) {
    const D = i.wordlists[S];
    if (D)
      o = D;
    else
      throw new Error('Could not find wordlist for language "' + S + '"');
  }
  or.setDefaultWordlist = N;
  function j() {
    if (!o)
      throw new Error("No Default Wordlist set");
    return Object.keys(i.wordlists).filter((S) => S === "JA" || S === "EN" ? !1 : i.wordlists[S].every((D, $) => D === o[$]))[0];
  }
  or.getDefaultWordlist = j;
  var q = $l();
  return or.wordlists = q.wordlists, or;
}
var Ay = _m(), Yi = { exports: {} }, Ra = { exports: {} };
function km(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Qf = { exports: {} }, Me = Qf.exports = {}, _r, kr;
function qn() {
  throw new Error("setTimeout has not been defined");
}
function Dn() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? _r = setTimeout : _r = qn;
  } catch {
    _r = qn;
  }
  try {
    typeof clearTimeout == "function" ? kr = clearTimeout : kr = Dn;
  } catch {
    kr = Dn;
  }
})();
function ed(e) {
  if (_r === setTimeout)
    return setTimeout(e, 0);
  if ((_r === qn || !_r) && setTimeout)
    return _r = setTimeout, setTimeout(e, 0);
  try {
    return _r(e, 0);
  } catch {
    try {
      return _r.call(null, e, 0);
    } catch {
      return _r.call(this, e, 0);
    }
  }
}
function Em(e) {
  if (kr === clearTimeout)
    return clearTimeout(e);
  if ((kr === Dn || !kr) && clearTimeout)
    return kr = clearTimeout, clearTimeout(e);
  try {
    return kr(e);
  } catch {
    try {
      return kr.call(null, e);
    } catch {
      return kr.call(this, e);
    }
  }
}
var Nr = [], jt = !1, dt, Ga = -1;
function xm() {
  !jt || !dt || (jt = !1, dt.length ? Nr = dt.concat(Nr) : Ga = -1, Nr.length && rd());
}
function rd() {
  if (!jt) {
    var e = ed(xm);
    jt = !0;
    for (var t = Nr.length; t; ) {
      for (dt = Nr, Nr = []; ++Ga < t; )
        dt && dt[Ga].run();
      Ga = -1, t = Nr.length;
    }
    dt = null, jt = !1, Em(e);
  }
}
Me.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  Nr.push(new td(e, t)), Nr.length === 1 && !jt && ed(rd);
};
function td(e, t) {
  this.fun = e, this.array = t;
}
td.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Me.title = "browser";
Me.browser = !0;
Me.env = {};
Me.argv = [];
Me.version = "";
Me.versions = {};
function qr() {
}
Me.on = qr;
Me.addListener = qr;
Me.once = qr;
Me.off = qr;
Me.removeListener = qr;
Me.removeAllListeners = qr;
Me.emit = qr;
Me.prependListener = qr;
Me.prependOnceListener = qr;
Me.listeners = function(e) {
  return [];
};
Me.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Me.cwd = function() {
  return "/";
};
Me.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Me.umask = function() {
  return 0;
};
var Am = Qf.exports;
const vr = /* @__PURE__ */ km(Am);
var Xi = {}, Ji = {}, Qi, Hl;
function ad() {
  return Hl || (Hl = 1, Qi = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, r = /* @__PURE__ */ Symbol("test"), a = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(a) !== "[object Symbol]")
      return !1;
    var i = 42;
    t[r] = i;
    for (var o in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var s = Object.getOwnPropertySymbols(t);
    if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var n = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, r)
      );
      if (n.value !== i || n.enumerable !== !0)
        return !1;
    }
    return !0;
  }), Qi;
}
var eo, Zl;
function _i() {
  if (Zl) return eo;
  Zl = 1;
  var e = ad();
  return eo = function() {
    return e() && !!Symbol.toStringTag;
  }, eo;
}
var ro, Gl;
function id() {
  return Gl || (Gl = 1, ro = Object), ro;
}
var to, Vl;
function Bm() {
  return Vl || (Vl = 1, to = Error), to;
}
var ao, Wl;
function zm() {
  return Wl || (Wl = 1, ao = EvalError), ao;
}
var io, Yl;
function Sm() {
  return Yl || (Yl = 1, io = RangeError), io;
}
var oo, Xl;
function Im() {
  return Xl || (Xl = 1, oo = ReferenceError), oo;
}
var no, Jl;
function od() {
  return Jl || (Jl = 1, no = SyntaxError), no;
}
var so, Ql;
function Mt() {
  return Ql || (Ql = 1, so = TypeError), so;
}
var lo, ec;
function Tm() {
  return ec || (ec = 1, lo = URIError), lo;
}
var co, rc;
function jm() {
  return rc || (rc = 1, co = Math.abs), co;
}
var uo, tc;
function Om() {
  return tc || (tc = 1, uo = Math.floor), uo;
}
var fo, ac;
function Rm() {
  return ac || (ac = 1, fo = Math.max), fo;
}
var ho, ic;
function Pm() {
  return ic || (ic = 1, ho = Math.min), ho;
}
var po, oc;
function Um() {
  return oc || (oc = 1, po = Math.pow), po;
}
var go, nc;
function Cm() {
  return nc || (nc = 1, go = Math.round), go;
}
var bo, sc;
function Lm() {
  return sc || (sc = 1, bo = Number.isNaN || function(t) {
    return t !== t;
  }), bo;
}
var mo, lc;
function Nm() {
  if (lc) return mo;
  lc = 1;
  var e = /* @__PURE__ */ Lm();
  return mo = function(r) {
    return e(r) || r === 0 ? r : r < 0 ? -1 : 1;
  }, mo;
}
var yo, cc;
function qm() {
  return cc || (cc = 1, yo = Object.getOwnPropertyDescriptor), yo;
}
var vo, uc;
function Ft() {
  if (uc) return vo;
  uc = 1;
  var e = /* @__PURE__ */ qm();
  if (e)
    try {
      e([], "length");
    } catch {
      e = null;
    }
  return vo = e, vo;
}
var wo, fc;
function ki() {
  if (fc) return wo;
  fc = 1;
  var e = Object.defineProperty || !1;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch {
      e = !1;
    }
  return wo = e, wo;
}
var _o, dc;
function Dm() {
  if (dc) return _o;
  dc = 1;
  var e = typeof Symbol < "u" && Symbol, t = ad();
  return _o = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof /* @__PURE__ */ Symbol("bar") != "symbol" ? !1 : t();
  }, _o;
}
var ko, hc;
function nd() {
  return hc || (hc = 1, ko = typeof Reflect < "u" && Reflect.getPrototypeOf || null), ko;
}
var Eo, pc;
function sd() {
  if (pc) return Eo;
  pc = 1;
  var e = /* @__PURE__ */ id();
  return Eo = e.getPrototypeOf || null, Eo;
}
var xo, gc;
function Mm() {
  if (gc) return xo;
  gc = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, r = Math.max, a = "[object Function]", i = function(p, d) {
    for (var u = [], w = 0; w < p.length; w += 1)
      u[w] = p[w];
    for (var y = 0; y < d.length; y += 1)
      u[y + p.length] = d[y];
    return u;
  }, o = function(p, d) {
    for (var u = [], w = d, y = 0; w < p.length; w += 1, y += 1)
      u[y] = p[w];
    return u;
  }, s = function(n, p) {
    for (var d = "", u = 0; u < n.length; u += 1)
      d += n[u], u + 1 < n.length && (d += p);
    return d;
  };
  return xo = function(p) {
    var d = this;
    if (typeof d != "function" || t.apply(d) !== a)
      throw new TypeError(e + d);
    for (var u = o(arguments, 1), w, y = function() {
      if (this instanceof w) {
        var I = d.apply(
          this,
          i(u, arguments)
        );
        return Object(I) === I ? I : this;
      }
      return d.apply(
        p,
        i(u, arguments)
      );
    }, k = r(0, d.length - u.length), A = [], E = 0; E < k; E++)
      A[E] = "$" + E;
    if (w = Function("binder", "return function (" + s(A, ",") + "){ return binder.apply(this,arguments); }")(y), d.prototype) {
      var x = function() {
      };
      x.prototype = d.prototype, w.prototype = new x(), x.prototype = null;
    }
    return w;
  }, xo;
}
var Ao, bc;
function ka() {
  if (bc) return Ao;
  bc = 1;
  var e = Mm();
  return Ao = Function.prototype.bind || e, Ao;
}
var Bo, mc;
function ps() {
  return mc || (mc = 1, Bo = Function.prototype.call), Bo;
}
var zo, yc;
function gs() {
  return yc || (yc = 1, zo = Function.prototype.apply), zo;
}
var So, vc;
function Fm() {
  return vc || (vc = 1, So = typeof Reflect < "u" && Reflect && Reflect.apply), So;
}
var Io, wc;
function ld() {
  if (wc) return Io;
  wc = 1;
  var e = ka(), t = gs(), r = ps(), a = Fm();
  return Io = a || e.call(r, t), Io;
}
var To, _c;
function bs() {
  if (_c) return To;
  _c = 1;
  var e = ka(), t = /* @__PURE__ */ Mt(), r = ps(), a = ld();
  return To = function(o) {
    if (o.length < 1 || typeof o[0] != "function")
      throw new t("a function is required");
    return a(e, r, o);
  }, To;
}
var jo, kc;
function $m() {
  if (kc) return jo;
  kc = 1;
  var e = bs(), t = /* @__PURE__ */ Ft(), r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (s) {
    if (!s || typeof s != "object" || !("code" in s) || s.code !== "ERR_PROTO_ACCESS")
      throw s;
  }
  var a = !!r && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, o = i.getPrototypeOf;
  return jo = a && typeof a.get == "function" ? e([a.get]) : typeof o == "function" ? (
    /** @type {import('./get')} */
    function(n) {
      return o(n == null ? n : i(n));
    }
  ) : !1, jo;
}
var Oo, Ec;
function ms() {
  if (Ec) return Oo;
  Ec = 1;
  var e = nd(), t = sd(), r = /* @__PURE__ */ $m();
  return Oo = e ? function(i) {
    return e(i);
  } : t ? function(i) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new TypeError("getProto: not an object");
    return t(i);
  } : r ? function(i) {
    return r(i);
  } : null, Oo;
}
var Ro, xc;
function cd() {
  if (xc) return Ro;
  xc = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = ka();
  return Ro = r.call(e, t), Ro;
}
var Po, Ac;
function ud() {
  if (Ac) return Po;
  Ac = 1;
  var e, t = /* @__PURE__ */ id(), r = /* @__PURE__ */ Bm(), a = /* @__PURE__ */ zm(), i = /* @__PURE__ */ Sm(), o = /* @__PURE__ */ Im(), s = /* @__PURE__ */ od(), n = /* @__PURE__ */ Mt(), p = /* @__PURE__ */ Tm(), d = /* @__PURE__ */ jm(), u = /* @__PURE__ */ Om(), w = /* @__PURE__ */ Rm(), y = /* @__PURE__ */ Pm(), k = /* @__PURE__ */ Um(), A = /* @__PURE__ */ Cm(), E = /* @__PURE__ */ Nm(), x = Function, I = function(Q) {
    try {
      return x('"use strict"; return (' + Q + ").constructor;")();
    } catch {
    }
  }, B = /* @__PURE__ */ Ft(), z = /* @__PURE__ */ ki(), O = function() {
    throw new n();
  }, F = B ? (function() {
    try {
      return arguments.callee, O;
    } catch {
      try {
        return B(arguments, "callee").get;
      } catch {
        return O;
      }
    }
  })() : O, N = Dm()(), j = ms(), q = sd(), S = nd(), D = gs(), $ = ps(), m = {}, U = typeof Uint8Array > "u" || !j ? e : j(Uint8Array), C = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": N && j ? j([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": m,
    "%AsyncGenerator%": m,
    "%AsyncGeneratorFunction%": m,
    "%AsyncIteratorPrototype%": m,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": r,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": a,
    "%Float16Array%": typeof Float16Array > "u" ? e : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": x,
    "%GeneratorFunction%": m,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": N && j ? j(j([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !N || !j ? e : j((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": t,
    "%Object.getOwnPropertyDescriptor%": B,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": i,
    "%ReferenceError%": o,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !N || !j ? e : j((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": N && j ? j(""[Symbol.iterator]()) : e,
    "%Symbol%": N ? Symbol : e,
    "%SyntaxError%": s,
    "%ThrowTypeError%": F,
    "%TypedArray%": U,
    "%TypeError%": n,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": p,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet,
    "%Function.prototype.call%": $,
    "%Function.prototype.apply%": D,
    "%Object.defineProperty%": z,
    "%Object.getPrototypeOf%": q,
    "%Math.abs%": d,
    "%Math.floor%": u,
    "%Math.max%": w,
    "%Math.min%": y,
    "%Math.pow%": k,
    "%Math.round%": A,
    "%Math.sign%": E,
    "%Reflect.getPrototypeOf%": S
  };
  if (j)
    try {
      null.error;
    } catch (Q) {
      var M = j(j(Q));
      C["%Error.prototype%"] = M;
    }
  var V = function Q(ae) {
    var ce;
    if (ae === "%AsyncFunction%")
      ce = I("async function () {}");
    else if (ae === "%GeneratorFunction%")
      ce = I("function* () {}");
    else if (ae === "%AsyncGeneratorFunction%")
      ce = I("async function* () {}");
    else if (ae === "%AsyncGenerator%") {
      var ue = Q("%AsyncGeneratorFunction%");
      ue && (ce = ue.prototype);
    } else if (ae === "%AsyncIteratorPrototype%") {
      var de = Q("%AsyncGenerator%");
      de && j && (ce = j(de.prototype));
    }
    return C[ae] = ce, ce;
  }, te = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, ie = ka(), oe = /* @__PURE__ */ cd(), ne = ie.call($, Array.prototype.concat), le = ie.call(D, Array.prototype.splice), P = ie.call($, String.prototype.replace), Z = ie.call($, String.prototype.slice), T = ie.call($, RegExp.prototype.exec), K = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, W = /\\(\\)?/g, X = function(ae) {
    var ce = Z(ae, 0, 1), ue = Z(ae, -1);
    if (ce === "%" && ue !== "%")
      throw new s("invalid intrinsic syntax, expected closing `%`");
    if (ue === "%" && ce !== "%")
      throw new s("invalid intrinsic syntax, expected opening `%`");
    var de = [];
    return P(ae, K, function(pe, ve, ge, ke) {
      de[de.length] = ge ? P(ke, W, "$1") : ve || pe;
    }), de;
  }, re = function(ae, ce) {
    var ue = ae, de;
    if (oe(te, ue) && (de = te[ue], ue = "%" + de[0] + "%"), oe(C, ue)) {
      var pe = C[ue];
      if (pe === m && (pe = V(ue)), typeof pe > "u" && !ce)
        throw new n("intrinsic " + ae + " exists, but is not available. Please file an issue!");
      return {
        alias: de,
        name: ue,
        value: pe
      };
    }
    throw new s("intrinsic " + ae + " does not exist!");
  };
  return Po = function(ae, ce) {
    if (typeof ae != "string" || ae.length === 0)
      throw new n("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof ce != "boolean")
      throw new n('"allowMissing" argument must be a boolean');
    if (T(/^%?[^%]*%?$/, ae) === null)
      throw new s("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var ue = X(ae), de = ue.length > 0 ? ue[0] : "", pe = re("%" + de + "%", ce), ve = pe.name, ge = pe.value, ke = !1, Le = pe.alias;
    Le && (de = Le[0], le(ue, ne([0, 1], Le)));
    for (var Y = 1, Ne = !0; Y < ue.length; Y += 1) {
      var se = ue[Y], he = Z(se, 0, 1), be = Z(se, -1);
      if ((he === '"' || he === "'" || he === "`" || be === '"' || be === "'" || be === "`") && he !== be)
        throw new s("property names with quotes must have matching quotes");
      if ((se === "constructor" || !Ne) && (ke = !0), de += "." + se, ve = "%" + de + "%", oe(C, ve))
        ge = C[ve];
      else if (ge != null) {
        if (!(se in ge)) {
          if (!ce)
            throw new n("base intrinsic for " + ae + " exists, but the property is not available.");
          return;
        }
        if (B && Y + 1 >= ue.length) {
          var Be = B(ge, se);
          Ne = !!Be, Ne && "get" in Be && !("originalValue" in Be.get) ? ge = Be.get : ge = ge[se];
        } else
          Ne = oe(ge, se), ge = ge[se];
        Ne && !ke && (C[ve] = ge);
      }
    }
    return ge;
  }, Po;
}
var Uo, Bc;
function $t() {
  if (Bc) return Uo;
  Bc = 1;
  var e = /* @__PURE__ */ ud(), t = bs(), r = t([e("%String.prototype.indexOf%")]);
  return Uo = function(i, o) {
    var s = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      e(i, !!o)
    );
    return typeof s == "function" && r(i, ".prototype.") > -1 ? t(
      /** @type {const} */
      [s]
    ) : s;
  }, Uo;
}
var Co, zc;
function Km() {
  if (zc) return Co;
  zc = 1;
  var e = _i()(), t = /* @__PURE__ */ $t(), r = t("Object.prototype.toString"), a = function(n) {
    return e && n && typeof n == "object" && Symbol.toStringTag in n ? !1 : r(n) === "[object Arguments]";
  }, i = function(n) {
    return a(n) ? !0 : n !== null && typeof n == "object" && "length" in n && typeof n.length == "number" && n.length >= 0 && r(n) !== "[object Array]" && "callee" in n && r(n.callee) === "[object Function]";
  }, o = (function() {
    return a(arguments);
  })();
  return a.isLegacyArguments = i, Co = o ? a : i, Co;
}
var Lo, Sc;
function Hm() {
  if (Sc) return Lo;
  Sc = 1;
  var e = /* @__PURE__ */ $t(), t = _i()(), r = /* @__PURE__ */ cd(), a = /* @__PURE__ */ Ft(), i;
  if (t) {
    var o = e("RegExp.prototype.exec"), s = {}, n = function() {
      throw s;
    }, p = {
      toString: n,
      valueOf: n
    };
    typeof Symbol.toPrimitive == "symbol" && (p[Symbol.toPrimitive] = n), i = function(y) {
      if (!y || typeof y != "object")
        return !1;
      var k = (
        /** @type {NonNullable<typeof gOPD>} */
        a(
          /** @type {{ lastIndex?: unknown }} */
          y,
          "lastIndex"
        )
      ), A = k && r(k, "value");
      if (!A)
        return !1;
      try {
        o(
          y,
          /** @type {string} */
          /** @type {unknown} */
          p
        );
      } catch (E) {
        return E === s;
      }
    };
  } else {
    var d = e("Object.prototype.toString"), u = "[object RegExp]";
    i = function(y) {
      return !y || typeof y != "object" && typeof y != "function" ? !1 : d(y) === u;
    };
  }
  return Lo = i, Lo;
}
var No, Ic;
function Zm() {
  if (Ic) return No;
  Ic = 1;
  var e = /* @__PURE__ */ $t(), t = Hm(), r = e("RegExp.prototype.exec"), a = /* @__PURE__ */ Mt();
  return No = function(o) {
    if (!t(o))
      throw new a("`regex` must be a RegExp");
    return function(n) {
      return r(o, n) !== null;
    };
  }, No;
}
var qo, Tc;
function Gm() {
  if (Tc) return qo;
  Tc = 1;
  const e = (
    /** @type {GeneratorFunctionConstructor} */
    function* () {
    }.constructor
  );
  return qo = () => e, qo;
}
var Do, jc;
function Vm() {
  if (jc) return Do;
  jc = 1;
  var e = /* @__PURE__ */ $t(), t = /* @__PURE__ */ Zm(), r = t(/^\s*(?:function)?\*/), a = _i()(), i = ms(), o = e("Object.prototype.toString"), s = e("Function.prototype.toString"), n = /* @__PURE__ */ Gm();
  return Do = function(d) {
    if (typeof d != "function")
      return !1;
    if (r(s(d)))
      return !0;
    if (!a) {
      var u = o(d);
      return u === "[object GeneratorFunction]";
    }
    if (!i)
      return !1;
    var w = n();
    return w && i(d) === w.prototype;
  }, Do;
}
var Mo, Oc;
function Wm() {
  if (Oc) return Mo;
  Oc = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, a;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw a;
        }
      }), a = {}, t(function() {
        throw 42;
      }, null, r);
    } catch (B) {
      B !== a && (t = null);
    }
  else
    t = null;
  var i = /^\s*class\b/, o = function(z) {
    try {
      var O = e.call(z);
      return i.test(O);
    } catch {
      return !1;
    }
  }, s = function(z) {
    try {
      return o(z) ? !1 : (e.call(z), !0);
    } catch {
      return !1;
    }
  }, n = Object.prototype.toString, p = "[object Object]", d = "[object Function]", u = "[object GeneratorFunction]", w = "[object HTMLAllCollection]", y = "[object HTML document.all class]", k = "[object HTMLCollection]", A = typeof Symbol == "function" && !!Symbol.toStringTag, E = !(0 in [,]), x = function() {
    return !1;
  };
  if (typeof document == "object") {
    var I = document.all;
    n.call(I) === n.call(document.all) && (x = function(z) {
      if ((E || !z) && (typeof z > "u" || typeof z == "object"))
        try {
          var O = n.call(z);
          return (O === w || O === y || O === k || O === p) && z("") == null;
        } catch {
        }
      return !1;
    });
  }
  return Mo = t ? function(z) {
    if (x(z))
      return !0;
    if (!z || typeof z != "function" && typeof z != "object")
      return !1;
    try {
      t(z, null, r);
    } catch (O) {
      if (O !== a)
        return !1;
    }
    return !o(z) && s(z);
  } : function(z) {
    if (x(z))
      return !0;
    if (!z || typeof z != "function" && typeof z != "object")
      return !1;
    if (A)
      return s(z);
    if (o(z))
      return !1;
    var O = n.call(z);
    return O !== d && O !== u && !/^\[object HTML/.test(O) ? !1 : s(z);
  }, Mo;
}
var Fo, Rc;
function Ym() {
  if (Rc) return Fo;
  Rc = 1;
  var e = Wm(), t = Object.prototype.toString, r = Object.prototype.hasOwnProperty, a = function(p, d, u) {
    for (var w = 0, y = p.length; w < y; w++)
      r.call(p, w) && (u == null ? d(p[w], w, p) : d.call(u, p[w], w, p));
  }, i = function(p, d, u) {
    for (var w = 0, y = p.length; w < y; w++)
      u == null ? d(p.charAt(w), w, p) : d.call(u, p.charAt(w), w, p);
  }, o = function(p, d, u) {
    for (var w in p)
      r.call(p, w) && (u == null ? d(p[w], w, p) : d.call(u, p[w], w, p));
  };
  function s(n) {
    return t.call(n) === "[object Array]";
  }
  return Fo = function(p, d, u) {
    if (!e(d))
      throw new TypeError("iterator must be a function");
    var w;
    arguments.length >= 3 && (w = u), s(p) ? a(p, d, w) : typeof p == "string" ? i(p, d, w) : o(p, d, w);
  }, Fo;
}
var $o, Pc;
function Xm() {
  return Pc || (Pc = 1, $o = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), $o;
}
var Ko, Uc;
function Jm() {
  if (Uc) return Ko;
  Uc = 1;
  var e = /* @__PURE__ */ Xm(), t = globalThis;
  return Ko = function() {
    for (var a = [], i = 0; i < e.length; i++)
      typeof t[e[i]] == "function" && (a[a.length] = e[i]);
    return a;
  }, Ko;
}
var Ho = { exports: {} }, Zo, Cc;
function Qm() {
  if (Cc) return Zo;
  Cc = 1;
  var e = /* @__PURE__ */ ki(), t = /* @__PURE__ */ od(), r = /* @__PURE__ */ Mt(), a = /* @__PURE__ */ Ft();
  return Zo = function(o, s, n) {
    if (!o || typeof o != "object" && typeof o != "function")
      throw new r("`obj` must be an object or a function`");
    if (typeof s != "string" && typeof s != "symbol")
      throw new r("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new r("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new r("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new r("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new r("`loose`, if provided, must be a boolean");
    var p = arguments.length > 3 ? arguments[3] : null, d = arguments.length > 4 ? arguments[4] : null, u = arguments.length > 5 ? arguments[5] : null, w = arguments.length > 6 ? arguments[6] : !1, y = !!a && a(o, s);
    if (e)
      e(o, s, {
        configurable: u === null && y ? y.configurable : !u,
        enumerable: p === null && y ? y.enumerable : !p,
        value: n,
        writable: d === null && y ? y.writable : !d
      });
    else if (w || !p && !d && !u)
      o[s] = n;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, Zo;
}
var Go, Lc;
function ey() {
  if (Lc) return Go;
  Lc = 1;
  var e = /* @__PURE__ */ ki(), t = function() {
    return !!e;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, Go = t, Go;
}
var Vo, Nc;
function ry() {
  if (Nc) return Vo;
  Nc = 1;
  var e = /* @__PURE__ */ ud(), t = /* @__PURE__ */ Qm(), r = /* @__PURE__ */ ey()(), a = /* @__PURE__ */ Ft(), i = /* @__PURE__ */ Mt(), o = e("%Math.floor%");
  return Vo = function(n, p) {
    if (typeof n != "function")
      throw new i("`fn` is not a function");
    if (typeof p != "number" || p < 0 || p > 4294967295 || o(p) !== p)
      throw new i("`length` must be a positive 32-bit integer");
    var d = arguments.length > 2 && !!arguments[2], u = !0, w = !0;
    if ("length" in n && a) {
      var y = a(n, "length");
      y && !y.configurable && (u = !1), y && !y.writable && (w = !1);
    }
    return (u || w || !d) && (r ? t(
      /** @type {Parameters<define>[0]} */
      n,
      "length",
      p,
      !0,
      !0
    ) : t(
      /** @type {Parameters<define>[0]} */
      n,
      "length",
      p
    )), n;
  }, Vo;
}
var Wo, qc;
function ty() {
  if (qc) return Wo;
  qc = 1;
  var e = ka(), t = gs(), r = ld();
  return Wo = function() {
    return r(e, t, arguments);
  }, Wo;
}
var Dc;
function ay() {
  return Dc || (Dc = 1, (function(e) {
    var t = /* @__PURE__ */ ry(), r = /* @__PURE__ */ ki(), a = bs(), i = ty();
    e.exports = function(s) {
      var n = a(arguments), p = s.length - (arguments.length - 1);
      return t(
        n,
        1 + (p > 0 ? p : 0),
        !0
      );
    }, r ? r(e.exports, "apply", { value: i }) : e.exports.apply = i;
  })(Ho)), Ho.exports;
}
var Yo, Mc;
function fd() {
  if (Mc) return Yo;
  Mc = 1;
  var e = Ym(), t = /* @__PURE__ */ Jm(), r = ay(), a = /* @__PURE__ */ $t(), i = /* @__PURE__ */ Ft(), o = ms(), s = a("Object.prototype.toString"), n = _i()(), p = globalThis, d = t(), u = a("String.prototype.slice"), w = a("Array.prototype.indexOf", !0) || function(x, I) {
    for (var B = 0; B < x.length; B += 1)
      if (x[B] === I)
        return B;
    return -1;
  }, y = { __proto__: null };
  n && i && o ? e(d, function(E) {
    var x = new p[E]();
    if (Symbol.toStringTag in x && o) {
      var I = o(x), B = i(I, Symbol.toStringTag);
      if (!B && I) {
        var z = o(I);
        B = i(z, Symbol.toStringTag);
      }
      if (B && B.get) {
        var O = r(B.get);
        y[
          /** @type {`$${import('.').TypedArrayName}`} */
          "$" + E
        ] = O;
      }
    }
  }) : e(d, function(E) {
    var x = new p[E](), I = x.slice || x.set;
    if (I) {
      var B = (
        /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
        // @ts-expect-error TODO FIXME
        r(I)
      );
      y[
        /** @type {`$${import('.').TypedArrayName}`} */
        "$" + E
      ] = B;
    }
  });
  var k = function(x) {
    var I = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      y,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(B, z) {
        if (!I)
          try {
            "$" + B(x) === z && (I = /** @type {import('.').TypedArrayName} */
            u(z, 1));
          } catch {
          }
      }
    ), I;
  }, A = function(x) {
    var I = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      y,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(B, z) {
        if (!I)
          try {
            B(x), I = /** @type {import('.').TypedArrayName} */
            u(z, 1);
          } catch {
          }
      }
    ), I;
  };
  return Yo = function(x) {
    if (!x || typeof x != "object")
      return !1;
    if (!n) {
      var I = u(s(x), 8, -1);
      return w(d, I) > -1 ? I : I !== "Object" ? !1 : A(x);
    }
    return i ? k(x) : null;
  }, Yo;
}
var Xo, Fc;
function dd() {
  if (Fc) return Xo;
  Fc = 1;
  var e = /* @__PURE__ */ fd();
  return Xo = function(r) {
    return !!e(r);
  }, Xo;
}
var $c;
function iy() {
  return $c || ($c = 1, (function(e) {
    var t = /* @__PURE__ */ Km(), r = Vm(), a = /* @__PURE__ */ fd(), i = /* @__PURE__ */ dd();
    function o(Y) {
      return Y.call.bind(Y);
    }
    var s = typeof BigInt < "u", n = typeof Symbol < "u", p = o(Object.prototype.toString), d = o(Number.prototype.valueOf), u = o(String.prototype.valueOf), w = o(Boolean.prototype.valueOf);
    if (s)
      var y = o(BigInt.prototype.valueOf);
    if (n)
      var k = o(Symbol.prototype.valueOf);
    function A(Y, Ne) {
      if (typeof Y != "object")
        return !1;
      try {
        return Ne(Y), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = i;
    function E(Y) {
      return typeof Promise < "u" && Y instanceof Promise || Y !== null && typeof Y == "object" && typeof Y.then == "function" && typeof Y.catch == "function";
    }
    e.isPromise = E;
    function x(Y) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Y) : i(Y) || Z(Y);
    }
    e.isArrayBufferView = x;
    function I(Y) {
      return a(Y) === "Uint8Array";
    }
    e.isUint8Array = I;
    function B(Y) {
      return a(Y) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = B;
    function z(Y) {
      return a(Y) === "Uint16Array";
    }
    e.isUint16Array = z;
    function O(Y) {
      return a(Y) === "Uint32Array";
    }
    e.isUint32Array = O;
    function F(Y) {
      return a(Y) === "Int8Array";
    }
    e.isInt8Array = F;
    function N(Y) {
      return a(Y) === "Int16Array";
    }
    e.isInt16Array = N;
    function j(Y) {
      return a(Y) === "Int32Array";
    }
    e.isInt32Array = j;
    function q(Y) {
      return a(Y) === "Float32Array";
    }
    e.isFloat32Array = q;
    function S(Y) {
      return a(Y) === "Float64Array";
    }
    e.isFloat64Array = S;
    function D(Y) {
      return a(Y) === "BigInt64Array";
    }
    e.isBigInt64Array = D;
    function $(Y) {
      return a(Y) === "BigUint64Array";
    }
    e.isBigUint64Array = $;
    function m(Y) {
      return p(Y) === "[object Map]";
    }
    m.working = typeof Map < "u" && m(/* @__PURE__ */ new Map());
    function U(Y) {
      return typeof Map > "u" ? !1 : m.working ? m(Y) : Y instanceof Map;
    }
    e.isMap = U;
    function C(Y) {
      return p(Y) === "[object Set]";
    }
    C.working = typeof Set < "u" && C(/* @__PURE__ */ new Set());
    function M(Y) {
      return typeof Set > "u" ? !1 : C.working ? C(Y) : Y instanceof Set;
    }
    e.isSet = M;
    function V(Y) {
      return p(Y) === "[object WeakMap]";
    }
    V.working = typeof WeakMap < "u" && V(/* @__PURE__ */ new WeakMap());
    function te(Y) {
      return typeof WeakMap > "u" ? !1 : V.working ? V(Y) : Y instanceof WeakMap;
    }
    e.isWeakMap = te;
    function ie(Y) {
      return p(Y) === "[object WeakSet]";
    }
    ie.working = typeof WeakSet < "u" && ie(/* @__PURE__ */ new WeakSet());
    function oe(Y) {
      return ie(Y);
    }
    e.isWeakSet = oe;
    function ne(Y) {
      return p(Y) === "[object ArrayBuffer]";
    }
    ne.working = typeof ArrayBuffer < "u" && ne(new ArrayBuffer());
    function le(Y) {
      return typeof ArrayBuffer > "u" ? !1 : ne.working ? ne(Y) : Y instanceof ArrayBuffer;
    }
    e.isArrayBuffer = le;
    function P(Y) {
      return p(Y) === "[object DataView]";
    }
    P.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && P(new DataView(new ArrayBuffer(1), 0, 1));
    function Z(Y) {
      return typeof DataView > "u" ? !1 : P.working ? P(Y) : Y instanceof DataView;
    }
    e.isDataView = Z;
    var T = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function K(Y) {
      return p(Y) === "[object SharedArrayBuffer]";
    }
    function W(Y) {
      return typeof T > "u" ? !1 : (typeof K.working > "u" && (K.working = K(new T())), K.working ? K(Y) : Y instanceof T);
    }
    e.isSharedArrayBuffer = W;
    function X(Y) {
      return p(Y) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = X;
    function re(Y) {
      return p(Y) === "[object Map Iterator]";
    }
    e.isMapIterator = re;
    function Q(Y) {
      return p(Y) === "[object Set Iterator]";
    }
    e.isSetIterator = Q;
    function ae(Y) {
      return p(Y) === "[object Generator]";
    }
    e.isGeneratorObject = ae;
    function ce(Y) {
      return p(Y) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = ce;
    function ue(Y) {
      return A(Y, d);
    }
    e.isNumberObject = ue;
    function de(Y) {
      return A(Y, u);
    }
    e.isStringObject = de;
    function pe(Y) {
      return A(Y, w);
    }
    e.isBooleanObject = pe;
    function ve(Y) {
      return s && A(Y, y);
    }
    e.isBigIntObject = ve;
    function ge(Y) {
      return n && A(Y, k);
    }
    e.isSymbolObject = ge;
    function ke(Y) {
      return ue(Y) || de(Y) || pe(Y) || ve(Y) || ge(Y);
    }
    e.isBoxedPrimitive = ke;
    function Le(Y) {
      return typeof Uint8Array < "u" && (le(Y) || W(Y));
    }
    e.isAnyArrayBuffer = Le, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Y) {
      Object.defineProperty(e, Y, {
        enumerable: !1,
        value: function() {
          throw new Error(Y + " is not supported in userland");
        }
      });
    });
  })(Ji)), Ji;
}
var Jo, Kc;
function oy() {
  return Kc || (Kc = 1, Jo = function(t) {
    return t instanceof dr;
  }), Jo;
}
var Hc;
function ny() {
  return Hc || (Hc = 1, (function(e) {
    var t = Object.getOwnPropertyDescriptors || function(Z) {
      for (var T = Object.keys(Z), K = {}, W = 0; W < T.length; W++)
        K[T[W]] = Object.getOwnPropertyDescriptor(Z, T[W]);
      return K;
    }, r = /%[sdj%]/g;
    e.format = function(P) {
      if (!F(P)) {
        for (var Z = [], T = 0; T < arguments.length; T++)
          Z.push(s(arguments[T]));
        return Z.join(" ");
      }
      for (var T = 1, K = arguments, W = K.length, X = String(P).replace(r, function(Q) {
        if (Q === "%%") return "%";
        if (T >= W) return Q;
        switch (Q) {
          case "%s":
            return String(K[T++]);
          case "%d":
            return Number(K[T++]);
          case "%j":
            try {
              return JSON.stringify(K[T++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Q;
        }
      }), re = K[T]; T < W; re = K[++T])
        B(re) || !S(re) ? X += " " + re : X += " " + s(re);
      return X;
    }, e.deprecate = function(P, Z) {
      if (typeof vr < "u" && vr.noDeprecation === !0)
        return P;
      if (typeof vr > "u")
        return function() {
          return e.deprecate(P, Z).apply(this, arguments);
        };
      var T = !1;
      function K() {
        if (!T) {
          if (vr.throwDeprecation)
            throw new Error(Z);
          vr.traceDeprecation ? console.trace(Z) : console.error(Z), T = !0;
        }
        return P.apply(this, arguments);
      }
      return K;
    };
    var a = {}, i = /^$/;
    if (vr.env.NODE_DEBUG) {
      var o = vr.env.NODE_DEBUG;
      o = o.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), i = new RegExp("^" + o + "$", "i");
    }
    e.debuglog = function(P) {
      if (P = P.toUpperCase(), !a[P])
        if (i.test(P)) {
          var Z = vr.pid;
          a[P] = function() {
            var T = e.format.apply(e, arguments);
            console.error("%s %d: %s", P, Z, T);
          };
        } else
          a[P] = function() {
          };
      return a[P];
    };
    function s(P, Z) {
      var T = {
        seen: [],
        stylize: p
      };
      return arguments.length >= 3 && (T.depth = arguments[2]), arguments.length >= 4 && (T.colors = arguments[3]), I(Z) ? T.showHidden = Z : Z && e._extend(T, Z), j(T.showHidden) && (T.showHidden = !1), j(T.depth) && (T.depth = 2), j(T.colors) && (T.colors = !1), j(T.customInspect) && (T.customInspect = !0), T.colors && (T.stylize = n), u(T, P, T.depth);
    }
    e.inspect = s, s.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, s.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function n(P, Z) {
      var T = s.styles[Z];
      return T ? "\x1B[" + s.colors[T][0] + "m" + P + "\x1B[" + s.colors[T][1] + "m" : P;
    }
    function p(P, Z) {
      return P;
    }
    function d(P) {
      var Z = {};
      return P.forEach(function(T, K) {
        Z[T] = !0;
      }), Z;
    }
    function u(P, Z, T) {
      if (P.customInspect && Z && m(Z.inspect) && // Filter out the util module, it's inspect function is special
      Z.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(Z.constructor && Z.constructor.prototype === Z)) {
        var K = Z.inspect(T, P);
        return F(K) || (K = u(P, K, T)), K;
      }
      var W = w(P, Z);
      if (W)
        return W;
      var X = Object.keys(Z), re = d(X);
      if (P.showHidden && (X = Object.getOwnPropertyNames(Z)), $(Z) && (X.indexOf("message") >= 0 || X.indexOf("description") >= 0))
        return y(Z);
      if (X.length === 0) {
        if (m(Z)) {
          var Q = Z.name ? ": " + Z.name : "";
          return P.stylize("[Function" + Q + "]", "special");
        }
        if (q(Z))
          return P.stylize(RegExp.prototype.toString.call(Z), "regexp");
        if (D(Z))
          return P.stylize(Date.prototype.toString.call(Z), "date");
        if ($(Z))
          return y(Z);
      }
      var ae = "", ce = !1, ue = ["{", "}"];
      if (x(Z) && (ce = !0, ue = ["[", "]"]), m(Z)) {
        var de = Z.name ? ": " + Z.name : "";
        ae = " [Function" + de + "]";
      }
      if (q(Z) && (ae = " " + RegExp.prototype.toString.call(Z)), D(Z) && (ae = " " + Date.prototype.toUTCString.call(Z)), $(Z) && (ae = " " + y(Z)), X.length === 0 && (!ce || Z.length == 0))
        return ue[0] + ae + ue[1];
      if (T < 0)
        return q(Z) ? P.stylize(RegExp.prototype.toString.call(Z), "regexp") : P.stylize("[Object]", "special");
      P.seen.push(Z);
      var pe;
      return ce ? pe = k(P, Z, T, re, X) : pe = X.map(function(ve) {
        return A(P, Z, T, re, ve, ce);
      }), P.seen.pop(), E(pe, ae, ue);
    }
    function w(P, Z) {
      if (j(Z))
        return P.stylize("undefined", "undefined");
      if (F(Z)) {
        var T = "'" + JSON.stringify(Z).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return P.stylize(T, "string");
      }
      if (O(Z))
        return P.stylize("" + Z, "number");
      if (I(Z))
        return P.stylize("" + Z, "boolean");
      if (B(Z))
        return P.stylize("null", "null");
    }
    function y(P) {
      return "[" + Error.prototype.toString.call(P) + "]";
    }
    function k(P, Z, T, K, W) {
      for (var X = [], re = 0, Q = Z.length; re < Q; ++re)
        ie(Z, String(re)) ? X.push(A(
          P,
          Z,
          T,
          K,
          String(re),
          !0
        )) : X.push("");
      return W.forEach(function(ae) {
        ae.match(/^\d+$/) || X.push(A(
          P,
          Z,
          T,
          K,
          ae,
          !0
        ));
      }), X;
    }
    function A(P, Z, T, K, W, X) {
      var re, Q, ae;
      if (ae = Object.getOwnPropertyDescriptor(Z, W) || { value: Z[W] }, ae.get ? ae.set ? Q = P.stylize("[Getter/Setter]", "special") : Q = P.stylize("[Getter]", "special") : ae.set && (Q = P.stylize("[Setter]", "special")), ie(K, W) || (re = "[" + W + "]"), Q || (P.seen.indexOf(ae.value) < 0 ? (B(T) ? Q = u(P, ae.value, null) : Q = u(P, ae.value, T - 1), Q.indexOf(`
`) > -1 && (X ? Q = Q.split(`
`).map(function(ce) {
        return "  " + ce;
      }).join(`
`).slice(2) : Q = `
` + Q.split(`
`).map(function(ce) {
        return "   " + ce;
      }).join(`
`))) : Q = P.stylize("[Circular]", "special")), j(re)) {
        if (X && W.match(/^\d+$/))
          return Q;
        re = JSON.stringify("" + W), re.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (re = re.slice(1, -1), re = P.stylize(re, "name")) : (re = re.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), re = P.stylize(re, "string"));
      }
      return re + ": " + Q;
    }
    function E(P, Z, T) {
      var K = P.reduce(function(W, X) {
        return X.indexOf(`
`) >= 0, W + X.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return K > 60 ? T[0] + (Z === "" ? "" : Z + `
 `) + " " + P.join(`,
  `) + " " + T[1] : T[0] + Z + " " + P.join(", ") + " " + T[1];
    }
    e.types = iy();
    function x(P) {
      return Array.isArray(P);
    }
    e.isArray = x;
    function I(P) {
      return typeof P == "boolean";
    }
    e.isBoolean = I;
    function B(P) {
      return P === null;
    }
    e.isNull = B;
    function z(P) {
      return P == null;
    }
    e.isNullOrUndefined = z;
    function O(P) {
      return typeof P == "number";
    }
    e.isNumber = O;
    function F(P) {
      return typeof P == "string";
    }
    e.isString = F;
    function N(P) {
      return typeof P == "symbol";
    }
    e.isSymbol = N;
    function j(P) {
      return P === void 0;
    }
    e.isUndefined = j;
    function q(P) {
      return S(P) && C(P) === "[object RegExp]";
    }
    e.isRegExp = q, e.types.isRegExp = q;
    function S(P) {
      return typeof P == "object" && P !== null;
    }
    e.isObject = S;
    function D(P) {
      return S(P) && C(P) === "[object Date]";
    }
    e.isDate = D, e.types.isDate = D;
    function $(P) {
      return S(P) && (C(P) === "[object Error]" || P instanceof Error);
    }
    e.isError = $, e.types.isNativeError = $;
    function m(P) {
      return typeof P == "function";
    }
    e.isFunction = m;
    function U(P) {
      return P === null || typeof P == "boolean" || typeof P == "number" || typeof P == "string" || typeof P == "symbol" || // ES6 symbol
      typeof P > "u";
    }
    e.isPrimitive = U, e.isBuffer = oy();
    function C(P) {
      return Object.prototype.toString.call(P);
    }
    function M(P) {
      return P < 10 ? "0" + P.toString(10) : P.toString(10);
    }
    var V = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function te() {
      var P = /* @__PURE__ */ new Date(), Z = [
        M(P.getHours()),
        M(P.getMinutes()),
        M(P.getSeconds())
      ].join(":");
      return [P.getDate(), V[P.getMonth()], Z].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", te(), e.format.apply(e, arguments));
    }, e.inherits = wt(), e._extend = function(P, Z) {
      if (!Z || !S(Z)) return P;
      for (var T = Object.keys(Z), K = T.length; K--; )
        P[T[K]] = Z[T[K]];
      return P;
    };
    function ie(P, Z) {
      return Object.prototype.hasOwnProperty.call(P, Z);
    }
    var oe = typeof Symbol < "u" ? /* @__PURE__ */ Symbol("util.promisify.custom") : void 0;
    e.promisify = function(Z) {
      if (typeof Z != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (oe && Z[oe]) {
        var T = Z[oe];
        if (typeof T != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(T, oe, {
          value: T,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), T;
      }
      function T() {
        for (var K, W, X = new Promise(function(ae, ce) {
          K = ae, W = ce;
        }), re = [], Q = 0; Q < arguments.length; Q++)
          re.push(arguments[Q]);
        re.push(function(ae, ce) {
          ae ? W(ae) : K(ce);
        });
        try {
          Z.apply(this, re);
        } catch (ae) {
          W(ae);
        }
        return X;
      }
      return Object.setPrototypeOf(T, Object.getPrototypeOf(Z)), oe && Object.defineProperty(T, oe, {
        value: T,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        T,
        t(Z)
      );
    }, e.promisify.custom = oe;
    function ne(P, Z) {
      if (!P) {
        var T = new Error("Promise was rejected with a falsy value");
        T.reason = P, P = T;
      }
      return Z(P);
    }
    function le(P) {
      if (typeof P != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function Z() {
        for (var T = [], K = 0; K < arguments.length; K++)
          T.push(arguments[K]);
        var W = T.pop();
        if (typeof W != "function")
          throw new TypeError("The last argument must be of type Function");
        var X = this, re = function() {
          return W.apply(X, arguments);
        };
        P.apply(this, T).then(
          function(Q) {
            vr.nextTick(re.bind(null, null, Q));
          },
          function(Q) {
            vr.nextTick(ne.bind(null, Q, re));
          }
        );
      }
      return Object.setPrototypeOf(Z, Object.getPrototypeOf(P)), Object.defineProperties(
        Z,
        t(P)
      ), Z;
    }
    e.callbackify = le;
  })(Xi)), Xi;
}
var Pa = { exports: {} }, Zc;
function sy() {
  return Zc || (Zc = 1, typeof Object.create == "function" ? Pa.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Pa.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var a = function() {
      };
      a.prototype = r.prototype, t.prototype = new a(), t.prototype.constructor = t;
    }
  }), Pa.exports;
}
var Gc;
function wt() {
  if (Gc) return Ra.exports;
  Gc = 1;
  try {
    var e = ny();
    if (typeof e.inherits != "function") throw "";
    Ra.exports = e.inherits;
  } catch {
    Ra.exports = sy();
  }
  return Ra.exports;
}
var Ua = { exports: {} }, Qo = {}, Vc;
function ly() {
  return Vc || (Vc = 1, (function(e) {
    Object.defineProperties(e, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
    var t = {}, r = {};
    r.byteLength = u, r.toByteArray = y, r.fromByteArray = E;
    for (var a = [], i = [], o = typeof Uint8Array < "u" ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = 0, p = s.length; n < p; ++n)
      a[n] = s[n], i[s.charCodeAt(n)] = n;
    i[45] = 62, i[95] = 63;
    function d(B) {
      var z = B.length;
      if (z % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var O = B.indexOf("=");
      O === -1 && (O = z);
      var F = O === z ? 0 : 4 - O % 4;
      return [O, F];
    }
    function u(B) {
      var z = d(B), O = z[0], F = z[1];
      return (O + F) * 3 / 4 - F;
    }
    function w(B, z, O) {
      return (z + O) * 3 / 4 - O;
    }
    function y(B) {
      var z, O = d(B), F = O[0], N = O[1], j = new o(w(B, F, N)), q = 0, S = N > 0 ? F - 4 : F, D;
      for (D = 0; D < S; D += 4)
        z = i[B.charCodeAt(D)] << 18 | i[B.charCodeAt(D + 1)] << 12 | i[B.charCodeAt(D + 2)] << 6 | i[B.charCodeAt(D + 3)], j[q++] = z >> 16 & 255, j[q++] = z >> 8 & 255, j[q++] = z & 255;
      return N === 2 && (z = i[B.charCodeAt(D)] << 2 | i[B.charCodeAt(D + 1)] >> 4, j[q++] = z & 255), N === 1 && (z = i[B.charCodeAt(D)] << 10 | i[B.charCodeAt(D + 1)] << 4 | i[B.charCodeAt(D + 2)] >> 2, j[q++] = z >> 8 & 255, j[q++] = z & 255), j;
    }
    function k(B) {
      return a[B >> 18 & 63] + a[B >> 12 & 63] + a[B >> 6 & 63] + a[B & 63];
    }
    function A(B, z, O) {
      for (var F, N = [], j = z; j < O; j += 3)
        F = (B[j] << 16 & 16711680) + (B[j + 1] << 8 & 65280) + (B[j + 2] & 255), N.push(k(F));
      return N.join("");
    }
    function E(B) {
      for (var z, O = B.length, F = O % 3, N = [], j = 16383, q = 0, S = O - F; q < S; q += j)
        N.push(A(B, q, q + j > S ? S : q + j));
      return F === 1 ? (z = B[O - 1], N.push(
        a[z >> 2] + a[z << 4 & 63] + "=="
      )) : F === 2 && (z = (B[O - 2] << 8) + B[O - 1], N.push(
        a[z >> 10] + a[z >> 4 & 63] + a[z << 2 & 63] + "="
      )), N.join("");
    }
    var x = {};
    x.read = function(B, z, O, F, N) {
      var j, q, S = N * 8 - F - 1, D = (1 << S) - 1, $ = D >> 1, m = -7, U = O ? N - 1 : 0, C = O ? -1 : 1, M = B[z + U];
      for (U += C, j = M & (1 << -m) - 1, M >>= -m, m += S; m > 0; j = j * 256 + B[z + U], U += C, m -= 8)
        ;
      for (q = j & (1 << -m) - 1, j >>= -m, m += F; m > 0; q = q * 256 + B[z + U], U += C, m -= 8)
        ;
      if (j === 0)
        j = 1 - $;
      else {
        if (j === D)
          return q ? NaN : (M ? -1 : 1) * (1 / 0);
        q = q + Math.pow(2, F), j = j - $;
      }
      return (M ? -1 : 1) * q * Math.pow(2, j - F);
    }, x.write = function(B, z, O, F, N, j) {
      var q, S, D, $ = j * 8 - N - 1, m = (1 << $) - 1, U = m >> 1, C = N === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, M = F ? 0 : j - 1, V = F ? 1 : -1, te = z < 0 || z === 0 && 1 / z < 0 ? 1 : 0;
      for (z = Math.abs(z), isNaN(z) || z === 1 / 0 ? (S = isNaN(z) ? 1 : 0, q = m) : (q = Math.floor(Math.log(z) / Math.LN2), z * (D = Math.pow(2, -q)) < 1 && (q--, D *= 2), q + U >= 1 ? z += C / D : z += C * Math.pow(2, 1 - U), z * D >= 2 && (q++, D /= 2), q + U >= m ? (S = 0, q = m) : q + U >= 1 ? (S = (z * D - 1) * Math.pow(2, N), q = q + U) : (S = z * Math.pow(2, U - 1) * Math.pow(2, N), q = 0)); N >= 8; B[O + M] = S & 255, M += V, S /= 256, N -= 8)
        ;
      for (q = q << N | S, $ += N; $ > 0; B[O + M] = q & 255, M += V, q /= 256, $ -= 8)
        ;
      B[O + M - V] |= te * 128;
    };
    (function(B) {
      const z = r, O = x, F = typeof Symbol == "function" && typeof Symbol.for == "function" ? /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom") : null;
      B.Buffer = m, B.SlowBuffer = Z, B.INSPECT_MAX_BYTES = 50;
      const N = 2147483647;
      B.kMaxLength = N;
      const { Uint8Array: j, ArrayBuffer: q, SharedArrayBuffer: S } = globalThis;
      m.TYPED_ARRAY_SUPPORT = D(), !m.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
      function D() {
        try {
          const b = new j(1), c = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(c, j.prototype), Object.setPrototypeOf(b, c), b.foo() === 42;
        } catch {
          return !1;
        }
      }
      Object.defineProperty(m.prototype, "parent", {
        enumerable: !0,
        get: function() {
          if (m.isBuffer(this))
            return this.buffer;
        }
      }), Object.defineProperty(m.prototype, "offset", {
        enumerable: !0,
        get: function() {
          if (m.isBuffer(this))
            return this.byteOffset;
        }
      });
      function $(b) {
        if (b > N)
          throw new RangeError('The value "' + b + '" is invalid for option "size"');
        const c = new j(b);
        return Object.setPrototypeOf(c, m.prototype), c;
      }
      function m(b, c, h) {
        if (typeof b == "number") {
          if (typeof c == "string")
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return V(b);
        }
        return U(b, c, h);
      }
      m.poolSize = 8192;
      function U(b, c, h) {
        if (typeof b == "string")
          return te(b, c);
        if (q.isView(b))
          return oe(b);
        if (b == null)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof b
          );
        if (hr(b, q) || b && hr(b.buffer, q) || typeof S < "u" && (hr(b, S) || b && hr(b.buffer, S)))
          return ne(b, c, h);
        if (typeof b == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const _ = b.valueOf && b.valueOf();
        if (_ != null && _ !== b)
          return m.from(_, c, h);
        const L = le(b);
        if (L) return L;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof b[Symbol.toPrimitive] == "function")
          return m.from(b[Symbol.toPrimitive]("string"), c, h);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof b
        );
      }
      m.from = function(b, c, h) {
        return U(b, c, h);
      }, Object.setPrototypeOf(m.prototype, j.prototype), Object.setPrototypeOf(m, j);
      function C(b) {
        if (typeof b != "number")
          throw new TypeError('"size" argument must be of type number');
        if (b < 0)
          throw new RangeError('The value "' + b + '" is invalid for option "size"');
      }
      function M(b, c, h) {
        return C(b), b <= 0 ? $(b) : c !== void 0 ? typeof h == "string" ? $(b).fill(c, h) : $(b).fill(c) : $(b);
      }
      m.alloc = function(b, c, h) {
        return M(b, c, h);
      };
      function V(b) {
        return C(b), $(b < 0 ? 0 : P(b) | 0);
      }
      m.allocUnsafe = function(b) {
        return V(b);
      }, m.allocUnsafeSlow = function(b) {
        return V(b);
      };
      function te(b, c) {
        if ((typeof c != "string" || c === "") && (c = "utf8"), !m.isEncoding(c))
          throw new TypeError("Unknown encoding: " + c);
        const h = T(b, c) | 0;
        let _ = $(h);
        const L = _.write(b, c);
        return L !== h && (_ = _.slice(0, L)), _;
      }
      function ie(b) {
        const c = b.length < 0 ? 0 : P(b.length) | 0, h = $(c);
        for (let _ = 0; _ < c; _ += 1)
          h[_] = b[_] & 255;
        return h;
      }
      function oe(b) {
        if (hr(b, j)) {
          const c = new j(b);
          return ne(c.buffer, c.byteOffset, c.byteLength);
        }
        return ie(b);
      }
      function ne(b, c, h) {
        if (c < 0 || b.byteLength < c)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (b.byteLength < c + (h || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let _;
        return c === void 0 && h === void 0 ? _ = new j(b) : h === void 0 ? _ = new j(b, c) : _ = new j(b, c, h), Object.setPrototypeOf(_, m.prototype), _;
      }
      function le(b) {
        if (m.isBuffer(b)) {
          const c = P(b.length) | 0, h = $(c);
          return h.length === 0 || b.copy(h, 0, 0, c), h;
        }
        if (b.length !== void 0)
          return typeof b.length != "number" || Ei(b.length) ? $(0) : ie(b);
        if (b.type === "Buffer" && Array.isArray(b.data))
          return ie(b.data);
      }
      function P(b) {
        if (b >= N)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + N.toString(16) + " bytes");
        return b | 0;
      }
      function Z(b) {
        return +b != b && (b = 0), m.alloc(+b);
      }
      m.isBuffer = function(c) {
        return c != null && c._isBuffer === !0 && c !== m.prototype;
      }, m.compare = function(c, h) {
        if (hr(c, j) && (c = m.from(c, c.offset, c.byteLength)), hr(h, j) && (h = m.from(h, h.offset, h.byteLength)), !m.isBuffer(c) || !m.isBuffer(h))
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (c === h) return 0;
        let _ = c.length, L = h.length;
        for (let G = 0, ee = Math.min(_, L); G < ee; ++G)
          if (c[G] !== h[G]) {
            _ = c[G], L = h[G];
            break;
          }
        return _ < L ? -1 : L < _ ? 1 : 0;
      }, m.isEncoding = function(c) {
        switch (String(c).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, m.concat = function(c, h) {
        if (!Array.isArray(c))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (c.length === 0)
          return m.alloc(0);
        let _;
        if (h === void 0)
          for (h = 0, _ = 0; _ < c.length; ++_)
            h += c[_].length;
        const L = m.allocUnsafe(h);
        let G = 0;
        for (_ = 0; _ < c.length; ++_) {
          let ee = c[_];
          if (hr(ee, j))
            G + ee.length > L.length ? (m.isBuffer(ee) || (ee = m.from(ee)), ee.copy(L, G)) : j.prototype.set.call(
              L,
              ee,
              G
            );
          else if (m.isBuffer(ee))
            ee.copy(L, G);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          G += ee.length;
        }
        return L;
      };
      function T(b, c) {
        if (m.isBuffer(b))
          return b.length;
        if (q.isView(b) || hr(b, q))
          return b.byteLength;
        if (typeof b != "string")
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof b
          );
        const h = b.length, _ = arguments.length > 2 && arguments[2] === !0;
        if (!_ && h === 0) return 0;
        let L = !1;
        for (; ; )
          switch (c) {
            case "ascii":
            case "latin1":
            case "binary":
              return h;
            case "utf8":
            case "utf-8":
              return Se(b).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return h * 2;
            case "hex":
              return h >>> 1;
            case "base64":
              return xe(b).length;
            default:
              if (L)
                return _ ? -1 : Se(b).length;
              c = ("" + c).toLowerCase(), L = !0;
          }
      }
      m.byteLength = T;
      function K(b, c, h) {
        let _ = !1;
        if ((c === void 0 || c < 0) && (c = 0), c > this.length || ((h === void 0 || h > this.length) && (h = this.length), h <= 0) || (h >>>= 0, c >>>= 0, h <= c))
          return "";
        for (b || (b = "utf8"); ; )
          switch (b) {
            case "hex":
              return Ne(this, c, h);
            case "utf8":
            case "utf-8":
              return ve(this, c, h);
            case "ascii":
              return Le(this, c, h);
            case "latin1":
            case "binary":
              return Y(this, c, h);
            case "base64":
              return pe(this, c, h);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return se(this, c, h);
            default:
              if (_) throw new TypeError("Unknown encoding: " + b);
              b = (b + "").toLowerCase(), _ = !0;
          }
      }
      m.prototype._isBuffer = !0;
      function W(b, c, h) {
        const _ = b[c];
        b[c] = b[h], b[h] = _;
      }
      m.prototype.swap16 = function() {
        const c = this.length;
        if (c % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let h = 0; h < c; h += 2)
          W(this, h, h + 1);
        return this;
      }, m.prototype.swap32 = function() {
        const c = this.length;
        if (c % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let h = 0; h < c; h += 4)
          W(this, h, h + 3), W(this, h + 1, h + 2);
        return this;
      }, m.prototype.swap64 = function() {
        const c = this.length;
        if (c % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let h = 0; h < c; h += 8)
          W(this, h, h + 7), W(this, h + 1, h + 6), W(this, h + 2, h + 5), W(this, h + 3, h + 4);
        return this;
      }, m.prototype.toString = function() {
        const c = this.length;
        return c === 0 ? "" : arguments.length === 0 ? ve(this, 0, c) : K.apply(this, arguments);
      }, m.prototype.toLocaleString = m.prototype.toString, m.prototype.equals = function(c) {
        if (!m.isBuffer(c)) throw new TypeError("Argument must be a Buffer");
        return this === c ? !0 : m.compare(this, c) === 0;
      }, m.prototype.inspect = function() {
        let c = "";
        const h = B.INSPECT_MAX_BYTES;
        return c = this.toString("hex", 0, h).replace(/(.{2})/g, "$1 ").trim(), this.length > h && (c += " ... "), "<Buffer " + c + ">";
      }, F && (m.prototype[F] = m.prototype.inspect), m.prototype.compare = function(c, h, _, L, G) {
        if (hr(c, j) && (c = m.from(c, c.offset, c.byteLength)), !m.isBuffer(c))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof c
          );
        if (h === void 0 && (h = 0), _ === void 0 && (_ = c ? c.length : 0), L === void 0 && (L = 0), G === void 0 && (G = this.length), h < 0 || _ > c.length || L < 0 || G > this.length)
          throw new RangeError("out of range index");
        if (L >= G && h >= _)
          return 0;
        if (L >= G)
          return -1;
        if (h >= _)
          return 1;
        if (h >>>= 0, _ >>>= 0, L >>>= 0, G >>>= 0, this === c) return 0;
        let ee = G - L, ye = _ - h;
        const qe = Math.min(ee, ye), Pe = this.slice(L, G), De = c.slice(h, _);
        for (let ze = 0; ze < qe; ++ze)
          if (Pe[ze] !== De[ze]) {
            ee = Pe[ze], ye = De[ze];
            break;
          }
        return ee < ye ? -1 : ye < ee ? 1 : 0;
      };
      function X(b, c, h, _, L) {
        if (b.length === 0) return -1;
        if (typeof h == "string" ? (_ = h, h = 0) : h > 2147483647 ? h = 2147483647 : h < -2147483648 && (h = -2147483648), h = +h, Ei(h) && (h = L ? 0 : b.length - 1), h < 0 && (h = b.length + h), h >= b.length) {
          if (L) return -1;
          h = b.length - 1;
        } else if (h < 0)
          if (L) h = 0;
          else return -1;
        if (typeof c == "string" && (c = m.from(c, _)), m.isBuffer(c))
          return c.length === 0 ? -1 : re(b, c, h, _, L);
        if (typeof c == "number")
          return c = c & 255, typeof j.prototype.indexOf == "function" ? L ? j.prototype.indexOf.call(b, c, h) : j.prototype.lastIndexOf.call(b, c, h) : re(b, [c], h, _, L);
        throw new TypeError("val must be string, number or Buffer");
      }
      function re(b, c, h, _, L) {
        let G = 1, ee = b.length, ye = c.length;
        if (_ !== void 0 && (_ = String(_).toLowerCase(), _ === "ucs2" || _ === "ucs-2" || _ === "utf16le" || _ === "utf-16le")) {
          if (b.length < 2 || c.length < 2)
            return -1;
          G = 2, ee /= 2, ye /= 2, h /= 2;
        }
        function qe(De, ze) {
          return G === 1 ? De[ze] : De.readUInt16BE(ze * G);
        }
        let Pe;
        if (L) {
          let De = -1;
          for (Pe = h; Pe < ee; Pe++)
            if (qe(b, Pe) === qe(c, De === -1 ? 0 : Pe - De)) {
              if (De === -1 && (De = Pe), Pe - De + 1 === ye) return De * G;
            } else
              De !== -1 && (Pe -= Pe - De), De = -1;
        } else
          for (h + ye > ee && (h = ee - ye), Pe = h; Pe >= 0; Pe--) {
            let De = !0;
            for (let ze = 0; ze < ye; ze++)
              if (qe(b, Pe + ze) !== qe(c, ze)) {
                De = !1;
                break;
              }
            if (De) return Pe;
          }
        return -1;
      }
      m.prototype.includes = function(c, h, _) {
        return this.indexOf(c, h, _) !== -1;
      }, m.prototype.indexOf = function(c, h, _) {
        return X(this, c, h, _, !0);
      }, m.prototype.lastIndexOf = function(c, h, _) {
        return X(this, c, h, _, !1);
      };
      function Q(b, c, h, _) {
        h = Number(h) || 0;
        const L = b.length - h;
        _ ? (_ = Number(_), _ > L && (_ = L)) : _ = L;
        const G = c.length;
        _ > G / 2 && (_ = G / 2);
        let ee;
        for (ee = 0; ee < _; ++ee) {
          const ye = parseInt(c.substr(ee * 2, 2), 16);
          if (Ei(ye)) return ee;
          b[h + ee] = ye;
        }
        return ee;
      }
      function ae(b, c, h, _) {
        return Ea(Se(c, b.length - h), b, h, _);
      }
      function ce(b, c, h, _) {
        return Ea(Ie(c), b, h, _);
      }
      function ue(b, c, h, _) {
        return Ea(xe(c), b, h, _);
      }
      function de(b, c, h, _) {
        return Ea(Re(c, b.length - h), b, h, _);
      }
      m.prototype.write = function(c, h, _, L) {
        if (h === void 0)
          L = "utf8", _ = this.length, h = 0;
        else if (_ === void 0 && typeof h == "string")
          L = h, _ = this.length, h = 0;
        else if (isFinite(h))
          h = h >>> 0, isFinite(_) ? (_ = _ >>> 0, L === void 0 && (L = "utf8")) : (L = _, _ = void 0);
        else
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        const G = this.length - h;
        if ((_ === void 0 || _ > G) && (_ = G), c.length > 0 && (_ < 0 || h < 0) || h > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        L || (L = "utf8");
        let ee = !1;
        for (; ; )
          switch (L) {
            case "hex":
              return Q(this, c, h, _);
            case "utf8":
            case "utf-8":
              return ae(this, c, h, _);
            case "ascii":
            case "latin1":
            case "binary":
              return ce(this, c, h, _);
            case "base64":
              return ue(this, c, h, _);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return de(this, c, h, _);
            default:
              if (ee) throw new TypeError("Unknown encoding: " + L);
              L = ("" + L).toLowerCase(), ee = !0;
          }
      }, m.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function pe(b, c, h) {
        return c === 0 && h === b.length ? z.fromByteArray(b) : z.fromByteArray(b.slice(c, h));
      }
      function ve(b, c, h) {
        h = Math.min(b.length, h);
        const _ = [];
        let L = c;
        for (; L < h; ) {
          const G = b[L];
          let ee = null, ye = G > 239 ? 4 : G > 223 ? 3 : G > 191 ? 2 : 1;
          if (L + ye <= h) {
            let qe, Pe, De, ze;
            switch (ye) {
              case 1:
                G < 128 && (ee = G);
                break;
              case 2:
                qe = b[L + 1], (qe & 192) === 128 && (ze = (G & 31) << 6 | qe & 63, ze > 127 && (ee = ze));
                break;
              case 3:
                qe = b[L + 1], Pe = b[L + 2], (qe & 192) === 128 && (Pe & 192) === 128 && (ze = (G & 15) << 12 | (qe & 63) << 6 | Pe & 63, ze > 2047 && (ze < 55296 || ze > 57343) && (ee = ze));
                break;
              case 4:
                qe = b[L + 1], Pe = b[L + 2], De = b[L + 3], (qe & 192) === 128 && (Pe & 192) === 128 && (De & 192) === 128 && (ze = (G & 15) << 18 | (qe & 63) << 12 | (Pe & 63) << 6 | De & 63, ze > 65535 && ze < 1114112 && (ee = ze));
            }
          }
          ee === null ? (ee = 65533, ye = 1) : ee > 65535 && (ee -= 65536, _.push(ee >>> 10 & 1023 | 55296), ee = 56320 | ee & 1023), _.push(ee), L += ye;
        }
        return ke(_);
      }
      const ge = 4096;
      function ke(b) {
        const c = b.length;
        if (c <= ge)
          return String.fromCharCode.apply(String, b);
        let h = "", _ = 0;
        for (; _ < c; )
          h += String.fromCharCode.apply(
            String,
            b.slice(_, _ += ge)
          );
        return h;
      }
      function Le(b, c, h) {
        let _ = "";
        h = Math.min(b.length, h);
        for (let L = c; L < h; ++L)
          _ += String.fromCharCode(b[L] & 127);
        return _;
      }
      function Y(b, c, h) {
        let _ = "";
        h = Math.min(b.length, h);
        for (let L = c; L < h; ++L)
          _ += String.fromCharCode(b[L]);
        return _;
      }
      function Ne(b, c, h) {
        const _ = b.length;
        (!c || c < 0) && (c = 0), (!h || h < 0 || h > _) && (h = _);
        let L = "";
        for (let G = c; G < h; ++G)
          L += gd[b[G]];
        return L;
      }
      function se(b, c, h) {
        const _ = b.slice(c, h);
        let L = "";
        for (let G = 0; G < _.length - 1; G += 2)
          L += String.fromCharCode(_[G] + _[G + 1] * 256);
        return L;
      }
      m.prototype.slice = function(c, h) {
        const _ = this.length;
        c = ~~c, h = h === void 0 ? _ : ~~h, c < 0 ? (c += _, c < 0 && (c = 0)) : c > _ && (c = _), h < 0 ? (h += _, h < 0 && (h = 0)) : h > _ && (h = _), h < c && (h = c);
        const L = this.subarray(c, h);
        return Object.setPrototypeOf(L, m.prototype), L;
      };
      function he(b, c, h) {
        if (b % 1 !== 0 || b < 0) throw new RangeError("offset is not uint");
        if (b + c > h) throw new RangeError("Trying to access beyond buffer length");
      }
      m.prototype.readUintLE = m.prototype.readUIntLE = function(c, h, _) {
        c = c >>> 0, h = h >>> 0, _ || he(c, h, this.length);
        let L = this[c], G = 1, ee = 0;
        for (; ++ee < h && (G *= 256); )
          L += this[c + ee] * G;
        return L;
      }, m.prototype.readUintBE = m.prototype.readUIntBE = function(c, h, _) {
        c = c >>> 0, h = h >>> 0, _ || he(c, h, this.length);
        let L = this[c + --h], G = 1;
        for (; h > 0 && (G *= 256); )
          L += this[c + --h] * G;
        return L;
      }, m.prototype.readUint8 = m.prototype.readUInt8 = function(c, h) {
        return c = c >>> 0, h || he(c, 1, this.length), this[c];
      }, m.prototype.readUint16LE = m.prototype.readUInt16LE = function(c, h) {
        return c = c >>> 0, h || he(c, 2, this.length), this[c] | this[c + 1] << 8;
      }, m.prototype.readUint16BE = m.prototype.readUInt16BE = function(c, h) {
        return c = c >>> 0, h || he(c, 2, this.length), this[c] << 8 | this[c + 1];
      }, m.prototype.readUint32LE = m.prototype.readUInt32LE = function(c, h) {
        return c = c >>> 0, h || he(c, 4, this.length), (this[c] | this[c + 1] << 8 | this[c + 2] << 16) + this[c + 3] * 16777216;
      }, m.prototype.readUint32BE = m.prototype.readUInt32BE = function(c, h) {
        return c = c >>> 0, h || he(c, 4, this.length), this[c] * 16777216 + (this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3]);
      }, m.prototype.readBigUInt64LE = Dr(function(c) {
        c = c >>> 0, R(c, "offset");
        const h = this[c], _ = this[c + 7];
        (h === void 0 || _ === void 0) && H(c, this.length - 8);
        const L = h + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + this[++c] * 2 ** 24, G = this[++c] + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + _ * 2 ** 24;
        return BigInt(L) + (BigInt(G) << BigInt(32));
      }), m.prototype.readBigUInt64BE = Dr(function(c) {
        c = c >>> 0, R(c, "offset");
        const h = this[c], _ = this[c + 7];
        (h === void 0 || _ === void 0) && H(c, this.length - 8);
        const L = h * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + this[++c], G = this[++c] * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + _;
        return (BigInt(L) << BigInt(32)) + BigInt(G);
      }), m.prototype.readIntLE = function(c, h, _) {
        c = c >>> 0, h = h >>> 0, _ || he(c, h, this.length);
        let L = this[c], G = 1, ee = 0;
        for (; ++ee < h && (G *= 256); )
          L += this[c + ee] * G;
        return G *= 128, L >= G && (L -= Math.pow(2, 8 * h)), L;
      }, m.prototype.readIntBE = function(c, h, _) {
        c = c >>> 0, h = h >>> 0, _ || he(c, h, this.length);
        let L = h, G = 1, ee = this[c + --L];
        for (; L > 0 && (G *= 256); )
          ee += this[c + --L] * G;
        return G *= 128, ee >= G && (ee -= Math.pow(2, 8 * h)), ee;
      }, m.prototype.readInt8 = function(c, h) {
        return c = c >>> 0, h || he(c, 1, this.length), this[c] & 128 ? (255 - this[c] + 1) * -1 : this[c];
      }, m.prototype.readInt16LE = function(c, h) {
        c = c >>> 0, h || he(c, 2, this.length);
        const _ = this[c] | this[c + 1] << 8;
        return _ & 32768 ? _ | 4294901760 : _;
      }, m.prototype.readInt16BE = function(c, h) {
        c = c >>> 0, h || he(c, 2, this.length);
        const _ = this[c + 1] | this[c] << 8;
        return _ & 32768 ? _ | 4294901760 : _;
      }, m.prototype.readInt32LE = function(c, h) {
        return c = c >>> 0, h || he(c, 4, this.length), this[c] | this[c + 1] << 8 | this[c + 2] << 16 | this[c + 3] << 24;
      }, m.prototype.readInt32BE = function(c, h) {
        return c = c >>> 0, h || he(c, 4, this.length), this[c] << 24 | this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3];
      }, m.prototype.readBigInt64LE = Dr(function(c) {
        c = c >>> 0, R(c, "offset");
        const h = this[c], _ = this[c + 7];
        (h === void 0 || _ === void 0) && H(c, this.length - 8);
        const L = this[c + 4] + this[c + 5] * 2 ** 8 + this[c + 6] * 2 ** 16 + (_ << 24);
        return (BigInt(L) << BigInt(32)) + BigInt(h + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + this[++c] * 2 ** 24);
      }), m.prototype.readBigInt64BE = Dr(function(c) {
        c = c >>> 0, R(c, "offset");
        const h = this[c], _ = this[c + 7];
        (h === void 0 || _ === void 0) && H(c, this.length - 8);
        const L = (h << 24) + // Overflow
        this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + this[++c];
        return (BigInt(L) << BigInt(32)) + BigInt(this[++c] * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + _);
      }), m.prototype.readFloatLE = function(c, h) {
        return c = c >>> 0, h || he(c, 4, this.length), O.read(this, c, !0, 23, 4);
      }, m.prototype.readFloatBE = function(c, h) {
        return c = c >>> 0, h || he(c, 4, this.length), O.read(this, c, !1, 23, 4);
      }, m.prototype.readDoubleLE = function(c, h) {
        return c = c >>> 0, h || he(c, 8, this.length), O.read(this, c, !0, 52, 8);
      }, m.prototype.readDoubleBE = function(c, h) {
        return c = c >>> 0, h || he(c, 8, this.length), O.read(this, c, !1, 52, 8);
      };
      function be(b, c, h, _, L, G) {
        if (!m.isBuffer(b)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (c > L || c < G) throw new RangeError('"value" argument is out of bounds');
        if (h + _ > b.length) throw new RangeError("Index out of range");
      }
      m.prototype.writeUintLE = m.prototype.writeUIntLE = function(c, h, _, L) {
        if (c = +c, h = h >>> 0, _ = _ >>> 0, !L) {
          const ye = Math.pow(2, 8 * _) - 1;
          be(this, c, h, _, ye, 0);
        }
        let G = 1, ee = 0;
        for (this[h] = c & 255; ++ee < _ && (G *= 256); )
          this[h + ee] = c / G & 255;
        return h + _;
      }, m.prototype.writeUintBE = m.prototype.writeUIntBE = function(c, h, _, L) {
        if (c = +c, h = h >>> 0, _ = _ >>> 0, !L) {
          const ye = Math.pow(2, 8 * _) - 1;
          be(this, c, h, _, ye, 0);
        }
        let G = _ - 1, ee = 1;
        for (this[h + G] = c & 255; --G >= 0 && (ee *= 256); )
          this[h + G] = c / ee & 255;
        return h + _;
      }, m.prototype.writeUint8 = m.prototype.writeUInt8 = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 1, 255, 0), this[h] = c & 255, h + 1;
      }, m.prototype.writeUint16LE = m.prototype.writeUInt16LE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 2, 65535, 0), this[h] = c & 255, this[h + 1] = c >>> 8, h + 2;
      }, m.prototype.writeUint16BE = m.prototype.writeUInt16BE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 2, 65535, 0), this[h] = c >>> 8, this[h + 1] = c & 255, h + 2;
      }, m.prototype.writeUint32LE = m.prototype.writeUInt32LE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 4, 4294967295, 0), this[h + 3] = c >>> 24, this[h + 2] = c >>> 16, this[h + 1] = c >>> 8, this[h] = c & 255, h + 4;
      }, m.prototype.writeUint32BE = m.prototype.writeUInt32BE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 4, 4294967295, 0), this[h] = c >>> 24, this[h + 1] = c >>> 16, this[h + 2] = c >>> 8, this[h + 3] = c & 255, h + 4;
      };
      function Be(b, c, h, _, L) {
        v(c, _, L, b, h, 7);
        let G = Number(c & BigInt(4294967295));
        b[h++] = G, G = G >> 8, b[h++] = G, G = G >> 8, b[h++] = G, G = G >> 8, b[h++] = G;
        let ee = Number(c >> BigInt(32) & BigInt(4294967295));
        return b[h++] = ee, ee = ee >> 8, b[h++] = ee, ee = ee >> 8, b[h++] = ee, ee = ee >> 8, b[h++] = ee, h;
      }
      function Oe(b, c, h, _, L) {
        v(c, _, L, b, h, 7);
        let G = Number(c & BigInt(4294967295));
        b[h + 7] = G, G = G >> 8, b[h + 6] = G, G = G >> 8, b[h + 5] = G, G = G >> 8, b[h + 4] = G;
        let ee = Number(c >> BigInt(32) & BigInt(4294967295));
        return b[h + 3] = ee, ee = ee >> 8, b[h + 2] = ee, ee = ee >> 8, b[h + 1] = ee, ee = ee >> 8, b[h] = ee, h + 8;
      }
      m.prototype.writeBigUInt64LE = Dr(function(c, h = 0) {
        return Be(this, c, h, BigInt(0), BigInt("0xffffffffffffffff"));
      }), m.prototype.writeBigUInt64BE = Dr(function(c, h = 0) {
        return Oe(this, c, h, BigInt(0), BigInt("0xffffffffffffffff"));
      }), m.prototype.writeIntLE = function(c, h, _, L) {
        if (c = +c, h = h >>> 0, !L) {
          const qe = Math.pow(2, 8 * _ - 1);
          be(this, c, h, _, qe - 1, -qe);
        }
        let G = 0, ee = 1, ye = 0;
        for (this[h] = c & 255; ++G < _ && (ee *= 256); )
          c < 0 && ye === 0 && this[h + G - 1] !== 0 && (ye = 1), this[h + G] = (c / ee >> 0) - ye & 255;
        return h + _;
      }, m.prototype.writeIntBE = function(c, h, _, L) {
        if (c = +c, h = h >>> 0, !L) {
          const qe = Math.pow(2, 8 * _ - 1);
          be(this, c, h, _, qe - 1, -qe);
        }
        let G = _ - 1, ee = 1, ye = 0;
        for (this[h + G] = c & 255; --G >= 0 && (ee *= 256); )
          c < 0 && ye === 0 && this[h + G + 1] !== 0 && (ye = 1), this[h + G] = (c / ee >> 0) - ye & 255;
        return h + _;
      }, m.prototype.writeInt8 = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 1, 127, -128), c < 0 && (c = 255 + c + 1), this[h] = c & 255, h + 1;
      }, m.prototype.writeInt16LE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 2, 32767, -32768), this[h] = c & 255, this[h + 1] = c >>> 8, h + 2;
      }, m.prototype.writeInt16BE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 2, 32767, -32768), this[h] = c >>> 8, this[h + 1] = c & 255, h + 2;
      }, m.prototype.writeInt32LE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 4, 2147483647, -2147483648), this[h] = c & 255, this[h + 1] = c >>> 8, this[h + 2] = c >>> 16, this[h + 3] = c >>> 24, h + 4;
      }, m.prototype.writeInt32BE = function(c, h, _) {
        return c = +c, h = h >>> 0, _ || be(this, c, h, 4, 2147483647, -2147483648), c < 0 && (c = 4294967295 + c + 1), this[h] = c >>> 24, this[h + 1] = c >>> 16, this[h + 2] = c >>> 8, this[h + 3] = c & 255, h + 4;
      }, m.prototype.writeBigInt64LE = Dr(function(c, h = 0) {
        return Be(this, c, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), m.prototype.writeBigInt64BE = Dr(function(c, h = 0) {
        return Oe(this, c, h, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function ar(b, c, h, _, L, G) {
        if (h + _ > b.length) throw new RangeError("Index out of range");
        if (h < 0) throw new RangeError("Index out of range");
      }
      function Sr(b, c, h, _, L) {
        return c = +c, h = h >>> 0, L || ar(b, c, h, 4), O.write(b, c, h, _, 23, 4), h + 4;
      }
      m.prototype.writeFloatLE = function(c, h, _) {
        return Sr(this, c, h, !0, _);
      }, m.prototype.writeFloatBE = function(c, h, _) {
        return Sr(this, c, h, !1, _);
      };
      function He(b, c, h, _, L) {
        return c = +c, h = h >>> 0, L || ar(b, c, h, 8), O.write(b, c, h, _, 52, 8), h + 8;
      }
      m.prototype.writeDoubleLE = function(c, h, _) {
        return He(this, c, h, !0, _);
      }, m.prototype.writeDoubleBE = function(c, h, _) {
        return He(this, c, h, !1, _);
      }, m.prototype.copy = function(c, h, _, L) {
        if (!m.isBuffer(c)) throw new TypeError("argument should be a Buffer");
        if (_ || (_ = 0), !L && L !== 0 && (L = this.length), h >= c.length && (h = c.length), h || (h = 0), L > 0 && L < _ && (L = _), L === _ || c.length === 0 || this.length === 0) return 0;
        if (h < 0)
          throw new RangeError("targetStart out of bounds");
        if (_ < 0 || _ >= this.length) throw new RangeError("Index out of range");
        if (L < 0) throw new RangeError("sourceEnd out of bounds");
        L > this.length && (L = this.length), c.length - h < L - _ && (L = c.length - h + _);
        const G = L - _;
        return this === c && typeof j.prototype.copyWithin == "function" ? this.copyWithin(h, _, L) : j.prototype.set.call(
          c,
          this.subarray(_, L),
          h
        ), G;
      }, m.prototype.fill = function(c, h, _, L) {
        if (typeof c == "string") {
          if (typeof h == "string" ? (L = h, h = 0, _ = this.length) : typeof _ == "string" && (L = _, _ = this.length), L !== void 0 && typeof L != "string")
            throw new TypeError("encoding must be a string");
          if (typeof L == "string" && !m.isEncoding(L))
            throw new TypeError("Unknown encoding: " + L);
          if (c.length === 1) {
            const ee = c.charCodeAt(0);
            (L === "utf8" && ee < 128 || L === "latin1") && (c = ee);
          }
        } else typeof c == "number" ? c = c & 255 : typeof c == "boolean" && (c = Number(c));
        if (h < 0 || this.length < h || this.length < _)
          throw new RangeError("Out of range index");
        if (_ <= h)
          return this;
        h = h >>> 0, _ = _ === void 0 ? this.length : _ >>> 0, c || (c = 0);
        let G;
        if (typeof c == "number")
          for (G = h; G < _; ++G)
            this[G] = c;
        else {
          const ee = m.isBuffer(c) ? c : m.from(c, L), ye = ee.length;
          if (ye === 0)
            throw new TypeError('The value "' + c + '" is invalid for argument "value"');
          for (G = 0; G < _ - h; ++G)
            this[G + h] = ee[G % ye];
        }
        return this;
      };
      const ur = {};
      function g(b, c, h) {
        ur[b] = class extends h {
          constructor() {
            super(), Object.defineProperty(this, "message", {
              value: c.apply(this, arguments),
              writable: !0,
              configurable: !0
            }), this.name = `${this.name} [${b}]`, this.stack, delete this.name;
          }
          get code() {
            return b;
          }
          set code(L) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: L,
              writable: !0
            });
          }
          toString() {
            return `${this.name} [${b}]: ${this.message}`;
          }
        };
      }
      g(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(b) {
          return b ? `${b} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ), g(
        "ERR_INVALID_ARG_TYPE",
        function(b, c) {
          return `The "${b}" argument must be of type number. Received type ${typeof c}`;
        },
        TypeError
      ), g(
        "ERR_OUT_OF_RANGE",
        function(b, c, h) {
          let _ = `The value of "${b}" is out of range.`, L = h;
          return Number.isInteger(h) && Math.abs(h) > 2 ** 32 ? L = l(String(h)) : typeof h == "bigint" && (L = String(h), (h > BigInt(2) ** BigInt(32) || h < -(BigInt(2) ** BigInt(32))) && (L = l(L)), L += "n"), _ += ` It must be ${c}. Received ${L}`, _;
        },
        RangeError
      );
      function l(b) {
        let c = "", h = b.length;
        const _ = b[0] === "-" ? 1 : 0;
        for (; h >= _ + 4; h -= 3)
          c = `_${b.slice(h - 3, h)}${c}`;
        return `${b.slice(0, h)}${c}`;
      }
      function f(b, c, h) {
        R(c, "offset"), (b[c] === void 0 || b[c + h] === void 0) && H(c, b.length - (h + 1));
      }
      function v(b, c, h, _, L, G) {
        if (b > h || b < c) {
          const ee = typeof c == "bigint" ? "n" : "";
          let ye;
          throw c === 0 || c === BigInt(0) ? ye = `>= 0${ee} and < 2${ee} ** ${(G + 1) * 8}${ee}` : ye = `>= -(2${ee} ** ${(G + 1) * 8 - 1}${ee}) and < 2 ** ${(G + 1) * 8 - 1}${ee}`, new ur.ERR_OUT_OF_RANGE("value", ye, b);
        }
        f(_, L, G);
      }
      function R(b, c) {
        if (typeof b != "number")
          throw new ur.ERR_INVALID_ARG_TYPE(c, "number", b);
      }
      function H(b, c, h) {
        throw Math.floor(b) !== b ? (R(b, h), new ur.ERR_OUT_OF_RANGE("offset", "an integer", b)) : c < 0 ? new ur.ERR_BUFFER_OUT_OF_BOUNDS() : new ur.ERR_OUT_OF_RANGE(
          "offset",
          `>= 0 and <= ${c}`,
          b
        );
      }
      const J = /[^+/0-9A-Za-z-_]/g;
      function me(b) {
        if (b = b.split("=")[0], b = b.trim().replace(J, ""), b.length < 2) return "";
        for (; b.length % 4 !== 0; )
          b = b + "=";
        return b;
      }
      function Se(b, c) {
        c = c || 1 / 0;
        let h;
        const _ = b.length;
        let L = null;
        const G = [];
        for (let ee = 0; ee < _; ++ee) {
          if (h = b.charCodeAt(ee), h > 55295 && h < 57344) {
            if (!L) {
              if (h > 56319) {
                (c -= 3) > -1 && G.push(239, 191, 189);
                continue;
              } else if (ee + 1 === _) {
                (c -= 3) > -1 && G.push(239, 191, 189);
                continue;
              }
              L = h;
              continue;
            }
            if (h < 56320) {
              (c -= 3) > -1 && G.push(239, 191, 189), L = h;
              continue;
            }
            h = (L - 55296 << 10 | h - 56320) + 65536;
          } else L && (c -= 3) > -1 && G.push(239, 191, 189);
          if (L = null, h < 128) {
            if ((c -= 1) < 0) break;
            G.push(h);
          } else if (h < 2048) {
            if ((c -= 2) < 0) break;
            G.push(
              h >> 6 | 192,
              h & 63 | 128
            );
          } else if (h < 65536) {
            if ((c -= 3) < 0) break;
            G.push(
              h >> 12 | 224,
              h >> 6 & 63 | 128,
              h & 63 | 128
            );
          } else if (h < 1114112) {
            if ((c -= 4) < 0) break;
            G.push(
              h >> 18 | 240,
              h >> 12 & 63 | 128,
              h >> 6 & 63 | 128,
              h & 63 | 128
            );
          } else
            throw new Error("Invalid code point");
        }
        return G;
      }
      function Ie(b) {
        const c = [];
        for (let h = 0; h < b.length; ++h)
          c.push(b.charCodeAt(h) & 255);
        return c;
      }
      function Re(b, c) {
        let h, _, L;
        const G = [];
        for (let ee = 0; ee < b.length && !((c -= 2) < 0); ++ee)
          h = b.charCodeAt(ee), _ = h >> 8, L = h % 256, G.push(L), G.push(_);
        return G;
      }
      function xe(b) {
        return z.toByteArray(me(b));
      }
      function Ea(b, c, h, _) {
        let L;
        for (L = 0; L < _ && !(L + h >= c.length || L >= b.length); ++L)
          c[L + h] = b[L];
        return L;
      }
      function hr(b, c) {
        return b instanceof c || b != null && b.constructor != null && b.constructor.name != null && b.constructor.name === c.name;
      }
      function Ei(b) {
        return b !== b;
      }
      const gd = (function() {
        const b = "0123456789abcdef", c = new Array(256);
        for (let h = 0; h < 16; ++h) {
          const _ = h * 16;
          for (let L = 0; L < 16; ++L)
            c[_ + L] = b[h] + b[L];
        }
        return c;
      })();
      function Dr(b) {
        return typeof BigInt > "u" ? bd : b;
      }
      function bd() {
        throw new Error("BigInt not supported");
      }
    })(t);
    const I = t.Buffer;
    e.Blob = t.Blob, e.BlobOptions = t.BlobOptions, e.Buffer = t.Buffer, e.File = t.File, e.FileOptions = t.FileOptions, e.INSPECT_MAX_BYTES = t.INSPECT_MAX_BYTES, e.SlowBuffer = t.SlowBuffer, e.TranscodeEncoding = t.TranscodeEncoding, e.atob = t.atob, e.btoa = t.btoa, e.constants = t.constants, e.default = I, e.isAscii = t.isAscii, e.isUtf8 = t.isUtf8, e.kMaxLength = t.kMaxLength, e.kStringMaxLength = t.kStringMaxLength, e.resolveObjectURL = t.resolveObjectURL, e.transcode = t.transcode;
  })(Qo)), Qo;
}
var Wc;
function et() {
  return Wc || (Wc = 1, (function(e, t) {
    var r = ly(), a = r.Buffer;
    function i(s, n) {
      for (var p in s)
        n[p] = s[p];
    }
    a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = o);
    function o(s, n, p) {
      return a(s, n, p);
    }
    o.prototype = Object.create(a.prototype), i(a, o), o.from = function(s, n, p) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return a(s, n, p);
    }, o.alloc = function(s, n, p) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var d = a(s);
      return n !== void 0 ? typeof p == "string" ? d.fill(n, p) : d.fill(n) : d.fill(0), d;
    }, o.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return a(s);
    }, o.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r.SlowBuffer(s);
    };
  })(Ua, Ua.exports)), Ua.exports;
}
var en, Yc;
function cy() {
  if (Yc) return en;
  Yc = 1;
  var e = {}.toString;
  return en = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, en;
}
var rn, Xc;
function uy() {
  if (Xc) return rn;
  Xc = 1;
  var e = /* @__PURE__ */ Mt(), t = /* @__PURE__ */ $t(), r = t("TypedArray.prototype.buffer", !0), a = /* @__PURE__ */ dd();
  return rn = r || function(o) {
    if (!a(o))
      throw new e("Not a Typed Array");
    return o.buffer;
  }, rn;
}
var tn, Jc;
function fy() {
  if (Jc) return tn;
  Jc = 1;
  var e = et().Buffer, t = cy(), r = /* @__PURE__ */ uy(), a = ArrayBuffer.isView || function(p) {
    try {
      return r(p), !0;
    } catch {
      return !1;
    }
  }, i = typeof Uint8Array < "u", o = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", s = o && (e.prototype instanceof Uint8Array || e.TYPED_ARRAY_SUPPORT);
  return tn = function(p, d) {
    if (e.isBuffer(p))
      return p.constructor && !("isBuffer" in p) ? e.from(p) : p;
    if (typeof p == "string")
      return e.from(p, d);
    if (o && a(p)) {
      if (p.byteLength === 0)
        return e.alloc(0);
      if (s) {
        var u = e.from(p.buffer, p.byteOffset, p.byteLength);
        if (u.byteLength === p.byteLength)
          return u;
      }
      var w = p instanceof Uint8Array ? p : new Uint8Array(p.buffer, p.byteOffset, p.byteLength), y = e.from(w);
      if (y.length === p.byteLength)
        return y;
    }
    if (i && p instanceof Uint8Array)
      return e.from(p);
    var k = t(p);
    if (k)
      for (var A = 0; A < p.length; A += 1) {
        var E = p[A];
        if (typeof E != "number" || E < 0 || E > 255 || ~~E !== E)
          throw new RangeError("Array items must be numbers in the range 0-255.");
      }
    if (k || e.isBuffer(p) && p.constructor && typeof p.constructor.isBuffer == "function" && p.constructor.isBuffer(p))
      return e.from(p);
    throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
  }, tn;
}
var an, Qc;
function Kt() {
  if (Qc) return an;
  Qc = 1;
  var e = et().Buffer, t = /* @__PURE__ */ fy();
  function r(a, i) {
    this._block = e.alloc(a), this._finalSize = i, this._blockSize = a, this._len = 0;
  }
  return r.prototype.update = function(a, i) {
    a = t(a, i || "utf8");
    for (var o = this._block, s = this._blockSize, n = a.length, p = this._len, d = 0; d < n; ) {
      for (var u = p % s, w = Math.min(n - d, s - u), y = 0; y < w; y++)
        o[u + y] = a[d + y];
      p += w, d += w, p % s === 0 && this._update(o);
    }
    return this._len += n, this;
  }, r.prototype.digest = function(a) {
    var i = this._len % this._blockSize;
    this._block[i] = 128, this._block.fill(0, i + 1), i >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var o = this._len * 8;
    if (o <= 4294967295)
      this._block.writeUInt32BE(o, this._blockSize - 4);
    else {
      var s = (o & 4294967295) >>> 0, n = (o - s) / 4294967296;
      this._block.writeUInt32BE(n, this._blockSize - 8), this._block.writeUInt32BE(s, this._blockSize - 4);
    }
    this._update(this._block);
    var p = this._hash();
    return a ? p.toString(a) : p;
  }, r.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, an = r, an;
}
var on, eu;
function dy() {
  if (eu) return on;
  eu = 1;
  var e = wt(), t = Kt(), r = et().Buffer, a = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], i = new Array(80);
  function o() {
    this.init(), this._w = i, t.call(this, 64, 56);
  }
  e(o, t), o.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function s(d) {
    return d << 5 | d >>> 27;
  }
  function n(d) {
    return d << 30 | d >>> 2;
  }
  function p(d, u, w, y) {
    return d === 0 ? u & w | ~u & y : d === 2 ? u & w | u & y | w & y : u ^ w ^ y;
  }
  return o.prototype._update = function(d) {
    for (var u = this._w, w = this._a | 0, y = this._b | 0, k = this._c | 0, A = this._d | 0, E = this._e | 0, x = 0; x < 16; ++x)
      u[x] = d.readInt32BE(x * 4);
    for (; x < 80; ++x)
      u[x] = u[x - 3] ^ u[x - 8] ^ u[x - 14] ^ u[x - 16];
    for (var I = 0; I < 80; ++I) {
      var B = ~~(I / 20), z = s(w) + p(B, y, k, A) + E + u[I] + a[B] | 0;
      E = A, A = k, k = n(y), y = w, w = z;
    }
    this._a = w + this._a | 0, this._b = y + this._b | 0, this._c = k + this._c | 0, this._d = A + this._d | 0, this._e = E + this._e | 0;
  }, o.prototype._hash = function() {
    var d = r.allocUnsafe(20);
    return d.writeInt32BE(this._a | 0, 0), d.writeInt32BE(this._b | 0, 4), d.writeInt32BE(this._c | 0, 8), d.writeInt32BE(this._d | 0, 12), d.writeInt32BE(this._e | 0, 16), d;
  }, on = o, on;
}
var nn, ru;
function hy() {
  if (ru) return nn;
  ru = 1;
  var e = wt(), t = Kt(), r = et().Buffer, a = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], i = new Array(80);
  function o() {
    this.init(), this._w = i, t.call(this, 64, 56);
  }
  e(o, t), o.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function s(u) {
    return u << 1 | u >>> 31;
  }
  function n(u) {
    return u << 5 | u >>> 27;
  }
  function p(u) {
    return u << 30 | u >>> 2;
  }
  function d(u, w, y, k) {
    return u === 0 ? w & y | ~w & k : u === 2 ? w & y | w & k | y & k : w ^ y ^ k;
  }
  return o.prototype._update = function(u) {
    for (var w = this._w, y = this._a | 0, k = this._b | 0, A = this._c | 0, E = this._d | 0, x = this._e | 0, I = 0; I < 16; ++I)
      w[I] = u.readInt32BE(I * 4);
    for (; I < 80; ++I)
      w[I] = s(w[I - 3] ^ w[I - 8] ^ w[I - 14] ^ w[I - 16]);
    for (var B = 0; B < 80; ++B) {
      var z = ~~(B / 20), O = n(y) + d(z, k, A, E) + x + w[B] + a[z] | 0;
      x = E, E = A, A = p(k), k = y, y = O;
    }
    this._a = y + this._a | 0, this._b = k + this._b | 0, this._c = A + this._c | 0, this._d = E + this._d | 0, this._e = x + this._e | 0;
  }, o.prototype._hash = function() {
    var u = r.allocUnsafe(20);
    return u.writeInt32BE(this._a | 0, 0), u.writeInt32BE(this._b | 0, 4), u.writeInt32BE(this._c | 0, 8), u.writeInt32BE(this._d | 0, 12), u.writeInt32BE(this._e | 0, 16), u;
  }, nn = o, nn;
}
var sn, tu;
function hd() {
  if (tu) return sn;
  tu = 1;
  var e = wt(), t = Kt(), r = et().Buffer, a = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], i = new Array(64);
  function o() {
    this.init(), this._w = i, t.call(this, 64, 56);
  }
  e(o, t), o.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function s(y, k, A) {
    return A ^ y & (k ^ A);
  }
  function n(y, k, A) {
    return y & k | A & (y | k);
  }
  function p(y) {
    return (y >>> 2 | y << 30) ^ (y >>> 13 | y << 19) ^ (y >>> 22 | y << 10);
  }
  function d(y) {
    return (y >>> 6 | y << 26) ^ (y >>> 11 | y << 21) ^ (y >>> 25 | y << 7);
  }
  function u(y) {
    return (y >>> 7 | y << 25) ^ (y >>> 18 | y << 14) ^ y >>> 3;
  }
  function w(y) {
    return (y >>> 17 | y << 15) ^ (y >>> 19 | y << 13) ^ y >>> 10;
  }
  return o.prototype._update = function(y) {
    for (var k = this._w, A = this._a | 0, E = this._b | 0, x = this._c | 0, I = this._d | 0, B = this._e | 0, z = this._f | 0, O = this._g | 0, F = this._h | 0, N = 0; N < 16; ++N)
      k[N] = y.readInt32BE(N * 4);
    for (; N < 64; ++N)
      k[N] = w(k[N - 2]) + k[N - 7] + u(k[N - 15]) + k[N - 16] | 0;
    for (var j = 0; j < 64; ++j) {
      var q = F + d(B) + s(B, z, O) + a[j] + k[j] | 0, S = p(A) + n(A, E, x) | 0;
      F = O, O = z, z = B, B = I + q | 0, I = x, x = E, E = A, A = q + S | 0;
    }
    this._a = A + this._a | 0, this._b = E + this._b | 0, this._c = x + this._c | 0, this._d = I + this._d | 0, this._e = B + this._e | 0, this._f = z + this._f | 0, this._g = O + this._g | 0, this._h = F + this._h | 0;
  }, o.prototype._hash = function() {
    var y = r.allocUnsafe(32);
    return y.writeInt32BE(this._a, 0), y.writeInt32BE(this._b, 4), y.writeInt32BE(this._c, 8), y.writeInt32BE(this._d, 12), y.writeInt32BE(this._e, 16), y.writeInt32BE(this._f, 20), y.writeInt32BE(this._g, 24), y.writeInt32BE(this._h, 28), y;
  }, sn = o, sn;
}
var ln, au;
function py() {
  if (au) return ln;
  au = 1;
  var e = wt(), t = hd(), r = Kt(), a = et().Buffer, i = new Array(64);
  function o() {
    this.init(), this._w = i, r.call(this, 64, 56);
  }
  return e(o, t), o.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, o.prototype._hash = function() {
    var s = a.allocUnsafe(28);
    return s.writeInt32BE(this._a, 0), s.writeInt32BE(this._b, 4), s.writeInt32BE(this._c, 8), s.writeInt32BE(this._d, 12), s.writeInt32BE(this._e, 16), s.writeInt32BE(this._f, 20), s.writeInt32BE(this._g, 24), s;
  }, ln = o, ln;
}
var cn, iu;
function pd() {
  if (iu) return cn;
  iu = 1;
  var e = wt(), t = Kt(), r = et().Buffer, a = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], i = new Array(160);
  function o() {
    this.init(), this._w = i, t.call(this, 128, 112);
  }
  e(o, t), o.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function s(E, x, I) {
    return I ^ E & (x ^ I);
  }
  function n(E, x, I) {
    return E & x | I & (E | x);
  }
  function p(E, x) {
    return (E >>> 28 | x << 4) ^ (x >>> 2 | E << 30) ^ (x >>> 7 | E << 25);
  }
  function d(E, x) {
    return (E >>> 14 | x << 18) ^ (E >>> 18 | x << 14) ^ (x >>> 9 | E << 23);
  }
  function u(E, x) {
    return (E >>> 1 | x << 31) ^ (E >>> 8 | x << 24) ^ E >>> 7;
  }
  function w(E, x) {
    return (E >>> 1 | x << 31) ^ (E >>> 8 | x << 24) ^ (E >>> 7 | x << 25);
  }
  function y(E, x) {
    return (E >>> 19 | x << 13) ^ (x >>> 29 | E << 3) ^ E >>> 6;
  }
  function k(E, x) {
    return (E >>> 19 | x << 13) ^ (x >>> 29 | E << 3) ^ (E >>> 6 | x << 26);
  }
  function A(E, x) {
    return E >>> 0 < x >>> 0 ? 1 : 0;
  }
  return o.prototype._update = function(E) {
    for (var x = this._w, I = this._ah | 0, B = this._bh | 0, z = this._ch | 0, O = this._dh | 0, F = this._eh | 0, N = this._fh | 0, j = this._gh | 0, q = this._hh | 0, S = this._al | 0, D = this._bl | 0, $ = this._cl | 0, m = this._dl | 0, U = this._el | 0, C = this._fl | 0, M = this._gl | 0, V = this._hl | 0, te = 0; te < 32; te += 2)
      x[te] = E.readInt32BE(te * 4), x[te + 1] = E.readInt32BE(te * 4 + 4);
    for (; te < 160; te += 2) {
      var ie = x[te - 30], oe = x[te - 30 + 1], ne = u(ie, oe), le = w(oe, ie);
      ie = x[te - 4], oe = x[te - 4 + 1];
      var P = y(ie, oe), Z = k(oe, ie), T = x[te - 14], K = x[te - 14 + 1], W = x[te - 32], X = x[te - 32 + 1], re = le + K | 0, Q = ne + T + A(re, le) | 0;
      re = re + Z | 0, Q = Q + P + A(re, Z) | 0, re = re + X | 0, Q = Q + W + A(re, X) | 0, x[te] = Q, x[te + 1] = re;
    }
    for (var ae = 0; ae < 160; ae += 2) {
      Q = x[ae], re = x[ae + 1];
      var ce = n(I, B, z), ue = n(S, D, $), de = p(I, S), pe = p(S, I), ve = d(F, U), ge = d(U, F), ke = a[ae], Le = a[ae + 1], Y = s(F, N, j), Ne = s(U, C, M), se = V + ge | 0, he = q + ve + A(se, V) | 0;
      se = se + Ne | 0, he = he + Y + A(se, Ne) | 0, se = se + Le | 0, he = he + ke + A(se, Le) | 0, se = se + re | 0, he = he + Q + A(se, re) | 0;
      var be = pe + ue | 0, Be = de + ce + A(be, pe) | 0;
      q = j, V = M, j = N, M = C, N = F, C = U, U = m + se | 0, F = O + he + A(U, m) | 0, O = z, m = $, z = B, $ = D, B = I, D = S, S = se + be | 0, I = he + Be + A(S, se) | 0;
    }
    this._al = this._al + S | 0, this._bl = this._bl + D | 0, this._cl = this._cl + $ | 0, this._dl = this._dl + m | 0, this._el = this._el + U | 0, this._fl = this._fl + C | 0, this._gl = this._gl + M | 0, this._hl = this._hl + V | 0, this._ah = this._ah + I + A(this._al, S) | 0, this._bh = this._bh + B + A(this._bl, D) | 0, this._ch = this._ch + z + A(this._cl, $) | 0, this._dh = this._dh + O + A(this._dl, m) | 0, this._eh = this._eh + F + A(this._el, U) | 0, this._fh = this._fh + N + A(this._fl, C) | 0, this._gh = this._gh + j + A(this._gl, M) | 0, this._hh = this._hh + q + A(this._hl, V) | 0;
  }, o.prototype._hash = function() {
    var E = r.allocUnsafe(64);
    function x(I, B, z) {
      E.writeInt32BE(I, z), E.writeInt32BE(B, z + 4);
    }
    return x(this._ah, this._al, 0), x(this._bh, this._bl, 8), x(this._ch, this._cl, 16), x(this._dh, this._dl, 24), x(this._eh, this._el, 32), x(this._fh, this._fl, 40), x(this._gh, this._gl, 48), x(this._hh, this._hl, 56), E;
  }, cn = o, cn;
}
var un, ou;
function gy() {
  if (ou) return un;
  ou = 1;
  var e = wt(), t = pd(), r = Kt(), a = et().Buffer, i = new Array(160);
  function o() {
    this.init(), this._w = i, r.call(this, 128, 112);
  }
  return e(o, t), o.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, o.prototype._hash = function() {
    var s = a.allocUnsafe(48);
    function n(p, d, u) {
      s.writeInt32BE(p, u), s.writeInt32BE(d, u + 4);
    }
    return n(this._ah, this._al, 0), n(this._bh, this._bl, 8), n(this._ch, this._cl, 16), n(this._dh, this._dl, 24), n(this._eh, this._el, 32), n(this._fh, this._fl, 40), s;
  }, un = o, un;
}
var nu;
function by() {
  return nu || (nu = 1, (function(e) {
    e.exports = function(r) {
      var a = r.toLowerCase(), i = e.exports[a];
      if (!i)
        throw new Error(a + " is not supported (we accept pull requests)");
      return new i();
    }, e.exports.sha = dy(), e.exports.sha1 = hy(), e.exports.sha224 = py(), e.exports.sha256 = hd(), e.exports.sha384 = gy(), e.exports.sha512 = pd();
  })(Yi)), Yi.exports;
}
var my = by();
const zy = /* @__PURE__ */ su(my);
export {
  ky as L,
  Lg as N,
  Ay as a,
  _y as b,
  $b as c,
  Ey as d,
  zy as e,
  ef as l,
  wy as p,
  Zr as s,
  Xa as z
};
