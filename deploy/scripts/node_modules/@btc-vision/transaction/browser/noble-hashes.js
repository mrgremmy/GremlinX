function k0(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Mt(t) {
  if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
  var e = t.default;
  if (typeof e == "function") {
    var s = function i() {
      var n = !1;
      try {
        n = this instanceof i;
      } catch {
      }
      return n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    s.prototype = e.prototype;
  } else s = {};
  return Object.defineProperty(s, "__esModule", { value: !0 }), Object.keys(t).forEach(function(i) {
    var n = Object.getOwnPropertyDescriptor(t, i);
    Object.defineProperty(s, i, n.get ? n : {
      enumerable: !0,
      get: function() {
        return t[i];
      }
    });
  }), s;
}
function Oe(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Ut(t, e = "") {
  if (!Number.isSafeInteger(t) || t < 0) {
    const s = e && `"${e}" `;
    throw new Error(`${s}expected integer >= 0, got ${t}`);
  }
}
function ft(t, e, s = "") {
  const i = Oe(t), n = t?.length, r = e !== void 0;
  if (!i || r && n !== e) {
    const c = s && `"${s}" `, o = r ? ` of length ${e}` : "", h = i ? `length=${n}` : `type=${typeof t}`;
    throw new Error(c + "expected Uint8Array" + o + ", got " + h);
  }
  return t;
}
function De(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  Ut(t.outputLen), Ut(t.blockLen);
}
function Ht(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function ie(t, e) {
  ft(t, void 0, "digestInto() output");
  const s = e.outputLen;
  if (t.length < s)
    throw new Error('"digestInto() output" expected to be of length >=' + s);
}
function Fe(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function J(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
function Dt(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function $(t, e) {
  return t << 32 - e | t >>> e;
}
function ht(t, e) {
  return t << e | t >>> 32 - e >>> 0;
}
const Te = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function ve(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function Me(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = ve(t[e]);
  return t;
}
const Rt = Te ? (t) => t : Me, ce = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", Ge = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function O0(t) {
  if (ft(t), ce)
    return t.toHex();
  let e = "";
  for (let s = 0; s < t.length; s++)
    e += Ge[t[s]];
  return e;
}
const et = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Wt(t) {
  if (t >= et._0 && t <= et._9)
    return t - et._0;
  if (t >= et.A && t <= et.F)
    return t - (et.A - 10);
  if (t >= et.a && t <= et.f)
    return t - (et.a - 10);
}
function D0(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  if (ce)
    return Uint8Array.fromHex(t);
  const e = t.length, s = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const i = new Uint8Array(s);
  for (let n = 0, r = 0; n < s; n++, r += 2) {
    const c = Wt(t.charCodeAt(r)), o = Wt(t.charCodeAt(r + 1));
    if (c === void 0 || o === void 0) {
      const h = t[r] + t[r + 1];
      throw new Error('hex string expected, got non-hex character "' + h + '" at index ' + r);
    }
    i[n] = c * 16 + o;
  }
  return i;
}
function F0(...t) {
  let e = 0;
  for (let i = 0; i < t.length; i++) {
    const n = t[i];
    ft(n), e += n.length;
  }
  const s = new Uint8Array(e);
  for (let i = 0, n = 0; i < t.length; i++) {
    const r = t[i];
    s.set(r, n), n += r.length;
  }
  return s;
}
function tt(t, e = {}) {
  const s = (n, r) => t(r).update(n).digest(), i = t(void 0);
  return s.outputLen = i.outputLen, s.blockLen = i.blockLen, s.create = (n) => t(n), Object.assign(s, e), Object.freeze(s);
}
function T0(t = 32) {
  const e = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof e?.getRandomValues != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return e.getRandomValues(new Uint8Array(t));
}
const dt = (t) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, t])
});
class Gt {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = !1;
  destroyed = !1;
  constructor(e, s) {
    if (De(e), ft(s, void 0, "key"), this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, n = new Uint8Array(i);
    n.set(s.length > i ? e.create().update(s).digest() : s);
    for (let r = 0; r < n.length; r++)
      n[r] ^= 54;
    this.iHash.update(n), this.oHash = e.create();
    for (let r = 0; r < n.length; r++)
      n[r] ^= 106;
    this.oHash.update(n), J(n);
  }
  update(e) {
    return Ht(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Ht(this), ft(e, this.outputLen, "output"), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash: s, iHash: i, finished: n, destroyed: r, blockLen: c, outputLen: o } = this;
    return e = e, e.finished = n, e.destroyed = r, e.blockLen = c, e.outputLen = o, e.oHash = s._cloneInto(e.oHash), e.iHash = i._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const oe = (t, e, s) => new Gt(t, e).update(s).digest();
oe.create = (t, e) => new Gt(t, e);
const je = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _HMAC: Gt,
  hmac: oe
}, Symbol.toStringTag, { value: "Module" })), v0 = /* @__PURE__ */ Mt(je);
function Et(t, e, s) {
  return t & e ^ ~t & s;
}
function ae(t, e, s) {
  return t & e ^ t & s ^ e & s;
}
class _t {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(e, s, i, n) {
    this.blockLen = e, this.outputLen = s, this.padOffset = i, this.isLE = n, this.buffer = new Uint8Array(e), this.view = Dt(this.buffer);
  }
  update(e) {
    Ht(this), ft(e);
    const { view: s, buffer: i, blockLen: n } = this, r = e.length;
    for (let c = 0; c < r; ) {
      const o = Math.min(n - this.pos, r - c);
      if (o === n) {
        const h = Dt(e);
        for (; n <= r - c; c += n)
          this.process(h, c);
        continue;
      }
      i.set(e.subarray(c, c + o), this.pos), this.pos += o, c += o, this.pos === n && (this.process(s, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Ht(this), ie(e, this), this.finished = !0;
    const { buffer: s, view: i, blockLen: n, isLE: r } = this;
    let { pos: c } = this;
    s[c++] = 128, J(this.buffer.subarray(c)), this.padOffset > n - c && (this.process(i, 0), c = 0);
    for (let f = c; f < n; f++)
      s[f] = 0;
    i.setBigUint64(n - 8, BigInt(this.length * 8), r), this.process(i, 0);
    const o = Dt(e), h = this.outputLen;
    if (h % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const u = h / 4, d = this.get();
    if (u > d.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f = 0; f < u; f++)
      o.setUint32(4 * f, d[f], r);
  }
  digest() {
    const { buffer: e, outputLen: s } = this;
    this.digestInto(e);
    const i = e.slice(0, s);
    return this.destroy(), i;
  }
  _cloneInto(e) {
    e ||= new this.constructor(), e.set(...this.get());
    const { blockLen: s, buffer: i, length: n, finished: r, destroyed: c, pos: o } = this;
    return e.destroyed = c, e.finished = r, e.length = n, e.pos = o, n % s && e.buffer.set(i), e;
  }
  clone() {
    return this._cloneInto();
  }
}
const nt = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), rt = /* @__PURE__ */ Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]), W = /* @__PURE__ */ Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]), q = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]), xt = /* @__PURE__ */ Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), it = /* @__PURE__ */ new Uint32Array(80);
class he extends _t {
  A = xt[0] | 0;
  B = xt[1] | 0;
  C = xt[2] | 0;
  D = xt[3] | 0;
  E = xt[4] | 0;
  constructor() {
    super(64, 20, 8, !1);
  }
  get() {
    const { A: e, B: s, C: i, D: n, E: r } = this;
    return [e, s, i, n, r];
  }
  set(e, s, i, n, r) {
    this.A = e | 0, this.B = s | 0, this.C = i | 0, this.D = n | 0, this.E = r | 0;
  }
  process(e, s) {
    for (let h = 0; h < 16; h++, s += 4)
      it[h] = e.getUint32(s, !1);
    for (let h = 16; h < 80; h++)
      it[h] = ht(it[h - 3] ^ it[h - 8] ^ it[h - 14] ^ it[h - 16], 1);
    let { A: i, B: n, C: r, D: c, E: o } = this;
    for (let h = 0; h < 80; h++) {
      let u, d;
      h < 20 ? (u = Et(n, r, c), d = 1518500249) : h < 40 ? (u = n ^ r ^ c, d = 1859775393) : h < 60 ? (u = ae(n, r, c), d = 2400959708) : (u = n ^ r ^ c, d = 3395469782);
      const f = ht(i, 5) + u + o + d + it[h] | 0;
      o = c, c = r, r = ht(n, 30), n = i, i = f;
    }
    i = i + this.A | 0, n = n + this.B | 0, r = r + this.C | 0, c = c + this.D | 0, o = o + this.E | 0, this.set(i, n, r, c, o);
  }
  roundClean() {
    J(it);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), J(this.buffer);
  }
}
const Pe = /* @__PURE__ */ tt(() => new he()), Re = /* @__PURE__ */ Math.pow(2, 32), We = /* @__PURE__ */ Array.from({ length: 64 }, (t, e) => Math.floor(Re * Math.abs(Math.sin(e + 1)))), wt = /* @__PURE__ */ xt.slice(0, 4), Ft = /* @__PURE__ */ new Uint32Array(16);
class fe extends _t {
  A = wt[0] | 0;
  B = wt[1] | 0;
  C = wt[2] | 0;
  D = wt[3] | 0;
  constructor() {
    super(64, 16, 8, !0);
  }
  get() {
    const { A: e, B: s, C: i, D: n } = this;
    return [e, s, i, n];
  }
  set(e, s, i, n) {
    this.A = e | 0, this.B = s | 0, this.C = i | 0, this.D = n | 0;
  }
  process(e, s) {
    for (let o = 0; o < 16; o++, s += 4)
      Ft[o] = e.getUint32(s, !0);
    let { A: i, B: n, C: r, D: c } = this;
    for (let o = 0; o < 64; o++) {
      let h, u, d;
      o < 16 ? (h = Et(n, r, c), u = o, d = [7, 12, 17, 22]) : o < 32 ? (h = Et(c, n, r), u = (5 * o + 1) % 16, d = [5, 9, 14, 20]) : o < 48 ? (h = n ^ r ^ c, u = (3 * o + 5) % 16, d = [4, 11, 16, 23]) : (h = r ^ (n | ~c), u = 7 * o % 16, d = [6, 10, 15, 21]), h = h + i + We[o] + Ft[u], i = c, c = r, r = n, n = n + ht(h, d[o % 4]);
    }
    i = i + this.A | 0, n = n + this.B | 0, r = r + this.C | 0, c = c + this.D | 0, this.set(i, n, r, c);
  }
  roundClean() {
    J(Ft);
  }
  destroy() {
    this.set(0, 0, 0, 0), J(this.buffer);
  }
}
const qe = /* @__PURE__ */ tt(() => new fe()), Ke = /* @__PURE__ */ Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]), de = Uint8Array.from(new Array(16).fill(0).map((t, e) => e)), Ne = de.map((t) => (9 * t + 5) % 16), ue = /* @__PURE__ */ (() => {
  const s = [[de], [Ne]];
  for (let i = 0; i < 4; i++)
    for (let n of s)
      n.push(n[i].map((r) => Ke[r]));
  return s;
})(), le = ue[0], be = ue[1], xe = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((t) => Uint8Array.from(t)), Xe = /* @__PURE__ */ le.map((t, e) => t.map((s) => xe[e][s])), Je = /* @__PURE__ */ be.map((t, e) => t.map((s) => xe[e][s])), Qe = /* @__PURE__ */ Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Ye = /* @__PURE__ */ Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function qt(t, e, s, i) {
  return t === 0 ? e ^ s ^ i : t === 1 ? e & s | ~e & i : t === 2 ? (e | ~s) ^ i : t === 3 ? e & i | s & ~i : e ^ (s | ~i);
}
const Lt = /* @__PURE__ */ new Uint32Array(16);
class He extends _t {
  h0 = 1732584193;
  h1 = -271733879;
  h2 = -1732584194;
  h3 = 271733878;
  h4 = -1009589776;
  constructor() {
    super(64, 20, 8, !0);
  }
  get() {
    const { h0: e, h1: s, h2: i, h3: n, h4: r } = this;
    return [e, s, i, n, r];
  }
  set(e, s, i, n, r) {
    this.h0 = e | 0, this.h1 = s | 0, this.h2 = i | 0, this.h3 = n | 0, this.h4 = r | 0;
  }
  process(e, s) {
    for (let p = 0; p < 16; p++, s += 4)
      Lt[p] = e.getUint32(s, !0);
    let i = this.h0 | 0, n = i, r = this.h1 | 0, c = r, o = this.h2 | 0, h = o, u = this.h3 | 0, d = u, f = this.h4 | 0, y = f;
    for (let p = 0; p < 5; p++) {
      const g = 4 - p, S = Qe[p], U = Ye[p], M = le[p], D = be[p], H = Xe[p], E = Je[p];
      for (let A = 0; A < 16; A++) {
        const L = ht(i + qt(p, r, o, u) + Lt[M[A]] + S, H[A]) + f | 0;
        i = f, f = u, u = ht(o, 10) | 0, o = r, r = L;
      }
      for (let A = 0; A < 16; A++) {
        const L = ht(n + qt(g, c, h, d) + Lt[D[A]] + U, E[A]) + y | 0;
        n = y, y = d, d = ht(h, 10) | 0, h = c, c = L;
      }
    }
    this.set(this.h1 + o + d | 0, this.h2 + u + y | 0, this.h3 + f + n | 0, this.h4 + i + c | 0, this.h0 + r + h | 0);
  }
  roundClean() {
    J(Lt);
  }
  destroy() {
    this.destroyed = !0, J(this.buffer), this.set(0, 0, 0, 0, 0);
  }
}
const Ze = /* @__PURE__ */ tt(() => new He()), ze = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _MD5: fe,
  _RIPEMD160: He,
  _SHA1: he,
  md5: qe,
  ripemd160: Ze,
  sha1: Pe
}, Symbol.toStringTag, { value: "Module" })), M0 = /* @__PURE__ */ Mt(ze), It = /* @__PURE__ */ BigInt(2 ** 32 - 1), Kt = /* @__PURE__ */ BigInt(32);
function $e(t, e = !1) {
  return e ? { h: Number(t & It), l: Number(t >> Kt & It) } : { h: Number(t >> Kt & It) | 0, l: Number(t & It) | 0 };
}
function Ae(t, e = !1) {
  const s = t.length;
  let i = new Uint32Array(s), n = new Uint32Array(s);
  for (let r = 0; r < s; r++) {
    const { h: c, l: o } = $e(t[r], e);
    [i[r], n[r]] = [c, o];
  }
  return [i, n];
}
const Nt = (t, e, s) => t >>> s, Xt = (t, e, s) => t << 32 - s | e >>> s, lt = (t, e, s) => t >>> s | e << 32 - s, bt = (t, e, s) => t << 32 - s | e >>> s, Bt = (t, e, s) => t << 64 - s | e >>> s - 32, mt = (t, e, s) => t >>> s - 32 | e << 64 - s, t0 = (t, e, s) => t << s | e >>> 32 - s, e0 = (t, e, s) => e << s | t >>> 32 - s, s0 = (t, e, s) => e << s - 32 | t >>> 64 - s, n0 = (t, e, s) => t << s - 32 | e >>> 64 - s;
function st(t, e, s, i) {
  const n = (e >>> 0) + (i >>> 0);
  return { h: t + s + (n / 2 ** 32 | 0) | 0, l: n | 0 };
}
const r0 = (t, e, s) => (t >>> 0) + (e >>> 0) + (s >>> 0), i0 = (t, e, s, i) => e + s + i + (t / 2 ** 32 | 0) | 0, c0 = (t, e, s, i) => (t >>> 0) + (e >>> 0) + (s >>> 0) + (i >>> 0), o0 = (t, e, s, i, n) => e + s + i + n + (t / 2 ** 32 | 0) | 0, a0 = (t, e, s, i, n) => (t >>> 0) + (e >>> 0) + (s >>> 0) + (i >>> 0) + (n >>> 0), h0 = (t, e, s, i, n, r) => e + s + i + n + r + (t / 2 ** 32 | 0) | 0, f0 = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ct = /* @__PURE__ */ new Uint32Array(64);
class pe extends _t {
  constructor(e) {
    super(64, e, 8, !1);
  }
  get() {
    const { A: e, B: s, C: i, D: n, E: r, F: c, G: o, H: h } = this;
    return [e, s, i, n, r, c, o, h];
  }
  // prettier-ignore
  set(e, s, i, n, r, c, o, h) {
    this.A = e | 0, this.B = s | 0, this.C = i | 0, this.D = n | 0, this.E = r | 0, this.F = c | 0, this.G = o | 0, this.H = h | 0;
  }
  process(e, s) {
    for (let f = 0; f < 16; f++, s += 4)
      ct[f] = e.getUint32(s, !1);
    for (let f = 16; f < 64; f++) {
      const y = ct[f - 15], p = ct[f - 2], g = $(y, 7) ^ $(y, 18) ^ y >>> 3, S = $(p, 17) ^ $(p, 19) ^ p >>> 10;
      ct[f] = S + ct[f - 7] + g + ct[f - 16] | 0;
    }
    let { A: i, B: n, C: r, D: c, E: o, F: h, G: u, H: d } = this;
    for (let f = 0; f < 64; f++) {
      const y = $(o, 6) ^ $(o, 11) ^ $(o, 25), p = d + y + Et(o, h, u) + f0[f] + ct[f] | 0, S = ($(i, 2) ^ $(i, 13) ^ $(i, 22)) + ae(i, n, r) | 0;
      d = u, u = h, h = o, o = c + p | 0, c = r, r = n, n = i, i = p + S | 0;
    }
    i = i + this.A | 0, n = n + this.B | 0, r = r + this.C | 0, c = c + this.D | 0, o = o + this.E | 0, h = h + this.F | 0, u = u + this.G | 0, d = d + this.H | 0, this.set(i, n, r, c, o, h, u, d);
  }
  roundClean() {
    J(ct);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), J(this.buffer);
  }
}
class ye extends pe {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = nt[0] | 0;
  B = nt[1] | 0;
  C = nt[2] | 0;
  D = nt[3] | 0;
  E = nt[4] | 0;
  F = nt[5] | 0;
  G = nt[6] | 0;
  H = nt[7] | 0;
  constructor() {
    super(32);
  }
}
class _e extends pe {
  A = rt[0] | 0;
  B = rt[1] | 0;
  C = rt[2] | 0;
  D = rt[3] | 0;
  E = rt[4] | 0;
  F = rt[5] | 0;
  G = rt[6] | 0;
  H = rt[7] | 0;
  constructor() {
    super(28);
  }
}
const ge = Ae([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((t) => BigInt(t))), d0 = ge[0], u0 = ge[1], ot = /* @__PURE__ */ new Uint32Array(80), at = /* @__PURE__ */ new Uint32Array(80);
class Vt extends _t {
  constructor(e) {
    super(128, e, 16, !1);
  }
  // prettier-ignore
  get() {
    const { Ah: e, Al: s, Bh: i, Bl: n, Ch: r, Cl: c, Dh: o, Dl: h, Eh: u, El: d, Fh: f, Fl: y, Gh: p, Gl: g, Hh: S, Hl: U } = this;
    return [e, s, i, n, r, c, o, h, u, d, f, y, p, g, S, U];
  }
  // prettier-ignore
  set(e, s, i, n, r, c, o, h, u, d, f, y, p, g, S, U) {
    this.Ah = e | 0, this.Al = s | 0, this.Bh = i | 0, this.Bl = n | 0, this.Ch = r | 0, this.Cl = c | 0, this.Dh = o | 0, this.Dl = h | 0, this.Eh = u | 0, this.El = d | 0, this.Fh = f | 0, this.Fl = y | 0, this.Gh = p | 0, this.Gl = g | 0, this.Hh = S | 0, this.Hl = U | 0;
  }
  process(e, s) {
    for (let H = 0; H < 16; H++, s += 4)
      ot[H] = e.getUint32(s), at[H] = e.getUint32(s += 4);
    for (let H = 16; H < 80; H++) {
      const E = ot[H - 15] | 0, A = at[H - 15] | 0, L = lt(E, A, 1) ^ lt(E, A, 8) ^ Nt(E, A, 7), m = bt(E, A, 1) ^ bt(E, A, 8) ^ Xt(E, A, 7), V = ot[H - 2] | 0, l = at[H - 2] | 0, b = lt(V, l, 19) ^ Bt(V, l, 61) ^ Nt(V, l, 6), x = bt(V, l, 19) ^ mt(V, l, 61) ^ Xt(V, l, 6), C = c0(m, x, at[H - 7], at[H - 16]), w = o0(C, L, b, ot[H - 7], ot[H - 16]);
      ot[H] = w | 0, at[H] = C | 0;
    }
    let { Ah: i, Al: n, Bh: r, Bl: c, Ch: o, Cl: h, Dh: u, Dl: d, Eh: f, El: y, Fh: p, Fl: g, Gh: S, Gl: U, Hh: M, Hl: D } = this;
    for (let H = 0; H < 80; H++) {
      const E = lt(f, y, 14) ^ lt(f, y, 18) ^ Bt(f, y, 41), A = bt(f, y, 14) ^ bt(f, y, 18) ^ mt(f, y, 41), L = f & p ^ ~f & S, m = y & g ^ ~y & U, V = a0(D, A, m, u0[H], at[H]), l = h0(V, M, E, L, d0[H], ot[H]), b = V | 0, x = lt(i, n, 28) ^ Bt(i, n, 34) ^ Bt(i, n, 39), C = bt(i, n, 28) ^ mt(i, n, 34) ^ mt(i, n, 39), w = i & r ^ i & o ^ r & o, k = n & c ^ n & h ^ c & h;
      M = S | 0, D = U | 0, S = p | 0, U = g | 0, p = f | 0, g = y | 0, { h: f, l: y } = st(u | 0, d | 0, l | 0, b | 0), u = o | 0, d = h | 0, o = r | 0, h = c | 0, r = i | 0, c = n | 0;
      const v = r0(b, C, k);
      i = i0(v, l, x, w), n = v | 0;
    }
    ({ h: i, l: n } = st(this.Ah | 0, this.Al | 0, i | 0, n | 0)), { h: r, l: c } = st(this.Bh | 0, this.Bl | 0, r | 0, c | 0), { h: o, l: h } = st(this.Ch | 0, this.Cl | 0, o | 0, h | 0), { h: u, l: d } = st(this.Dh | 0, this.Dl | 0, u | 0, d | 0), { h: f, l: y } = st(this.Eh | 0, this.El | 0, f | 0, y | 0), { h: p, l: g } = st(this.Fh | 0, this.Fl | 0, p | 0, g | 0), { h: S, l: U } = st(this.Gh | 0, this.Gl | 0, S | 0, U | 0), { h: M, l: D } = st(this.Hh | 0, this.Hl | 0, M | 0, D | 0), this.set(i, n, r, c, o, h, u, d, f, y, p, g, S, U, M, D);
  }
  roundClean() {
    J(ot, at);
  }
  destroy() {
    J(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class Se extends Vt {
  Ah = q[0] | 0;
  Al = q[1] | 0;
  Bh = q[2] | 0;
  Bl = q[3] | 0;
  Ch = q[4] | 0;
  Cl = q[5] | 0;
  Dh = q[6] | 0;
  Dl = q[7] | 0;
  Eh = q[8] | 0;
  El = q[9] | 0;
  Fh = q[10] | 0;
  Fl = q[11] | 0;
  Gh = q[12] | 0;
  Gl = q[13] | 0;
  Hh = q[14] | 0;
  Hl = q[15] | 0;
  constructor() {
    super(64);
  }
}
class we extends Vt {
  Ah = W[0] | 0;
  Al = W[1] | 0;
  Bh = W[2] | 0;
  Bl = W[3] | 0;
  Ch = W[4] | 0;
  Cl = W[5] | 0;
  Dh = W[6] | 0;
  Dl = W[7] | 0;
  Eh = W[8] | 0;
  El = W[9] | 0;
  Fh = W[10] | 0;
  Fl = W[11] | 0;
  Gh = W[12] | 0;
  Gl = W[13] | 0;
  Hh = W[14] | 0;
  Hl = W[15] | 0;
  constructor() {
    super(48);
  }
}
const K = /* @__PURE__ */ Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]), N = /* @__PURE__ */ Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
class Le extends Vt {
  Ah = K[0] | 0;
  Al = K[1] | 0;
  Bh = K[2] | 0;
  Bl = K[3] | 0;
  Ch = K[4] | 0;
  Cl = K[5] | 0;
  Dh = K[6] | 0;
  Dl = K[7] | 0;
  Eh = K[8] | 0;
  El = K[9] | 0;
  Fh = K[10] | 0;
  Fl = K[11] | 0;
  Gh = K[12] | 0;
  Gl = K[13] | 0;
  Hh = K[14] | 0;
  Hl = K[15] | 0;
  constructor() {
    super(28);
  }
}
class Ie extends Vt {
  Ah = N[0] | 0;
  Al = N[1] | 0;
  Bh = N[2] | 0;
  Bl = N[3] | 0;
  Ch = N[4] | 0;
  Cl = N[5] | 0;
  Dh = N[6] | 0;
  Dl = N[7] | 0;
  Eh = N[8] | 0;
  El = N[9] | 0;
  Fh = N[10] | 0;
  Fl = N[11] | 0;
  Gh = N[12] | 0;
  Gl = N[13] | 0;
  Hh = N[14] | 0;
  Hl = N[15] | 0;
  constructor() {
    super(32);
  }
}
const l0 = /* @__PURE__ */ tt(
  () => new ye(),
  /* @__PURE__ */ dt(1)
), b0 = /* @__PURE__ */ tt(
  () => new _e(),
  /* @__PURE__ */ dt(4)
), x0 = /* @__PURE__ */ tt(
  () => new Se(),
  /* @__PURE__ */ dt(3)
), H0 = /* @__PURE__ */ tt(
  () => new we(),
  /* @__PURE__ */ dt(2)
), A0 = /* @__PURE__ */ tt(
  () => new Ie(),
  /* @__PURE__ */ dt(6)
), p0 = /* @__PURE__ */ tt(
  () => new Le(),
  /* @__PURE__ */ dt(5)
), y0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _SHA224: _e,
  _SHA256: ye,
  _SHA384: we,
  _SHA512: Se,
  _SHA512_224: Le,
  _SHA512_256: Ie,
  sha224: b0,
  sha256: l0,
  sha384: H0,
  sha512: x0,
  sha512_224: p0,
  sha512_256: A0
}, Symbol.toStringTag, { value: "Module" })), G0 = /* @__PURE__ */ Mt(y0), _0 = BigInt(0), At = BigInt(1), g0 = BigInt(2), S0 = BigInt(7), w0 = BigInt(256), L0 = BigInt(113), Be = [], me = [], Ue = [];
for (let t = 0, e = At, s = 1, i = 0; t < 24; t++) {
  [s, i] = [i, (2 * s + 3 * i) % 5], Be.push(2 * (5 * i + s)), me.push((t + 1) * (t + 2) / 2 % 64);
  let n = _0;
  for (let r = 0; r < 7; r++)
    e = (e << At ^ (e >> S0) * L0) % w0, e & g0 && (n ^= At << (At << BigInt(r)) - At);
  Ue.push(n);
}
const Ee = Ae(Ue, !0), I0 = Ee[0], B0 = Ee[1], Jt = (t, e, s) => s > 32 ? s0(t, e, s) : t0(t, e, s), Qt = (t, e, s) => s > 32 ? n0(t, e, s) : e0(t, e, s);
function m0(t, e = 24) {
  const s = new Uint32Array(10);
  for (let i = 24 - e; i < 24; i++) {
    for (let c = 0; c < 10; c++)
      s[c] = t[c] ^ t[c + 10] ^ t[c + 20] ^ t[c + 30] ^ t[c + 40];
    for (let c = 0; c < 10; c += 2) {
      const o = (c + 8) % 10, h = (c + 2) % 10, u = s[h], d = s[h + 1], f = Jt(u, d, 1) ^ s[o], y = Qt(u, d, 1) ^ s[o + 1];
      for (let p = 0; p < 50; p += 10)
        t[c + p] ^= f, t[c + p + 1] ^= y;
    }
    let n = t[2], r = t[3];
    for (let c = 0; c < 24; c++) {
      const o = me[c], h = Jt(n, r, o), u = Qt(n, r, o), d = Be[c];
      n = t[d], r = t[d + 1], t[d] = h, t[d + 1] = u;
    }
    for (let c = 0; c < 50; c += 10) {
      for (let o = 0; o < 10; o++)
        s[o] = t[c + o];
      for (let o = 0; o < 10; o++)
        t[c + o] ^= ~s[(o + 2) % 10] & s[(o + 4) % 10];
    }
    t[0] ^= I0[i], t[1] ^= B0[i];
  }
  J(s);
}
class jt {
  state;
  pos = 0;
  posOut = 0;
  finished = !1;
  state32;
  destroyed = !1;
  blockLen;
  suffix;
  outputLen;
  enableXOF = !1;
  rounds;
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, s, i, n = !1, r = 24) {
    if (this.blockLen = e, this.suffix = s, this.outputLen = i, this.enableXOF = n, this.rounds = r, Ut(i, "outputLen"), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = Fe(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Rt(this.state32), m0(this.state32, this.rounds), Rt(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Ht(this), ft(e);
    const { blockLen: s, state: i } = this, n = e.length;
    for (let r = 0; r < n; ) {
      const c = Math.min(s - this.pos, n - r);
      for (let o = 0; o < c; o++)
        i[this.pos++] ^= e[r++];
      this.pos === s && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: s, pos: i, blockLen: n } = this;
    e[i] ^= s, (s & 128) !== 0 && i === n - 1 && this.keccak(), e[n - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Ht(this, !1), ft(e), this.finish();
    const s = this.state, { blockLen: i } = this;
    for (let n = 0, r = e.length; n < r; ) {
      this.posOut >= i && this.keccak();
      const c = Math.min(i - this.posOut, r - n);
      e.set(s.subarray(this.posOut, this.posOut + c), n), this.posOut += c, n += c;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Ut(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (ie(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, J(this.state);
  }
  _cloneInto(e) {
    const { blockLen: s, suffix: i, outputLen: n, rounds: r, enableXOF: c } = this;
    return e ||= new jt(s, i, n, c, r), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = r, e.suffix = i, e.outputLen = n, e.enableXOF = c, e.destroyed = this.destroyed, e;
  }
}
const Ve = (t, e, s, i = {}) => tt((n = {}) => new jt(e, t, n.dkLen === void 0 ? s : n.dkLen, !0), i), j0 = /* @__PURE__ */ Ve(31, 168, 16, /* @__PURE__ */ dt(11)), P0 = /* @__PURE__ */ Ve(31, 136, 32, /* @__PURE__ */ dt(12));
var z = {}, F = {}, X = {}, Tt = {}, pt = {}, Yt;
function U0() {
  return Yt || (Yt = 1, Object.defineProperty(pt, "__esModule", { value: !0 }), pt.crypto = void 0, pt.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0), pt;
}
var Zt;
function Ct() {
  return Zt || (Zt = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.Hash = t.nextTick = t.swap32IfBE = t.byteSwapIfBE = t.swap8IfBE = t.isLE = void 0, t.isBytes = s, t.anumber = i, t.abytes = n, t.ahash = r, t.aexists = c, t.aoutput = o, t.u8 = h, t.u32 = u, t.clean = d, t.createView = f, t.rotr = y, t.rotl = p, t.byteSwap = g, t.byteSwap32 = S, t.bytesToHex = D, t.hexToBytes = A, t.asyncLoop = m, t.utf8ToBytes = V, t.bytesToUtf8 = l, t.toBytes = b, t.kdfInputToBytes = x, t.concatBytes = C, t.checkOpts = w, t.createHasher = v, t.createOptHasher = j, t.createXOFer = P, t.randomBytes = Q;
    const e = /* @__PURE__ */ U0();
    function s(a) {
      return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
    }
    function i(a) {
      if (!Number.isSafeInteger(a) || a < 0)
        throw new Error("positive integer expected, got " + a);
    }
    function n(a, ..._) {
      if (!s(a))
        throw new Error("Uint8Array expected");
      if (_.length > 0 && !_.includes(a.length))
        throw new Error("Uint8Array expected of length " + _ + ", got length=" + a.length);
    }
    function r(a) {
      if (typeof a != "function" || typeof a.create != "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      i(a.outputLen), i(a.blockLen);
    }
    function c(a, _ = !0) {
      if (a.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (_ && a.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function o(a, _) {
      n(a);
      const I = _.outputLen;
      if (a.length < I)
        throw new Error("digestInto() expects output buffer of length at least " + I);
    }
    function h(a) {
      return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    }
    function u(a) {
      return new Uint32Array(a.buffer, a.byteOffset, Math.floor(a.byteLength / 4));
    }
    function d(...a) {
      for (let _ = 0; _ < a.length; _++)
        a[_].fill(0);
    }
    function f(a) {
      return new DataView(a.buffer, a.byteOffset, a.byteLength);
    }
    function y(a, _) {
      return a << 32 - _ | a >>> _;
    }
    function p(a, _) {
      return a << _ | a >>> 32 - _ >>> 0;
    }
    t.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    function g(a) {
      return a << 24 & 4278190080 | a << 8 & 16711680 | a >>> 8 & 65280 | a >>> 24 & 255;
    }
    t.swap8IfBE = t.isLE ? (a) => a : (a) => g(a), t.byteSwapIfBE = t.swap8IfBE;
    function S(a) {
      for (let _ = 0; _ < a.length; _++)
        a[_] = g(a[_]);
      return a;
    }
    t.swap32IfBE = t.isLE ? (a) => a : S;
    const U = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", M = /* @__PURE__ */ Array.from({ length: 256 }, (a, _) => _.toString(16).padStart(2, "0"));
    function D(a) {
      if (n(a), U)
        return a.toHex();
      let _ = "";
      for (let I = 0; I < a.length; I++)
        _ += M[a[I]];
      return _;
    }
    const H = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function E(a) {
      if (a >= H._0 && a <= H._9)
        return a - H._0;
      if (a >= H.A && a <= H.F)
        return a - (H.A - 10);
      if (a >= H.a && a <= H.f)
        return a - (H.a - 10);
    }
    function A(a) {
      if (typeof a != "string")
        throw new Error("hex string expected, got " + typeof a);
      if (U)
        return Uint8Array.fromHex(a);
      const _ = a.length, I = _ / 2;
      if (_ % 2)
        throw new Error("hex string expected, got unpadded hex of length " + _);
      const O = new Uint8Array(I);
      for (let T = 0, R = 0; T < I; T++, R += 2) {
        const ut = E(a.charCodeAt(R)), Y = E(a.charCodeAt(R + 1));
        if (ut === void 0 || Y === void 0) {
          const Z = a[R] + a[R + 1];
          throw new Error('hex string expected, got non-hex character "' + Z + '" at index ' + R);
        }
        O[T] = ut * 16 + Y;
      }
      return O;
    }
    const L = async () => {
    };
    t.nextTick = L;
    async function m(a, _, I) {
      let O = Date.now();
      for (let T = 0; T < a; T++) {
        I(T);
        const R = Date.now() - O;
        R >= 0 && R < _ || (await (0, t.nextTick)(), O += R);
      }
    }
    function V(a) {
      if (typeof a != "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(a));
    }
    function l(a) {
      return new TextDecoder().decode(a);
    }
    function b(a) {
      return typeof a == "string" && (a = V(a)), n(a), a;
    }
    function x(a) {
      return typeof a == "string" && (a = V(a)), n(a), a;
    }
    function C(...a) {
      let _ = 0;
      for (let O = 0; O < a.length; O++) {
        const T = a[O];
        n(T), _ += T.length;
      }
      const I = new Uint8Array(_);
      for (let O = 0, T = 0; O < a.length; O++) {
        const R = a[O];
        I.set(R, T), T += R.length;
      }
      return I;
    }
    function w(a, _) {
      if (_ !== void 0 && {}.toString.call(_) !== "[object Object]")
        throw new Error("options should be object or undefined");
      return Object.assign(a, _);
    }
    class k {
    }
    t.Hash = k;
    function v(a) {
      const _ = (O) => a().update(b(O)).digest(), I = a();
      return _.outputLen = I.outputLen, _.blockLen = I.blockLen, _.create = () => a(), _;
    }
    function j(a) {
      const _ = (O, T) => a(T).update(b(O)).digest(), I = a({});
      return _.outputLen = I.outputLen, _.blockLen = I.blockLen, _.create = (O) => a(O), _;
    }
    function P(a) {
      const _ = (O, T) => a(T).update(b(O)).digest(), I = a({});
      return _.outputLen = I.outputLen, _.blockLen = I.blockLen, _.create = (O) => a(O), _;
    }
    t.wrapConstructor = v, t.wrapConstructorWithOpts = j, t.wrapXOFConstructorWithOpts = P;
    function Q(a = 32) {
      if (e.crypto && typeof e.crypto.getRandomValues == "function")
        return e.crypto.getRandomValues(new Uint8Array(a));
      if (e.crypto && typeof e.crypto.randomBytes == "function")
        return Uint8Array.from(e.crypto.randomBytes(a));
      throw new Error("crypto.getRandomValues must be defined");
    }
  })(Tt)), Tt;
}
var zt;
function E0() {
  if (zt) return X;
  zt = 1, Object.defineProperty(X, "__esModule", { value: !0 }), X.SHA512_IV = X.SHA384_IV = X.SHA224_IV = X.SHA256_IV = X.HashMD = void 0, X.setBigUint64 = e, X.Chi = s, X.Maj = i;
  const t = /* @__PURE__ */ Ct();
  function e(r, c, o, h) {
    if (typeof r.setBigUint64 == "function")
      return r.setBigUint64(c, o, h);
    const u = BigInt(32), d = BigInt(4294967295), f = Number(o >> u & d), y = Number(o & d), p = h ? 4 : 0, g = h ? 0 : 4;
    r.setUint32(c + p, f, h), r.setUint32(c + g, y, h);
  }
  function s(r, c, o) {
    return r & c ^ ~r & o;
  }
  function i(r, c, o) {
    return r & c ^ r & o ^ c & o;
  }
  class n extends t.Hash {
    constructor(c, o, h, u) {
      super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = c, this.outputLen = o, this.padOffset = h, this.isLE = u, this.buffer = new Uint8Array(c), this.view = (0, t.createView)(this.buffer);
    }
    update(c) {
      (0, t.aexists)(this), c = (0, t.toBytes)(c), (0, t.abytes)(c);
      const { view: o, buffer: h, blockLen: u } = this, d = c.length;
      for (let f = 0; f < d; ) {
        const y = Math.min(u - this.pos, d - f);
        if (y === u) {
          const p = (0, t.createView)(c);
          for (; u <= d - f; f += u)
            this.process(p, f);
          continue;
        }
        h.set(c.subarray(f, f + y), this.pos), this.pos += y, f += y, this.pos === u && (this.process(o, 0), this.pos = 0);
      }
      return this.length += c.length, this.roundClean(), this;
    }
    digestInto(c) {
      (0, t.aexists)(this), (0, t.aoutput)(c, this), this.finished = !0;
      const { buffer: o, view: h, blockLen: u, isLE: d } = this;
      let { pos: f } = this;
      o[f++] = 128, (0, t.clean)(this.buffer.subarray(f)), this.padOffset > u - f && (this.process(h, 0), f = 0);
      for (let U = f; U < u; U++)
        o[U] = 0;
      e(h, u - 8, BigInt(this.length * 8), d), this.process(h, 0);
      const y = (0, t.createView)(c), p = this.outputLen;
      if (p % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const g = p / 4, S = this.get();
      if (g > S.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let U = 0; U < g; U++)
        y.setUint32(4 * U, S[U], d);
    }
    digest() {
      const { buffer: c, outputLen: o } = this;
      this.digestInto(c);
      const h = c.slice(0, o);
      return this.destroy(), h;
    }
    _cloneInto(c) {
      c || (c = new this.constructor()), c.set(...this.get());
      const { blockLen: o, buffer: h, length: u, finished: d, destroyed: f, pos: y } = this;
      return c.destroyed = f, c.finished = d, c.length = u, c.pos = y, u % o && c.buffer.set(h), c;
    }
    clone() {
      return this._cloneInto();
    }
  }
  return X.HashMD = n, X.SHA256_IV = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]), X.SHA224_IV = Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]), X.SHA384_IV = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]), X.SHA512_IV = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]), X;
}
var B = {}, $t;
function V0() {
  if ($t) return B;
  $t = 1, Object.defineProperty(B, "__esModule", { value: !0 }), B.toBig = B.shrSL = B.shrSH = B.rotrSL = B.rotrSH = B.rotrBL = B.rotrBH = B.rotr32L = B.rotr32H = B.rotlSL = B.rotlSH = B.rotlBL = B.rotlBH = B.add5L = B.add5H = B.add4L = B.add4H = B.add3L = B.add3H = void 0, B.add = M, B.fromBig = s, B.split = i;
  const t = /* @__PURE__ */ BigInt(2 ** 32 - 1), e = /* @__PURE__ */ BigInt(32);
  function s(l, b = !1) {
    return b ? { h: Number(l & t), l: Number(l >> e & t) } : { h: Number(l >> e & t) | 0, l: Number(l & t) | 0 };
  }
  function i(l, b = !1) {
    const x = l.length;
    let C = new Uint32Array(x), w = new Uint32Array(x);
    for (let k = 0; k < x; k++) {
      const { h: v, l: j } = s(l[k], b);
      [C[k], w[k]] = [v, j];
    }
    return [C, w];
  }
  const n = (l, b) => BigInt(l >>> 0) << e | BigInt(b >>> 0);
  B.toBig = n;
  const r = (l, b, x) => l >>> x;
  B.shrSH = r;
  const c = (l, b, x) => l << 32 - x | b >>> x;
  B.shrSL = c;
  const o = (l, b, x) => l >>> x | b << 32 - x;
  B.rotrSH = o;
  const h = (l, b, x) => l << 32 - x | b >>> x;
  B.rotrSL = h;
  const u = (l, b, x) => l << 64 - x | b >>> x - 32;
  B.rotrBH = u;
  const d = (l, b, x) => l >>> x - 32 | b << 64 - x;
  B.rotrBL = d;
  const f = (l, b) => b;
  B.rotr32H = f;
  const y = (l, b) => l;
  B.rotr32L = y;
  const p = (l, b, x) => l << x | b >>> 32 - x;
  B.rotlSH = p;
  const g = (l, b, x) => b << x | l >>> 32 - x;
  B.rotlSL = g;
  const S = (l, b, x) => b << x - 32 | l >>> 64 - x;
  B.rotlBH = S;
  const U = (l, b, x) => l << x - 32 | b >>> 64 - x;
  B.rotlBL = U;
  function M(l, b, x, C) {
    const w = (b >>> 0) + (C >>> 0);
    return { h: l + x + (w / 2 ** 32 | 0) | 0, l: w | 0 };
  }
  const D = (l, b, x) => (l >>> 0) + (b >>> 0) + (x >>> 0);
  B.add3L = D;
  const H = (l, b, x, C) => b + x + C + (l / 2 ** 32 | 0) | 0;
  B.add3H = H;
  const E = (l, b, x, C) => (l >>> 0) + (b >>> 0) + (x >>> 0) + (C >>> 0);
  B.add4L = E;
  const A = (l, b, x, C, w) => b + x + C + w + (l / 2 ** 32 | 0) | 0;
  B.add4H = A;
  const L = (l, b, x, C, w) => (l >>> 0) + (b >>> 0) + (x >>> 0) + (C >>> 0) + (w >>> 0);
  B.add5L = L;
  const m = (l, b, x, C, w, k) => b + x + C + w + k + (l / 2 ** 32 | 0) | 0;
  B.add5H = m;
  const V = {
    fromBig: s,
    split: i,
    toBig: n,
    shrSH: r,
    shrSL: c,
    rotrSH: o,
    rotrSL: h,
    rotrBH: u,
    rotrBL: d,
    rotr32H: f,
    rotr32L: y,
    rotlSH: p,
    rotlSL: g,
    rotlBH: S,
    rotlBL: U,
    add: M,
    add3L: D,
    add3H: H,
    add4L: E,
    add4H: A,
    add5H: m,
    add5L: L
  };
  return B.default = V, B;
}
var te;
function Ce() {
  if (te) return F;
  te = 1, Object.defineProperty(F, "__esModule", { value: !0 }), F.sha512_224 = F.sha512_256 = F.sha384 = F.sha512 = F.sha224 = F.sha256 = F.SHA512_256 = F.SHA512_224 = F.SHA384 = F.SHA512 = F.SHA224 = F.SHA256 = void 0;
  const t = /* @__PURE__ */ E0(), e = /* @__PURE__ */ V0(), s = /* @__PURE__ */ Ct(), i = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), n = /* @__PURE__ */ new Uint32Array(64);
  class r extends t.HashMD {
    constructor(H = 32) {
      super(64, H, 8, !1), this.A = t.SHA256_IV[0] | 0, this.B = t.SHA256_IV[1] | 0, this.C = t.SHA256_IV[2] | 0, this.D = t.SHA256_IV[3] | 0, this.E = t.SHA256_IV[4] | 0, this.F = t.SHA256_IV[5] | 0, this.G = t.SHA256_IV[6] | 0, this.H = t.SHA256_IV[7] | 0;
    }
    get() {
      const { A: H, B: E, C: A, D: L, E: m, F: V, G: l, H: b } = this;
      return [H, E, A, L, m, V, l, b];
    }
    // prettier-ignore
    set(H, E, A, L, m, V, l, b) {
      this.A = H | 0, this.B = E | 0, this.C = A | 0, this.D = L | 0, this.E = m | 0, this.F = V | 0, this.G = l | 0, this.H = b | 0;
    }
    process(H, E) {
      for (let w = 0; w < 16; w++, E += 4)
        n[w] = H.getUint32(E, !1);
      for (let w = 16; w < 64; w++) {
        const k = n[w - 15], v = n[w - 2], j = (0, s.rotr)(k, 7) ^ (0, s.rotr)(k, 18) ^ k >>> 3, P = (0, s.rotr)(v, 17) ^ (0, s.rotr)(v, 19) ^ v >>> 10;
        n[w] = P + n[w - 7] + j + n[w - 16] | 0;
      }
      let { A, B: L, C: m, D: V, E: l, F: b, G: x, H: C } = this;
      for (let w = 0; w < 64; w++) {
        const k = (0, s.rotr)(l, 6) ^ (0, s.rotr)(l, 11) ^ (0, s.rotr)(l, 25), v = C + k + (0, t.Chi)(l, b, x) + i[w] + n[w] | 0, P = ((0, s.rotr)(A, 2) ^ (0, s.rotr)(A, 13) ^ (0, s.rotr)(A, 22)) + (0, t.Maj)(A, L, m) | 0;
        C = x, x = b, b = l, l = V + v | 0, V = m, m = L, L = A, A = v + P | 0;
      }
      A = A + this.A | 0, L = L + this.B | 0, m = m + this.C | 0, V = V + this.D | 0, l = l + this.E | 0, b = b + this.F | 0, x = x + this.G | 0, C = C + this.H | 0, this.set(A, L, m, V, l, b, x, C);
    }
    roundClean() {
      (0, s.clean)(n);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), (0, s.clean)(this.buffer);
    }
  }
  F.SHA256 = r;
  class c extends r {
    constructor() {
      super(28), this.A = t.SHA224_IV[0] | 0, this.B = t.SHA224_IV[1] | 0, this.C = t.SHA224_IV[2] | 0, this.D = t.SHA224_IV[3] | 0, this.E = t.SHA224_IV[4] | 0, this.F = t.SHA224_IV[5] | 0, this.G = t.SHA224_IV[6] | 0, this.H = t.SHA224_IV[7] | 0;
    }
  }
  F.SHA224 = c;
  const o = e.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((D) => BigInt(D))), h = o[0], u = o[1], d = /* @__PURE__ */ new Uint32Array(80), f = /* @__PURE__ */ new Uint32Array(80);
  class y extends t.HashMD {
    constructor(H = 64) {
      super(128, H, 16, !1), this.Ah = t.SHA512_IV[0] | 0, this.Al = t.SHA512_IV[1] | 0, this.Bh = t.SHA512_IV[2] | 0, this.Bl = t.SHA512_IV[3] | 0, this.Ch = t.SHA512_IV[4] | 0, this.Cl = t.SHA512_IV[5] | 0, this.Dh = t.SHA512_IV[6] | 0, this.Dl = t.SHA512_IV[7] | 0, this.Eh = t.SHA512_IV[8] | 0, this.El = t.SHA512_IV[9] | 0, this.Fh = t.SHA512_IV[10] | 0, this.Fl = t.SHA512_IV[11] | 0, this.Gh = t.SHA512_IV[12] | 0, this.Gl = t.SHA512_IV[13] | 0, this.Hh = t.SHA512_IV[14] | 0, this.Hl = t.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah: H, Al: E, Bh: A, Bl: L, Ch: m, Cl: V, Dh: l, Dl: b, Eh: x, El: C, Fh: w, Fl: k, Gh: v, Gl: j, Hh: P, Hl: Q } = this;
      return [H, E, A, L, m, V, l, b, x, C, w, k, v, j, P, Q];
    }
    // prettier-ignore
    set(H, E, A, L, m, V, l, b, x, C, w, k, v, j, P, Q) {
      this.Ah = H | 0, this.Al = E | 0, this.Bh = A | 0, this.Bl = L | 0, this.Ch = m | 0, this.Cl = V | 0, this.Dh = l | 0, this.Dl = b | 0, this.Eh = x | 0, this.El = C | 0, this.Fh = w | 0, this.Fl = k | 0, this.Gh = v | 0, this.Gl = j | 0, this.Hh = P | 0, this.Hl = Q | 0;
    }
    process(H, E) {
      for (let I = 0; I < 16; I++, E += 4)
        d[I] = H.getUint32(E), f[I] = H.getUint32(E += 4);
      for (let I = 16; I < 80; I++) {
        const O = d[I - 15] | 0, T = f[I - 15] | 0, R = e.rotrSH(O, T, 1) ^ e.rotrSH(O, T, 8) ^ e.shrSH(O, T, 7), ut = e.rotrSL(O, T, 1) ^ e.rotrSL(O, T, 8) ^ e.shrSL(O, T, 7), Y = d[I - 2] | 0, Z = f[I - 2] | 0, gt = e.rotrSH(Y, Z, 19) ^ e.rotrBH(Y, Z, 61) ^ e.shrSH(Y, Z, 6), kt = e.rotrSL(Y, Z, 19) ^ e.rotrBL(Y, Z, 61) ^ e.shrSL(Y, Z, 6), St = e.add4L(ut, kt, f[I - 7], f[I - 16]), Ot = e.add4H(St, R, gt, d[I - 7], d[I - 16]);
        d[I] = Ot | 0, f[I] = St | 0;
      }
      let { Ah: A, Al: L, Bh: m, Bl: V, Ch: l, Cl: b, Dh: x, Dl: C, Eh: w, El: k, Fh: v, Fl: j, Gh: P, Gl: Q, Hh: a, Hl: _ } = this;
      for (let I = 0; I < 80; I++) {
        const O = e.rotrSH(w, k, 14) ^ e.rotrSH(w, k, 18) ^ e.rotrBH(w, k, 41), T = e.rotrSL(w, k, 14) ^ e.rotrSL(w, k, 18) ^ e.rotrBL(w, k, 41), R = w & v ^ ~w & P, ut = k & j ^ ~k & Q, Y = e.add5L(_, T, ut, u[I], f[I]), Z = e.add5H(Y, a, O, R, h[I], d[I]), gt = Y | 0, kt = e.rotrSH(A, L, 28) ^ e.rotrBH(A, L, 34) ^ e.rotrBH(A, L, 39), St = e.rotrSL(A, L, 28) ^ e.rotrBL(A, L, 34) ^ e.rotrBL(A, L, 39), Ot = A & m ^ A & l ^ m & l, ke = L & V ^ L & b ^ V & b;
        a = P | 0, _ = Q | 0, P = v | 0, Q = j | 0, v = w | 0, j = k | 0, { h: w, l: k } = e.add(x | 0, C | 0, Z | 0, gt | 0), x = l | 0, C = b | 0, l = m | 0, b = V | 0, m = A | 0, V = L | 0;
        const Pt = e.add3L(gt, St, ke);
        A = e.add3H(Pt, Z, kt, Ot), L = Pt | 0;
      }
      ({ h: A, l: L } = e.add(this.Ah | 0, this.Al | 0, A | 0, L | 0)), { h: m, l: V } = e.add(this.Bh | 0, this.Bl | 0, m | 0, V | 0), { h: l, l: b } = e.add(this.Ch | 0, this.Cl | 0, l | 0, b | 0), { h: x, l: C } = e.add(this.Dh | 0, this.Dl | 0, x | 0, C | 0), { h: w, l: k } = e.add(this.Eh | 0, this.El | 0, w | 0, k | 0), { h: v, l: j } = e.add(this.Fh | 0, this.Fl | 0, v | 0, j | 0), { h: P, l: Q } = e.add(this.Gh | 0, this.Gl | 0, P | 0, Q | 0), { h: a, l: _ } = e.add(this.Hh | 0, this.Hl | 0, a | 0, _ | 0), this.set(A, L, m, V, l, b, x, C, w, k, v, j, P, Q, a, _);
    }
    roundClean() {
      (0, s.clean)(d, f);
    }
    destroy() {
      (0, s.clean)(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }
  F.SHA512 = y;
  class p extends y {
    constructor() {
      super(48), this.Ah = t.SHA384_IV[0] | 0, this.Al = t.SHA384_IV[1] | 0, this.Bh = t.SHA384_IV[2] | 0, this.Bl = t.SHA384_IV[3] | 0, this.Ch = t.SHA384_IV[4] | 0, this.Cl = t.SHA384_IV[5] | 0, this.Dh = t.SHA384_IV[6] | 0, this.Dl = t.SHA384_IV[7] | 0, this.Eh = t.SHA384_IV[8] | 0, this.El = t.SHA384_IV[9] | 0, this.Fh = t.SHA384_IV[10] | 0, this.Fl = t.SHA384_IV[11] | 0, this.Gh = t.SHA384_IV[12] | 0, this.Gl = t.SHA384_IV[13] | 0, this.Hh = t.SHA384_IV[14] | 0, this.Hl = t.SHA384_IV[15] | 0;
    }
  }
  F.SHA384 = p;
  const g = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]), S = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  class U extends y {
    constructor() {
      super(28), this.Ah = g[0] | 0, this.Al = g[1] | 0, this.Bh = g[2] | 0, this.Bl = g[3] | 0, this.Ch = g[4] | 0, this.Cl = g[5] | 0, this.Dh = g[6] | 0, this.Dl = g[7] | 0, this.Eh = g[8] | 0, this.El = g[9] | 0, this.Fh = g[10] | 0, this.Fl = g[11] | 0, this.Gh = g[12] | 0, this.Gl = g[13] | 0, this.Hh = g[14] | 0, this.Hl = g[15] | 0;
    }
  }
  F.SHA512_224 = U;
  class M extends y {
    constructor() {
      super(32), this.Ah = S[0] | 0, this.Al = S[1] | 0, this.Bh = S[2] | 0, this.Bl = S[3] | 0, this.Ch = S[4] | 0, this.Cl = S[5] | 0, this.Dh = S[6] | 0, this.Dl = S[7] | 0, this.Eh = S[8] | 0, this.El = S[9] | 0, this.Fh = S[10] | 0, this.Fl = S[11] | 0, this.Gh = S[12] | 0, this.Gl = S[13] | 0, this.Hh = S[14] | 0, this.Hl = S[15] | 0;
    }
  }
  return F.SHA512_256 = M, F.sha256 = (0, s.createHasher)(() => new r()), F.sha224 = (0, s.createHasher)(() => new c()), F.sha512 = (0, s.createHasher)(() => new y()), F.sha384 = (0, s.createHasher)(() => new p()), F.sha512_256 = (0, s.createHasher)(() => new M()), F.sha512_224 = (0, s.createHasher)(() => new U()), F;
}
var ee;
function R0() {
  if (ee) return z;
  ee = 1, Object.defineProperty(z, "__esModule", { value: !0 }), z.sha224 = z.SHA224 = z.sha256 = z.SHA256 = void 0;
  const t = /* @__PURE__ */ Ce();
  return z.SHA256 = t.SHA256, z.sha256 = t.sha256, z.SHA224 = t.SHA224, z.sha224 = t.sha224, z;
}
var G = {}, se;
function W0() {
  if (se) return G;
  se = 1, Object.defineProperty(G, "__esModule", { value: !0 }), G.sha512_256 = G.SHA512_256 = G.sha512_224 = G.SHA512_224 = G.sha384 = G.SHA384 = G.sha512 = G.SHA512 = void 0;
  const t = /* @__PURE__ */ Ce();
  return G.SHA512 = t.SHA512, G.sha512 = t.sha512, G.SHA384 = t.SHA384, G.sha384 = t.sha384, G.SHA512_224 = t.SHA512_224, G.sha512_224 = t.sha512_224, G.SHA512_256 = t.SHA512_256, G.sha512_256 = t.sha512_256, G;
}
var yt = {}, vt = {}, ne;
function C0() {
  return ne || (ne = 1, (function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.hmac = t.HMAC = void 0;
    const e = /* @__PURE__ */ Ct();
    class s extends e.Hash {
      constructor(r, c) {
        super(), this.finished = !1, this.destroyed = !1, (0, e.ahash)(r);
        const o = (0, e.toBytes)(c);
        if (this.iHash = r.create(), typeof this.iHash.update != "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const h = this.blockLen, u = new Uint8Array(h);
        u.set(o.length > h ? r.create().update(o).digest() : o);
        for (let d = 0; d < u.length; d++)
          u[d] ^= 54;
        this.iHash.update(u), this.oHash = r.create();
        for (let d = 0; d < u.length; d++)
          u[d] ^= 106;
        this.oHash.update(u), (0, e.clean)(u);
      }
      update(r) {
        return (0, e.aexists)(this), this.iHash.update(r), this;
      }
      digestInto(r) {
        (0, e.aexists)(this), (0, e.abytes)(r, this.outputLen), this.finished = !0, this.iHash.digestInto(r), this.oHash.update(r), this.oHash.digestInto(r), this.destroy();
      }
      digest() {
        const r = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(r), r;
      }
      _cloneInto(r) {
        r || (r = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: c, iHash: o, finished: h, destroyed: u, blockLen: d, outputLen: f } = this;
        return r = r, r.finished = h, r.destroyed = u, r.blockLen = d, r.outputLen = f, r.oHash = c._cloneInto(r.oHash), r.iHash = o._cloneInto(r.iHash), r;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
      }
    }
    t.HMAC = s;
    const i = (n, r, c) => new s(n, r).update(c).digest();
    t.hmac = i, t.hmac.create = (n, r) => new s(n, r);
  })(vt)), vt;
}
var re;
function q0() {
  if (re) return yt;
  re = 1, Object.defineProperty(yt, "__esModule", { value: !0 }), yt.pbkdf2 = n, yt.pbkdf2Async = r;
  const t = /* @__PURE__ */ C0(), e = /* @__PURE__ */ Ct();
  function s(c, o, h, u) {
    (0, e.ahash)(c);
    const d = (0, e.checkOpts)({ dkLen: 32, asyncTick: 10 }, u), { c: f, dkLen: y, asyncTick: p } = d;
    if ((0, e.anumber)(f), (0, e.anumber)(y), (0, e.anumber)(p), f < 1)
      throw new Error("iterations (c) should be >= 1");
    const g = (0, e.kdfInputToBytes)(o), S = (0, e.kdfInputToBytes)(h), U = new Uint8Array(y), M = t.hmac.create(c, g), D = M._cloneInto().update(S);
    return { c: f, dkLen: y, asyncTick: p, DK: U, PRF: M, PRFSalt: D };
  }
  function i(c, o, h, u, d) {
    return c.destroy(), o.destroy(), u && u.destroy(), (0, e.clean)(d), h;
  }
  function n(c, o, h, u) {
    const { c: d, dkLen: f, DK: y, PRF: p, PRFSalt: g } = s(c, o, h, u);
    let S;
    const U = new Uint8Array(4), M = (0, e.createView)(U), D = new Uint8Array(p.outputLen);
    for (let H = 1, E = 0; E < f; H++, E += p.outputLen) {
      const A = y.subarray(E, E + p.outputLen);
      M.setInt32(0, H, !1), (S = g._cloneInto(S)).update(U).digestInto(D), A.set(D.subarray(0, A.length));
      for (let L = 1; L < d; L++) {
        p._cloneInto(S).update(D).digestInto(D);
        for (let m = 0; m < A.length; m++)
          A[m] ^= D[m];
      }
    }
    return i(p, g, y, S, D);
  }
  async function r(c, o, h, u) {
    const { c: d, dkLen: f, asyncTick: y, DK: p, PRF: g, PRFSalt: S } = s(c, o, h, u);
    let U;
    const M = new Uint8Array(4), D = (0, e.createView)(M), H = new Uint8Array(g.outputLen);
    for (let E = 1, A = 0; A < f; E++, A += g.outputLen) {
      const L = p.subarray(A, A + g.outputLen);
      D.setInt32(0, E, !1), (U = S._cloneInto(U)).update(M).digestInto(H), L.set(H.subarray(0, L.length)), await (0, e.asyncLoop)(d - 1, y, () => {
        g._cloneInto(U).update(H).digestInto(H);
        for (let m = 0; m < L.length; m++)
          L[m] ^= H[m];
      });
    }
    return i(g, S, p, U, H);
  }
  return yt;
}
export {
  G0 as a,
  v0 as b,
  T0 as c,
  ft as d,
  F0 as e,
  j0 as f,
  Mt as g,
  P0 as h,
  Oe as i,
  k0 as j,
  q0 as k,
  W0 as l,
  R0 as m,
  Ct as n,
  O0 as o,
  Ut as p,
  D0 as q,
  M0 as r,
  l0 as s,
  De as t,
  oe as u,
  x0 as v
};
