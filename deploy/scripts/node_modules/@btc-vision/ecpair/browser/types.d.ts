import { Bytes20, Bytes32, MessageHash, PrivateKey, PublicKey, Satoshi, SchnorrSignature, Signature, XOnlyPublicKey } from './branded.js';
/**
 * Decodes a hexadecimal string into a `Uint8Array`.
 *
 * @param hex - Even-length hex string (case-insensitive).
 * @returns Decoded bytes.
 * @throws {TypeError} On odd-length input or invalid hex characters.
 */
export declare function fromHexInternal(hex: string): Uint8Array;
/**
 * Returns `true` if every byte in `bytes` is zero.
 * @param bytes - Input to test.
 */
export declare function isZeroBytes(bytes: Uint8Array): boolean;
/**
 * Lexicographic comparison of two byte arrays.
 *
 * @returns `-1` if `a < b`, `0` if equal, `1` if `a > b`.
 */
export declare function compareBytes(a: Uint8Array, b: Uint8Array): number;
/**
 * Returns `true` if `a` and `b` have identical length and contents.
 */
export declare function bytesEqual(a: Uint8Array, b: Uint8Array): boolean;
/**
 * Encodes `bytes` as a lowercase hexadecimal string.
 */
export declare function toHex(bytes: Uint8Array): string;
/**
 * Concatenates one or more `Uint8Array` values into a single array.
 * @param arrays - Arrays to concatenate (in order).
 */
export declare function concatBytes(...arrays: Uint8Array[]): Uint8Array;
/** secp256k1 curve order `n`. */
export declare const EC_N: bigint;
/** secp256k1 field prime `p`. */
export declare const EC_P: bigint;
/** Maximum satoshi value (`21_000_000 * 10^8`). */
export declare const SATOSHI_MAX: bigint;
/**
 * Type guard for {@link Bytes32}.
 * @param value - Value to test.
 */
export declare function isBytes32(value: unknown): value is Bytes32;
/**
 * Type guard for {@link Bytes20}.
 * @param value - Value to test.
 */
export declare function isBytes20(value: unknown): value is Bytes20;
/**
 * Type guard for {@link PrivateKey}.
 *
 * Returns `true` when `value` is a 32-byte `Uint8Array` whose numeric
 * value falls in the range `[1, n)`.
 * @param value - Value to test.
 */
export declare function isPrivateKey(value: unknown): value is PrivateKey;
/**
 * Type guard for {@link PublicKey}.
 *
 * Accepts compressed (`02`/`03`, 33 bytes), uncompressed (`04`, 65 bytes),
 * and hybrid (`06`/`07`, 65 bytes) SEC1 encodings.
 * @param value - Value to test.
 */
export declare function isPublicKey(value: unknown): value is PublicKey;
/**
 * Type guard for {@link XOnlyPublicKey}.
 *
 * Returns `true` when `value` is a non-zero 32-byte `Uint8Array`.
 * @param value - Value to test.
 */
export declare function isXOnlyPublicKey(value: unknown): value is XOnlyPublicKey;
/**
 * Type guard for {@link Signature}.
 *
 * Accepts compact ECDSA signatures (8 -- 73 bytes).
 * @param value - Value to test.
 */
export declare function isSignature(value: unknown): value is Signature;
/**
 * Type guard for {@link SchnorrSignature} (exactly 64 bytes).
 * @param value - Value to test.
 */
export declare function isSchnorrSignature(value: unknown): value is SchnorrSignature;
/**
 * Type guard for {@link MessageHash} (exactly 32 bytes).
 * @param value - Value to test.
 */
export declare function isMessageHash(value: unknown): value is MessageHash;
/**
 * Type guard for {@link Satoshi}.
 *
 * Returns `true` when `value` is a `bigint` in the range `[0, SATOSHI_MAX]`.
 * @param value - Value to test.
 */
export declare function isSatoshi(value: unknown): value is Satoshi;
/**
 * Asserts that `value` is a {@link Bytes32}.
 * @throws {TypeError} If the assertion fails.
 */
export declare function assertBytes32(value: unknown): asserts value is Bytes32;
/**
 * Asserts that `value` is a valid {@link PrivateKey} (32 bytes, in `[1, n)`).
 * @throws {TypeError} If the assertion fails.
 */
export declare function assertPrivateKey(value: unknown): asserts value is PrivateKey;
/**
 * Asserts that `value` is a valid SEC1-encoded {@link PublicKey}.
 * @throws {TypeError} If the assertion fails.
 */
export declare function assertPublicKey(value: unknown): asserts value is PublicKey;
/**
 * Asserts that `value` is a valid {@link XOnlyPublicKey} (32 non-zero bytes).
 * @throws {TypeError} If the assertion fails.
 */
export declare function assertXOnlyPublicKey(value: unknown): asserts value is XOnlyPublicKey;
/**
 * Asserts that `value` is a valid {@link MessageHash} (exactly 32 bytes).
 * @throws {TypeError} If the assertion fails.
 */
export declare function assertMessageHash(value: unknown): asserts value is MessageHash;
/**
 * Creates a branded {@link Bytes32} after validating length.
 * @param bytes - Raw bytes (must be exactly 32).
 * @throws {TypeError} If validation fails.
 */
export declare function createBytes32(bytes: Uint8Array): Bytes32;
/**
 * Creates a branded {@link Bytes20} after validating length.
 * @param bytes - Raw bytes (must be exactly 20).
 * @throws {TypeError} If validation fails.
 */
export declare function createBytes20(bytes: Uint8Array): Bytes20;
/**
 * Creates a branded {@link PrivateKey} after validating range `[1, n)`.
 * @param bytes - Raw bytes (must be 32 bytes, non-zero, `< n`).
 * @throws {TypeError} If validation fails.
 */
export declare function createPrivateKey(bytes: Uint8Array): PrivateKey;
/**
 * Creates a branded {@link PublicKey} after validating SEC1 encoding.
 * @param bytes - Compressed, uncompressed, or hybrid SEC1 public key.
 * @throws {TypeError} If validation fails.
 */
export declare function createPublicKey(bytes: Uint8Array): PublicKey;
/**
 * Creates a branded {@link XOnlyPublicKey} after validating 32 non-zero bytes.
 * @param bytes - Raw 32-byte x-coordinate.
 * @throws {TypeError} If validation fails.
 */
export declare function createXOnlyPublicKey(bytes: Uint8Array): XOnlyPublicKey;
/**
 * Creates a branded {@link Signature} after validating length (8 -- 73 bytes).
 * @param bytes - Compact ECDSA signature bytes.
 * @throws {TypeError} If validation fails.
 */
export declare function createSignature(bytes: Uint8Array): Signature;
/**
 * Creates a branded {@link SchnorrSignature} after validating 64-byte length.
 * @param bytes - BIP-340 Schnorr signature bytes.
 * @throws {TypeError} If validation fails.
 */
export declare function createSchnorrSignature(bytes: Uint8Array): SchnorrSignature;
/**
 * Creates a branded {@link MessageHash} after validating 32-byte length.
 * @param bytes - Hash digest bytes.
 * @throws {TypeError} If validation fails.
 */
export declare function createMessageHash(bytes: Uint8Array): MessageHash;
/**
 * Creates a branded {@link Satoshi} after validating `[0, SATOSHI_MAX]`.
 * @param value - Amount in satoshis.
 * @throws {TypeError} If `value` is out of range.
 */
export declare function createSatoshi(value: bigint): Satoshi;
//# sourceMappingURL=types.d.ts.map