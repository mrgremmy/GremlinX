import { SignerCapability } from './capability.js';
import { assertBytes32, concatBytes, createPrivateKey, createPublicKey, createXOnlyPublicKey, EC_N, } from './types.js';
import { decodeWIF, encodeWIF } from './wif.js';
/**
 * Returns `true` when the SEC1 public key has an odd Y coordinate.
 *
 * Handles compressed (prefix `0x03`) and uncompressed (prefix `0x04`,
 * 65 bytes, last byte odd) encodings.
 */
function hasOddY(pubKey) {
    if (pubKey[0] === 0x03)
        return true;
    if (pubKey[0] === 0x04 && pubKey.length === 65) {
        return (pubKey[64] & 1) === 1;
    }
    return false;
}
/**
 * Extracts the 32-byte x-only public key from a SEC1-encoded key and
 * returns it as a validated {@link XOnlyPublicKey}.
 *
 * @param pubKey - Compressed (33 bytes) or x-only (32 bytes) public key.
 * @returns Branded 32-byte x-only public key.
 */
function toXOnly(pubKey) {
    const raw = pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
    return createXOnlyPublicKey(raw);
}
/**
 * FIPS 186-5 B.4.2 / RFC 9380 seed length.
 *
 * `fieldLen + ceil(fieldLen / 2)` = 32 + 16 = 48 bytes.
 * The extra bytes eliminate modular bias to below 2^-128.
 */
const FIPS_SEED_LENGTH = 48;
/**
 * Interprets a byte array as a big-endian unsigned integer.
 */
function bytesToBigInt(bytes) {
    let result = 0n;
    for (let i = 0; i < bytes.length; i++) {
        result = (result << 8n) | BigInt(bytes[i]);
    }
    return result;
}
/**
 * Encodes a bigint as a 32-byte big-endian `Uint8Array`.
 */
function bigintToBytes32(n) {
    const out = new Uint8Array(32);
    for (let i = 31; i >= 0; i--) {
        out[i] = Number(n & 0xffn);
        n >>= 8n;
    }
    return out;
}
/**
 * Concrete secp256k1 key-pair signer backed by a {@link CryptoBackend}.
 *
 * Instances are created exclusively through the static factory methods
 * ({@link ECPairSigner.fromPrivateKey}, {@link ECPairSigner.fromPublicKey},
 * {@link ECPairSigner.fromWIF}, {@link ECPairSigner.makeRandom}).
 *
 * @example
 * ```ts
 * import { ECPairSigner, createNobleBackend } from 'ecpair';
 *
 * const backend = createNobleBackend();
 * const signer  = ECPairSigner.makeRandom(backend, bitcoin);
 * const sig     = signer.sign(messageHash);
 * ```
 */
export class ECPairSigner {
    #backend;
    #privateKey;
    #network;
    #compressed;
    #publicKey;
    #xOnlyPublicKey;
    #capabilities;
    constructor(backend, privateKey, publicKey, network, options) {
        if (options?.compressed !== undefined && typeof options.compressed !== 'boolean') {
            throw new TypeError(`Expected boolean for compressed, got ${typeof options.compressed}`);
        }
        this.#backend = backend;
        this.#privateKey = privateKey;
        this.#compressed = options?.compressed ?? true;
        this.#network = network;
        if (publicKey !== undefined) {
            this.#publicKey = backend.pointCompress(publicKey, this.#compressed);
        }
    }
    /** Raw private key bytes, or `undefined` for public-key-only signers. */
    get privateKey() {
        return this.#privateKey;
    }
    /**
     * SEC1-encoded public key.  Lazily derived from the private key when
     * the signer was created via {@link fromPrivateKey} or {@link fromWIF}.
     *
     * @throws If neither a private nor public key is available (should never happen).
     */
    get publicKey() {
        if (this.#publicKey === undefined) {
            const pk = this.#privateKey;
            if (pk === undefined) {
                throw new Error('Missing both private and public key');
            }
            const p = this.#backend.pointFromScalar(pk, this.#compressed);
            if (p === null) {
                throw new Error('Failed to derive public key from private key');
            }
            this.#publicKey = p;
        }
        return this.#publicKey;
    }
    /** 32-byte BIP-340 x-only public key (lazily derived and cached). */
    get xOnlyPublicKey() {
        if (this.#xOnlyPublicKey === undefined) {
            this.#xOnlyPublicKey = toXOnly(this.publicKey);
        }
        return this.#xOnlyPublicKey;
    }
    /** Network this signer is bound to. */
    get network() {
        return this.#network;
    }
    /** Whether the public key is in compressed SEC1 form. */
    get compressed() {
        return this.#compressed;
    }
    /**
     * Bitmask of {@link SignerCapability} flags representing the operations
     * this signer can perform.  Lazily computed and cached.
     */
    get capabilities() {
        if (this.#capabilities === undefined) {
            let caps = SignerCapability.EcdsaVerify | SignerCapability.PublicKeyTweak;
            if (this.#privateKey !== undefined) {
                caps |= SignerCapability.EcdsaSign | SignerCapability.PrivateKeyExport;
            }
            if (this.#backend.signSchnorr && this.#privateKey !== undefined) {
                caps |= SignerCapability.SchnorrSign;
            }
            if (this.#backend.verifySchnorr) {
                caps |= SignerCapability.SchnorrVerify;
            }
            this.#capabilities = caps;
        }
        return this.#capabilities;
    }
    /**
     * Creates a signer from a raw private key.
     *
     * @param backend - Cryptographic backend to use.
     * @param privateKey - 32-byte secp256k1 private key.
     * @param network - Target network.
     * @param options - Optional settings (e.g. compressed).
     * @throws {TypeError} If the private key is not in the valid range `[1, n)`.
     */
    static fromPrivateKey(backend, privateKey, network, options) {
        if (!backend.isPrivate(privateKey)) {
            throw new TypeError('Private key not in range [1, n)');
        }
        return new ECPairSigner(backend, privateKey, undefined, network, options);
    }
    /**
     * Creates a public-key-only signer (cannot sign, export WIF, etc.).
     *
     * @param backend - Cryptographic backend to use.
     * @param publicKey - SEC1-encoded public key.
     * @param network - Target network.
     * @param options - Optional settings (e.g. compressed).
     * @throws If the public key is not a valid curve point.
     */
    static fromPublicKey(backend, publicKey, network, options) {
        if (!backend.isPoint(publicKey)) {
            throw new Error('Point not on the curve');
        }
        return new ECPairSigner(backend, undefined, publicKey, network, options);
    }
    /**
     * Imports a signer from a WIF-encoded private key string.
     *
     * @param backend - Cryptographic backend to use.
     * @param wifString - Base58Check WIF string.
     * @param network - One or more candidate networks whose WIF version byte is matched.
     * @throws If no network matches the decoded version byte.
     */
    static fromWIF(backend, wifString, network) {
        const decoded = decodeWIF(wifString, network);
        return ECPairSigner.fromPrivateKey(backend, decoded.privateKey, decoded.network, {
            compressed: decoded.compressed,
        });
    }
    /**
     * Generates a new signer with a random private key.
     *
     * Uses FIPS 186-5 B.4.2 / RFC 9380 modular reduction:
     * 48 bytes of entropy are reduced via `(seed mod (n − 1)) + 1`,
     * producing a key in `[1, n)` with negligible bias (< 2^−128).
     *
     * @param backend - Cryptographic backend to use.
     * @param network - Target network.
     * @param options - Optional settings (rng, compressed).
     */
    static makeRandom(backend, network, options) {
        const rng = options?.rng ?? ((size) => crypto.getRandomValues(new Uint8Array(size)));
        const seed = rng(FIPS_SEED_LENGTH);
        if (seed.length !== FIPS_SEED_LENGTH) {
            throw new TypeError(`Expected ${FIPS_SEED_LENGTH} bytes from rng, got ${seed.length} bytes`);
        }
        const num = bytesToBigInt(seed);
        const reduced = (num % (EC_N - 1n)) + 1n;
        const privateKeyBytes = bigintToBytes32(reduced);
        return ECPairSigner.fromPrivateKey(backend, createPrivateKey(privateKeyBytes), network, options);
    }
    /**
     * Tests whether this signer has a specific capability.
     * @param cap - {@link SignerCapability} flag to test.
     */
    hasCapability(cap) {
        return (this.capabilities & cap) !== 0;
    }
    /**
     * Produces a compact ECDSA signature.
     *
     * When `lowR` is `true`, grinds the nonce until the R value's first
     * byte is `<= 0x7f`, producing a smaller DER encoding.
     *
     * @param hash - 32-byte message digest.
     * @param lowR - Enable low-R grinding.  Defaults to `false`.
     * @throws If this is a public-key-only signer.
     */
    sign(hash, lowR) {
        if (this.#privateKey === undefined)
            throw new Error('Missing private key');
        if (!lowR) {
            return this.#backend.sign(hash, this.#privateKey);
        }
        let sig = this.#backend.sign(hash, this.#privateKey);
        const extraData = new Uint8Array(32);
        const view = new DataView(extraData.buffer, extraData.byteOffset, extraData.byteLength);
        let counter = 0;
        for (;;) {
            const b = sig[0];
            if (b === undefined)
                throw new Error('Backend returned invalid signature');
            if (b <= 0x7f)
                break;
            counter++;
            view.setUint32(0, counter, true);
            sig = this.#backend.sign(hash, this.#privateKey, extraData);
        }
        return sig;
    }
    /**
     * Produces a 64-byte BIP-340 Schnorr signature.
     *
     * @param hash - 32-byte message digest.
     * @throws If this is a public-key-only signer.
     * @throws If the backend does not support Schnorr signing.
     */
    signSchnorr(hash) {
        if (this.#privateKey === undefined)
            throw new Error('Missing private key');
        if (!this.#backend.signSchnorr) {
            throw new Error('signSchnorr not supported by ecc library');
        }
        return this.#backend.signSchnorr(hash, this.#privateKey);
    }
    /**
     * Verifies a compact ECDSA signature against this signer's public key.
     *
     * @param hash - 32-byte message digest.
     * @param signature - Compact ECDSA signature.
     */
    verify(hash, signature) {
        return this.#backend.verify(hash, this.publicKey, signature);
    }
    /**
     * Verifies a BIP-340 Schnorr signature against this signer's x-only public key.
     *
     * @param hash - 32-byte message digest.
     * @param signature - 64-byte Schnorr signature.
     * @throws If the backend does not support Schnorr verification.
     */
    verifySchnorr(hash, signature) {
        if (!this.#backend.verifySchnorr) {
            throw new Error('verifySchnorr not supported by ecc library');
        }
        return this.#backend.verifySchnorr(hash, this.xOnlyPublicKey, signature);
    }
    /**
     * Derives a new signer by applying a Taproot-style scalar tweak.
     *
     * When a private key is available the tweak is applied to the scalar
     * (negating first if the public key has odd Y).  Otherwise, only the
     * public key is tweaked via x-only point addition.
     *
     * @param t - 32-byte tweak scalar.
     * @throws If the tweaked key is invalid (e.g. lands on the point at infinity).
     */
    tweak(t) {
        assertBytes32(t);
        if (this.#privateKey !== undefined) {
            return this.#tweakFromPrivateKey(t);
        }
        return this.#tweakFromPublicKey(t);
    }
    /**
     * Exports the private key as a WIF string using this signer's network.
     *
     * @throws If this is a public-key-only signer.
     */
    toWIF() {
        if (this.#privateKey === undefined)
            throw new Error('Missing private key');
        return encodeWIF(this.#privateKey, this.#compressed, this.#network);
    }
    #tweakFromPrivateKey(t) {
        const pubKey = this.publicKey;
        const privateKey = this.#privateKey;
        if (privateKey === undefined) {
            throw new Error('Missing private key');
        }
        const effectiveKey = hasOddY(pubKey) ? this.#backend.privateNegate(privateKey) : privateKey;
        const tweakedPrivateKey = this.#backend.privateAdd(effectiveKey, t);
        if (tweakedPrivateKey === null)
            throw new Error('Invalid tweaked private key!');
        return ECPairSigner.fromPrivateKey(this.#backend, tweakedPrivateKey, this.#network, {
            compressed: this.#compressed,
        });
    }
    #tweakFromPublicKey(t) {
        const xOnlyPubKey = this.xOnlyPublicKey;
        const tweakedPublicKey = this.#backend.xOnlyPointAddTweak(xOnlyPubKey, t);
        if (tweakedPublicKey === null || tweakedPublicKey.xOnlyPubkey === null) {
            throw new Error('Cannot tweak public key!');
        }
        const parityByte = new Uint8Array([tweakedPublicKey.parity === 0 ? 0x02 : 0x03]);
        const fullKey = concatBytes(parityByte, tweakedPublicKey.xOnlyPubkey);
        return ECPairSigner.fromPublicKey(this.#backend, createPublicKey(fullKey), this.#network, {
            compressed: this.#compressed,
        });
    }
}
//# sourceMappingURL=signer.js.map