/**
 * {@link CryptoBackend} adapter that delegates to a `tiny-secp256k1`
 * compatible library.
 *
 * Prefer {@link createLegacyBackend} for construction.
 */
export class LegacyBackend {
    #ecc;
    /**
     * @param ecc - Object implementing the {@link TinySecp256k1Interface}.
     */
    constructor(ecc) {
        this.#ecc = ecc;
    }
    /** `true` when the underlying library supports Schnorr signing. */
    get hasSchnorrSign() {
        return typeof this.#ecc.signSchnorr === 'function';
    }
    /** `true` when the underlying library supports Schnorr verification. */
    get hasSchnorrVerify() {
        return typeof this.#ecc.verifySchnorr === 'function';
    }
    /** @inheritDoc */
    isPrivate(d) {
        return this.#ecc.isPrivate(d);
    }
    /** @inheritDoc */
    isPoint(p) {
        return this.#ecc.isPoint(p);
    }
    /** @inheritDoc */
    isXOnlyPoint(p) {
        if (p.length !== 32)
            return false;
        const compressed = new Uint8Array(33);
        compressed[0] = 0x02;
        compressed.set(p, 1);
        return this.#ecc.isPoint(compressed);
    }
    /** @inheritDoc */
    pointFromScalar(d, compressed) {
        return this.#ecc.pointFromScalar(d, compressed);
    }
    /** @inheritDoc */
    pointCompress(p, compressed) {
        return this.#ecc.pointCompress(p, compressed);
    }
    /** @inheritDoc */
    pointAddScalar(p, tweak, compressed) {
        return this.#ecc.pointAddScalar(p, tweak, compressed);
    }
    /** @inheritDoc */
    xOnlyPointAddTweak(p, tweak) {
        const result = this.#ecc.xOnlyPointAddTweak(p, tweak);
        if (result === null)
            return null;
        return {
            parity: result.parity,
            xOnlyPubkey: result.xOnlyPubkey,
        };
    }
    /** @inheritDoc */
    privateAdd(d, tweak) {
        return this.#ecc.privateAdd(d, tweak);
    }
    /** @inheritDoc */
    privateNegate(d) {
        return this.#ecc.privateNegate(d);
    }
    /** @inheritDoc */
    sign(hash, privateKey, extraEntropy) {
        return this.#ecc.sign(hash, privateKey, extraEntropy);
    }
    /** @inheritDoc */
    verify(hash, publicKey, signature) {
        return this.#ecc.verify(hash, publicKey, signature);
    }
    /**
     * @inheritDoc
     * @throws If the underlying `tiny-secp256k1` library lacks `signSchnorr`.
     */
    signSchnorr(hash, privateKey, extraEntropy) {
        if (!this.#ecc.signSchnorr) {
            throw new Error('signSchnorr not supported by ecc library');
        }
        return this.#ecc.signSchnorr(hash, privateKey, extraEntropy);
    }
    /**
     * @inheritDoc
     * @throws If the underlying `tiny-secp256k1` library lacks `verifySchnorr`.
     */
    verifySchnorr(hash, publicKey, signature) {
        if (!this.#ecc.verifySchnorr) {
            throw new Error('verifySchnorr not supported by ecc library');
        }
        return this.#ecc.verifySchnorr(hash, publicKey, signature);
    }
}
/**
 * Creates a {@link LegacyBackend} wrapping a `tiny-secp256k1` compatible object.
 *
 * @param ecc - Object satisfying the {@link TinySecp256k1Interface}.
 */
export function createLegacyBackend(ecc) {
    return new LegacyBackend(ecc);
}
//# sourceMappingURL=legacy.js.map