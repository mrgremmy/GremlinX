import { schnorr, secp256k1 } from '@noble/curves/secp256k1.js';
import { mod } from '@noble/curves/abstract/modular.js';
import { toHex } from './types.js';
const Point = secp256k1.Point;
const N = Point.Fn.ORDER;
function bigintToBytes32(n) {
    const hex = n.toString(16).padStart(64, '0');
    const out = new Uint8Array(32);
    for (let i = 0; i < 32; i++) {
        out[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
    }
    return out;
}
function bytesToBigInt(bytes) {
    let result = 0n;
    for (let i = 0; i < bytes.length; i++) {
        result = (result << 8n) | BigInt(bytes[i]);
    }
    return result;
}
/**
 * {@link CryptoBackend} implementation backed by `@noble/curves/secp256k1`.
 *
 * Pure JavaScript, no native dependencies.
 *
 * Prefer {@link createNobleBackend} for construction.
 */
export class NobleBackend {
    /** @inheritDoc */
    isPrivate(d) {
        return secp256k1.utils.isValidSecretKey(d);
    }
    /** @inheritDoc */
    isPoint(p) {
        try {
            Point.fromHex(toHex(p));
            return true;
        }
        catch {
            return false;
        }
    }
    /** @inheritDoc */
    isXOnlyPoint(p) {
        if (p.length !== 32)
            return false;
        try {
            schnorr.utils.lift_x(bytesToBigInt(p));
            return true;
        }
        catch {
            return false;
        }
    }
    /** @inheritDoc */
    pointFromScalar(d, compressed) {
        try {
            return secp256k1.getPublicKey(d, compressed ?? true);
        }
        catch {
            return null;
        }
    }
    /** @inheritDoc */
    pointCompress(p, compressed) {
        const point = Point.fromHex(toHex(p));
        return point.toBytes(compressed ?? true);
    }
    /** @inheritDoc */
    pointAddScalar(p, tweak, compressed) {
        try {
            const point = Point.fromHex(toHex(p));
            const tweakBigint = bytesToBigInt(tweak);
            if (tweakBigint === 0n) {
                return point.toBytes(compressed ?? true);
            }
            const tweakPub = secp256k1.getPublicKey(tweak, true);
            const tweakPoint = Point.fromHex(toHex(tweakPub));
            const result = point.add(tweakPoint);
            return result.toBytes(compressed ?? true);
        }
        catch {
            return null;
        }
    }
    /** @inheritDoc */
    xOnlyPointAddTweak(p, tweak) {
        try {
            const point = schnorr.utils.lift_x(bytesToBigInt(p));
            const tweakBigint = bytesToBigInt(tweak);
            if (tweakBigint >= N)
                return null;
            const tweakPub = secp256k1.getPublicKey(tweak, true);
            const tweakPoint = Point.fromHex(toHex(tweakPub));
            const result = point.add(tweakPoint);
            const xBytes = schnorr.utils.pointToBytes(result);
            const parity = Number(result.y & 1n);
            return {
                parity,
                xOnlyPubkey: xBytes,
            };
        }
        catch {
            return null;
        }
    }
    /** @inheritDoc */
    privateAdd(d, tweak) {
        const dBigint = bytesToBigInt(d);
        const tweakBigint = bytesToBigInt(tweak);
        const result = mod(dBigint + tweakBigint, N);
        if (result === 0n)
            return null;
        return bigintToBytes32(result);
    }
    /** @inheritDoc */
    privateNegate(d) {
        const dBigint = bytesToBigInt(d);
        const result = mod(N - dBigint, N);
        return bigintToBytes32(result);
    }
    /** @inheritDoc */
    sign(hash, privateKey, extraEntropy) {
        return secp256k1.sign(hash, privateKey, {
            prehash: false,
            lowS: true,
            extraEntropy: extraEntropy ?? false,
        });
    }
    /** @inheritDoc */
    verify(hash, publicKey, signature) {
        return secp256k1.verify(signature, hash, publicKey, {
            prehash: false,
            lowS: true,
        });
    }
    /** @inheritDoc */
    signSchnorr(hash, privateKey, extraEntropy) {
        return schnorr.sign(hash, privateKey, extraEntropy);
    }
    /** @inheritDoc */
    verifySchnorr(hash, publicKey, signature) {
        return schnorr.verify(signature, hash, publicKey);
    }
}
/**
 * Creates a {@link NobleBackend} instance.
 *
 * @returns A new pure-JS secp256k1 backend powered by `@noble/curves`.
 */
export function createNobleBackend() {
    return new NobleBackend();
}
//# sourceMappingURL=noble.js.map