import { createSequentialWorker } from './SequentialWorker.js';
export const isNode = false;
export const isReactNative = true;
export const isBrowser = false;
export function detectRuntime() {
    return 'react-native';
}
let workletsModule = null;
let workletsLoadFailed = false;
let runtimeCounter = 0;
async function getWorklets() {
    if (workletsModule)
        return workletsModule;
    if (workletsLoadFailed)
        return null;
    try {
        workletsModule = (await import('react-native-worklets'));
        return workletsModule;
    }
    catch {
        workletsLoadFailed = true;
        return null;
    }
}
export async function createWorker(_workerScript) {
    const worklets = await getWorklets();
    if (worklets) {
        return createWorkletWorker(worklets);
    }
    return createSequentialWorker();
}
function createWorkletWorker(worklets) {
    const runtime = worklets.createWorkletRuntime(`worker-${runtimeCounter++}`);
    let messageCallback = null;
    let terminated = false;
    return {
        postMessage: (msg) => {
            if (terminated || !messageCallback)
                return;
            const { id, op, data } = msg;
            const callback = messageCallback;
            void (async () => {
                try {
                    let result;
                    if (op === 'parse') {
                        const text = data instanceof ArrayBuffer
                            ? new TextDecoder().decode(data)
                            : data;
                        result = await worklets.runOnRuntime(runtime, () => {
                            'worklet';
                            return JSON.parse(text);
                        });
                    }
                    else if (op === 'stringify') {
                        const toStringify = data;
                        result = await worklets.runOnRuntime(runtime, () => {
                            'worklet';
                            return JSON.stringify(toStringify);
                        });
                    }
                    else if (op === 'fetch') {
                        const { url, payload, timeout, headers } = data;
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), timeout || 20000);
                        try {
                            const resp = await fetch(url, {
                                method: 'POST',
                                headers: headers || {
                                    'Content-Type': 'application/json',
                                    Accept: 'application/json',
                                },
                                body: JSON.stringify(payload),
                                signal: controller.signal,
                            });
                            clearTimeout(timeoutId);
                            if (!resp.ok) {
                                throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                            }
                            const text = await resp.text();
                            result = await worklets.runOnRuntime(runtime, () => {
                                'worklet';
                                return JSON.parse(text);
                            });
                        }
                        catch (err) {
                            clearTimeout(timeoutId);
                            if (err.name === 'AbortError') {
                                throw new Error(`Request timed out after ${timeout || 20000}ms`, {
                                    cause: err,
                                });
                            }
                            throw err;
                        }
                    }
                    else {
                        throw new Error(`Unknown operation: ${op}`);
                    }
                    if (!terminated)
                        callback({ id, result });
                }
                catch (err) {
                    if (!terminated) {
                        callback({ id, error: err instanceof Error ? err.message : String(err) });
                    }
                }
            })();
        },
        onMessage: (callback) => {
            messageCallback = callback;
        },
        terminate: () => {
            terminated = true;
            messageCallback = null;
        },
    };
}
