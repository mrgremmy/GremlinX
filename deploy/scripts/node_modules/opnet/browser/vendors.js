import { s as sha256$2, r as ripemd160$1, a as sha1$2, b as require$$1$1, c as require$$2$2, d as require$$0$3, e as randomBytes$1, f as abytes$1, g as concatBytes$1, i as isBytes$1, h as shake128, j as shake256, k as sha512$1, l as requirePbkdf2, m as requireSha512$1, n as requireSha256$1, o as requireUtils } from './noble-hashes.js';
import { F as FFTCore, r as reverseBits, a as abool, s as secp256k1, m as mod$1, b as bytesToNumberBE } from './noble-curves.js';

// https://en.bitcoin.it/wiki/List_of_address_prefixes
// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731
/**
 * Represents the Bitcoin network configuration.
 */
const bitcoin$1 = {
    /**
     * The message prefix used for signing Bitcoin messages.
     */
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    /**
     * The Bech32 prefix used for Bitcoin addresses.
     */
    bech32: 'bc',
    bech32Opnet: 'op',
    /**
     * The BIP32 key prefixes for Bitcoin.
     */
    bip32: {
        /**
         * The public key prefix for BIP32 extended public keys.
         */
        public: 0x0488b21e,
        /**
         * The private key prefix for BIP32 extended private keys.
         */
        private: 0x0488ade4,
    },
    /**
     * The prefix for Bitcoin public key hashes.
     */
    pubKeyHash: 0x00,
    /**
     * The prefix for Bitcoin script hashes.
     */
    scriptHash: 0x05,
    /**
     * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
     */
    wif: 0x80,
};
/**
 * Represents the regtest network configuration.
 */
const regtest = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bcrt',
    bech32Opnet: 'opr',
    bip32: {
        public: 0x043587cf,
        private: 0x04358394,
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef,
};
/**
 * Represents the testnet network configuration.
 */
const testnet = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'tb',
    bech32Opnet: 'opt',
    bip32: {
        public: 0x043587cf,
        private: 0x04358394,
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef,
};
const opnetTestnet = {
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'opt',
    bech32Opnet: 'opt',
    bip32: {
        public: 0x043587cf,
        private: 0x04358394,
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef,
};

function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}

var dist$1 = {};

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$1;
	hasRequiredDist$1 = 1;
	Object.defineProperty(dist$1, "__esModule", { value: true });
	dist$1.bech32m = dist$1.bech32 = void 0;
	const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
	const ALPHABET_MAP = {};
	for (let z = 0; z < ALPHABET.length; z++) {
	    const x = ALPHABET.charAt(z);
	    ALPHABET_MAP[x] = z;
	}
	function polymodStep(pre) {
	    const b = pre >> 25;
	    return (((pre & 0x1ffffff) << 5) ^
	        (-((b >> 0) & 1) & 0x3b6a57b2) ^
	        (-((b >> 1) & 1) & 0x26508e6d) ^
	        (-((b >> 2) & 1) & 0x1ea119fa) ^
	        (-((b >> 3) & 1) & 0x3d4233dd) ^
	        (-((b >> 4) & 1) & 0x2a1462b3));
	}
	function prefixChk(prefix) {
	    let chk = 1;
	    for (let i = 0; i < prefix.length; ++i) {
	        const c = prefix.charCodeAt(i);
	        if (c < 33 || c > 126)
	            return 'Invalid prefix (' + prefix + ')';
	        chk = polymodStep(chk) ^ (c >> 5);
	    }
	    chk = polymodStep(chk);
	    for (let i = 0; i < prefix.length; ++i) {
	        const v = prefix.charCodeAt(i);
	        chk = polymodStep(chk) ^ (v & 0x1f);
	    }
	    return chk;
	}
	function convert(data, inBits, outBits, pad) {
	    let value = 0;
	    let bits = 0;
	    const maxV = (1 << outBits) - 1;
	    const result = [];
	    for (let i = 0; i < data.length; ++i) {
	        value = (value << inBits) | data[i];
	        bits += inBits;
	        while (bits >= outBits) {
	            bits -= outBits;
	            result.push((value >> bits) & maxV);
	        }
	    }
	    if (pad) {
	        if (bits > 0) {
	            result.push((value << (outBits - bits)) & maxV);
	        }
	    }
	    else {
	        if (bits >= inBits)
	            return 'Excess padding';
	        if ((value << (outBits - bits)) & maxV)
	            return 'Non-zero padding';
	    }
	    return result;
	}
	function toWords(bytes) {
	    return convert(bytes, 8, 5, true);
	}
	function fromWordsUnsafe(words) {
	    const res = convert(words, 5, 8, false);
	    if (Array.isArray(res))
	        return res;
	}
	function fromWords(words) {
	    const res = convert(words, 5, 8, false);
	    if (Array.isArray(res))
	        return res;
	    throw new Error(res);
	}
	function getLibraryFromEncoding(encoding) {
	    let ENCODING_CONST;
	    if (encoding === 'bech32') {
	        ENCODING_CONST = 1;
	    }
	    else {
	        ENCODING_CONST = 0x2bc830a3;
	    }
	    function encode(prefix, words, LIMIT) {
	        LIMIT = LIMIT || 90;
	        if (prefix.length + 7 + words.length > LIMIT)
	            throw new TypeError('Exceeds length limit');
	        prefix = prefix.toLowerCase();
	        // determine chk mod
	        let chk = prefixChk(prefix);
	        if (typeof chk === 'string')
	            throw new Error(chk);
	        let result = prefix + '1';
	        for (let i = 0; i < words.length; ++i) {
	            const x = words[i];
	            if (x >> 5 !== 0)
	                throw new Error('Non 5-bit word');
	            chk = polymodStep(chk) ^ x;
	            result += ALPHABET.charAt(x);
	        }
	        for (let i = 0; i < 6; ++i) {
	            chk = polymodStep(chk);
	        }
	        chk ^= ENCODING_CONST;
	        for (let i = 0; i < 6; ++i) {
	            const v = (chk >> ((5 - i) * 5)) & 0x1f;
	            result += ALPHABET.charAt(v);
	        }
	        return result;
	    }
	    function __decode(str, LIMIT) {
	        LIMIT = LIMIT || 90;
	        if (str.length < 8)
	            return str + ' too short';
	        if (str.length > LIMIT)
	            return 'Exceeds length limit';
	        // don't allow mixed case
	        const lowered = str.toLowerCase();
	        const uppered = str.toUpperCase();
	        if (str !== lowered && str !== uppered)
	            return 'Mixed-case string ' + str;
	        str = lowered;
	        const split = str.lastIndexOf('1');
	        if (split === -1)
	            return 'No separator character for ' + str;
	        if (split === 0)
	            return 'Missing prefix for ' + str;
	        const prefix = str.slice(0, split);
	        const wordChars = str.slice(split + 1);
	        if (wordChars.length < 6)
	            return 'Data too short';
	        let chk = prefixChk(prefix);
	        if (typeof chk === 'string')
	            return chk;
	        const words = [];
	        for (let i = 0; i < wordChars.length; ++i) {
	            const c = wordChars.charAt(i);
	            const v = ALPHABET_MAP[c];
	            if (v === undefined)
	                return 'Unknown character ' + c;
	            chk = polymodStep(chk) ^ v;
	            // not in the checksum?
	            if (i + 6 >= wordChars.length)
	                continue;
	            words.push(v);
	        }
	        if (chk !== ENCODING_CONST)
	            return 'Invalid checksum for ' + str;
	        return { prefix, words };
	    }
	    function decodeUnsafe(str, LIMIT) {
	        const res = __decode(str, LIMIT);
	        if (typeof res === 'object')
	            return res;
	    }
	    function decode(str, LIMIT) {
	        const res = __decode(str, LIMIT);
	        if (typeof res === 'object')
	            return res;
	        throw new Error(res);
	    }
	    return {
	        decodeUnsafe,
	        decode,
	        encode,
	        toWords,
	        fromWordsUnsafe,
	        fromWords,
	    };
	}
	dist$1.bech32 = getLibraryFromEncoding('bech32');
	dist$1.bech32m = getLibraryFromEncoding('bech32m');
	return dist$1;
}

var distExports = requireDist$1();

/**
 * Bech32 encoding/decoding utilities
 * @packageDocumentation
 */
/**
 * decode address with bech32 specification,  return address versionã€address prefix and address data if valid
 */
function fromBech32(address) {
    let result;
    let version;
    try {
        result = distExports.bech32.decode(address);
    }
    catch (e) { }
    if (result) {
        version = result.words[0];
        if (version !== 0)
            throw new TypeError(address + ' uses wrong encoding');
    }
    else {
        result = distExports.bech32m.decode(address);
        version = result.words[0];
        if (version === 0)
            throw new TypeError(address + ' uses wrong encoding');
    }
    const data = distExports.bech32.fromWords(result.words.slice(1));
    return {
        version: version,
        prefix: result.prefix,
        data: new Uint8Array(data),
    };
}

const HEX_STRINGS$1 = "0123456789abcdefABCDEF";
HEX_STRINGS$1.split("").map((c) => c.codePointAt(0));
Array(256)
    .fill(true)
    .map((_, i) => {
    const s = String.fromCodePoint(i);
    const index = HEX_STRINGS$1.indexOf(s);
    // ABCDEF will use 10 - 15
    return index < 0 ? undefined : index < 16 ? index : index - 6;
});
new TextEncoder();
new TextDecoder();
function writeUInt16$1(buffer, offset, value, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffff}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
    }
    else {
        buffer[offset] = (value >> 8) & 0xff;
        buffer[offset + 1] = value & 0xff;
    }
}
function writeUInt32$1(buffer, offset, value, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffffffff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffff}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
        buffer[offset + 2] = (value >> 16) & 0xff;
        buffer[offset + 3] = (value >> 24) & 0xff;
    }
    else {
        buffer[offset] = (value >> 24) & 0xff;
        buffer[offset + 1] = (value >> 16) & 0xff;
        buffer[offset + 2] = (value >> 8) & 0xff;
        buffer[offset + 3] = value & 0xff;
    }
}
function writeUInt64$1(buffer, offset, value, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffffffffffffffffn) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = Number(value & 0xffn);
        buffer[offset + 1] = Number((value >> 8n) & 0xffn);
        buffer[offset + 2] = Number((value >> 16n) & 0xffn);
        buffer[offset + 3] = Number((value >> 24n) & 0xffn);
        buffer[offset + 4] = Number((value >> 32n) & 0xffn);
        buffer[offset + 5] = Number((value >> 40n) & 0xffn);
        buffer[offset + 6] = Number((value >> 48n) & 0xffn);
        buffer[offset + 7] = Number((value >> 56n) & 0xffn);
    }
    else {
        buffer[offset] = Number((value >> 56n) & 0xffn);
        buffer[offset + 1] = Number((value >> 48n) & 0xffn);
        buffer[offset + 2] = Number((value >> 40n) & 0xffn);
        buffer[offset + 3] = Number((value >> 32n) & 0xffn);
        buffer[offset + 4] = Number((value >> 24n) & 0xffn);
        buffer[offset + 5] = Number((value >> 16n) & 0xffn);
        buffer[offset + 6] = Number((value >> 8n) & 0xffn);
        buffer[offset + 7] = Number(value & 0xffn);
    }
}
function readUInt16$1(buffer, offset, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0;
        num = (num << 8) + buffer[offset + 1];
        num = (num << 8) + buffer[offset];
        return num;
    }
    else {
        let num = 0;
        num = (num << 8) + buffer[offset];
        num = (num << 8) + buffer[offset + 1];
        return num;
    }
}
function readUInt32$1(buffer, offset, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0;
        num = ((num << 8) + buffer[offset + 3]) >>> 0;
        num = ((num << 8) + buffer[offset + 2]) >>> 0;
        num = ((num << 8) + buffer[offset + 1]) >>> 0;
        num = ((num << 8) + buffer[offset]) >>> 0;
        return num;
    }
    else {
        let num = 0;
        num = ((num << 8) + buffer[offset]) >>> 0;
        num = ((num << 8) + buffer[offset + 1]) >>> 0;
        num = ((num << 8) + buffer[offset + 2]) >>> 0;
        num = ((num << 8) + buffer[offset + 3]) >>> 0;
        return num;
    }
}
function readUInt64$1(buffer, offset, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset]);
        return num;
    }
    else {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        return num;
    }
}

const checkUInt64 = (n) => {
    if (n < 0 || n > 0xffffffffffffffffn) {
        throw new RangeError('value out of range');
    }
};
function checkUInt53(n) {
    if (n < 0 || n > Number.MAX_SAFE_INTEGER || n % 1 !== 0)
        throw new RangeError('value out of range');
}
function checkUint53OrUint64(n) {
    if (typeof n === 'number')
        checkUInt53(n);
    else
        checkUInt64(n);
}
function encode$k(n, buffer, offset) {
    checkUint53OrUint64(n);
    if (offset === undefined)
        offset = 0;
    if (buffer === undefined) {
        buffer = new Uint8Array(encodingLength$1(n));
    }
    let bytes = 0;
    // 8 bit
    if (n < 0xfd) {
        buffer.set([Number(n)], offset);
        bytes = 1;
        // 16 bit
    }
    else if (n <= 0xffff) {
        buffer.set([0xfd], offset);
        writeUInt16$1(buffer, offset + 1, Number(n), 'LE');
        bytes = 3;
        // 32 bit
    }
    else if (n <= 0xffffffff) {
        buffer.set([0xfe], offset);
        writeUInt32$1(buffer, offset + 1, Number(n), 'LE');
        bytes = 5;
        // 64 bit
    }
    else {
        buffer.set([0xff], offset);
        writeUInt64$1(buffer, offset + 1, BigInt(n), 'LE');
        bytes = 9;
    }
    return { buffer, bytes };
}
function decode$j(buffer, offset) {
    if (offset === undefined)
        offset = 0;
    const first = buffer.at(offset);
    if (first === undefined)
        throw new Error('buffer too small');
    // 8 bit
    if (first < 0xfd) {
        return { numberValue: first, bigintValue: BigInt(first), bytes: 1 };
        // 16 bit
    }
    else if (first === 0xfd) {
        const val = readUInt16$1(buffer, offset + 1, 'LE');
        return {
            numberValue: val,
            bigintValue: BigInt(val),
            bytes: 3
        };
        // 32 bit
    }
    else if (first === 0xfe) {
        const val = readUInt32$1(buffer, offset + 1, 'LE');
        return {
            numberValue: val,
            bigintValue: BigInt(val),
            bytes: 5
        };
        // 64 bit
    }
    else {
        const number = readUInt64$1(buffer, offset + 1, 'LE');
        return { numberValue: number <= Number.MAX_SAFE_INTEGER ? Number(number) : null, bigintValue: number, bytes: 9 };
    }
}
function encodingLength$1(n) {
    checkUint53OrUint64(n);
    return n < 0xfd ? 1 : n <= 0xffff ? 3 : n <= 0xffffffff ? 5 : 9;
}

/**
 * Hex encoding and decoding utilities.
 *
 * Direct implementations with zero dependencies and no wrappers.
 * Optimized for performance with lookup tables.
 *
 * @packageDocumentation
 */
/**
 * Lookup table for byte to hex conversion.
 * Pre-computed for O(1) lookup per byte.
 */
const BYTE_TO_HEX = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Lookup table for hex character to nibble conversion.
 * Returns -1 for invalid characters.
 */
const HEX_TO_NIBBLE = (() => {
    const table = new Array(128).fill(-1);
    for (let i = 0; i < 10; i++) {
        table[0x30 + i] = i; // '0'-'9'
    }
    for (let i = 0; i < 6; i++) {
        table[0x41 + i] = 10 + i; // 'A'-'F'
        table[0x61 + i] = 10 + i; // 'a'-'f'
    }
    return table;
})();
/**
 * Converts a Uint8Array to a lowercase hex string.
 *
 * @param bytes - The byte array to convert
 * @returns Lowercase hex string representation
 *
 * @example
 * ```typescript
 * import { toHex } from '@btc-vision/bitcoin';
 *
 * const bytes = new Uint8Array([0xde, 0xad, 0xbe, 0xef]);
 * const hex = toHex(bytes);
 * console.log(hex); // 'deadbeef'
 * ```
 */
function toHex$1(bytes) {
    let result = '';
    for (let i = 0; i < bytes.length; i++) {
        const hex = BYTE_TO_HEX[bytes[i]];
        result += hex;
    }
    return result;
}
/**
 * Converts a hex string to a Uint8Array.
 *
 * Accepts hex strings with or without '0x' prefix.
 * Case-insensitive (accepts both 'DEADBEEF' and 'deadbeef').
 *
 * @param hex - The hex string to convert
 * @returns Uint8Array containing the decoded bytes
 * @throws TypeError if hex string has odd length
 * @throws TypeError if hex string contains invalid characters
 *
 * @example
 * ```typescript
 * import { fromHex, toHex } from '@btc-vision/bitcoin';
 *
 * const bytes = fromHex('deadbeef');
 * console.log(bytes); // Uint8Array [222, 173, 190, 239]
 *
 * // Also works with 0x prefix
 * const bytes2 = fromHex('0xCAFEBABE');
 * console.log(toHex(bytes2)); // 'cafebabe'
 * ```
 */
function fromHex$1(hex) {
    // Strip 0x prefix if present
    if (hex.length >= 2 && hex[0] === '0' && (hex[1] === 'x' || hex[1] === 'X')) {
        hex = hex.slice(2);
    }
    const len = hex.length;
    if (len % 2 !== 0) {
        throw new TypeError('Invalid hex string: odd length');
    }
    const byteLength = len / 2;
    const result = new Uint8Array(byteLength);
    for (let i = 0; i < byteLength; i++) {
        const charIndex = i * 2;
        const highCode = hex.charCodeAt(charIndex);
        const lowCode = hex.charCodeAt(charIndex + 1);
        // Bounds check for lookup table
        if (highCode >= 128 || lowCode >= 128) {
            throw new TypeError(`Invalid hex character at position ${charIndex}`);
        }
        const high = HEX_TO_NIBBLE[highCode];
        const low = HEX_TO_NIBBLE[lowCode];
        if (high === -1) {
            throw new TypeError(`Invalid hex character at position ${charIndex}`);
        }
        if (low === -1) {
            throw new TypeError(`Invalid hex character at position ${charIndex + 1}`);
        }
        result[i] = (high << 4) | low; // Safe: validated above
    }
    return result;
}

/**
 * Stateful binary reader with a single DataView instance.
 *
 * Zero allocations during read operations. The DataView is created once
 * in the constructor and reused for all reads.
 *
 * @packageDocumentation
 */
/**
 * High-performance binary reader for parsing binary data.
 *
 * Creates exactly ONE DataView instance that is reused for all read operations.
 * This eliminates garbage collection pressure from repeated DataView allocations.
 *
 * @example
 * ```typescript
 * import { BinaryReader, fromHex } from '@btc-vision/bitcoin';
 *
 * // Parse a Bitcoin transaction
 * const data = fromHex('01000000...');
 * const reader = new BinaryReader(data);
 *
 * const version = reader.readInt32LE();
 * const inputCount = reader.readVarInt();
 *
 * for (let i = 0; i < inputCount; i++) {
 *     const txid = reader.readBytes(32);
 *     const vout = reader.readUInt32LE();
 *     const script = reader.readVarBytes();
 *     const sequence = reader.readUInt32LE();
 * }
 * ```
 */
let BinaryReader$1 = class BinaryReader {
    /**
     * The underlying byte array.
     */
    #data;
    /**
     * Single DataView instance reused for all reads.
     */
    #view;
    /**
     * Current read position.
     */
    #offset;
    /**
     * Creates a new BinaryReader.
     *
     * @param data - The byte array to read from
     * @param offset - Initial read position (default 0)
     *
     * @example
     * ```typescript
     * import { BinaryReader, fromHex } from '@btc-vision/bitcoin';
     *
     * const data = fromHex('01020304');
     * const reader = new BinaryReader(data);
     * ```
     */
    constructor(data, offset = 0) {
        this.#data = data;
        this.#view = new DataView(data.buffer, data.byteOffset, data.byteLength);
        this.#offset = offset;
    }
    /**
     * Current read position in the buffer.
     */
    get offset() {
        return this.#offset;
    }
    /**
     * Sets the read position.
     *
     * @param value - New offset value
     * @throws RangeError if offset is negative or beyond buffer length
     */
    set offset(value) {
        if (value < 0 || value > this.#data.length) {
            throw new RangeError(`Offset ${value} is out of bounds [0, ${this.#data.length}]`);
        }
        this.#offset = value;
    }
    /**
     * Total length of the underlying buffer.
     */
    get length() {
        return this.#data.length;
    }
    /**
     * Number of bytes remaining to be read.
     */
    get remaining() {
        return this.#data.length - this.#offset;
    }
    /**
     * The underlying data buffer.
     */
    get data() {
        return this.#data;
    }
    /**
     * Creates a BinaryReader from a hex string.
     *
     * @param hex - Hex string (with or without 0x prefix)
     * @returns A new BinaryReader instance
     *
     * @example
     * ```typescript
     * import { BinaryReader } from '@btc-vision/bitcoin';
     *
     * const reader = BinaryReader.fromHex('01000000');
     * const version = reader.readInt32LE(); // 1
     * ```
     */
    static fromHex(hex) {
        return new BinaryReader(fromHex$1(hex));
    }
    /**
     * Reads an 8-bit unsigned integer.
     *
     * @returns The value (0-255)
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('ff');
     * reader.readUInt8(); // 255
     * ```
     */
    readUInt8() {
        if (this.#offset >= this.#data.length) {
            throw new RangeError('Read past end of buffer');
        }
        return this.#data[this.#offset++]; // Safe: bounds checked above
    }
    /**
     * Reads an 8-bit signed integer.
     *
     * @returns The value (-128 to 127)
     * @throws RangeError if reading past end of buffer
     */
    readInt8() {
        const value = this.readUInt8();
        return value > 127 ? value - 256 : value;
    }
    /**
     * Reads a 16-bit unsigned integer in little-endian format.
     *
     * @returns The value (0-65535)
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('0100'); // 1 in LE
     * reader.readUInt16LE(); // 1
     * ```
     */
    readUInt16LE() {
        if (this.#offset + 2 > this.#data.length) {
            throw new RangeError('Read past end of buffer');
        }
        const value = this.#view.getUint16(this.#offset, true);
        this.#offset += 2;
        return value;
    }
    /**
     * Reads a 16-bit signed integer in little-endian format.
     *
     * @returns The value (-32768 to 32767)
     * @throws RangeError if reading past end of buffer
     */
    readInt16LE() {
        if (this.#offset + 2 > this.#data.length) {
            throw new RangeError('Read past end of buffer');
        }
        const value = this.#view.getInt16(this.#offset, true);
        this.#offset += 2;
        return value;
    }
    /**
     * Reads a 32-bit unsigned integer in little-endian format.
     *
     * @returns The value (0 to 4294967295)
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('01000000'); // 1 in LE
     * reader.readUInt32LE(); // 1
     * ```
     */
    readUInt32LE() {
        if (this.#offset + 4 > this.#data.length) {
            throw new RangeError('Read past end of buffer');
        }
        const value = this.#view.getUint32(this.#offset, true);
        this.#offset += 4;
        return value;
    }
    /**
     * Reads a 32-bit signed integer in little-endian format.
     *
     * @returns The value (-2147483648 to 2147483647)
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('ffffffff'); // -1 in LE signed
     * reader.readInt32LE(); // -1
     * ```
     */
    readInt32LE() {
        if (this.#offset + 4 > this.#data.length) {
            throw new RangeError('Read past end of buffer');
        }
        const value = this.#view.getInt32(this.#offset, true);
        this.#offset += 4;
        return value;
    }
    /**
     * Reads a 64-bit unsigned integer in little-endian format as bigint.
     *
     * @returns The value as bigint
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('0100000000000000'); // 1 in LE 64-bit
     * reader.readUInt64LE(); // 1n
     * ```
     */
    readUInt64LE() {
        if (this.#offset + 8 > this.#data.length) {
            throw new RangeError('Read past end of buffer');
        }
        const value = this.#view.getBigUint64(this.#offset, true);
        this.#offset += 8;
        return value;
    }
    /**
     * Reads a 64-bit signed integer in little-endian format as bigint.
     *
     * @returns The value as bigint
     * @throws RangeError if reading past end of buffer
     */
    readInt64LE() {
        if (this.#offset + 8 > this.#data.length) {
            throw new RangeError('Read past end of buffer');
        }
        const value = this.#view.getBigInt64(this.#offset, true);
        this.#offset += 8;
        return value;
    }
    /**
     * Reads a specified number of bytes.
     *
     * Returns a subarray view (no copy) for performance.
     * Use readBytesCopy() if you need an independent copy.
     *
     * @param length - Number of bytes to read
     * @returns Uint8Array view into the buffer
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('deadbeefcafebabe');
     * const first4 = reader.readBytes(4); // deadbeef
     * const next4 = reader.readBytes(4); // cafebabe
     * ```
     */
    readBytes(length) {
        if (this.#offset + length > this.#data.length) {
            throw new RangeError('Read past end of buffer');
        }
        const value = this.#data.subarray(this.#offset, this.#offset + length);
        this.#offset += length;
        return value;
    }
    /**
     * Reads a specified number of bytes as an independent copy.
     *
     * @param length - Number of bytes to read
     * @returns New Uint8Array with copied data
     * @throws RangeError if reading past end of buffer
     */
    readBytesCopy(length) {
        if (this.#offset + length > this.#data.length) {
            throw new RangeError('Read past end of buffer');
        }
        const value = this.#data.slice(this.#offset, this.#offset + length);
        this.#offset += length;
        return value;
    }
    /**
     * Reads a Bitcoin CompactSize variable-length integer.
     *
     * CompactSize encoding:
     * - 0x00-0xFC: 1 byte (value as-is)
     * - 0xFD: 3 bytes (0xFD + 2-byte LE uint16)
     * - 0xFE: 5 bytes (0xFE + 4-byte LE uint32)
     * - 0xFF: 9 bytes (0xFF + 8-byte LE uint64)
     *
     * @returns The decoded integer value
     * @throws RangeError if reading past end of buffer
     * @throws RangeError if value exceeds MAX_SAFE_INTEGER
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('fd0302'); // 515 encoded
     * reader.readVarInt(); // 515
     * ```
     */
    readVarInt() {
        const first = this.readUInt8();
        if (first < 0xfd) {
            return first;
        }
        if (first === 0xfd) {
            return this.readUInt16LE();
        }
        if (first === 0xfe) {
            return this.readUInt32LE();
        }
        // first === 0xff
        const value = this.readUInt64LE();
        if (value > BigInt(Number.MAX_SAFE_INTEGER)) {
            throw new RangeError('VarInt value exceeds MAX_SAFE_INTEGER');
        }
        return Number(value);
    }
    /**
     * Reads a Bitcoin CompactSize variable-length integer as bigint.
     *
     * Use this when you need the full 64-bit range.
     *
     * @returns The decoded integer value as bigint
     * @throws RangeError if reading past end of buffer
     */
    readVarIntBig() {
        const first = this.readUInt8();
        if (first < 0xfd) {
            return BigInt(first);
        }
        if (first === 0xfd) {
            return BigInt(this.readUInt16LE());
        }
        if (first === 0xfe) {
            return BigInt(this.readUInt32LE());
        }
        // first === 0xff
        return this.readUInt64LE();
    }
    /**
     * Reads a length-prefixed byte array (VarInt length + bytes).
     *
     * @returns Uint8Array view into the buffer
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('04deadbeef');
     * reader.readVarBytes(); // Uint8Array [0xde, 0xad, 0xbe, 0xef]
     * ```
     */
    readVarBytes() {
        const length = this.readVarInt();
        return this.readBytes(length);
    }
    /**
     * Reads an array of length-prefixed byte arrays.
     *
     * Format: VarInt count + (VarInt length + bytes) for each item.
     *
     * @returns Array of Uint8Array views
     * @throws RangeError if reading past end of buffer
     */
    readVector() {
        const count = this.readVarInt();
        const result = [];
        for (let i = 0; i < count; i++) {
            result.push(this.readVarBytes());
        }
        return result;
    }
    /**
     * Peeks at the next byte without advancing the position.
     *
     * @returns The next byte value, or undefined if at end
     */
    peek() {
        if (this.#offset >= this.#data.length) {
            return undefined;
        }
        return this.#data[this.#offset];
    }
    /**
     * Skips a specified number of bytes.
     *
     * @param length - Number of bytes to skip
     * @throws RangeError if skipping past end of buffer
     */
    skip(length) {
        if (this.#offset + length > this.#data.length) {
            throw new RangeError('Skip past end of buffer');
        }
        this.#offset += length;
    }
    /**
     * Resets the read position to the beginning.
     */
    reset() {
        this.#offset = 0;
    }
    /**
     * Checks if there are more bytes to read.
     *
     * @returns True if there are remaining bytes
     */
    hasMore() {
        return this.#offset < this.#data.length;
    }
};

/**
 * Stateful binary writer with a single DataView instance.
 *
 * Zero allocations during write operations. The DataView is created once
 * in the constructor and reused for all writes.
 *
 * @packageDocumentation
 */
/**
 * High-performance binary writer for serializing binary data.
 *
 * Creates exactly ONE DataView instance that is reused for all write operations.
 * This eliminates garbage collection pressure from repeated DataView allocations.
 *
 * Methods return `this` for chaining.
 *
 * @example
 * ```typescript
 * import { BinaryWriter } from '@btc-vision/bitcoin';
 *
 * // Serialize a simple structure
 * const writer = new BinaryWriter(16);
 * writer
 *     .writeInt32LE(1)        // version
 *     .writeUInt32LE(0)       // input count
 *     .writeUInt32LE(0)       // output count
 *     .writeUInt32LE(0);      // locktime
 *
 * const bytes = writer.finish();
 * ```
 */
let BinaryWriter$1 = class BinaryWriter {
    /**
     * The underlying byte array.
     */
    #data;
    /**
     * Single DataView instance reused for all writes.
     */
    #view;
    /**
     * Current write position.
     */
    #offset;
    constructor(arg, offset = 0) {
        if (typeof arg === 'number') {
            this.#data = new Uint8Array(arg);
            this.#offset = 0;
        }
        else {
            this.#data = arg;
            this.#offset = offset;
        }
        this.#view = new DataView(this.#data.buffer, this.#data.byteOffset, this.#data.byteLength);
    }
    /**
     * Current write position in the buffer.
     */
    get offset() {
        return this.#offset;
    }
    /**
     * Sets the write position.
     *
     * @param value - New offset value
     * @throws RangeError if offset is negative or beyond buffer length
     */
    set offset(value) {
        if (value < 0 || value > this.#data.length) {
            throw new RangeError(`Offset ${value} is out of bounds [0, ${this.#data.length}]`);
        }
        this.#offset = value;
    }
    /**
     * Total capacity of the underlying buffer.
     */
    get capacity() {
        return this.#data.length;
    }
    /**
     * Number of bytes remaining in the buffer.
     */
    get remaining() {
        return this.#data.length - this.#offset;
    }
    /**
     * The underlying data buffer.
     */
    get data() {
        return this.#data;
    }
    /**
     * Creates a BinaryWriter with automatic capacity management.
     *
     * Initial capacity is 256 bytes, grows as needed.
     *
     * @returns A new GrowableBinaryWriter instance
     *
     * @example
     * ```typescript
     * import { BinaryWriter } from '@btc-vision/bitcoin';
     *
     * const writer = BinaryWriter.growable();
     * writer.writeUInt32LE(1);
     * writer.writeBytes(new Uint8Array(1000)); // Automatically grows
     * ```
     */
    static growable(initialCapacity = 256) {
        return new GrowableBinaryWriter(initialCapacity);
    }
    /**
     * Writes an 8-bit unsigned integer.
     *
     * @param value - Value to write (0-255)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeUInt8(255);
     * ```
     */
    writeUInt8(value) {
        if (this.#offset >= this.#data.length) {
            throw new RangeError('Write past end of buffer');
        }
        this.#data[this.#offset++] = value & 0xff;
        return this;
    }
    /**
     * Writes an 8-bit signed integer.
     *
     * @param value - Value to write (-128 to 127)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeInt8(value) {
        return this.writeUInt8(value < 0 ? value + 256 : value);
    }
    /**
     * Writes a 16-bit unsigned integer in little-endian format.
     *
     * @param value - Value to write (0-65535)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeUInt16LE(1); // Writes 01 00
     * ```
     */
    writeUInt16LE(value) {
        if (this.#offset + 2 > this.#data.length) {
            throw new RangeError('Write past end of buffer');
        }
        this.#view.setUint16(this.#offset, value, true);
        this.#offset += 2;
        return this;
    }
    /**
     * Writes a 16-bit signed integer in little-endian format.
     *
     * @param value - Value to write (-32768 to 32767)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeInt16LE(value) {
        if (this.#offset + 2 > this.#data.length) {
            throw new RangeError('Write past end of buffer');
        }
        this.#view.setInt16(this.#offset, value, true);
        this.#offset += 2;
        return this;
    }
    /**
     * Writes a 32-bit unsigned integer in little-endian format.
     *
     * @param value - Value to write (0 to 4294967295)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeUInt32LE(1); // Writes 01 00 00 00
     * ```
     */
    writeUInt32LE(value) {
        if (this.#offset + 4 > this.#data.length) {
            throw new RangeError('Write past end of buffer');
        }
        this.#view.setUint32(this.#offset, value, true);
        this.#offset += 4;
        return this;
    }
    /**
     * Writes a 32-bit signed integer in little-endian format.
     *
     * @param value - Value to write (-2147483648 to 2147483647)
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeInt32LE(-1); // Writes ff ff ff ff
     * ```
     */
    writeInt32LE(value) {
        if (this.#offset + 4 > this.#data.length) {
            throw new RangeError('Write past end of buffer');
        }
        this.#view.setInt32(this.#offset, value, true);
        this.#offset += 4;
        return this;
    }
    /**
     * Writes a 64-bit unsigned integer in little-endian format.
     *
     * @param value - Value to write as bigint
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeUInt64LE(50000n); // Writes 50 c3 00 00 00 00 00 00
     * ```
     */
    writeUInt64LE(value) {
        if (this.#offset + 8 > this.#data.length) {
            throw new RangeError('Write past end of buffer');
        }
        this.#view.setBigUint64(this.#offset, value, true);
        this.#offset += 8;
        return this;
    }
    /**
     * Writes a 64-bit signed integer in little-endian format.
     *
     * @param value - Value to write as bigint
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeInt64LE(value) {
        if (this.#offset + 8 > this.#data.length) {
            throw new RangeError('Write past end of buffer');
        }
        this.#view.setBigInt64(this.#offset, value, true);
        this.#offset += 8;
        return this;
    }
    /**
     * Writes raw bytes.
     *
     * @param bytes - Bytes to write
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeBytes(new Uint8Array([0xde, 0xad, 0xbe, 0xef]));
     * ```
     */
    writeBytes(bytes) {
        if (this.#offset + bytes.length > this.#data.length) {
            throw new RangeError('Write past end of buffer');
        }
        this.#data.set(bytes, this.#offset);
        this.#offset += bytes.length;
        return this;
    }
    /**
     * Writes a Bitcoin CompactSize variable-length integer.
     *
     * CompactSize encoding:
     * - 0x00-0xFC: 1 byte (value as-is)
     * - 0xFD-0xFFFF: 3 bytes (0xFD + 2-byte LE uint16)
     * - 0x10000-0xFFFFFFFF: 5 bytes (0xFE + 4-byte LE uint32)
     * - Larger: 9 bytes (0xFF + 8-byte LE uint64)
     *
     * @param value - Value to write
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeVarInt(252);    // Writes fc
     * writer.writeVarInt(253);    // Writes fd fd 00
     * writer.writeVarInt(65535);  // Writes fd ff ff
     * writer.writeVarInt(65536);  // Writes fe 00 00 01 00
     * ```
     */
    writeVarInt(value) {
        if (value < 0xfd) {
            return this.writeUInt8(value);
        }
        if (value <= 0xffff) {
            this.writeUInt8(0xfd);
            return this.writeUInt16LE(value);
        }
        if (value <= 0xffffffff) {
            this.writeUInt8(0xfe);
            return this.writeUInt32LE(value);
        }
        this.writeUInt8(0xff);
        return this.writeUInt64LE(BigInt(value));
    }
    /**
     * Writes a Bitcoin CompactSize variable-length integer from bigint.
     *
     * @param value - Value to write as bigint
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeVarIntBig(value) {
        if (value < 0xfdn) {
            return this.writeUInt8(Number(value));
        }
        if (value <= 0xffffn) {
            this.writeUInt8(0xfd);
            return this.writeUInt16LE(Number(value));
        }
        if (value <= 0xffffffffn) {
            this.writeUInt8(0xfe);
            return this.writeUInt32LE(Number(value));
        }
        this.writeUInt8(0xff);
        return this.writeUInt64LE(value);
    }
    /**
     * Writes a length-prefixed byte array (VarInt length + bytes).
     *
     * @param bytes - Bytes to write
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     *
     * @example
     * ```typescript
     * writer.writeVarBytes(new Uint8Array([0xde, 0xad])); // Writes 02 de ad
     * ```
     */
    writeVarBytes(bytes) {
        this.writeVarInt(bytes.length);
        return this.writeBytes(bytes);
    }
    /**
     * Writes an array of length-prefixed byte arrays.
     *
     * Format: VarInt count + (VarInt length + bytes) for each item.
     *
     * @param vector - Array of byte arrays to write
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    writeVector(vector) {
        this.writeVarInt(vector.length);
        for (const item of vector) {
            this.writeVarBytes(item);
        }
        return this;
    }
    /**
     * Fills a region with a specific byte value.
     *
     * @param value - Byte value to fill with
     * @param length - Number of bytes to fill
     * @returns This writer for chaining
     * @throws RangeError if writing past end of buffer
     */
    fill(value, length) {
        if (this.#offset + length > this.#data.length) {
            throw new RangeError('Write past end of buffer');
        }
        this.#data.fill(value, this.#offset, this.#offset + length);
        this.#offset += length;
        return this;
    }
    /**
     * Skips a specified number of bytes (leaves them unchanged).
     *
     * @param length - Number of bytes to skip
     * @returns This writer for chaining
     * @throws RangeError if skipping past end of buffer
     */
    skip(length) {
        if (this.#offset + length > this.#data.length) {
            throw new RangeError('Skip past end of buffer');
        }
        this.#offset += length;
        return this;
    }
    /**
     * Resets the write position to the beginning.
     *
     * @returns This writer for chaining
     */
    reset() {
        this.#offset = 0;
        return this;
    }
    /**
     * Verifies the buffer was fully written and returns it.
     *
     * Unlike {@link finish}, this method throws if the writer has not
     * written exactly to the end of the buffer.
     *
     * @returns The underlying buffer
     * @throws Error if the buffer was not fully written
     *
     * @example
     * ```typescript
     * const writer = new BinaryWriter(8);
     * writer.writeUInt32LE(1);
     * writer.writeUInt32LE(2);
     * const bytes = writer.end(); // OK: wrote exactly 8 bytes
     *
     * const writer2 = new BinaryWriter(8);
     * writer2.writeUInt32LE(1);
     * writer2.end(); // throws: buffer size 8, offset 4
     * ```
     */
    end() {
        if (this.#offset === this.#data.length) {
            return this.#data;
        }
        throw new Error(`buffer size ${this.#data.length}, offset ${this.#offset}`);
    }
    /**
     * Returns the written portion of the buffer.
     *
     * If the entire buffer was written, returns the buffer directly (no copy).
     * Otherwise, returns a subarray view.
     *
     * @returns Uint8Array containing the written data
     *
     * @example
     * ```typescript
     * const writer = new BinaryWriter(100);
     * writer.writeUInt32LE(42);
     * const bytes = writer.finish(); // 4 bytes
     * ```
     */
    finish() {
        return this.#offset === this.#data.length
            ? this.#data
            : this.#data.subarray(0, this.#offset);
    }
    /**
     * Returns the written portion as a hex string.
     *
     * @returns Hex string representation
     *
     * @example
     * ```typescript
     * const writer = new BinaryWriter(4);
     * writer.writeUInt32LE(1);
     * writer.toHex(); // '01000000'
     * ```
     */
    toHex() {
        return toHex$1(this.finish());
    }
};
/**
 * A BinaryWriter that automatically grows its buffer as needed.
 *
 * Use when the final size is unknown.
 *
 * @example
 * ```typescript
 * const writer = BinaryWriter.growable();
 * writer.writeBytes(largeData); // Automatically grows
 * const bytes = writer.finish();
 * ```
 */
class GrowableBinaryWriter {
    #data;
    #view;
    #offset = 0;
    /**
     * Creates a new GrowableBinaryWriter.
     *
     * @param initialCapacity - Initial buffer size (default 256)
     */
    constructor(initialCapacity = 256) {
        this.#data = new Uint8Array(initialCapacity);
        this.#view = new DataView(this.#data.buffer);
    }
    /**
     * Current write position.
     */
    get offset() {
        return this.#offset;
    }
    /**
     * Sets the write position.
     *
     * @param value - New offset value
     * @throws RangeError if offset is negative
     */
    set offset(value) {
        if (value < 0) {
            throw new RangeError(`Offset ${value} cannot be negative`);
        }
        // GrowableBinaryWriter can grow, so allow setting offset beyond current capacity
        this.#offset = value;
    }
    /**
     * Current buffer capacity.
     */
    get capacity() {
        return this.#data.length;
    }
    writeUInt8(value) {
        this.#ensureCapacity(1);
        this.#data[this.#offset++] = value & 0xff;
        return this;
    }
    writeUInt16LE(value) {
        this.#ensureCapacity(2);
        this.#view.setUint16(this.#offset, value, true);
        this.#offset += 2;
        return this;
    }
    writeUInt32LE(value) {
        this.#ensureCapacity(4);
        this.#view.setUint32(this.#offset, value, true);
        this.#offset += 4;
        return this;
    }
    writeInt32LE(value) {
        this.#ensureCapacity(4);
        this.#view.setInt32(this.#offset, value, true);
        this.#offset += 4;
        return this;
    }
    writeUInt64LE(value) {
        this.#ensureCapacity(8);
        this.#view.setBigUint64(this.#offset, value, true);
        this.#offset += 8;
        return this;
    }
    writeBytes(bytes) {
        this.#ensureCapacity(bytes.length);
        this.#data.set(bytes, this.#offset);
        this.#offset += bytes.length;
        return this;
    }
    writeVarInt(value) {
        if (value < 0xfd) {
            return this.writeUInt8(value);
        }
        if (value <= 0xffff) {
            this.writeUInt8(0xfd);
            return this.writeUInt16LE(value);
        }
        if (value <= 0xffffffff) {
            this.writeUInt8(0xfe);
            return this.writeUInt32LE(value);
        }
        this.writeUInt8(0xff);
        return this.writeUInt64LE(BigInt(value));
    }
    writeVarBytes(bytes) {
        this.writeVarInt(bytes.length);
        return this.writeBytes(bytes);
    }
    writeVector(vector) {
        this.writeVarInt(vector.length);
        for (const item of vector) {
            this.writeVarBytes(item);
        }
        return this;
    }
    /**
     * Returns the written data as a new Uint8Array.
     *
     * @returns Copy of the written data
     */
    finish() {
        return this.#data.slice(0, this.#offset);
    }
    /**
     * Returns the written data as a hex string.
     *
     * @returns Hex string representation
     */
    toHex() {
        return toHex$1(this.finish());
    }
    /**
     * Ensures the buffer has enough space for additional bytes.
     *
     * @param additionalBytes - Number of additional bytes needed
     */
    #ensureCapacity(additionalBytes) {
        const required = this.#offset + additionalBytes;
        if (required <= this.#data.length) {
            return;
        }
        // Grow by at least 2x or to required size
        let newCapacity = this.#data.length * 2;
        while (newCapacity < required) {
            newCapacity *= 2;
        }
        const newData = new Uint8Array(newCapacity);
        newData.set(this.#data.subarray(0, this.#offset));
        this.#data = newData;
        this.#view = new DataView(this.#data.buffer);
    }
}

/**
 * Base64 encoding and decoding utilities.
 *
 * @packageDocumentation
 */
/**
 * Decodes a base64 string to a Uint8Array.
 *
 * @param base64 - The base64-encoded string to decode
 * @returns Uint8Array containing the decoded bytes
 */
function fromBase64$1(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
}
/**
 * Encode a Uint8Array into a Base64 string.
 * Uses the native btoa() available in both browser and service worker contexts.
 *
 * @param bytes - The bytes to encode
 * @returns Base64-encoded string
 */
function toBase64$1(bytes) {
    let binaryString = '';
    for (let i = 0; i < bytes.length; i++) {
        binaryString += String.fromCharCode(bytes[i]);
    }
    return btoa(binaryString);
}

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i = 0; i < ALPHABET.length; i++) {
    const x = ALPHABET.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i;
  }
  const BASE = ALPHABET.length;
  const LEADER = ALPHABET.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  const iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode (source) {
    // eslint-disable-next-line no-empty
    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
    // Skip & count leading zeroes.
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    // Allocate enough space in big-endian base58 representation.
    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
    const b58 = new Uint8Array(size);
    // Process the bytes.
    while (pbegin !== pend) {
      let carry = source[pbegin];
      // Apply "b58 = b58 * 256 + ch".
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0;
        b58[it1] = (carry % BASE) >>> 0;
        carry = (carry / BASE) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      pbegin++;
    }
    // Skip leading zeroes in base58 result.
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    // Translate the result into a string.
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    let psz = 0;
    // Skip and count leading '1's.
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    // Allocate enough space in big-endian base256 representation.
    const size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
    const b256 = new Uint8Array(size);
    // Process the characters.
    while (psz < source.length) {
      // Find code of next character
      const charCode = source.charCodeAt(psz);
      // Base map can not be indexed using char code
      if (charCode > 255) { return }
      // Decode character
      let carry = BASE_MAP[charCode];
      // Invalid character
      if (carry === 255) { return }
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0;
        b256[it3] = (carry % 256) >>> 0;
        carry = (carry / 256) >>> 0;
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i;
      psz++;
    }
    // Skip leading zeroes in b256.
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch
  }
  function decode (string) {
    const buffer = decodeUnsafe(string);
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode,
    decodeUnsafe,
    decode
  }
}

var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
const base58 = base(ALPHABET);

function bs58checkBase(checksumFn) {
    function encode(payload) {
        const checksum = checksumFn(payload);
        const length = payload.length + 4;
        const both = new Uint8Array(length);
        both.set(payload, 0);
        both.set(checksum.subarray(0, 4), payload.length);
        return base58.encode(both);
    }
    function decodeRaw(buffer) {
        const payload = buffer.slice(0, -4);
        const checksum = buffer.slice(-4);
        const newChecksum = checksumFn(payload);
        if ((checksum[0] ^ newChecksum[0]) |
            (checksum[1] ^ newChecksum[1]) |
            (checksum[2] ^ newChecksum[2]) |
            (checksum[3] ^ newChecksum[3])) {
            return undefined;
        }
        return payload;
    }
    function decodeUnsafe(str) {
        const buffer = base58.decodeUnsafe(str);
        if (buffer === undefined)
            return undefined;
        return decodeRaw(buffer);
    }
    function decode(str) {
        const buffer = base58.decode(str);
        const payload = decodeRaw(buffer);
        if (payload === undefined)
            throw new Error('Invalid checksum');
        return payload;
    }
    return {
        encode,
        decode,
        decodeUnsafe,
    };
}

function sha256x2(payload) {
    return sha256$2(sha256$2(payload));
}
const { encode: encode$j, decode: decode$i, decodeUnsafe } = bs58checkBase(sha256x2);
const bs58check = { encode: encode$j, decode: decode$i, decodeUnsafe };

const build$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    bs58checkBase,
    decode: decode$i,
    decodeUnsafe,
    default: bs58check,
    encode: encode$j
}, Symbol.toStringTag, { value: 'Module' }));

/**
 * Pure utility functions for Uint8Array operations.
 *
 * No DataView allocations. No wrappers.
 * Optimized for performance with minimal allocations.
 *
 * @packageDocumentation
 */
/**
 * Concatenates multiple Uint8Arrays into a single Uint8Array.
 *
 * Allocates exactly once for the result array.
 *
 * @param arrays - Arrays to concatenate
 * @returns A new Uint8Array containing all input arrays
 *
 * @example
 * ```typescript
 * import { concat, fromHex } from '@btc-vision/bitcoin';
 *
 * const a = fromHex('deadbeef');
 * const b = fromHex('cafebabe');
 * const result = concat([a, b]);
 * // result contains deadbeefcafebabe
 * ```
 */
function concat$1(arrays) {
    let totalLength = 0;
    for (const arr of arrays) {
        totalLength += arr.length;
    }
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
/**
 * Checks if two Uint8Arrays have identical contents.
 *
 * @param a - First array
 * @param b - Second array
 * @returns True if arrays have the same length and contents
 *
 * @example
 * ```typescript
 * import { equals, fromHex } from '@btc-vision/bitcoin';
 *
 * const a = fromHex('deadbeef');
 * const b = fromHex('deadbeef');
 * const c = fromHex('cafebabe');
 *
 * equals(a, b); // true
 * equals(a, c); // false
 * ```
 */
function equals(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Compares two Uint8Arrays lexicographically.
 *
 * @param a - First array
 * @param b - Second array
 * @returns Negative if a < b, positive if a > b, 0 if equal
 *
 * @example
 * ```typescript
 * import { compare, fromHex } from '@btc-vision/bitcoin';
 *
 * const a = fromHex('0001');
 * const b = fromHex('0002');
 *
 * compare(a, b); // -1 (a < b)
 * compare(b, a); // 1 (b > a)
 * compare(a, a); // 0 (equal)
 * ```
 */
function compare$2(a, b) {
    const minLength = Math.min(a.length, b.length);
    for (let i = 0; i < minLength; i++) {
        const diff = a[i] - b[i];
        if (diff !== 0) {
            return diff;
        }
    }
    return a.length - b.length;
}
/**
 * Checks if a Uint8Array contains only zero bytes.
 *
 * @param bytes - Array to check
 * @returns True if all bytes are zero
 *
 * @example
 * ```typescript
 * import { isZero } from '@btc-vision/bitcoin';
 *
 * isZero(new Uint8Array(32)); // true
 * isZero(new Uint8Array([0, 0, 1])); // false
 * ```
 */
function isZero(bytes) {
    for (let i = 0; i < bytes.length; i++) {
        if (bytes[i] !== 0) {
            return false;
        }
    }
    return true;
}
/**
 * Creates a copy of a Uint8Array.
 *
 * @param bytes - Array to clone
 * @returns A new Uint8Array with the same contents
 *
 * @example
 * ```typescript
 * import { clone, fromHex } from '@btc-vision/bitcoin';
 *
 * const original = fromHex('deadbeef');
 * const copy = clone(original);
 * copy[0] = 0; // Modifying copy doesn't affect original
 * ```
 */
function clone$1(bytes) {
    // Create a true copy - .slice() on Buffer returns a view, not a copy
    const copy = new Uint8Array(bytes.length);
    copy.set(bytes);
    return copy;
}
/**
 * Reverses a Uint8Array in place.
 *
 * @param bytes - Array to reverse
 * @returns The same array, reversed
 *
 * @example
 * ```typescript
 * import { reverse, fromHex, toHex } from '@btc-vision/bitcoin';
 *
 * const bytes = fromHex('01020304');
 * reverse(bytes);
 * toHex(bytes); // '04030201'
 * ```
 */
function reverse(bytes) {
    bytes.reverse();
    return bytes;
}
/**
 * Allocates a new Uint8Array of the specified size.
 *
 * @param size - Number of bytes to allocate
 * @param fill - Optional fill value (default 0)
 * @returns A new Uint8Array filled with the specified value
 *
 * @example
 * ```typescript
 * import { alloc, toHex } from '@btc-vision/bitcoin';
 *
 * const zeros = alloc(4); // 4 zero bytes
 * const ones = alloc(4, 0xff); // 4 bytes of 0xff
 * toHex(ones); // 'ffffffff'
 * ```
 */
function alloc(size, fill = 0) {
    const result = new Uint8Array(size);
    if (fill !== 0) {
        result.fill(fill);
    }
    return result;
}
/**
 * Creates a Uint8Array from a UTF-8 string.
 *
 * @param str - String to encode
 * @returns Uint8Array containing UTF-8 encoded bytes
 *
 * @example
 * ```typescript
 * import { fromUtf8, toHex } from '@btc-vision/bitcoin';
 *
 * const bytes = fromUtf8('hello');
 * toHex(bytes); // '68656c6c6f'
 * ```
 */
function fromUtf8$1(str) {
    return new TextEncoder().encode(str);
}

// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use
function check$d(buffer) {
    if (buffer.length < 8)
        return false;
    if (buffer.length > 72)
        return false;
    if (buffer[0] !== 0x30)
        return false;
    if (buffer[1] !== buffer.length - 2)
        return false;
    if (buffer[2] !== 0x02)
        return false;
    const lenR = buffer[3]; // Safe: length >= 8
    if (lenR === 0)
        return false;
    if (5 + lenR >= buffer.length)
        return false;
    if (buffer[4 + lenR] !== 0x02)
        return false;
    const lenS = buffer[5 + lenR]; // Safe: bounds checked above
    if (lenS === 0)
        return false;
    if (6 + lenR + lenS !== buffer.length)
        return false;
    if (buffer[4] & 0x80)
        return false;
    if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))
        return false;
    if (buffer[lenR + 6] & 0x80)
        return false;
    if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
        return false;
    return true;
}
function decode$h(buffer) {
    if (buffer.length < 8)
        throw new Error('DER sequence length is too short');
    if (buffer.length > 72)
        throw new Error('DER sequence length is too long');
    if (buffer[0] !== 0x30)
        throw new Error('Expected DER sequence');
    if (buffer[1] !== buffer.length - 2)
        throw new Error('DER sequence length is invalid');
    if (buffer[2] !== 0x02)
        throw new Error('Expected DER integer');
    const lenR = buffer[3]; // Safe: length >= 8
    if (lenR === 0)
        throw new Error('R length is zero');
    if (5 + lenR >= buffer.length)
        throw new Error('R length is too long');
    if (buffer[4 + lenR] !== 0x02)
        throw new Error('Expected DER integer (2)');
    const lenS = buffer[5 + lenR]; // Safe: bounds checked above
    if (lenS === 0)
        throw new Error('S length is zero');
    if (6 + lenR + lenS !== buffer.length)
        throw new Error('S length is invalid');
    if (buffer[4] & 0x80)
        throw new Error('R value is negative');
    if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))
        throw new Error('R value excessively padded');
    if (buffer[lenR + 6] & 0x80)
        throw new Error('S value is negative');
    if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))
        throw new Error('S value excessively padded');
    // non-BIP66 - extract R, S values
    return {
        r: buffer.subarray(4, 4 + lenR),
        s: buffer.subarray(6 + lenR),
    };
}
/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
 */
function encode$i(r, s) {
    const lenR = r.length;
    const lenS = s.length;
    if (lenR === 0)
        throw new Error('R length is zero');
    if (lenS === 0)
        throw new Error('S length is zero');
    if (lenR > 33)
        throw new Error('R length is too long');
    if (lenS > 33)
        throw new Error('S length is too long');
    if (r[0] & 0x80)
        throw new Error('R value is negative');
    if (s[0] & 0x80)
        throw new Error('S value is negative');
    if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))
        throw new Error('R value excessively padded');
    if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))
        throw new Error('S value excessively padded');
    const signature = alloc(6 + lenR + lenS);
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    signature[0] = 0x30;
    signature[1] = signature.length - 2;
    signature[2] = 0x02;
    signature[3] = r.length;
    signature.set(r, 4);
    signature[4 + lenR] = 0x02;
    signature[5 + lenR] = s.length;
    signature.set(s, 6 + lenR);
    return signature;
}

const opcodes = {
    OP_FALSE: 0,
    OP_0: 0,
    OP_PUSHDATA1: 76,
    OP_PUSHDATA2: 77,
    OP_PUSHDATA4: 78,
    OP_1NEGATE: 79,
    OP_RESERVED: 80,
    OP_TRUE: 81,
    OP_1: 81,
    OP_2: 82,
    OP_3: 83,
    OP_4: 84,
    OP_5: 85,
    OP_6: 86,
    OP_7: 87,
    OP_8: 88,
    OP_9: 89,
    OP_10: 90,
    OP_11: 91,
    OP_12: 92,
    OP_13: 93,
    OP_14: 94,
    OP_15: 95,
    OP_16: 96,
    OP_NOP: 97,
    OP_VER: 98,
    OP_IF: 99,
    OP_NOTIF: 100,
    OP_VERIF: 101,
    OP_VERNOTIF: 102,
    OP_ELSE: 103,
    OP_ENDIF: 104,
    OP_VERIFY: 105,
    OP_RETURN: 106,
    OP_TOALTSTACK: 107,
    OP_FROMALTSTACK: 108,
    OP_2DROP: 109,
    OP_2DUP: 110,
    OP_3DUP: 111,
    OP_2OVER: 112,
    OP_2ROT: 113,
    OP_2SWAP: 114,
    OP_IFDUP: 115,
    OP_DEPTH: 116,
    OP_DROP: 117,
    OP_DUP: 118,
    OP_NIP: 119,
    OP_OVER: 120,
    OP_PICK: 121,
    OP_ROLL: 122,
    OP_ROT: 123,
    OP_SWAP: 124,
    OP_TUCK: 125,
    OP_CAT: 126,
    OP_SUBSTR: 127,
    OP_LEFT: 128,
    OP_RIGHT: 129,
    OP_SIZE: 130,
    OP_INVERT: 131,
    OP_AND: 132,
    OP_OR: 133,
    OP_XOR: 134,
    OP_EQUAL: 135,
    OP_EQUALVERIFY: 136,
    OP_RESERVED1: 137,
    OP_RESERVED2: 138,
    OP_1ADD: 139,
    OP_1SUB: 140,
    OP_2MUL: 141,
    OP_2DIV: 142,
    OP_NEGATE: 143,
    OP_ABS: 144,
    OP_NOT: 145,
    OP_0NOTEQUAL: 146,
    OP_ADD: 147,
    OP_SUB: 148,
    OP_MUL: 149,
    OP_DIV: 150,
    OP_MOD: 151,
    OP_LSHIFT: 152,
    OP_RSHIFT: 153,
    OP_BOOLAND: 154,
    OP_BOOLOR: 155,
    OP_NUMEQUAL: 156,
    OP_NUMEQUALVERIFY: 157,
    OP_NUMNOTEQUAL: 158,
    OP_LESSTHAN: 159,
    OP_GREATERTHAN: 160,
    OP_LESSTHANOREQUAL: 161,
    OP_GREATERTHANOREQUAL: 162,
    OP_MIN: 163,
    OP_MAX: 164,
    OP_WITHIN: 165,
    OP_RIPEMD160: 166,
    OP_SHA1: 167,
    OP_SHA256: 168,
    OP_HASH160: 169,
    OP_HASH256: 170,
    OP_CODESEPARATOR: 171,
    OP_CHECKSIG: 172,
    OP_CHECKSIGVERIFY: 173,
    OP_CHECKMULTISIG: 174,
    OP_CHECKMULTISIGVERIFY: 175,
    OP_NOP1: 176,
    OP_NOP2: 177,
    OP_CHECKLOCKTIMEVERIFY: 177,
    OP_NOP3: 178,
    OP_CHECKSEQUENCEVERIFY: 178,
    OP_NOP4: 179,
    OP_NOP5: 180,
    OP_NOP6: 181,
    OP_NOP7: 182,
    OP_NOP8: 183,
    OP_NOP9: 184,
    OP_NOP10: 185,
    OP_CHECKSIGADD: 186,
    OP_PUBKEYHASH: 253,
    OP_PUBKEY: 254,
    OP_INVALIDOPCODE: 255,
};
let _reverseOps;
/**
 * Returns the reverse mapping from opcode number to opcode name.
 * Lazily computed on first call.
 */
function getReverseOps() {
    if (!_reverseOps) {
        _reverseOps = {};
        for (const op of Object.keys(opcodes)) {
            const code = opcodes[op];
            _reverseOps[code] = op;
        }
    }
    return _reverseOps;
}
/**
 * @deprecated Use {@link getReverseOps}() for lazy initialization.
 * This eagerly-initialized alias exists for backward compatibility.
 */
getReverseOps();

/**
 * Calculates the encoding length of a number used for push data in Bitcoin transactions.
 * @param i The number to calculate the encoding length for.
 * @returns The encoding length of the number.
 */
function encodingLength(i) {
    return i < opcodes.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;
}
/**
 * Encodes a number into a buffer using a variable-length encoding scheme.
 * The encoded buffer is written starting at the specified offset.
 * Returns the size of the encoded buffer.
 *
 * @param buffer - The buffer to write the encoded data into.
 * @param num - The number to encode.
 * @param offset - The offset at which to start writing the encoded buffer.
 * @returns The size of the encoded buffer.
 */
function encode$h(buffer, num, offset) {
    const size = encodingLength(num);
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    // ~6 bit
    if (size === 1) {
        buffer[offset] = num;
        // 8 bit
    }
    else if (size === 2) {
        buffer[offset] = opcodes.OP_PUSHDATA1;
        buffer[offset + 1] = num;
        // 16 bit
    }
    else if (size === 3) {
        buffer[offset] = opcodes.OP_PUSHDATA2;
        view.setUint16(offset + 1, num, true);
        // 32 bit
    }
    else {
        buffer[offset] = opcodes.OP_PUSHDATA4;
        view.setUint32(offset + 1, num, true);
    }
    return size;
}
/**
 * Decodes a buffer and returns information about the opcode, number, and size.
 * @param buffer - The buffer to decode.
 * @param offset - The offset within the buffer to start decoding.
 * @returns An object containing the opcode, number, and size, or null if decoding fails.
 */
function decode$g(buffer, offset) {
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    const opcode = buffer[offset];
    let num;
    let size;
    // ~6 bit
    if (opcode < opcodes.OP_PUSHDATA1) {
        num = opcode;
        size = 1;
        // 8 bit
    }
    else if (opcode === opcodes.OP_PUSHDATA1) {
        if (offset + 2 > buffer.length)
            return null;
        num = buffer[offset + 1];
        size = 2;
        // 16 bit
    }
    else if (opcode === opcodes.OP_PUSHDATA2) {
        if (offset + 3 > buffer.length)
            return null;
        num = view.getUint16(offset + 1, true);
        size = 3;
        // 32 bit
    }
    else {
        if (offset + 5 > buffer.length)
            return null;
        if (opcode !== opcodes.OP_PUSHDATA4)
            throw new Error('Unexpected opcode');
        num = view.getUint32(offset + 1, true);
        size = 5;
    }
    return {
        opcode,
        number: num,
        size,
    };
}

var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports$1) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer2;
  exports$1.SlowBuffer = SlowBuffer2;
  exports$1.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer2, GlobalUint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer2(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, GlobalUint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = (function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  })();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer = buffer.Buffer;

/**
 * Decodes a script number from a buffer.
 *
 * @param buffer - The buffer containing the script number.
 * @param maxLength - The maximum length of the script number. Defaults to 4.
 * @param minimal - Whether the script number should be minimal. Defaults to true.
 * @returns The decoded script number.
 * @throws {TypeError} If the script number overflows the maximum length.
 * @throws {Error} If the script number is not minimally encoded when minimal is true.
 */
function decode$f(buffer, maxLength, minimal) {
    maxLength = maxLength || 4;
    minimal = minimal === undefined ? true : minimal;
    const length = buffer.length;
    if (length === 0)
        return 0;
    if (length > maxLength)
        throw new TypeError('Script number overflow');
    if (minimal) {
        if ((buffer[length - 1] & 0x7f) === 0) {
            if (length <= 1 || (buffer[length - 2] & 0x80) === 0)
                throw new Error('Non-minimally encoded script number');
        }
    }
    // 40-bit
    if (length === 5) {
        const a = buffer.readUInt32LE(0);
        const b = buffer.readUInt8(4);
        if (b & 0x80)
            return -((b & -129) * 0x100000000 + a);
        return b * 0x100000000 + a;
    }
    // 32-bit / 24-bit / 16-bit / 8-bit
    let result = 0;
    for (let i = 0; i < length; ++i) {
        result |= buffer[i] << (8 * i);
    }
    if (buffer[length - 1] & 0x80)
        return -(result & ~(0x80 << (8 * (length - 1))));
    return result;
}
function scriptNumSize(i) {
    return i > 0x7fffffff ? 5 : i > 0x7fffff ? 4 : i > 0x7fff ? 3 : i > 0x7f ? 2 : i > 0x00 ? 1 : 0;
}
/**
 * Encodes a number into a Buffer using a specific format.
 *
 * @param _number - The number to encode.
 * @returns The encoded number as a Buffer.
 */
function encode$g(_number) {
    let value = Math.abs(_number);
    const size = scriptNumSize(value);
    const buffer = Buffer.allocUnsafe(size);
    const negative = _number < 0;
    for (let i = 0; i < size; ++i) {
        buffer.writeUInt8(value & 0xff, i);
        value >>= 8;
    }
    if (buffer[size - 1] & 0x80) {
        buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
    }
    else if (negative) {
        buffer[size - 1] = buffer[size - 1] | 0x80;
    }
    return buffer;
}

const scriptNumber = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    decode: decode$f,
    encode: encode$g
}, Symbol.toStringTag, { value: 'Module' }));

/**
 * Core type definitions, branded types, and type guard functions.
 *
 * @packageDocumentation
 */
/** @internal Do not mutate */
const EC_P = fromHex$1('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
/** @internal Do not mutate â€” secp256k1 curve order */
fromHex$1('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
const SATOSHI_MAX = 21n * 10n ** 14n;
const TAPLEAF_VERSION_MASK = 0xfe;
function isUInt8(value) {
    return typeof value === 'number' && Number.isInteger(value) && value >= 0 && value <= 0xff;
}
function isNumber(value) {
    return typeof value === 'number' && Number.isFinite(value);
}
function isUint8ArrayN(value, n) {
    return value instanceof Uint8Array && value.length === n;
}
function isArray(value) {
    return Array.isArray(value);
}
function isHex(value) {
    if (typeof value !== 'string')
        return false;
    if (value.length % 2 !== 0)
        return false;
    return /^[0-9a-fA-F]*$/.test(value);
}
function isBytes32(value) {
    return value instanceof Uint8Array && value.length === 32;
}
function isBytes20(value) {
    return value instanceof Uint8Array && value.length === 20;
}
function isXOnlyPublicKey(value) {
    if (!(value instanceof Uint8Array) || value.length !== 32)
        return false;
    if (isZero(value))
        return false;
    return compare$2(value, EC_P) < 0;
}
function isPoint(value) {
    if (!(value instanceof Uint8Array))
        return false;
    if (value.length < 33)
        return false;
    const prefix = value[0];
    const x = value.subarray(1, 33);
    if (isZero(x))
        return false;
    if (compare$2(x, EC_P) >= 0)
        return false;
    if ((prefix === 0x02 || prefix === 0x03) && value.length === 33) {
        return true;
    }
    if (value.length !== 65)
        return false;
    const y = value.subarray(33);
    if (isZero(y))
        return false;
    if (compare$2(y, EC_P) >= 0)
        return false;
    return prefix === 0x04 || prefix === 0x06 || prefix === 0x07;
}
function isTapleaf(value) {
    if (!value || typeof value !== 'object')
        return false;
    const obj = value;
    if (!('output' in obj))
        return false;
    if (!(obj['output'] instanceof Uint8Array))
        return false;
    if (obj['version'] !== undefined) {
        if (typeof obj['version'] !== 'number')
            return false;
        if ((obj['version'] & TAPLEAF_VERSION_MASK) !== obj['version'])
            return false;
    }
    return true;
}
// Utility Functions
function stacksEqual(a, b) {
    if (a.length !== b.length)
        return false;
    return a.every((x, i) => equals(x, b[i]));
}
function toBytes32(value) {
    if (!isBytes32(value)) {
        throw new TypeError(`Expected 32-byte Uint8Array, got ${value.length} bytes`);
    }
    return value;
}
function isMessageHash(value) {
    return value instanceof Uint8Array && value.length === 32;
}
function toMessageHash(value) {
    if (!isMessageHash(value)) {
        throw new TypeError(`Expected 32-byte Uint8Array, got ${value.length} bytes`);
    }
    return value;
}
function toBytes20(value) {
    if (!isBytes20(value)) {
        throw new TypeError(`Expected 20-byte Uint8Array, got ${value.length} bytes`);
    }
    return value;
}
function toSatoshi(value) {
    if (value < 0n) {
        throw new RangeError(`Satoshi cannot be negative, got ${value}`);
    }
    if (value > SATOSHI_MAX) {
        throw new RangeError(`Satoshi exceeds maximum supply (${SATOSHI_MAX}), got ${value}`);
    }
    return value;
}

const ZERO$2 = new Uint8Array([0]);
/**
 * Checks if a hash type is defined (valid for Bitcoin signatures).
 * @param hashType - The hash type to check.
 * @returns True if the hash type is valid, false otherwise.
 */
function isDefinedHashType(hashType) {
    const hashTypeMod = hashType & -129;
    return hashTypeMod > 0x00 && hashTypeMod < 0x04;
}
/**
 * Converts a Uint8Array to a DER-encoded Uint8Array.
 * @param x - The Uint8Array to be converted.
 * @returns The DER-encoded Uint8Array.
 */
function toDER(x) {
    let i = 0;
    while (x[i] === 0)
        ++i;
    if (i === x.length)
        return ZERO$2;
    x = x.subarray(i);
    if (x[0] & 0x80)
        return concat$1([ZERO$2, x]);
    return x;
}
/**
 * Converts a DER-encoded signature to a Uint8Array.
 * If the first byte of the input is 0x00, it is skipped.
 * The resulting Uint8Array is 32 bytes long, filled with zeros if necessary.
 * @param x - The DER-encoded signature.
 * @returns The converted Uint8Array.
 */
function fromDER(x) {
    if (x[0] === 0x00)
        x = x.subarray(1);
    const buffer = alloc(32);
    const bstart = Math.max(0, 32 - x.length);
    buffer.set(x, bstart);
    return buffer;
}
// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)
/**
 * Decodes a Uint8Array into a ScriptSignature object.
 * @param buffer - The Uint8Array to decode.
 * @returns The decoded ScriptSignature object.
 * @throws Error if the hashType is invalid.
 */
function decode$e(buffer) {
    const hashType = buffer[buffer.length - 1];
    if (!isDefinedHashType(hashType)) {
        throw new Error(`Invalid hashType ${hashType}`);
    }
    const decoded = decode$h(buffer.subarray(0, -1));
    const r = fromDER(decoded.r);
    const s = fromDER(decoded.s);
    const signature = concat$1([r, s]);
    return { signature, hashType };
}
/**
 * Encodes a signature and hash type into a Uint8Array.
 * @param signature - The signature to encode.
 * @param hashType - The hash type to encode.
 * @returns The encoded Uint8Array.
 * @throws Error if the hashType is invalid.
 */
function encode$f(signature, hashType) {
    if (!isUint8ArrayN(signature, 64)) {
        throw new TypeError('Expected signature to be a 64-byte Uint8Array');
    }
    if (!isUInt8(hashType)) {
        throw new TypeError('Expected hashType to be a UInt8');
    }
    if (!isDefinedHashType(hashType)) {
        throw new Error(`Invalid hashType ${hashType}`);
    }
    const hashTypeBuffer = new Uint8Array([hashType]);
    const r = toDER(signature.subarray(0, 32));
    const s = toDER(signature.subarray(32, 64));
    return concat$1([encode$i(r, s), hashTypeBuffer]);
}

const scriptSignature = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    decode: decode$e,
    encode: encode$f,
    isDefinedHashType
}, Symbol.toStringTag, { value: 'Module' }));

/**
 * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature
 * @packageDocumentation
 */
const OP_INT_BASE$1 = opcodes.OP_RESERVED; // OP_1 - 1
function isOPInt(value) {
    return (isNumber(value) &&
        (value === opcodes.OP_0 ||
            (value >= opcodes.OP_1 && value <= opcodes.OP_16) ||
            value === opcodes.OP_1NEGATE));
}
function isPushOnlyChunk(value) {
    if (value instanceof Uint8Array)
        return true;
    return isOPInt(value);
}
function isPushOnly(value) {
    return isArray(value) && value.every(isPushOnlyChunk);
}
function countNonPushOnlyOPs(value) {
    return value.length - value.filter(isPushOnlyChunk).length;
}
function asMinimalOP(buffer) {
    if (buffer.length === 0)
        return opcodes.OP_0;
    if (buffer.length !== 1)
        return undefined;
    const firstByte = buffer[0];
    if (firstByte >= 1 && firstByte <= 16)
        return OP_INT_BASE$1 + firstByte;
    if (firstByte === 0x81)
        return opcodes.OP_1NEGATE;
    return undefined;
}
function chunksIsUint8Array(buf) {
    return buf instanceof Uint8Array;
}
function chunksIsArray(buf) {
    return isArray(buf);
}
function singleChunkIsUint8Array(buf) {
    return buf instanceof Uint8Array;
}
/**
 * Compiles an array of chunks into a Uint8Array.
 *
 * @param chunks - The array of chunks to compile.
 * @returns The compiled Uint8Array.
 * @throws Error if the compilation fails.
 */
function compile(chunks) {
    // Already compiled - return as-is
    if (chunksIsUint8Array(chunks))
        return chunks;
    if (!isArray(chunks)) {
        throw new TypeError('Expected an array');
    }
    const bufferSize = chunks.reduce((accum, chunk) => {
        // data chunk
        if (singleChunkIsUint8Array(chunk)) {
            // adhere to BIP62.3, minimal push policy
            if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
                return accum + 1;
            }
            return accum + encodingLength(chunk.length) + chunk.length;
        }
        // opcode
        return accum + 1;
    }, 0.0);
    const buffer = new Uint8Array(bufferSize);
    let offset = 0;
    chunks.forEach((chunk) => {
        // data chunk
        if (singleChunkIsUint8Array(chunk)) {
            // adhere to BIP62.3, minimal push policy
            const opcode = asMinimalOP(chunk);
            if (opcode !== undefined) {
                buffer[offset] = opcode;
                offset += 1;
                return;
            }
            offset += encode$h(buffer, chunk.length, offset);
            buffer.set(chunk, offset);
            offset += chunk.length;
            // opcode
        }
        else {
            buffer[offset] = chunk;
            offset += 1;
        }
    });
    if (offset !== buffer.length)
        throw new Error('Could not decode chunks');
    return buffer;
}
function decompile(buffer) {
    // Already decompiled - return as-is
    if (chunksIsArray(buffer))
        return buffer;
    if (!(buffer instanceof Uint8Array)) {
        throw new TypeError('Expected a Uint8Array');
    }
    const chunks = [];
    let i = 0;
    while (i < buffer.length) {
        const opcode = buffer[i];
        // data chunk
        if (opcode > opcodes.OP_0 && opcode <= opcodes.OP_PUSHDATA4) {
            const d = decode$g(buffer, i);
            // did reading a pushDataInt fail?
            if (d === null)
                return null;
            i += d.size;
            // attempt to read too much data?
            if (i + d.number > buffer.length)
                return null;
            const data = buffer.subarray(i, i + d.number);
            i += d.number;
            // decompile minimally
            const op = asMinimalOP(data);
            if (op !== undefined) {
                chunks.push(op);
            }
            else {
                chunks.push(data);
            }
            // opcode
        }
        else {
            chunks.push(opcode);
            i += 1;
        }
    }
    return chunks;
}
/**
 * Converts the given chunks into an ASM (Assembly) string representation.
 * If the chunks parameter is a Uint8Array, it will be decompiled into a Stack before conversion.
 * @param chunks - The chunks to convert into ASM.
 * @returns The ASM string representation of the chunks.
 */
function toASM(chunks) {
    let resolved;
    if (chunksIsUint8Array(chunks)) {
        const decompiled = decompile(chunks);
        if (!decompiled) {
            throw new Error('Could not convert invalid chunks to ASM');
        }
        resolved = decompiled;
    }
    else {
        resolved = chunks;
    }
    return resolved
        .map((chunk) => {
        // data?
        if (singleChunkIsUint8Array(chunk)) {
            const op = asMinimalOP(chunk);
            if (op === undefined)
                return toHex$1(chunk);
            chunk = op;
        }
        // opcode!
        return getReverseOps()[chunk];
    })
        .join(' ');
}
/**
 * Converts an ASM string to a Uint8Array.
 * @param asm The ASM string to convert.
 * @returns The converted Uint8Array.
 */
function fromASM(asm) {
    if (typeof asm !== 'string') {
        throw new TypeError('Expected a string');
    }
    return compile(asm.split(' ').map((chunkStr) => {
        // opcode?
        if (opcodes[chunkStr] !== undefined) {
            return opcodes[chunkStr];
        }
        if (!isHex(chunkStr)) {
            throw new TypeError('Expected hex string');
        }
        // data!
        return fromHex$1(chunkStr);
    }));
}
/**
 * Converts the given chunks into a stack of Uint8Arrays.
 *
 * @param chunks - The chunks to convert.
 * @returns The stack of Uint8Arrays.
 */
function toStack(chunks) {
    const resolved = chunksIsUint8Array(chunks) ? decompile(chunks) : chunks;
    if (!resolved || !isPushOnly(resolved)) {
        throw new TypeError('Expected push-only script');
    }
    return resolved.map((op) => {
        if (singleChunkIsUint8Array(op))
            return op;
        if (op === opcodes.OP_0)
            return alloc(0);
        return encode$g(op - OP_INT_BASE$1);
    });
}
function isCanonicalPubKey(buffer) {
    return isPoint(buffer);
}
function isCanonicalScriptSignature(buffer) {
    if (!(buffer instanceof Uint8Array))
        return false;
    if (!isDefinedHashType(buffer[buffer.length - 1]))
        return false;
    return check$d(buffer.subarray(0, -1));
}
const number = scriptNumber;
const signature = scriptSignature;

const script = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    compile,
    countNonPushOnlyOPs,
    decompile,
    fromASM,
    isCanonicalPubKey,
    isCanonicalScriptSignature,
    isPushOnly,
    number,
    opcodes,
    signature,
    toASM,
    toStack
}, Symbol.toStringTag, { value: 'Module' }));

/**
 * Payment types and interfaces
 * @packageDocumentation
 */
const PaymentType = {
    P2PK: 'p2pk',
    P2PKH: 'p2pkh',
    P2SH: 'p2sh',
    P2MS: 'p2ms',
    P2WPKH: 'p2wpkh',
    P2WSH: 'p2wsh',
    P2TR: 'p2tr',
    P2MR: 'p2mr',
    P2OP: 'p2op',
    Embed: 'embed',
    ScriptRedeem: 'scriptRedeem',
};

/**
 * Pay-to-OPNet (P2OP) payment class.
 *
 * P2OP is a custom witness version 16 output type for the OPNet network.
 * The witness program contains a deployment version and hash160.
 *
 * @packageDocumentation
 */
const OPS$9 = opcodes;
const P2OP_WITNESS_VERSION = 0x10;
const MIN_SIZE = 2;
const MAX_SIZE = 40;
/**
 * Pay-to-OPNet (P2OP) payment class.
 *
 * Creates locking scripts of the form: `OP_16 {program}`
 * where program = `{deploymentVersion:uint8}{hash160:20-bytes|...}`
 *
 * @example
 * ```typescript
 * import { P2OP } from '@btc-vision/bitcoin';
 *
 * // Create from program
 * const payment = P2OP.fromProgram(program);
 * console.log(payment.address); // opnet address
 *
 * // Create from deployment version and hash160
 * const fromParts = P2OP.fromParts(deploymentVersion, hash160);
 *
 * // Decode an existing output
 * const decoded = P2OP.fromOutput(scriptPubKey);
 * console.log(decoded.program);
 * ```
 */
class P2OP {
    // Static public fields
    static NAME = PaymentType.P2OP;
    // Private instance fields
    #network;
    #opts;
    // Input data (provided by user)
    #inputAddress;
    #inputProgram;
    #inputDeploymentVersion;
    #inputHash160;
    #inputOutput;
    // Cached computed values
    #address;
    #program;
    #deploymentVersion;
    #hash160;
    #output;
    // Cache flags
    #addressComputed = false;
    #programComputed = false;
    #deploymentVersionComputed = false;
    #hash160Computed = false;
    #outputComputed = false;
    // Decoded address cache
    #decodedAddress;
    #decodedAddressComputed = false;
    /**
     * Creates a new P2OP payment instance.
     *
     * @param params - Payment parameters
     * @param params.address - Bech32m encoded OPNet address
     * @param params.program - Witness program (2-40 bytes)
     * @param params.deploymentVersion - Deployment version (0-255)
     * @param params.hash160 - 20-byte hash
     * @param params.output - The scriptPubKey
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        this.#network = params.network ?? bitcoin$1;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputAddress = params.address;
        this.#inputProgram = params.program;
        this.#inputDeploymentVersion = params.deploymentVersion;
        this.#inputHash160 = params.hash160;
        this.#inputOutput = params.output;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    // Public getters
    /**
     * Payment type discriminant.
     */
    get name() {
        return PaymentType.P2OP;
    }
    /**
     * Network parameters.
     */
    get network() {
        return this.#network;
    }
    /**
     * Bech32m encoded OPNet address.
     */
    get address() {
        if (!this.#addressComputed) {
            this.#address = this.#computeAddress();
            this.#addressComputed = true;
        }
        return this.#address;
    }
    /**
     * Witness program (2-40 bytes).
     * Format: `{deploymentVersion:uint8}{hash160:20-bytes|...}`
     */
    get program() {
        if (!this.#programComputed) {
            this.#program = this.#computeProgram();
            this.#programComputed = true;
        }
        return this.#program;
    }
    /**
     * Deployment version (first byte of program).
     */
    get deploymentVersion() {
        if (!this.#deploymentVersionComputed) {
            this.#deploymentVersion = this.#computeDeploymentVersion();
            this.#deploymentVersionComputed = true;
        }
        return this.#deploymentVersion;
    }
    /**
     * Hash160 (remaining bytes of program).
     */
    get hash160() {
        if (!this.#hash160Computed) {
            this.#hash160 = this.#computeHash160();
            this.#hash160Computed = true;
        }
        return this.#hash160;
    }
    /**
     * The scriptPubKey: `OP_16 {program}`
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    // Static factory methods
    /**
     * Creates a P2OP payment from a witness program.
     *
     * @param program - Witness program (2-40 bytes)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2OP payment instance
     */
    static fromProgram(program, network) {
        return new P2OP({ program, network });
    }
    /**
     * Creates a P2OP payment from deployment version and hash160.
     *
     * @param deploymentVersion - Deployment version (0-255)
     * @param hash160 - 20-byte hash
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2OP payment instance
     */
    static fromParts(deploymentVersion, hash160, network) {
        return new P2OP({ deploymentVersion, hash160, network });
    }
    /**
     * Creates a P2OP payment from an OPNet address.
     *
     * @param address - Bech32m encoded OPNet address
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2OP payment instance
     */
    static fromAddress(address, network) {
        return new P2OP({ address, network });
    }
    /**
     * Creates a P2OP payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2OP payment instance
     */
    static fromOutput(output, network) {
        return new P2OP({ output, network });
    }
    // Private helper methods
    /**
     * Converts to a plain P2OPPayment object for backwards compatibility.
     *
     * @returns A P2OPPayment object
     */
    toPayment() {
        return {
            name: this.name,
            network: this.network,
            address: this.address,
            program: this.program,
            deploymentVersion: this.deploymentVersion,
            hash160: this.hash160,
            output: this.output,
        };
    }
    #getDecodedAddress() {
        if (!this.#decodedAddressComputed) {
            if (this.#inputAddress) {
                const decoded = fromBech32(this.#inputAddress);
                if (decoded) {
                    this.#decodedAddress = {
                        version: decoded.version,
                        prefix: decoded.prefix,
                        data: decoded.data,
                    };
                }
            }
            this.#decodedAddressComputed = true;
        }
        return this.#decodedAddress;
    }
    // Private computation methods
    #makeProgramFromParts() {
        if (typeof this.#inputDeploymentVersion !== 'undefined' &&
            typeof this.#inputHash160 !== 'undefined') {
            if (this.#inputHash160.length !== 20) {
                throw new TypeError('hash160 must be exactly 20 bytes');
            }
            if (this.#inputDeploymentVersion < 0 || this.#inputDeploymentVersion > 0xff) {
                throw new TypeError('deploymentVersion must fit in one byte');
            }
            return concat$1([new Uint8Array([this.#inputDeploymentVersion]), this.#inputHash160]);
        }
        return undefined;
    }
    #computeAddress() {
        if (this.#inputAddress) {
            return this.#inputAddress;
        }
        const prog = this.program;
        if (!prog)
            return undefined;
        if (!this.#network.bech32Opnet) {
            throw new TypeError('Network does not support opnet');
        }
        const words = distExports.bech32m.toWords(prog);
        words.unshift(P2OP_WITNESS_VERSION);
        return distExports.bech32m.encode(this.#network.bech32Opnet, words);
    }
    #computeProgram() {
        if (this.#inputProgram) {
            return this.#inputProgram;
        }
        // Build from deployment version + hash160
        const fromParts = this.#makeProgramFromParts();
        if (fromParts) {
            return fromParts;
        }
        if (this.#inputOutput) {
            if (this.#inputOutput[0] !== OPS$9.OP_16) {
                throw new TypeError('Invalid P2OP script');
            }
            let pushPos = 1;
            let progLen;
            const byte1 = this.#inputOutput[1];
            const byte2 = this.#inputOutput[2];
            if (byte1 !== undefined && byte1 < 0x4c) {
                progLen = byte1;
                pushPos = 2;
            }
            else if (byte1 === 0x4c && byte2 !== undefined) {
                progLen = byte2;
                pushPos = 3;
            }
            else {
                throw new TypeError('Unsupported push opcode in P2OP script');
            }
            return this.#inputOutput.subarray(pushPos, pushPos + progLen);
        }
        if (this.#inputAddress) {
            return this.#getDecodedAddress()?.data;
        }
        return undefined;
    }
    #computeDeploymentVersion() {
        if (this.#inputDeploymentVersion !== undefined) {
            return this.#inputDeploymentVersion;
        }
        const prog = this.program;
        if (!prog)
            return undefined;
        return prog[0];
    }
    #computeHash160() {
        if (this.#inputHash160) {
            return this.#inputHash160;
        }
        const prog = this.program;
        if (!prog)
            return undefined;
        return prog.subarray(1);
    }
    // Validation
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        const prog = this.program;
        if (!prog)
            return undefined;
        return compile([OPS$9.OP_16, prog]);
    }
    #validate() {
        let prog = alloc(0);
        if (this.#inputAddress) {
            const dec = this.#getDecodedAddress();
            if (!dec) {
                throw new TypeError('Invalid address');
            }
            if (this.#network.bech32Opnet !== dec.prefix) {
                throw new TypeError('Invalid prefix or network mismatch');
            }
            if (dec.version !== P2OP_WITNESS_VERSION) {
                throw new TypeError('Invalid witness version for p2op');
            }
            if (dec.data.length < MIN_SIZE || dec.data.length > MAX_SIZE) {
                throw new TypeError('Invalid witness program length');
            }
            prog = dec.data;
        }
        if (this.#inputProgram) {
            if (prog.length > 0 && !equals(prog, this.#inputProgram)) {
                throw new TypeError('Program mismatch');
            }
            prog = this.#inputProgram;
        }
        if (!prog.length && this.#inputDeploymentVersion !== undefined && this.#inputHash160) {
            const made = this.#makeProgramFromParts();
            if (made)
                prog = made;
        }
        if (this.#inputOutput) {
            const outProg = this.program;
            if (!outProg) {
                throw new TypeError('Output program is required');
            }
            if (prog.length > 0 && !equals(prog, outProg)) {
                throw new TypeError('Program mismatch (output vs other source)');
            }
            prog = outProg;
        }
        if (prog.length < MIN_SIZE || prog.length > MAX_SIZE) {
            throw new TypeError(`Witness program must be 2â€“40 bytes. Was ${prog.length} bytes`);
        }
        if (this.#inputDeploymentVersion !== undefined &&
            this.#inputDeploymentVersion !== prog[0]) {
            throw new TypeError('deploymentVersion mismatch');
        }
        if (this.#inputHash160 && !equals(this.#inputHash160, prog.subarray(1))) {
            throw new TypeError('hash160 mismatch');
        }
    }
}
/**
 * Creates a Pay-to-OPNet (P2OP) payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the P2OP class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The P2OP payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2op } from '@btc-vision/bitcoin';
 *
 * // Create from program
 * const payment = p2op({ program });
 *
 * // Create from parts
 * const fromParts = p2op({ deploymentVersion: 0, hash160 });
 * ```
 */
function p2op(a, opts) {
    if (!a.address &&
        !a.output &&
        !a.program &&
        (typeof a.deploymentVersion === 'undefined' || !a.hash160)) {
        throw new TypeError('At least one of address, output or program must be provided');
    }
    const instance = new P2OP({
        address: a.address,
        program: a.program,
        deploymentVersion: a.deploymentVersion,
        hash160: a.hash160,
        output: a.output,
        network: a.network,
    }, opts);
    // Return a merged object for backwards compatibility
    return Object.assign(instance.toPayment(), a);
}

/**
 * Cryptographic hashing functions for Bitcoin.
 * Includes ripemd160, sha1, sha256, hash160, hash256, and taggedHash.
 *
 * @packageDocumentation
 */
/**
 * Computes RIPEMD-160 hash of the input.
 * @param data - Input data
 * @returns 20-byte hash (Bytes20)
 */
function ripemd160(data) {
    return ripemd160$1(data);
}
/**
 * Computes SHA-1 hash of the input.
 * @param data - Input data
 * @returns 20-byte hash (Bytes20)
 */
function sha1$1(data) {
    return sha1$2(data);
}
/**
 * Computes SHA-256 hash of the input.
 * @param data - Input data
 * @returns 32-byte hash (Bytes32)
 */
function sha256$1(data) {
    return sha256$2(data);
}
/**
 * Computes HASH160 (RIPEMD160(SHA256(data))) of the input.
 * @param data - Input data
 * @returns 20-byte hash (Bytes20)
 */
function hash160(data) {
    return ripemd160$1(sha256$2(data));
}
/**
 * Computes double SHA-256 hash of the input.
 * @param data - Input data
 * @returns 32-byte hash (Bytes32)
 */
function hash256(data) {
    return sha256$2(sha256$2(data));
}
/**
 * BIP340/Taproot tag names for tagged hashing.
 */
const TAGS = [
    'BIP0340/challenge',
    'BIP0340/aux',
    'BIP0340/nonce',
    'TapLeaf',
    'TapBranch',
    'TapSighash',
    'TapTweak',
    'KeyAgg list',
    'KeyAgg coefficient',
];
/**
 * Precomputed tagged hash prefixes: SHA256(tag) || SHA256(tag)
 */
const TAGGED_HASH_PREFIXES = {
    'BIP0340/challenge': new Uint8Array([
        123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242,
        216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124, 123, 181, 45, 122, 159, 239, 88,
        50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81,
        143, 109, 72, 211, 124,
    ]),
    'BIP0340/aux': new Uint8Array([
        241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88,
        57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144, 241, 239, 78, 94, 192, 99, 202,
        218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119,
        165, 46, 216, 193, 204, 144,
    ]),
    'BIP0340/nonce': new Uint8Array([
        7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247,
        45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73, 119, 52, 167, 155, 203, 53, 91, 155,
        140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235,
        47,
    ]),
    TapLeaf: new Uint8Array([
        174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64,
        8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75,
        88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,
    ]),
    TapBranch: new Uint8Array([
        25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237,
        130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25, 65, 161, 242, 229, 110, 185, 95,
        162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91,
        245, 22, 160, 21,
    ]),
    TapSighash: new Uint8Array([
        244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102,
        163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244, 10, 72, 223, 75, 42, 112, 200,
        180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151,
        198, 40, 228, 160, 49,
    ]),
    TapTweak: new Uint8Array([
        232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235,
        21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232, 15, 225, 99, 156, 156, 160,
        80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161,
        244, 175, 87, 197, 233,
    ]),
    'KeyAgg list': new Uint8Array([
        72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156,
        89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28, 151, 28, 60, 11, 70, 215,
        240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212,
        153, 2, 148, 240,
    ]),
    'KeyAgg coefficient': new Uint8Array([
        191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66,
        114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191, 201, 4, 3, 77, 28, 136, 232, 200,
        14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205,
        82, 201, 129,
    ]),
};
/**
 * Computes a BIP340-style tagged hash.
 * @param prefix - The tag name
 * @param data - Input data
 * @returns 32-byte hash (Bytes32)
 */
function taggedHash(prefix, data) {
    return sha256$1(concat$1([TAGGED_HASH_PREFIXES[prefix], data]));
}

const crypto$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    TAGGED_HASH_PREFIXES,
    TAGS,
    hash160,
    hash256,
    ripemd160,
    sha1: sha1$1,
    sha256: sha256$1,
    taggedHash
}, Symbol.toStringTag, { value: 'Module' }));

/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const secp256k1_CURVE = {
  p: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,
  n: 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,
  h: 1n,
  a: 0n,
  b: 7n,
  Gx: 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,
  Gy: 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n
};
const { p: P$2, n: N$1, Gx, Gy, b: _b } = secp256k1_CURVE;
const L = 32;
const L2 = 64;
const lengths = {
  publicKey: L + 1,
  publicKeyUncompressed: L2 + 1};
const captureTrace = (...args) => {
  if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(...args);
  }
};
const err$1 = (message = "") => {
  const e = new Error(message);
  captureTrace(e, err$1);
  throw e;
};
const isBig = (n) => typeof n === "bigint";
const isStr = (s) => typeof s === "string";
const isBytes = (a) => a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
const abytes = (value, length, title = "") => {
  const bytes = isBytes(value);
  const len = value?.length;
  const needsLen = length !== void 0;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    err$1(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
};
const u8n = (len) => new Uint8Array(len);
const padh = (n, pad) => n.toString(16).padStart(pad, "0");
const bytesToHex = (b) => Array.from(abytes(b)).map((e) => padh(e, 2)).join("");
const C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
const _ch = (ch) => {
  if (ch >= C._0 && ch <= C._9)
    return ch - C._0;
  if (ch >= C.A && ch <= C.F)
    return ch - (C.A - 10);
  if (ch >= C.a && ch <= C.f)
    return ch - (C.a - 10);
  return;
};
const hexToBytes = (hex) => {
  const e = "hex invalid";
  if (!isStr(hex))
    return err$1(e);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    return err$1(e);
  const array = u8n(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = _ch(hex.charCodeAt(hi));
    const n2 = _ch(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0)
      return err$1(e);
    array[ai] = n1 * 16 + n2;
  }
  return array;
};
const concatBytes = (...arrs) => {
  const r = u8n(arrs.reduce((sum, a) => sum + abytes(a).length, 0));
  let pad = 0;
  arrs.forEach((a) => {
    r.set(a, pad);
    pad += a.length;
  });
  return r;
};
const big = BigInt;
const arange = (n, min, max, msg = "bad number: out of range") => isBig(n) && min <= n && n < max ? n : err$1(msg);
const M$1 = (a, b = P$2) => {
  const r = a % b;
  return r >= 0n ? r : b + r;
};
const invert = (num, md) => {
  if (num === 0n || md <= 0n)
    err$1("no inverse n=" + num + " mod=" + md);
  let a = M$1(num, md), b = md, x = 0n, u = 1n;
  while (a !== 0n) {
    const q = b / a, r = b % a;
    const m = x - u * q;
    b = a, a = r, x = u, u = m;
  }
  return b === 1n ? M$1(x, md) : err$1("no inverse");
};
const apoint = (p) => p instanceof Point$1 ? p : err$1("Point expected");
const koblitz = (x) => M$1(M$1(x * x) * x + _b);
const FpIsValid = (n) => arange(n, 0n, P$2);
const FpIsValidNot0 = (n) => arange(n, 1n, P$2);
const FnIsValidNot0 = (n) => arange(n, 1n, N$1);
const isEven = (y) => (y & 1n) === 0n;
const u8of = (n) => Uint8Array.of(n);
const getPrefix = (y) => u8of(isEven(y) ? 2 : 3);
const lift_x = (x) => {
  const c = koblitz(FpIsValidNot0(x));
  let r = 1n;
  for (let num = c, e = (P$2 + 1n) / 4n; e > 0n; e >>= 1n) {
    if (e & 1n)
      r = r * num % P$2;
    num = num * num % P$2;
  }
  return M$1(r * r) === c ? r : err$1("sqrt invalid");
};
let Point$1 = class Point {
  static BASE;
  static ZERO;
  X;
  Y;
  Z;
  constructor(X, Y, Z) {
    this.X = FpIsValid(X);
    this.Y = FpIsValidNot0(Y);
    this.Z = FpIsValid(Z);
    Object.freeze(this);
  }
  static CURVE() {
    return secp256k1_CURVE;
  }
  /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */
  static fromAffine(ap) {
    const { x, y } = ap;
    return x === 0n && y === 0n ? I : new Point(x, y, 1n);
  }
  /** Convert Uint8Array or hex string to Point. */
  static fromBytes(bytes) {
    abytes(bytes);
    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
    let p = void 0;
    const length = bytes.length;
    const head = bytes[0];
    const tail = bytes.subarray(1);
    const x = sliceBytesNumBE(tail, 0, L);
    if (length === comp && (head === 2 || head === 3)) {
      let y = lift_x(x);
      const evenY = isEven(y);
      const evenH = isEven(big(head));
      if (evenH !== evenY)
        y = M$1(-y);
      p = new Point(x, y, 1n);
    }
    if (length === uncomp && head === 4)
      p = new Point(x, sliceBytesNumBE(tail, L, L2), 1n);
    return p ? p.assertValidity() : err$1("bad point: not on curve");
  }
  static fromHex(hex) {
    return Point.fromBytes(hexToBytes(hex));
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  /** Equality check: compare points P&Q. */
  equals(other) {
    const { X: X1, Y: Y1, Z: Z1 } = this;
    const { X: X2, Y: Y2, Z: Z2 } = apoint(other);
    const X1Z2 = M$1(X1 * Z2);
    const X2Z1 = M$1(X2 * Z1);
    const Y1Z2 = M$1(Y1 * Z2);
    const Y2Z1 = M$1(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  is0() {
    return this.equals(I);
  }
  /** Flip point over y coordinate. */
  negate() {
    return new Point(this.X, M$1(-this.Y), this.Z);
  }
  /** Point doubling: P+P, complete formula. */
  double() {
    return this.add(this);
  }
  /**
   * Point addition: P+Q, complete, exception-free formula
   * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).
   * Cost: `12M + 0S + 3*a + 3*b3 + 23add`.
   */
  // prettier-ignore
  add(other) {
    const { X: X1, Y: Y1, Z: Z1 } = this;
    const { X: X2, Y: Y2, Z: Z2 } = apoint(other);
    const a = 0n;
    const b = _b;
    let X3 = 0n, Y3 = 0n, Z3 = 0n;
    const b3 = M$1(b * 3n);
    let t0 = M$1(X1 * X2), t1 = M$1(Y1 * Y2), t2 = M$1(Z1 * Z2), t3 = M$1(X1 + Y1);
    let t4 = M$1(X2 + Y2);
    t3 = M$1(t3 * t4);
    t4 = M$1(t0 + t1);
    t3 = M$1(t3 - t4);
    t4 = M$1(X1 + Z1);
    let t5 = M$1(X2 + Z2);
    t4 = M$1(t4 * t5);
    t5 = M$1(t0 + t2);
    t4 = M$1(t4 - t5);
    t5 = M$1(Y1 + Z1);
    X3 = M$1(Y2 + Z2);
    t5 = M$1(t5 * X3);
    X3 = M$1(t1 + t2);
    t5 = M$1(t5 - X3);
    Z3 = M$1(a * t4);
    X3 = M$1(b3 * t2);
    Z3 = M$1(X3 + Z3);
    X3 = M$1(t1 - Z3);
    Z3 = M$1(t1 + Z3);
    Y3 = M$1(X3 * Z3);
    t1 = M$1(t0 + t0);
    t1 = M$1(t1 + t0);
    t2 = M$1(a * t2);
    t4 = M$1(b3 * t4);
    t1 = M$1(t1 + t2);
    t2 = M$1(t0 - t2);
    t2 = M$1(a * t2);
    t4 = M$1(t4 + t2);
    t0 = M$1(t1 * t4);
    Y3 = M$1(Y3 + t0);
    t0 = M$1(t5 * t4);
    X3 = M$1(t3 * X3);
    X3 = M$1(X3 - t0);
    t0 = M$1(t3 * t1);
    Z3 = M$1(t5 * Z3);
    Z3 = M$1(Z3 + t0);
    return new Point(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(apoint(other).negate());
  }
  /**
   * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.
   * Uses {@link wNAF} for base point.
   * Uses fake point to mitigate side-channel leakage.
   * @param n scalar by which point is multiplied
   * @param safe safe mode guards against timing attacks; unsafe mode is faster
   */
  multiply(n, safe = true) {
    if (!safe && n === 0n)
      return I;
    FnIsValidNot0(n);
    if (n === 1n)
      return this;
    if (this.equals(G$1))
      return wNAF(n).p;
    let p = I;
    let f = G$1;
    for (let d = this; n > 0n; d = d.double(), n >>= 1n) {
      if (n & 1n)
        p = p.add(d);
      else if (safe)
        f = f.add(d);
    }
    return p;
  }
  multiplyUnsafe(scalar) {
    return this.multiply(scalar, false);
  }
  /** Convert point to 2d xy affine point. (X, Y, Z) âˆ‹ (x=X/Z, y=Y/Z) */
  toAffine() {
    const { X: x, Y: y, Z: z } = this;
    if (this.equals(I))
      return { x: 0n, y: 0n };
    if (z === 1n)
      return { x, y };
    const iz = invert(z, P$2);
    if (M$1(z * iz) !== 1n)
      err$1("inverse invalid");
    return { x: M$1(x * iz), y: M$1(y * iz) };
  }
  /** Checks if the point is valid and on-curve. */
  assertValidity() {
    const { x, y } = this.toAffine();
    FpIsValidNot0(x);
    FpIsValidNot0(y);
    return M$1(y * y) === koblitz(x) ? this : err$1("bad point: not on curve");
  }
  /** Converts point to 33/65-byte Uint8Array. */
  toBytes(isCompressed = true) {
    const { x, y } = this.assertValidity().toAffine();
    const x32b = numTo32b(x);
    if (isCompressed)
      return concatBytes(getPrefix(y), x32b);
    return concatBytes(u8of(4), x32b, numTo32b(y));
  }
  toHex(isCompressed) {
    return bytesToHex(this.toBytes(isCompressed));
  }
};
const G$1 = new Point$1(Gx, Gy, 1n);
const I = new Point$1(0n, 1n, 0n);
Point$1.BASE = G$1;
Point$1.ZERO = I;
const bytesToNumBE = (b) => big("0x" + (bytesToHex(b) || "0"));
const sliceBytesNumBE = (b, from, to) => bytesToNumBE(b.subarray(from, to));
const B256 = 2n ** 256n;
const numTo32b = (num) => hexToBytes(padh(arange(num, 0n, B256), L2));
const W$1 = 8;
const scalarBits = 256;
const pwindows = Math.ceil(scalarBits / W$1) + 1;
const pwindowSize = 2 ** (W$1 - 1);
const precompute = () => {
  const points = [];
  let p = G$1;
  let b = p;
  for (let w = 0; w < pwindows; w++) {
    b = p;
    points.push(b);
    for (let i = 1; i < pwindowSize; i++) {
      b = b.add(p);
      points.push(b);
    }
    p = b.double();
  }
  return points;
};
let Gpows = void 0;
const ctneg = (cnd, p) => {
  const n = p.negate();
  return cnd ? n : p;
};
const wNAF = (n) => {
  const comp = Gpows || (Gpows = precompute());
  let p = I;
  let f = G$1;
  const pow_2_w = 2 ** W$1;
  const maxNum = pow_2_w;
  const mask = big(pow_2_w - 1);
  const shiftBy = big(W$1);
  for (let w = 0; w < pwindows; w++) {
    let wbits = Number(n & mask);
    n >>= shiftBy;
    if (wbits > pwindowSize) {
      wbits -= maxNum;
      n += 1n;
    }
    const off = w * pwindowSize;
    const offF = off;
    const offP = off + Math.abs(wbits) - 1;
    const isEven2 = w % 2 !== 0;
    const isNeg = wbits < 0;
    if (wbits === 0) {
      f = f.add(ctneg(isEven2, comp[offF]));
    } else {
      p = p.add(ctneg(isNeg, comp[offP]));
    }
  }
  if (n !== 0n)
    err$1("invalid wnaf");
  return { p, f };
};

/**
 * Public key utilities for Bitcoin
 * @packageDocumentation
 */
/**
 * Converts a public key to x-only format (32 bytes).
 * @param pubKey - The public key buffer (33 or 65 bytes)
 * @returns The x-only public key (32 bytes)
 */
const toXOnly = (pubKey) => {
    return (pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33));
};
/**
 * Converts bigint to 32-byte Uint8Array.
 */
function bigIntTo32Bytes(num) {
    let hex = num.toString(16);
    hex = hex.padStart(64, '0');
    if (hex.length > 64) {
        hex = hex.slice(-64);
    }
    return fromHex$1(hex);
}
/**
 * Converts an existing real Bitcoin public key (compressed or uncompressed)
 * to its "hybrid" form (prefix 0x06/0x07), then derives a P2PKH address from it.
 *
 * @param realPubKey - 33-byte compressed (0x02/0x03) or 65-byte uncompressed (0x04) pubkey
 * @returns UncompressedPublicKey | undefined
 */
function decompressPublicKey(realPubKey) {
    if (realPubKey.length === 32) {
        return;
    }
    if (![33, 65].includes(realPubKey.length)) {
        console.warn(`Unsupported key length=${realPubKey.length}. Must be 33 (compressed) or 65 (uncompressed).`);
        return;
    }
    let point;
    try {
        point = Point$1.fromHex(toHex$1(realPubKey));
    }
    catch (err) {
        throw new Error('Invalid secp256k1 public key bytes. Cannot parse.', { cause: err });
    }
    const xBuf = bigIntTo32Bytes(point.x);
    const yBuf = bigIntTo32Bytes(point.y);
    const isEven = point.y % 2n === 0n;
    const prefix = isEven ? 0x06 : 0x07;
    const hybridPubKey = alloc(65);
    hybridPubKey[0] = prefix;
    hybridPubKey.set(xBuf, 1);
    hybridPubKey.set(yBuf, 33);
    const uncompressedPubKey = concat$1([new Uint8Array([0x04]), xBuf, yBuf]);
    return {
        hybrid: hybridPubKey,
        uncompressed: uncompressedPubKey,
    };
}
/**
 * Compare two potential pubkey Uint8Arrays, treating hybrid keys (0x06/0x07)
 * as equivalent to uncompressed (0x04).
 */
function pubkeysMatch(a, b) {
    if (equals(a, b))
        return true;
    if (a.length === 65 && b.length === 65) {
        const aCopy = new Uint8Array(a);
        const bCopy = new Uint8Array(b);
        if (aCopy[0] === 0x06 || aCopy[0] === 0x07)
            aCopy[0] = 0x04;
        if (bCopy[0] === 0x06 || bCopy[0] === 0x07)
            bCopy[0] = 0x04;
        return equals(aCopy, bCopy);
    }
    return false;
}

/**
 * Pay-to-Public-Key-Hash (P2PKH) payment class.
 *
 * P2PKH is the most common legacy Bitcoin payment type. The output script
 * contains the hash of a public key, and spending requires the full public key
 * and a valid signature.
 *
 * @packageDocumentation
 */
const OPS$8 = opcodes;
/**
 * Pay-to-Public-Key-Hash (P2PKH) payment class.
 *
 * Creates locking scripts of the form:
 * `OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG`
 *
 * Spending requires providing: `{signature} {pubkey}`
 *
 * @example
 * ```typescript
 * import { P2PKH } from '@btc-vision/bitcoin';
 *
 * // Create from public key
 * const payment = P2PKH.fromPubkey(pubkey);
 * console.log(payment.address); // Bitcoin address
 * console.log(payment.output); // scriptPubKey
 *
 * // Create from address
 * const fromAddr = P2PKH.fromAddress('1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2');
 * console.log(fromAddr.hash); // 20-byte pubkey hash
 *
 * // Create from hash
 * const fromHash = P2PKH.fromHash(hash160);
 * console.log(fromHash.address);
 * ```
 */
class P2PKH {
    // Static public fields
    static NAME = PaymentType.P2PKH;
    // Private instance fields
    #network;
    #opts;
    // Input data (provided by user)
    #inputAddress;
    #inputHash;
    #inputPubkey;
    #inputSignature;
    #inputOutput;
    #inputInput;
    // Hybrid/uncompressed key flags
    #useHybrid = false;
    #useUncompressed = false;
    // Cached computed values
    #address;
    #hash;
    #pubkey;
    #signature;
    #output;
    #input;
    #witness;
    // Cache flags
    #addressComputed = false;
    #hashComputed = false;
    #pubkeyComputed = false;
    #signatureComputed = false;
    #outputComputed = false;
    #inputComputed = false;
    #witnessComputed = false;
    // Decoded address cache
    #decodedAddress;
    #decodedAddressComputed = false;
    // Decoded input chunks cache
    #inputChunks;
    #inputChunksComputed = false;
    /**
     * Creates a new P2PKH payment instance.
     *
     * @param params - Payment parameters
     * @param params.address - Base58Check encoded address
     * @param params.hash - 20-byte pubkey hash (RIPEMD160(SHA256(pubkey)))
     * @param params.pubkey - The public key (33 or 65 bytes)
     * @param params.signature - DER-encoded signature
     * @param params.output - The scriptPubKey
     * @param params.input - The scriptSig
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        this.#network = params.network ?? bitcoin$1;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputAddress = params.address;
        this.#inputHash = params.hash;
        this.#inputPubkey = params.pubkey;
        this.#inputSignature = params.signature;
        this.#inputOutput = params.output;
        this.#inputInput = params.input;
        this.#useHybrid = params.useHybrid ?? false;
        this.#useUncompressed = params.useUncompressed ?? false;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    // Public getters
    /**
     * Payment type discriminant.
     */
    get name() {
        return PaymentType.P2PKH;
    }
    /**
     * Network parameters.
     */
    get network() {
        return this.#network;
    }
    /**
     * Base58Check encoded Bitcoin address.
     */
    get address() {
        if (!this.#addressComputed) {
            this.#address = this.#computeAddress();
            this.#addressComputed = true;
        }
        return this.#address;
    }
    /**
     * 20-byte pubkey hash (RIPEMD160(SHA256(pubkey))).
     */
    get hash() {
        if (!this.#hashComputed) {
            this.#hash = this.#computeHash();
            this.#hashComputed = true;
        }
        return this.#hash;
    }
    /**
     * The public key (33 or 65 bytes).
     */
    get pubkey() {
        if (!this.#pubkeyComputed) {
            this.#pubkey = this.#computePubkey();
            this.#pubkeyComputed = true;
        }
        return this.#pubkey;
    }
    /**
     * The DER-encoded signature.
     */
    get signature() {
        if (!this.#signatureComputed) {
            this.#signature = this.#computeSignature();
            this.#signatureComputed = true;
        }
        return this.#signature;
    }
    /**
     * The scriptPubKey:
     * `OP_DUP OP_HASH160 {hash} OP_EQUALVERIFY OP_CHECKSIG`
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    /**
     * The scriptSig: `{signature} {pubkey}`
     */
    get input() {
        if (!this.#inputComputed) {
            this.#input = this.#computeInput();
            this.#inputComputed = true;
        }
        return this.#input;
    }
    /**
     * Witness stack (empty for P2PKH as it's not a SegWit type).
     */
    get witness() {
        if (!this.#witnessComputed) {
            this.#witness = this.#computeWitness();
            this.#witnessComputed = true;
        }
        return this.#witness;
    }
    // Static factory methods
    /**
     * Creates a P2PKH payment from a public key.
     *
     * @param pubkey - The public key (33 or 65 bytes)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2PKH payment instance
     *
     * @example
     * ```typescript
     * const payment = P2PKH.fromPubkey(pubkey);
     * const address = payment.address;
     * ```
     */
    static fromPubkey(pubkey, network) {
        return new P2PKH({ pubkey, network });
    }
    /**
     * Creates a P2PKH payment from a Base58Check address.
     *
     * @param address - Base58Check encoded address
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2PKH payment instance
     *
     * @example
     * ```typescript
     * const payment = P2PKH.fromAddress('1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2');
     * const hash = payment.hash;
     * ```
     */
    static fromAddress(address, network) {
        return new P2PKH({ address, network });
    }
    /**
     * Creates a P2PKH payment from a 20-byte pubkey hash.
     *
     * @param hash - 20-byte pubkey hash
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2PKH payment instance
     *
     * @example
     * ```typescript
     * const payment = P2PKH.fromHash(hash160);
     * const address = payment.address;
     * ```
     */
    static fromHash(hash, network) {
        return new P2PKH({ hash, network });
    }
    /**
     * Creates a P2PKH payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2PKH payment instance
     */
    static fromOutput(output, network) {
        return new P2PKH({ output, network });
    }
    // Private helper methods
    /**
     * Converts to a plain P2PKHPayment object for backwards compatibility.
     *
     * @returns A P2PKHPayment object
     */
    toPayment() {
        return {
            name: this.name,
            network: this.network,
            address: this.address,
            hash: this.hash,
            pubkey: this.pubkey,
            signature: this.signature,
            output: this.output,
            input: this.input,
            witness: this.witness,
        };
    }
    #getDecodedAddress() {
        if (!this.#decodedAddressComputed) {
            if (this.#inputAddress) {
                const payload = new Uint8Array(decode$i(this.#inputAddress));
                this.#decodedAddress = {
                    version: payload[0],
                    hash: payload.subarray(1),
                };
            }
            this.#decodedAddressComputed = true;
        }
        return this.#decodedAddress;
    }
    // Private computation methods
    #getInputChunks() {
        if (!this.#inputChunksComputed) {
            if (this.#inputInput) {
                this.#inputChunks = decompile(this.#inputInput) ?? undefined;
            }
            this.#inputChunksComputed = true;
        }
        return this.#inputChunks;
    }
    #computeAddress() {
        if (this.#inputAddress) {
            return this.#inputAddress;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        const payload = alloc(21);
        payload[0] = this.#network.pubKeyHash;
        payload.set(h, 1);
        return encode$j(payload);
    }
    #computeHash() {
        if (this.#inputHash) {
            return this.#inputHash;
        }
        if (this.#inputOutput) {
            return this.#inputOutput.subarray(3, 23);
        }
        if (this.#inputAddress) {
            return this.#getDecodedAddress()?.hash;
        }
        // Use the pubkey getter to derive pubkey from input if available
        const pk = this.pubkey;
        if (pk) {
            return hash160(pk);
        }
        return undefined;
    }
    #computePubkey() {
        if (this.#inputPubkey) {
            return this.#inputPubkey;
        }
        if (this.#inputInput) {
            const chunks = this.#getInputChunks();
            if (chunks && chunks.length >= 2) {
                return chunks[1];
            }
        }
        return undefined;
    }
    #computeSignature() {
        if (this.#inputSignature) {
            return this.#inputSignature;
        }
        if (this.#inputInput) {
            const chunks = this.#getInputChunks();
            if (chunks && chunks.length >= 1) {
                return chunks[0];
            }
        }
        return undefined;
    }
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        return compile([
            OPS$8.OP_DUP,
            OPS$8.OP_HASH160,
            h,
            OPS$8.OP_EQUALVERIFY,
            OPS$8.OP_CHECKSIG,
        ]);
    }
    #computeInput() {
        if (this.#inputInput) {
            return this.#inputInput;
        }
        if (!this.#inputPubkey || !this.#inputSignature) {
            return undefined;
        }
        let pubKey = this.#inputPubkey;
        if (this.#useHybrid || this.#useUncompressed) {
            const decompressed = decompressPublicKey(this.#inputPubkey);
            if (decompressed) {
                if (this.#useUncompressed) {
                    pubKey = decompressed.uncompressed;
                }
                else {
                    pubKey = decompressed.hybrid;
                }
            }
        }
        return compile([this.#inputSignature, pubKey]);
    }
    // Validation
    #computeWitness() {
        if (this.input) {
            return [];
        }
        return undefined;
    }
    #validate() {
        let hash = new Uint8Array(0);
        if (this.#inputAddress) {
            const addr = this.#getDecodedAddress();
            if (!addr) {
                throw new TypeError('Invalid address');
            }
            if (addr.version !== this.#network.pubKeyHash) {
                throw new TypeError('Invalid version or Network mismatch');
            }
            if (addr.hash.length !== 20) {
                throw new TypeError('Invalid address');
            }
            hash = addr.hash;
        }
        if (this.#inputHash) {
            if (hash.length > 0 && !equals(hash, this.#inputHash)) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = this.#inputHash;
            }
        }
        if (this.#inputOutput) {
            if (this.#inputOutput.length !== 25 ||
                this.#inputOutput[0] !== OPS$8.OP_DUP ||
                this.#inputOutput[1] !== OPS$8.OP_HASH160 ||
                this.#inputOutput[2] !== 0x14 ||
                this.#inputOutput[23] !== OPS$8.OP_EQUALVERIFY ||
                this.#inputOutput[24] !== OPS$8.OP_CHECKSIG) {
                throw new TypeError('Output is invalid');
            }
            const hash2 = this.#inputOutput.subarray(3, 23);
            if (hash.length > 0 && !equals(hash, hash2)) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = hash2;
            }
        }
        if (this.#inputPubkey) {
            const pkh = hash160(this.#inputPubkey);
            let badHash = hash.length > 0 && !equals(hash, pkh);
            if (badHash) {
                if ((this.#inputPubkey.length === 33 &&
                    (this.#inputPubkey[0] === 0x02 || this.#inputPubkey[0] === 0x03)) ||
                    (this.#inputPubkey.length === 65 && this.#inputPubkey[0] === 0x04)) {
                    const uncompressed = decompressPublicKey(this.#inputPubkey);
                    if (uncompressed) {
                        const pkh2 = hash160(uncompressed.uncompressed);
                        if (!equals(hash, pkh2)) {
                            const pkh3 = hash160(uncompressed.hybrid);
                            badHash = !equals(hash, pkh3);
                            if (!badHash) {
                                this.#useHybrid = true;
                            }
                        }
                        else {
                            badHash = false;
                            this.#useUncompressed = true;
                        }
                    }
                }
            }
            if (badHash) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = pkh;
            }
        }
        if (this.#inputInput) {
            const chunks = this.#getInputChunks();
            if (!chunks || chunks.length !== 2) {
                throw new TypeError('Input is invalid');
            }
            if (!isCanonicalScriptSignature(chunks[0])) {
                throw new TypeError('Input has invalid signature');
            }
            if (!isPoint(chunks[1])) {
                throw new TypeError('Input has invalid pubkey');
            }
            if (this.#inputSignature && !equals(this.#inputSignature, chunks[0])) {
                throw new TypeError('Signature mismatch');
            }
            if (this.#inputPubkey && !equals(this.#inputPubkey, chunks[1])) {
                throw new TypeError('Pubkey mismatch');
            }
            const pkh = hash160(chunks[1]);
            if (hash.length > 0 && !equals(hash, pkh)) {
                throw new TypeError('Hash mismatch (input)');
            }
        }
    }
}
/**
 * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the P2PKH class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The P2PKH payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2pkh } from '@btc-vision/bitcoin';
 *
 * // Create from public key
 * const payment = p2pkh({ pubkey });
 *
 * // Create from address
 * const fromAddr = p2pkh({ address: '1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2' });
 * ```
 */
function p2pkh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input) {
        throw new TypeError('Not enough data');
    }
    const instance = new P2PKH({
        address: a.address,
        hash: a.hash,
        pubkey: a.pubkey,
        signature: a.signature,
        output: a.output,
        input: a.input,
        network: a.network,
        useHybrid: a.useHybrid,
        useUncompressed: a.useUncompressed,
    }, opts);
    // Return a merged object for backwards compatibility
    return Object.assign(instance.toPayment(), a);
}

/**
 * Pay-to-Script-Hash (P2SH) payment class.
 *
 * P2SH allows spending to be based on a hash of a script, with the actual
 * script revealed only at spend time. This enables complex spending conditions
 * while keeping addresses short.
 *
 * @packageDocumentation
 */
const OPS$7 = opcodes;
/**
 * Pay-to-Script-Hash (P2SH) payment class.
 *
 * Creates locking scripts of the form:
 * `OP_HASH160 {hash160(redeemScript)} OP_EQUAL`
 *
 * Spending requires: `{redeemScriptSig...} {redeemScript}`
 *
 * @example
 * ```typescript
 * import { P2SH, P2MS } from '@btc-vision/bitcoin';
 *
 * // Wrap a multisig in P2SH
 * const multisig = P2MS.fromPubkeys(2, [pubkey1, pubkey2, pubkey3]);
 * const p2sh = P2SH.fromRedeem({ output: multisig.output });
 * console.log(p2sh.address); // 3... address
 *
 * // Decode an existing output
 * const decoded = P2SH.fromOutput(scriptPubKey);
 * console.log(decoded.hash); // 20-byte script hash
 * ```
 */
class P2SH {
    // Static public fields
    static NAME = PaymentType.P2SH;
    // Private instance fields
    #network;
    #opts;
    // Input data (provided by user)
    #inputAddress;
    #inputHash;
    #inputOutput;
    #inputInput;
    #inputRedeem;
    #inputWitness;
    // Cached computed values
    #address;
    #hash;
    #output;
    #input;
    #redeem;
    #witness;
    // Cache flags
    #addressComputed = false;
    #hashComputed = false;
    #outputComputed = false;
    #inputComputed = false;
    #redeemComputed = false;
    #witnessComputed = false;
    // Decoded address cache
    #decodedAddress;
    #decodedAddressComputed = false;
    // Decoded input chunks cache
    #inputChunks;
    #inputChunksComputed = false;
    // Derived redeem from input
    #derivedRedeem;
    #derivedRedeemComputed = false;
    /**
     * Creates a new P2SH payment instance.
     *
     * @param params - Payment parameters
     * @param params.address - Base58Check encoded address (3...)
     * @param params.hash - 20-byte script hash
     * @param params.output - The scriptPubKey
     * @param params.input - The scriptSig
     * @param params.redeem - The redeem script information
     * @param params.witness - The witness stack (for wrapped SegWit)
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        // Derive network from redeem if not specified
        let network = params.network;
        if (!network) {
            network = (params.redeem && params.redeem.network) || bitcoin$1;
        }
        this.#network = network;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputAddress = params.address;
        this.#inputHash = params.hash;
        this.#inputOutput = params.output;
        this.#inputInput = params.input;
        this.#inputRedeem = params.redeem;
        this.#inputWitness = params.witness;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    // Public getters
    /**
     * Payment type discriminant.
     */
    get name() {
        const r = this.redeem;
        if (r !== undefined && r.name !== undefined) {
            return `p2sh-${r.name}`;
        }
        return PaymentType.P2SH;
    }
    /**
     * Network parameters.
     */
    get network() {
        return this.#network;
    }
    /**
     * Base58Check encoded address (3... for mainnet).
     */
    get address() {
        if (!this.#addressComputed) {
            this.#address = this.#computeAddress();
            this.#addressComputed = true;
        }
        return this.#address;
    }
    /**
     * 20-byte script hash (HASH160 of redeem script).
     */
    get hash() {
        if (!this.#hashComputed) {
            this.#hash = this.#computeHash();
            this.#hashComputed = true;
        }
        return this.#hash;
    }
    /**
     * The scriptPubKey: `OP_HASH160 {hash} OP_EQUAL`
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    /**
     * The scriptSig: `{redeemScriptSig...} {redeemScript}`
     */
    get input() {
        if (!this.#inputComputed) {
            this.#input = this.#computeInput();
            this.#inputComputed = true;
        }
        return this.#input;
    }
    /**
     * The redeem script information.
     */
    get redeem() {
        if (!this.#redeemComputed) {
            this.#redeem = this.#computeRedeem();
            this.#redeemComputed = true;
        }
        return this.#redeem;
    }
    /**
     * The witness stack (for wrapped SegWit).
     */
    get witness() {
        if (!this.#witnessComputed) {
            this.#witness = this.#computeWitness();
            this.#witnessComputed = true;
        }
        return this.#witness;
    }
    // Static factory methods
    /**
     * Creates a P2SH payment from a redeem script.
     *
     * @param redeem - The redeem script information
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2SH payment instance
     *
     * @example
     * ```typescript
     * const p2sh = P2SH.fromRedeem({ output: redeemScript });
     * ```
     */
    static fromRedeem(redeem, network) {
        return new P2SH({ redeem, network });
    }
    /**
     * Creates a P2SH payment from a Base58Check address.
     *
     * @param address - Base58Check encoded address
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2SH payment instance
     */
    static fromAddress(address, network) {
        return new P2SH({ address, network });
    }
    /**
     * Creates a P2SH payment from a 20-byte script hash.
     *
     * @param hash - 20-byte script hash
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2SH payment instance
     */
    static fromHash(hash, network) {
        return new P2SH({ hash, network });
    }
    /**
     * Creates a P2SH payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2SH payment instance
     */
    static fromOutput(output, network) {
        return new P2SH({ output, network });
    }
    // Private helper methods
    /**
     * Converts to a plain P2SHPayment object for backwards compatibility.
     *
     * @returns A P2SHPayment object
     */
    toPayment() {
        return {
            name: this.name,
            network: this.network,
            address: this.address,
            hash: this.hash,
            output: this.output,
            input: this.input,
            redeem: this.redeem,
            witness: this.witness,
        };
    }
    #getDecodedAddress() {
        if (!this.#decodedAddressComputed) {
            if (this.#inputAddress) {
                const payload = new Uint8Array(decode$i(this.#inputAddress));
                this.#decodedAddress = {
                    version: payload[0],
                    hash: payload.subarray(1),
                };
            }
            this.#decodedAddressComputed = true;
        }
        return this.#decodedAddress;
    }
    #getInputChunks() {
        if (!this.#inputChunksComputed) {
            if (this.#inputInput) {
                this.#inputChunks = decompile(this.#inputInput) ?? undefined;
            }
            this.#inputChunksComputed = true;
        }
        return this.#inputChunks;
    }
    // Private computation methods
    #getDerivedRedeem() {
        if (!this.#derivedRedeemComputed) {
            const chunks = this.#getInputChunks();
            if (chunks) {
                const lastChunk = chunks[chunks.length - 1];
                this.#derivedRedeem = {
                    network: this.#network,
                    output: (lastChunk === OPS$7.OP_FALSE
                        ? new Uint8Array(0)
                        : lastChunk),
                    input: compile(chunks.slice(0, -1)),
                    witness: this.#inputWitness || [],
                };
            }
            this.#derivedRedeemComputed = true;
        }
        return this.#derivedRedeem;
    }
    #computeAddress() {
        if (this.#inputAddress) {
            return this.#inputAddress;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        const payload = alloc(21);
        payload[0] = this.#network.scriptHash;
        payload.set(h, 1);
        return encode$j(payload);
    }
    #computeHash() {
        if (this.#inputHash) {
            return this.#inputHash;
        }
        if (this.#inputOutput) {
            return this.#inputOutput.subarray(2, 22);
        }
        if (this.#inputAddress) {
            return this.#getDecodedAddress()?.hash;
        }
        const r = this.redeem;
        if (r && r.output) {
            return hash160(r.output);
        }
        return undefined;
    }
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        return compile([OPS$7.OP_HASH160, h, OPS$7.OP_EQUAL]);
    }
    #computeInput() {
        if (this.#inputInput) {
            return this.#inputInput;
        }
        const r = this.#inputRedeem;
        if (!r || !r.input || !r.output) {
            return undefined;
        }
        return compile([].concat(decompile(r.input), r.output));
    }
    #computeRedeem() {
        if (this.#inputRedeem) {
            return this.#inputRedeem;
        }
        if (this.#inputInput) {
            return this.#getDerivedRedeem();
        }
        return undefined;
    }
    // Validation
    #computeWitness() {
        if (this.#inputWitness) {
            return this.#inputWitness;
        }
        const r = this.redeem;
        if (r && r.witness) {
            return r.witness;
        }
        if (this.input) {
            return [];
        }
        return undefined;
    }
    #checkRedeem(redeem) {
        // Is the redeem output empty/invalid?
        if (redeem.output) {
            const decompile$1 = decompile(redeem.output);
            if (!decompile$1 || decompile$1.length < 1) {
                throw new TypeError('Redeem.output too short');
            }
            if (redeem.output.byteLength > 520) {
                throw new TypeError('Redeem.output unspendable if larger than 520 bytes');
            }
            if (countNonPushOnlyOPs(decompile$1) > 201) {
                throw new TypeError('Redeem.output unspendable with more than 201 non-push ops');
            }
        }
        if (redeem.input) {
            const hasInput = redeem.input.length > 0;
            const hasWitness = redeem.witness && redeem.witness.length > 0;
            if (!hasInput && !hasWitness) {
                throw new TypeError('Empty input');
            }
            if (hasInput && hasWitness) {
                throw new TypeError('Input and witness provided');
            }
            if (hasInput) {
                const richunks = decompile(redeem.input);
                if (!isPushOnly(richunks)) {
                    throw new TypeError('Non push-only scriptSig');
                }
            }
        }
    }
    #validate() {
        let hash = new Uint8Array(0);
        if (this.#inputAddress) {
            const addr = this.#getDecodedAddress();
            if (!addr) {
                throw new TypeError('Invalid address');
            }
            if (addr.version !== this.#network.scriptHash) {
                throw new TypeError('Invalid version or Network mismatch');
            }
            if (addr.hash.length !== 20) {
                throw new TypeError('Invalid address');
            }
            hash = addr.hash;
        }
        if (this.#inputHash) {
            if (hash.length > 0 && !equals(hash, this.#inputHash)) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = this.#inputHash;
            }
        }
        if (this.#inputOutput) {
            if (this.#inputOutput.length !== 23 ||
                this.#inputOutput[0] !== OPS$7.OP_HASH160 ||
                this.#inputOutput[1] !== 0x14 ||
                this.#inputOutput[22] !== OPS$7.OP_EQUAL) {
                throw new TypeError('Output is invalid');
            }
            const hash2 = this.#inputOutput.subarray(2, 22);
            if (hash.length > 0 && !equals(hash, hash2)) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = hash2;
            }
        }
        if (this.#inputInput) {
            const chunks = this.#getInputChunks();
            if (!chunks || chunks.length < 1) {
                throw new TypeError('Input too short');
            }
            const derived = this.#getDerivedRedeem();
            if (!derived || !(derived.output instanceof Uint8Array)) {
                throw new TypeError('Input is invalid');
            }
            this.#checkRedeem(derived);
            // Match hash against redeem output
            if (derived.output) {
                const hash2 = hash160(derived.output);
                if (hash.length > 0 && !equals(hash, hash2)) {
                    throw new TypeError('Hash mismatch');
                }
                else {
                    hash = hash2;
                }
            }
        }
        if (this.#inputRedeem) {
            if (this.#inputRedeem.network && this.#inputRedeem.network !== this.#network) {
                throw new TypeError('Network mismatch');
            }
            if (this.#inputInput) {
                const derived = this.#getDerivedRedeem();
                if (derived) {
                    if (this.#inputRedeem.output &&
                        derived.output &&
                        !equals(this.#inputRedeem.output, derived.output)) {
                        throw new TypeError('Redeem.output mismatch');
                    }
                    if (this.#inputRedeem.input &&
                        derived.input &&
                        !equals(this.#inputRedeem.input, derived.input)) {
                        throw new TypeError('Redeem.input mismatch');
                    }
                }
            }
            this.#checkRedeem(this.#inputRedeem);
            // Match hash against redeem output
            if (this.#inputRedeem.output) {
                const hash2 = hash160(this.#inputRedeem.output);
                if (hash.length > 0 && !equals(hash, hash2)) {
                    throw new TypeError('Hash mismatch');
                }
            }
        }
        if (this.#inputWitness) {
            if (this.#inputRedeem &&
                this.#inputRedeem.witness &&
                !stacksEqual(this.#inputRedeem.witness, this.#inputWitness)) {
                throw new TypeError('Witness and redeem.witness mismatch');
            }
        }
    }
}
/**
 * Creates a Pay-to-Script-Hash (P2SH) payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the P2SH class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The P2SH payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2sh, p2ms } from '@btc-vision/bitcoin';
 *
 * // Wrap a multisig in P2SH
 * const multisig = p2ms({ m: 2, pubkeys: [pk1, pk2, pk3] });
 * const payment = p2sh({ redeem: multisig });
 * ```
 */
function p2sh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.redeem && !a.input) {
        throw new TypeError('Not enough data');
    }
    const instance = new P2SH({
        address: a.address,
        hash: a.hash,
        output: a.output,
        input: a.input,
        redeem: a.redeem,
        witness: a.witness,
        network: a.network,
    }, opts);
    // Return a merged object for backwards compatibility
    return Object.assign(instance.toPayment(), a);
}

function en(e) {
  const t = e.length;
  if (t % 2 !== 0) throw new TypeError("fromHexInternal: odd-length hex string");
  const r = new Uint8Array(t / 2);
  for (let n = 0; n < t; n += 2) {
    const i = de(e.charCodeAt(n)), o = de(e.charCodeAt(n + 1));
    if (i === -1 || o === -1) throw new TypeError("fromHexInternal: invalid hex character");
    r[n >> 1] = i << 4 | o;
  }
  return r;
}
function de(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function Lt(e) {
  for (let t = 0; t < e.length; t++)
    if (e[t] !== 0) return false;
  return true;
}
function pr(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; n++) {
    const i = e[n], o = t[n];
    if (i < o) return -1;
    if (i > o) return 1;
  }
  return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
}
function M(e, t) {
  if (e.length !== t.length) return false;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r]) return false;
  return true;
}
function wt(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function nn(...e) {
  let t = 0;
  for (const i of e) t += i.length;
  const r = new Uint8Array(t);
  let n = 0;
  for (const i of e)
    r.set(i, n), n += i.length;
  return r;
}
const Jt = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n, mr = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, Be = 21n * 10n ** 14n;
function Se(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
function Er(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function xr(e) {
  return e instanceof Uint8Array && e.length === 20;
}
function vr(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 || Lt(e) ? false : Se(e) < Jt;
}
function rn(e) {
  if (!(e instanceof Uint8Array)) return false;
  const t = e[0];
  return e.length === 33 && (t === 2 || t === 3) || e.length === 65 && (t === 4 || t === 6 || t === 7);
}
function Br(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 ? false : !Lt(e);
}
function on(e) {
  return e instanceof Uint8Array && e.length >= 8 && e.length <= 73;
}
function sn(e) {
  return e instanceof Uint8Array && e.length === 64;
}
function Sr(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function fn(e) {
  return typeof e == "bigint" && e >= 0n && e <= Be;
}
function Ae(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertBytes32: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertBytes32: expected 32 bytes, got ${e.length} bytes`);
}
function cn(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPrivateKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertPrivateKey: expected 32 bytes, got ${e.length} bytes`);
  if (Lt(e))
    throw new TypeError("assertPrivateKey: key is zero");
  if (Se(e) >= Jt)
    throw new TypeError("assertPrivateKey: key not in range [1, n)");
}
function an(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPublicKey: expected Uint8Array");
  if (!rn(e))
    throw new TypeError(
      `assertPublicKey: invalid SEC1 public key (length=${e.length}, prefix=0x${(e[0] ?? 0).toString(16).padStart(2, "0")})`
    );
}
function dn(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertXOnlyPublicKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertXOnlyPublicKey: expected 32 bytes, got ${e.length} bytes`);
  if (Lt(e))
    throw new TypeError("assertXOnlyPublicKey: key is zero");
}
function un(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertMessageHash: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertMessageHash: expected 32 bytes, got ${e.length} bytes`);
}
function Ar(e) {
  return Ae(e), e;
}
function Or(e) {
  if (!(e instanceof Uint8Array) || e.length !== 20)
    throw new TypeError("createBytes20: expected 20 bytes Uint8Array");
  return e;
}
function zt(e) {
  return cn(e), e;
}
function ln(e) {
  return an(e), e;
}
function hn(e) {
  return dn(e), e;
}
function Rr(e) {
  if (!on(e))
    throw new TypeError(`createSignature: expected 8-73 bytes, got ${e.length} bytes`);
  return e;
}
function Ir(e) {
  if (!sn(e))
    throw new TypeError(`createSchnorrSignature: expected 64 bytes, got ${e.length} bytes`);
  return e;
}
function Ur(e) {
  return un(e), e;
}
function Pr(e) {
  if (!fn(e))
    throw new TypeError(`createSatoshi: value out of range [0, ${Be}]`);
  return e;
}
const lt = {
  /** Can produce ECDSA signatures (requires a private key). */
  EcdsaSign: 1,
  /** Can verify ECDSA signatures. */
  EcdsaVerify: 2,
  /** Can produce BIP-340 Schnorr signatures (requires a private key and backend support). */
  SchnorrSign: 4,
  /** Can verify BIP-340 Schnorr signatures (requires backend support). */
  SchnorrVerify: 8,
  /** Can export the raw private key bytes. */
  PrivateKeyExport: 16,
  /** Can derive a tweaked child key via Taproot-style tweaking. */
  PublicKeyTweak: 32,
  /** Supports BIP-32 hierarchical deterministic derivation. */
  HdDerivation: 64
};
function te(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function dt(e, t = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const r = t && `"${t}" `;
    throw new Error(`${r}expected integer >= 0, got ${e}`);
  }
}
function _(e, t, r = "") {
  const n = te(e), i = e?.length, o = t !== void 0;
  if (!n || o && i !== t) {
    const s = r && `"${r}" `, f = o ? ` of length ${t}` : "", c = n ? `length=${i}` : `type=${typeof e}`;
    throw new Error(s + "expected Uint8Array" + f + ", got " + c);
  }
  return e;
}
function Oe(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  dt(e.outputLen), dt(e.blockLen);
}
function It(e, t = true) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function bn(e, t) {
  _(e, void 0, "digestInto() output");
  const r = t.outputLen;
  if (e.length < r)
    throw new Error('"digestInto() output" expected to be of length >=' + r);
}
function Ut(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function $t(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function G(e, t) {
  return e << 32 - t | e >>> t;
}
const Re = (
  /* @ts-ignore */
  typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
), yn = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ht(e) {
  if (_(e), Re)
    return e.toHex();
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += yn[e[r]];
  return t;
}
const Q$1 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function ue(e) {
  if (e >= Q$1._0 && e <= Q$1._9)
    return e - Q$1._0;
  if (e >= Q$1.A && e <= Q$1.F)
    return e - (Q$1.A - 10);
  if (e >= Q$1.a && e <= Q$1.f)
    return e - (Q$1.a - 10);
}
function Pt(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (Re)
    return Uint8Array.fromHex(e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let i = 0, o = 0; i < r; i++, o += 2) {
    const s = ue(e.charCodeAt(o)), f = ue(e.charCodeAt(o + 1));
    if (s === void 0 || f === void 0) {
      const c = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + o);
    }
    n[i] = s * 16 + f;
  }
  return n;
}
function W(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    _(i), t += i.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, i = 0; n < e.length; n++) {
    const o = e[n];
    r.set(o, i), i += o.length;
  }
  return r;
}
function gn(e, t = {}) {
  const r = (i, o) => e(o).update(i).digest(), n = e(void 0);
  return r.outputLen = n.outputLen, r.blockLen = n.blockLen, r.create = (i) => e(i), Object.assign(r, t), Object.freeze(r);
}
function Kt(e = 32) {
  const t = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof t?.getRandomValues != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t.getRandomValues(new Uint8Array(e));
}
const wn = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function pn(e, t, r) {
  return e & t ^ ~e & r;
}
function mn(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
class En {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = false;
  length = 0;
  pos = 0;
  destroyed = false;
  constructor(t, r, n, i) {
    this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = $t(this.buffer);
  }
  update(t) {
    It(this), _(t);
    const { view: r, buffer: n, blockLen: i } = this, o = t.length;
    for (let s = 0; s < o; ) {
      const f = Math.min(i - this.pos, o - s);
      if (f === i) {
        const c = $t(t);
        for (; i <= o - s; s += i)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + f), this.pos), this.pos += f, s += f, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    It(this), bn(t, this), this.finished = true;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, Ut(this.buffer.subarray(s)), this.padOffset > i - s && (this.process(n, 0), s = 0);
    for (let b = s; b < i; b++)
      r[b] = 0;
    n.setBigUint64(i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const f = $t(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const a = c / 4, h = this.get();
    if (a > h.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let b = 0; b < a; b++)
      f.setUint32(4 * b, h[b], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t ||= new this.constructor(), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: f } = this;
    return t.destroyed = s, t.finished = o, t.length = i, t.pos = f, i % r && t.buffer.set(n), t;
  }
  clone() {
    return this._cloneInto();
  }
}
const et = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), xn = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), nt = /* @__PURE__ */ new Uint32Array(64);
class vn extends En {
  constructor(t) {
    super(64, t, 8, false);
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: s, G: f, H: c } = this;
    return [t, r, n, i, o, s, f, c];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, f, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = f | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let b = 0; b < 16; b++, r += 4)
      nt[b] = t.getUint32(r, false);
    for (let b = 16; b < 64; b++) {
      const m = nt[b - 15], y = nt[b - 2], E = G(m, 7) ^ G(m, 18) ^ m >>> 3, O = G(y, 17) ^ G(y, 19) ^ y >>> 10;
      nt[b] = O + nt[b - 7] + E + nt[b - 16] | 0;
    }
    let { A: n, B: i, C: o, D: s, E: f, F: c, G: a, H: h } = this;
    for (let b = 0; b < 64; b++) {
      const m = G(f, 6) ^ G(f, 11) ^ G(f, 25), y = h + m + pn(f, c, a) + xn[b] + nt[b] | 0, O = (G(n, 2) ^ G(n, 13) ^ G(n, 22)) + mn(n, i, o) | 0;
      h = a, a = c, c = f, f = s + y | 0, s = o, o = i, i = n, n = y + O | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, f = f + this.E | 0, c = c + this.F | 0, a = a + this.G | 0, h = h + this.H | 0, this.set(n, i, o, s, f, c, a, h);
  }
  roundClean() {
    Ut(nt);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Ut(this.buffer);
  }
}
class Bn extends vn {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = et[0] | 0;
  B = et[1] | 0;
  C = et[2] | 0;
  D = et[3] | 0;
  E = et[4] | 0;
  F = et[5] | 0;
  G = et[6] | 0;
  H = et[7] | 0;
  constructor() {
    super(32);
  }
}
const Et = /* @__PURE__ */ gn(
  () => new Bn(),
  /* @__PURE__ */ wn(1)
);
function Sn(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let a = 0; a < t.length; a++)
    t[a] = 255;
  for (let a = 0; a < e.length; a++) {
    const h = e.charAt(a), b = h.charCodeAt(0);
    if (t[b] !== 255)
      throw new TypeError(h + " is ambiguous");
    t[b] = a;
  }
  const r = e.length, n = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function s(a) {
    if (a instanceof Uint8Array || (ArrayBuffer.isView(a) ? a = new Uint8Array(a.buffer, a.byteOffset, a.byteLength) : Array.isArray(a) && (a = Uint8Array.from(a))), !(a instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (a.length === 0)
      return "";
    let h = 0, b = 0, m = 0;
    const y = a.length;
    for (; m !== y && a[m] === 0; )
      m++, h++;
    const E = (y - m) * o + 1 >>> 0, O = new Uint8Array(E);
    for (; m !== y; ) {
      let q = a[m], Z = 0;
      for (let L = E - 1; (q !== 0 || Z < b) && L !== -1; L--, Z++)
        q += 256 * O[L] >>> 0, O[L] = q % r >>> 0, q = q / r >>> 0;
      if (q !== 0)
        throw new Error("Non-zero carry");
      b = Z, m++;
    }
    let A = E - b;
    for (; A !== E && O[A] === 0; )
      A++;
    let T = n.repeat(h);
    for (; A < E; ++A)
      T += e.charAt(O[A]);
    return T;
  }
  function f(a) {
    if (typeof a != "string")
      throw new TypeError("Expected String");
    if (a.length === 0)
      return new Uint8Array();
    let h = 0, b = 0, m = 0;
    for (; a[h] === n; )
      b++, h++;
    const y = (a.length - h) * i + 1 >>> 0, E = new Uint8Array(y);
    for (; h < a.length; ) {
      const q = a.charCodeAt(h);
      if (q > 255)
        return;
      let Z = t[q];
      if (Z === 255)
        return;
      let L = 0;
      for (let j = y - 1; (Z !== 0 || L < m) && j !== -1; j--, L++)
        Z += r * E[j] >>> 0, E[j] = Z % 256 >>> 0, Z = Z / 256 >>> 0;
      if (Z !== 0)
        throw new Error("Non-zero carry");
      m = L, h++;
    }
    let O = y - m;
    for (; O !== y && E[O] === 0; )
      O++;
    const A = new Uint8Array(b + (y - O));
    let T = b;
    for (; O !== y; )
      A[T++] = E[O++];
    return A;
  }
  function c(a) {
    const h = f(a);
    if (h)
      return h;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: f,
    decode: c
  };
}
var An = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const Vt = Sn(An);
function On(e) {
  function t(o) {
    const s = e(o), f = o.length + 4, c = new Uint8Array(f);
    return c.set(o, 0), c.set(s.subarray(0, 4), o.length), Vt.encode(c);
  }
  function r(o) {
    const s = o.slice(0, -4), f = o.slice(-4), c = e(s);
    if (!(f[0] ^ c[0] | f[1] ^ c[1] | f[2] ^ c[2] | f[3] ^ c[3]))
      return s;
  }
  function n(o) {
    const s = Vt.decodeUnsafe(o);
    if (s !== void 0)
      return r(s);
  }
  function i(o) {
    const s = Vt.decode(o), f = r(s);
    if (f === void 0)
      throw new Error("Invalid checksum");
    return f;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: n
  };
}
function Rn(e) {
  return Et(Et(e));
}
const { encode: In, decode: Un, decodeUnsafe: Pn } = On(Rn), Ie = { encode: In, decode: Un, decodeUnsafe: Pn };
function Nn(e, t) {
  if (e.length === 33)
    return {
      version: e[0],
      privateKey: e.slice(1, 33),
      compressed: false
    };
  if (e.length !== 34)
    throw new Error("Invalid WIF length");
  if (e[33] !== 1)
    throw new Error("Invalid compression flag");
  return {
    version: e[0],
    privateKey: e.slice(1, 33),
    compressed: true
  };
}
function Tn(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  const n = new Uint8Array(r ? 34 : 33);
  return new DataView(n.buffer).setUint8(0, e), n.set(t, 1), r && (n[33] = 1), n;
}
function _n(e, t) {
  return Nn(Ie.decode(e));
}
function kn(e) {
  return Ie.encode(Tn(e.version, e.privateKey, e.compressed));
}
function Ln(e, t, r) {
  return kn({
    version: r.wif,
    privateKey: e,
    compressed: t
  });
}
function Hn(e, t) {
  const r = _n(e), n = r.version;
  if (Array.isArray(t)) {
    const s = t.find((f) => f.wif === n);
    if (!s) throw new Error("Unknown network version");
    return {
      privateKey: zt(r.privateKey),
      compressed: r.compressed,
      network: s
    };
  }
  const i = t;
  if (n !== i.wif)
    throw new Error("Invalid network version");
  return {
    privateKey: zt(r.privateKey),
    compressed: r.compressed,
    network: i
  };
}
function Kn(e) {
  return e[0] === 3 ? true : e[0] === 4 && e.length === 65 ? (e[64] & 1) === 1 : false;
}
function qn(e) {
  const t = e.length === 32 ? e : e.subarray(1, 33);
  return hn(t);
}
const Dt = 48;
function Zn(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
function Cn(e) {
  const t = new Uint8Array(32);
  for (let r = 31; r >= 0; r--)
    t[r] = Number(e & 0xffn), e >>= 8n;
  return t;
}
class st {
  #t;
  #e;
  #r;
  #n;
  #i;
  #o;
  #s;
  constructor(t, r, n, i, o) {
    if (o?.compressed !== void 0 && typeof o.compressed != "boolean")
      throw new TypeError(
        `Expected boolean for compressed, got ${typeof o.compressed}`
      );
    this.#t = t, this.#e = r, this.#n = o?.compressed ?? true, this.#r = i, n !== void 0 && (this.#i = t.pointCompress(n, this.#n));
  }
  /** Raw private key bytes, or `undefined` for public-key-only signers. */
  get privateKey() {
    return this.#e;
  }
  /**
   * SEC1-encoded public key.  Lazily derived from the private key when
   * the signer was created via {@link fromPrivateKey} or {@link fromWIF}.
   *
   * @throws If neither a private nor public key is available (should never happen).
   */
  get publicKey() {
    if (this.#i === void 0) {
      const t = this.#e;
      if (t === void 0)
        throw new Error("Missing both private and public key");
      const r = this.#t.pointFromScalar(t, this.#n);
      if (r === null)
        throw new Error("Failed to derive public key from private key");
      this.#i = r;
    }
    return this.#i;
  }
  /** 32-byte BIP-340 x-only public key (lazily derived and cached). */
  get xOnlyPublicKey() {
    return this.#o === void 0 && (this.#o = qn(this.publicKey)), this.#o;
  }
  /** Network this signer is bound to. */
  get network() {
    return this.#r;
  }
  /** Whether the public key is in compressed SEC1 form. */
  get compressed() {
    return this.#n;
  }
  /**
   * Bitmask of {@link SignerCapability} flags representing the operations
   * this signer can perform.  Lazily computed and cached.
   */
  get capabilities() {
    if (this.#s === void 0) {
      let t = lt.EcdsaVerify | lt.PublicKeyTweak;
      this.#e !== void 0 && (t |= lt.EcdsaSign | lt.PrivateKeyExport), this.#t.signSchnorr && this.#e !== void 0 && (t |= lt.SchnorrSign), this.#t.verifySchnorr && (t |= lt.SchnorrVerify), this.#s = t;
    }
    return this.#s;
  }
  /**
   * Creates a signer from a raw private key.
   *
   * @param backend - Cryptographic backend to use.
   * @param privateKey - 32-byte secp256k1 private key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws {TypeError} If the private key is not in the valid range `[1, n)`.
   */
  static fromPrivateKey(t, r, n, i) {
    if (!t.isPrivate(r))
      throw new TypeError("Private key not in range [1, n)");
    return new st(t, r, void 0, n, i);
  }
  /**
   * Creates a public-key-only signer (cannot sign, export WIF, etc.).
   *
   * @param backend - Cryptographic backend to use.
   * @param publicKey - SEC1-encoded public key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws If the public key is not a valid curve point.
   */
  static fromPublicKey(t, r, n, i) {
    if (!t.isPoint(r))
      throw new Error("Point not on the curve");
    return new st(t, void 0, r, n, i);
  }
  /**
   * Imports a signer from a WIF-encoded private key string.
   *
   * @param backend - Cryptographic backend to use.
   * @param wifString - Base58Check WIF string.
   * @param network - One or more candidate networks whose WIF version byte is matched.
   * @throws If no network matches the decoded version byte.
   */
  static fromWIF(t, r, n) {
    const i = Hn(r, n);
    return st.fromPrivateKey(t, i.privateKey, i.network, {
      compressed: i.compressed
    });
  }
  /**
   * Generates a new signer with a random private key.
   *
   * Uses FIPS 186-5 B.4.2 / RFC 9380 modular reduction:
   * 48 bytes of entropy are reduced via `(seed mod (n âˆ’ 1)) + 1`,
   * producing a key in `[1, n)` with negligible bias (< 2^âˆ’128).
   *
   * @param backend - Cryptographic backend to use.
   * @param network - Target network.
   * @param options - Optional settings (rng, compressed).
   */
  static makeRandom(t, r, n) {
    const o = (n?.rng ?? ((a) => crypto.getRandomValues(new Uint8Array(a))))(Dt);
    if (o.length !== Dt)
      throw new TypeError(
        `Expected ${Dt} bytes from rng, got ${o.length} bytes`
      );
    const f = Zn(o) % (Jt - 1n) + 1n, c = Cn(f);
    return st.fromPrivateKey(
      t,
      zt(c),
      r,
      n
    );
  }
  /**
   * Tests whether this signer has a specific capability.
   * @param cap - {@link SignerCapability} flag to test.
   */
  hasCapability(t) {
    return (this.capabilities & t) !== 0;
  }
  /**
   * Produces a compact ECDSA signature.
   *
   * When `lowR` is `true`, grinds the nonce until the R value's first
   * byte is `<= 0x7f`, producing a smaller DER encoding.
   *
   * @param hash - 32-byte message digest.
   * @param lowR - Enable low-R grinding.  Defaults to `false`.
   * @throws If this is a public-key-only signer.
   */
  sign(t, r) {
    if (this.#e === void 0) throw new Error("Missing private key");
    if (!r)
      return this.#t.sign(t, this.#e);
    let n = this.#t.sign(t, this.#e);
    const i = new Uint8Array(32), o = new DataView(i.buffer, i.byteOffset, i.byteLength);
    let s = 0;
    for (; ; ) {
      const f = n[0];
      if (f === void 0) throw new Error("Backend returned invalid signature");
      if (f <= 127) break;
      s++, o.setUint32(0, s, true), n = this.#t.sign(t, this.#e, i);
    }
    return n;
  }
  /**
   * Produces a 64-byte BIP-340 Schnorr signature.
   *
   * @param hash - 32-byte message digest.
   * @throws If this is a public-key-only signer.
   * @throws If the backend does not support Schnorr signing.
   */
  signSchnorr(t) {
    if (this.#e === void 0) throw new Error("Missing private key");
    if (!this.#t.signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return this.#t.signSchnorr(t, this.#e);
  }
  /**
   * Verifies a compact ECDSA signature against this signer's public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - Compact ECDSA signature.
   */
  verify(t, r) {
    return this.#t.verify(t, this.publicKey, r);
  }
  /**
   * Verifies a BIP-340 Schnorr signature against this signer's x-only public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - 64-byte Schnorr signature.
   * @throws If the backend does not support Schnorr verification.
   */
  verifySchnorr(t, r) {
    if (!this.#t.verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return this.#t.verifySchnorr(t, this.xOnlyPublicKey, r);
  }
  /**
   * Derives a new signer by applying a Taproot-style scalar tweak.
   *
   * When a private key is available the tweak is applied to the scalar
   * (negating first if the public key has odd Y).  Otherwise, only the
   * public key is tweaked via x-only point addition.
   *
   * @param t - 32-byte tweak scalar.
   * @throws If the tweaked key is invalid (e.g. lands on the point at infinity).
   */
  tweak(t) {
    return Ae(t), this.#e !== void 0 ? this.#f(t) : this.#c(t);
  }
  /**
   * Exports the private key as a WIF string using this signer's network.
   *
   * @throws If this is a public-key-only signer.
   */
  toWIF() {
    if (this.#e === void 0) throw new Error("Missing private key");
    return Ln(this.#e, this.#n, this.#r);
  }
  #f(t) {
    const r = this.publicKey, n = this.#e;
    if (n === void 0)
      throw new Error("Missing private key");
    const i = Kn(r) ? this.#t.privateNegate(n) : n, o = this.#t.privateAdd(i, t);
    if (o === null) throw new Error("Invalid tweaked private key!");
    return st.fromPrivateKey(this.#t, o, this.#r, {
      compressed: this.#n
    });
  }
  #c(t) {
    const r = this.xOnlyPublicKey, n = this.#t.xOnlyPointAddTweak(r, t);
    if (n === null || n.xOnlyPubkey === null)
      throw new Error("Cannot tweak public key!");
    const i = new Uint8Array([n.parity === 0 ? 2 : 3]), o = nn(i, n.xOnlyPubkey);
    return st.fromPublicKey(this.#t, ln(o), this.#r, {
      compressed: this.#n
    });
  }
}
const ee = /* @__PURE__ */ BigInt(0), Ft = /* @__PURE__ */ BigInt(1);
function Nt(e, t = "") {
  if (typeof e != "boolean") {
    const r = t && `"${t}" `;
    throw new Error(r + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function Ue(e) {
  if (typeof e == "bigint") {
    if (!Rt(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    dt(e);
  return e;
}
function St(e) {
  const t = Ue(e).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function Pe(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? ee : BigInt("0x" + e);
}
function xt(e) {
  return Pe(Ht(e));
}
function Ne(e) {
  return Pe(Ht($n(_(e)).reverse()));
}
function ne(e, t) {
  dt(t), e = Ue(e);
  const r = Pt(e.toString(16).padStart(t * 2, "0"));
  if (r.length !== t)
    throw new Error("number too large");
  return r;
}
function Te(e, t) {
  return ne(e, t).reverse();
}
function $n(e) {
  return Uint8Array.from(e);
}
function Vn(e) {
  return Uint8Array.from(e, (t, r) => {
    const n = t.charCodeAt(0);
    if (t.length !== 1 || n > 127)
      throw new Error(`string contains non-ASCII character "${e[r]}" with code ${n} at position ${r}`);
    return n;
  });
}
const Rt = (e) => typeof e == "bigint" && ee <= e;
function Dn(e, t, r) {
  return Rt(e) && Rt(t) && Rt(r) && t <= e && e < r;
}
function Mn(e, t, r, n) {
  if (!Dn(t, r, n))
    throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t);
}
function Xn(e) {
  let t;
  for (t = 0; e > ee; e >>= Ft, t += 1)
    ;
  return t;
}
const re = (e) => (Ft << BigInt(e)) - Ft;
function Yn(e, t, r) {
  if (dt(e, "hashLen"), dt(t, "qByteLen"), typeof r != "function")
    throw new Error("hmacFn must be a function");
  const n = (A) => new Uint8Array(A), i = Uint8Array.of(), o = Uint8Array.of(0), s = Uint8Array.of(1), f = 1e3;
  let c = n(e), a = n(e), h = 0;
  const b = () => {
    c.fill(1), a.fill(0), h = 0;
  }, m = (...A) => r(a, W(c, ...A)), y = (A = i) => {
    a = m(o, A), c = m(), A.length !== 0 && (a = m(s, A), c = m());
  }, E = () => {
    if (h++ >= f)
      throw new Error("drbg: tried max amount of iterations");
    let A = 0;
    const T = [];
    for (; A < t; ) {
      c = m();
      const q = c.slice();
      T.push(q), A += c.length;
    }
    return W(...T);
  };
  return (A, T) => {
    b(), y(A);
    let q;
    for (; !(q = T(E())); )
      y();
    return b(), q;
  };
}
function ie(e, t = {}, r = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function n(o, s, f) {
    const c = e[o];
    if (f && c === void 0)
      return;
    const a = typeof c;
    if (a !== s || c === null)
      throw new Error(`param "${o}" is invalid: expected ${s}, got ${a}`);
  }
  const i = (o, s) => Object.entries(o).forEach(([f, c]) => n(f, c, s));
  i(t, false), i(r, true);
}
function le(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const i = t.get(r);
    if (i !== void 0)
      return i;
    const o = e(r, ...n);
    return t.set(r, o), o;
  };
}
const X = /* @__PURE__ */ BigInt(0), D$1 = /* @__PURE__ */ BigInt(1), ct = /* @__PURE__ */ BigInt(2), _e = /* @__PURE__ */ BigInt(3), ke = /* @__PURE__ */ BigInt(4), Le = /* @__PURE__ */ BigInt(5), jn = /* @__PURE__ */ BigInt(7), He = /* @__PURE__ */ BigInt(8), zn = /* @__PURE__ */ BigInt(9), Ke = /* @__PURE__ */ BigInt(16);
function Y(e, t) {
  const r = e % t;
  return r >= X ? r : t + r;
}
function z(e, t, r) {
  let n = e;
  for (; t-- > X; )
    n *= n, n %= r;
  return n;
}
function he(e, t) {
  if (e === X)
    throw new Error("invert: expected non-zero number");
  if (t <= X)
    throw new Error("invert: expected positive modulus, got " + t);
  let r = Y(e, t), n = t, i = X, o = D$1;
  for (; r !== X; ) {
    const f = n / r, c = n % r, a = i - o * f;
    n = r, r = c, i = o, o = a;
  }
  if (n !== D$1)
    throw new Error("invert: does not exist");
  return Y(i, t);
}
function oe(e, t, r) {
  if (!e.eql(e.sqr(t), r))
    throw new Error("Cannot find square root");
}
function qe(e, t) {
  const r = (e.ORDER + D$1) / ke, n = e.pow(t, r);
  return oe(e, n, t), n;
}
function Fn(e, t) {
  const r = (e.ORDER - Le) / He, n = e.mul(t, ct), i = e.pow(n, r), o = e.mul(t, i), s = e.mul(e.mul(o, ct), i), f = e.mul(o, e.sub(s, e.ONE));
  return oe(e, f, t), f;
}
function Gn(e) {
  const t = qt(e), r = Ze(e), n = r(t, t.neg(t.ONE)), i = r(t, n), o = r(t, t.neg(n)), s = (e + jn) / Ke;
  return (f, c) => {
    let a = f.pow(c, s), h = f.mul(a, n);
    const b = f.mul(a, i), m = f.mul(a, o), y = f.eql(f.sqr(h), c), E = f.eql(f.sqr(b), c);
    a = f.cmov(a, h, y), h = f.cmov(m, b, E);
    const O = f.eql(f.sqr(h), c), A = f.cmov(a, h, O);
    return oe(f, A, c), A;
  };
}
function Ze(e) {
  if (e < _e)
    throw new Error("sqrt is not defined for small field");
  let t = e - D$1, r = 0;
  for (; t % ct === X; )
    t /= ct, r++;
  let n = ct;
  const i = qt(e);
  for (; be(i, n) === 1; )
    if (n++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (r === 1)
    return qe;
  let o = i.pow(n, t);
  const s = (t + D$1) / ct;
  return function(c, a) {
    if (c.is0(a))
      return a;
    if (be(c, a) !== 1)
      throw new Error("Cannot find square root");
    let h = r, b = c.mul(c.ONE, o), m = c.pow(a, t), y = c.pow(a, s);
    for (; !c.eql(m, c.ONE); ) {
      if (c.is0(m))
        return c.ZERO;
      let E = 1, O = c.sqr(m);
      for (; !c.eql(O, c.ONE); )
        if (E++, O = c.sqr(O), E === h)
          throw new Error("Cannot find square root");
      const A = D$1 << BigInt(h - E - 1), T = c.pow(b, A);
      h = E, b = c.sqr(T), m = c.mul(m, b), y = c.mul(y, T);
    }
    return y;
  };
}
function Wn(e) {
  return e % ke === _e ? qe : e % He === Le ? Fn : e % Ke === zn ? Gn(e) : Ze(e);
}
const Qn = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Jn(e) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, r = Qn.reduce((n, i) => (n[i] = "function", n), t);
  return ie(e, r), e;
}
function tr(e, t, r) {
  if (r < X)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === X)
    return e.ONE;
  if (r === D$1)
    return t;
  let n = e.ONE, i = t;
  for (; r > X; )
    r & D$1 && (n = e.mul(n, i)), i = e.sqr(i), r >>= D$1;
  return n;
}
function Ce(e, t, r = false) {
  const n = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((s, f, c) => e.is0(f) ? s : (n[c] = s, e.mul(s, f)), e.ONE), o = e.inv(i);
  return t.reduceRight((s, f, c) => e.is0(f) ? s : (n[c] = e.mul(s, n[c]), e.mul(s, f)), o), n;
}
function be(e, t) {
  const r = (e.ORDER - D$1) / ct, n = e.pow(t, r), i = e.eql(n, e.ONE), o = e.eql(n, e.ZERO), s = e.eql(n, e.neg(e.ONE));
  if (!i && !o && !s)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : o ? 0 : -1;
}
function er(e, t) {
  t !== void 0 && dt(t);
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
class nr {
  ORDER;
  BITS;
  BYTES;
  isLE;
  ZERO = X;
  ONE = D$1;
  _lengths;
  _sqrt;
  // cached sqrt
  _mod;
  constructor(t, r = {}) {
    if (t <= X)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let n;
    this.isLE = false, r != null && typeof r == "object" && (typeof r.BITS == "number" && (n = r.BITS), typeof r.sqrt == "function" && (this.sqrt = r.sqrt), typeof r.isLE == "boolean" && (this.isLE = r.isLE), r.allowedLengths && (this._lengths = r.allowedLengths?.slice()), typeof r.modFromBytes == "boolean" && (this._mod = r.modFromBytes));
    const { nBitLength: i, nByteLength: o } = er(t, n);
    if (o > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = i, this.BYTES = o, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return Y(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return X <= t && t < this.ORDER;
  }
  is0(t) {
    return t === X;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & D$1) === D$1;
  }
  neg(t) {
    return Y(-t, this.ORDER);
  }
  eql(t, r) {
    return t === r;
  }
  sqr(t) {
    return Y(t * t, this.ORDER);
  }
  add(t, r) {
    return Y(t + r, this.ORDER);
  }
  sub(t, r) {
    return Y(t - r, this.ORDER);
  }
  mul(t, r) {
    return Y(t * r, this.ORDER);
  }
  pow(t, r) {
    return tr(this, t, r);
  }
  div(t, r) {
    return Y(t * he(r, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, r) {
    return t + r;
  }
  subN(t, r) {
    return t - r;
  }
  mulN(t, r) {
    return t * r;
  }
  inv(t) {
    return he(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = Wn(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? Te(t, this.BYTES) : ne(t, this.BYTES);
  }
  fromBytes(t, r = false) {
    _(t);
    const { _lengths: n, BYTES: i, isLE: o, ORDER: s, _mod: f } = this;
    if (n) {
      if (!n.includes(t.length) || t.length > i)
        throw new Error("Field.fromBytes: expected " + n + " bytes, got " + t.length);
      const a = new Uint8Array(i);
      a.set(t, o ? 0 : a.length - t.length), t = a;
    }
    if (t.length !== i)
      throw new Error("Field.fromBytes: expected " + i + " bytes, got " + t.length);
    let c = o ? Ne(t) : xt(t);
    if (f && (c = Y(c, s)), !r && !this.isValid(c))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return c;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return Ce(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, r, n) {
    return n ? r : t;
  }
}
function qt(e, t = {}) {
  return new nr(e, t);
}
function $e(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function Ve(e) {
  const t = $e(e);
  return t + Math.ceil(t / 2);
}
function De(e, t, r = false) {
  _(e);
  const n = e.length, i = $e(t), o = Ve(t);
  if (n < 16 || n < o || n > 1024)
    throw new Error("expected " + o + "-1024 bytes of input, got " + n);
  const s = r ? Ne(e) : xt(e), f = Y(s, t - D$1) + D$1;
  return r ? Te(f, i) : ne(f, i);
}
const yt = /* @__PURE__ */ BigInt(0), at = /* @__PURE__ */ BigInt(1);
function Tt(e, t) {
  const r = t.negate();
  return e ? r : t;
}
function ye(e, t) {
  const r = Ce(e.Fp, t.map((n) => n.Z));
  return t.map((n, i) => e.fromAffine(n.toAffine(r[i])));
}
function Me(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function Mt(e, t) {
  Me(e, t);
  const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i = 2 ** e, o = re(e), s = BigInt(e);
  return { windows: r, windowSize: n, mask: o, maxNumber: i, shiftBy: s };
}
function ge(e, t, r) {
  const { windowSize: n, mask: i, maxNumber: o, shiftBy: s } = r;
  let f = Number(e & i), c = e >> s;
  f > n && (f -= o, c += at);
  const a = t * n, h = a + Math.abs(f) - 1, b = f === 0, m = f < 0, y = t % 2 !== 0;
  return { nextN: c, offset: h, isZero: b, isNeg: m, isNegF: y, offsetF: a };
}
const Xt = /* @__PURE__ */ new WeakMap(), Xe = /* @__PURE__ */ new WeakMap();
function Yt(e) {
  return Xe.get(e) || 1;
}
function we(e) {
  if (e !== yt)
    throw new Error("invalid wNAF");
}
class rr {
  BASE;
  ZERO;
  Fn;
  bits;
  // Parametrized with a given Point class (not individual point)
  constructor(t, r) {
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = r;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, r, n = this.ZERO) {
    let i = t;
    for (; r > yt; )
      r & at && (n = n.add(i)), i = i.double(), r >>= at;
    return n;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(ð‘Šâˆ’1) * (Math.ceil(ð‘› / ð‘Š) + 1), where:
   * - ð‘Š is the window size
   * - ð‘› is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, r) {
    const { windows: n, windowSize: i } = Mt(r, this.bits), o = [];
    let s = t, f = s;
    for (let c = 0; c < n; c++) {
      f = s, o.push(f);
      for (let a = 1; a < i; a++)
        f = f.add(s), o.push(f);
      s = f.double();
    }
    return o;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, r, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let i = this.ZERO, o = this.BASE;
    const s = Mt(t, this.bits);
    for (let f = 0; f < s.windows; f++) {
      const { nextN: c, offset: a, isZero: h, isNeg: b, isNegF: m, offsetF: y } = ge(n, f, s);
      n = c, h ? o = o.add(Tt(m, r[y])) : i = i.add(Tt(b, r[a]));
    }
    return we(n), { p: i, f: o };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, r, n, i = this.ZERO) {
    const o = Mt(t, this.bits);
    for (let s = 0; s < o.windows && n !== yt; s++) {
      const { nextN: f, offset: c, isZero: a, isNeg: h } = ge(n, s, o);
      if (n = f, !a) {
        const b = r[c];
        i = i.add(h ? b.negate() : b);
      }
    }
    return we(n), i;
  }
  getPrecomputes(t, r, n) {
    let i = Xt.get(r);
    return i || (i = this.precomputeWindow(r, t), t !== 1 && (typeof n == "function" && (i = n(i)), Xt.set(r, i))), i;
  }
  cached(t, r, n) {
    const i = Yt(t);
    return this.wNAF(i, this.getPrecomputes(i, t, n), r);
  }
  unsafe(t, r, n, i) {
    const o = Yt(t);
    return o === 1 ? this._unsafeLadder(t, r, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, n), r, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, r) {
    Me(r, this.bits), Xe.set(t, r), Xt.delete(t);
  }
  hasCache(t) {
    return Yt(t) !== 1;
  }
}
function ir(e, t, r, n) {
  let i = t, o = e.ZERO, s = e.ZERO;
  for (; r > yt || n > yt; )
    r & at && (o = o.add(i)), n & at && (s = s.add(i)), i = i.double(), r >>= at, n >>= at;
  return { p1: o, p2: s };
}
function pe(e, t, r) {
  if (t) {
    if (t.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Jn(t), t;
  } else
    return qt(e, { isLE: r });
}
function or(e, t, r = {}, n) {
  if (n === void 0 && (n = e === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const a = t[c];
    if (!(typeof a == "bigint" && a > yt))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const i = pe(t.p, r.Fp, n), o = pe(t.n, r.Fn, n), f = ["Gx", "Gy", "a", "b"];
  for (const c of f)
    if (!i.isValid(t[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: i, Fn: o };
}
function Ye(e, t) {
  return function(n) {
    const i = e(n);
    return { secretKey: i, publicKey: t(i) };
  };
}
class je {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = false;
  destroyed = false;
  constructor(t, r) {
    if (Oe(t), _(r, void 0, "key"), this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n = this.blockLen, i = new Uint8Array(n);
    i.set(r.length > n ? t.create().update(r).digest() : r);
    for (let o = 0; o < i.length; o++)
      i[o] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let o = 0; o < i.length; o++)
      i[o] ^= 106;
    this.oHash.update(i), Ut(i);
  }
  update(t) {
    return It(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    It(this), _(t, this.outputLen, "output"), this.finished = true, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: f } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = f, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
}
const ze = (e, t, r) => new je(e, t).update(r).digest();
ze.create = (e, t) => new je(e, t);
const me = (e, t) => (e + (e >= 0 ? t : -t) / Fe) / t;
function sr(e, t, r) {
  const [[n, i], [o, s]] = t, f = me(s * e, r), c = me(-i * e, r);
  let a = e - f * n - c * o, h = -f * i - c * s;
  const b = a < J, m = h < J;
  b && (a = -a), m && (h = -h);
  const y = re(Math.ceil(Xn(r) / 2)) + bt;
  if (a < J || a >= y || h < J || h >= y)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: b, k1: a, k2neg: m, k2: h };
}
function Gt(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function jt(e, t) {
  const r = {};
  for (let n of Object.keys(t))
    r[n] = e[n] === void 0 ? t[n] : e[n];
  return Nt(r.lowS, "lowS"), Nt(r.prehash, "prehash"), r.format !== void 0 && Gt(r.format), r;
}
class fr extends Error {
  constructor(t = "") {
    super(t);
  }
}
const rt = {
  // asn.1 DER encoding utils
  Err: fr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = rt;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const n = t.length / 2, i = St(n);
      if (i.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const o = n > 127 ? St(i.length / 2 | 128) : "";
      return St(e) + o + i + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = rt;
      let n = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const i = t[n++], o = !!(i & 128);
      let s = 0;
      if (!o)
        s = i;
      else {
        const c = i & 127;
        if (!c)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const a = t.subarray(n, n + c);
        if (a.length !== c)
          throw new r("tlv.decode: length bytes not complete");
        if (a[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const h of a)
          s = s << 8 | h;
        if (n += c, s < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const f = t.subarray(n, n + s);
      if (f.length !== s)
        throw new r("tlv.decode: wrong value length");
      return { v: f, l: t.subarray(n + s) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = rt;
      if (e < J)
        throw new t("integer: negative integers are not allowed");
      let r = St(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(e) {
      const { Err: t } = rt;
      if (e[0] & 128)
        throw new t("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return xt(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: n } = rt, i = _(e, void 0, "signature"), { v: o, l: s } = n.decode(48, i);
    if (s.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: f, l: c } = n.decode(2, o), { v: a, l: h } = n.decode(2, c);
    if (h.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: r.decode(f), s: r.decode(a) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = rt, n = t.encode(2, r.encode(e.r)), i = t.encode(2, r.encode(e.s)), o = n + i;
    return t.encode(48, o);
  }
}, J = BigInt(0), bt = BigInt(1), Fe = BigInt(2), At = BigInt(3), cr = BigInt(4);
function ar(e, t = {}) {
  const r = or("weierstrass", e, t), { Fp: n, Fn: i } = r;
  let o = r.CURVE;
  const { h: s, n: f } = o;
  ie(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: c } = t;
  if (c && (!n.is0(o.a) || typeof c.beta != "bigint" || !Array.isArray(c.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const a = We(n, i);
  function h() {
    if (!n.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function b(U, l, u) {
    const { x: d, y: g } = l.toAffine(), x = n.toBytes(d);
    if (Nt(u, "isCompressed"), u) {
      h();
      const B = !n.isOdd(g);
      return W(Ge(B), x);
    } else
      return W(Uint8Array.of(4), x, n.toBytes(g));
  }
  function m(U) {
    _(U, void 0, "Point");
    const { publicKey: l, publicKeyUncompressed: u } = a, d = U.length, g = U[0], x = U.subarray(1);
    if (d === l && (g === 2 || g === 3)) {
      const B = n.fromBytes(x);
      if (!n.isValid(B))
        throw new Error("bad point: is not on curve, wrong x");
      const v = O(B);
      let p;
      try {
        p = n.sqrt(v);
      } catch (C) {
        const k = C instanceof Error ? ": " + C.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + k);
      }
      h();
      const S = n.isOdd(p);
      return (g & 1) === 1 !== S && (p = n.neg(p)), { x: B, y: p };
    } else if (d === u && g === 4) {
      const B = n.BYTES, v = n.fromBytes(x.subarray(0, B)), p = n.fromBytes(x.subarray(B, B * 2));
      if (!A(v, p))
        throw new Error("bad point: is not on curve");
      return { x: v, y: p };
    } else
      throw new Error(`bad point: got length ${d}, expected compressed=${l} or uncompressed=${u}`);
  }
  const y = t.toBytes || b, E = t.fromBytes || m;
  function O(U) {
    const l = n.sqr(U), u = n.mul(l, U);
    return n.add(n.add(u, n.mul(U, o.a)), o.b);
  }
  function A(U, l) {
    const u = n.sqr(l), d = O(U);
    return n.eql(u, d);
  }
  if (!A(o.Gx, o.Gy))
    throw new Error("bad curve params: generator point");
  const T = n.mul(n.pow(o.a, At), cr), q = n.mul(n.sqr(o.b), BigInt(27));
  if (n.is0(n.add(T, q)))
    throw new Error("bad curve params: a or b");
  function Z(U, l, u = false) {
    if (!n.isValid(l) || u && n.is0(l))
      throw new Error(`bad point coordinate ${U}`);
    return l;
  }
  function L(U) {
    if (!(U instanceof N))
      throw new Error("Weierstrass Point expected");
  }
  function j(U) {
    if (!c || !c.basises)
      throw new Error("no endo");
    return sr(U, c.basises, i.ORDER);
  }
  const tt = le((U, l) => {
    const { X: u, Y: d, Z: g } = U;
    if (n.eql(g, n.ONE))
      return { x: u, y: d };
    const x = U.is0();
    l == null && (l = x ? n.ONE : n.inv(g));
    const B = n.mul(u, l), v = n.mul(d, l), p = n.mul(g, l);
    if (x)
      return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(p, n.ONE))
      throw new Error("invZ was invalid");
    return { x: B, y: v };
  }), Ct = le((U) => {
    if (U.is0()) {
      if (t.allowInfinityPoint && !n.is0(U.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: l, y: u } = U.toAffine();
    if (!n.isValid(l) || !n.isValid(u))
      throw new Error("bad point: x or y not field elements");
    if (!A(l, u))
      throw new Error("bad point: equation left != right");
    if (!U.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function gt(U, l, u, d, g) {
    return u = new N(n.mul(u.X, U), u.Y, u.Z), l = Tt(d, l), u = Tt(g, u), l.add(u);
  }
  class N {
    // base / generator point
    static BASE = new N(o.Gx, o.Gy, n.ONE);
    // zero / infinity / identity point
    static ZERO = new N(n.ZERO, n.ONE, n.ZERO);
    // 0, 1, 0
    // math field
    static Fp = n;
    // scalar field
    static Fn = i;
    X;
    Y;
    Z;
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(l, u, d) {
      this.X = Z("x", l), this.Y = Z("y", u, true), this.Z = Z("z", d), Object.freeze(this);
    }
    static CURVE() {
      return o;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(l) {
      const { x: u, y: d } = l || {};
      if (!l || !n.isValid(u) || !n.isValid(d))
        throw new Error("invalid affine point");
      if (l instanceof N)
        throw new Error("projective point not allowed");
      return n.is0(u) && n.is0(d) ? N.ZERO : new N(u, d, n.ONE);
    }
    static fromBytes(l) {
      const u = N.fromAffine(E(_(l, void 0, "point")));
      return u.assertValidity(), u;
    }
    static fromHex(l) {
      return N.fromBytes(Pt(l));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(l = 8, u = true) {
      return it.createCache(this, l), u || this.multiply(At), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      Ct(this);
    }
    hasEvenY() {
      const { y: l } = this.toAffine();
      if (!n.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n.isOdd(l);
    }
    /** Compare one point to another. */
    equals(l) {
      L(l);
      const { X: u, Y: d, Z: g } = this, { X: x, Y: B, Z: v } = l, p = n.eql(n.mul(u, v), n.mul(x, g)), S = n.eql(n.mul(d, v), n.mul(B, g));
      return p && S;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new N(this.X, n.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: l, b: u } = o, d = n.mul(u, At), { X: g, Y: x, Z: B } = this;
      let v = n.ZERO, p = n.ZERO, S = n.ZERO, R = n.mul(g, g), C = n.mul(x, x), k = n.mul(B, B), I = n.mul(g, x);
      return I = n.add(I, I), S = n.mul(g, B), S = n.add(S, S), v = n.mul(l, S), p = n.mul(d, k), p = n.add(v, p), v = n.sub(C, p), p = n.add(C, p), p = n.mul(v, p), v = n.mul(I, v), S = n.mul(d, S), k = n.mul(l, k), I = n.sub(R, k), I = n.mul(l, I), I = n.add(I, S), S = n.add(R, R), R = n.add(S, R), R = n.add(R, k), R = n.mul(R, I), p = n.add(p, R), k = n.mul(x, B), k = n.add(k, k), R = n.mul(k, I), v = n.sub(v, R), S = n.mul(k, C), S = n.add(S, S), S = n.add(S, S), new N(v, p, S);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(l) {
      L(l);
      const { X: u, Y: d, Z: g } = this, { X: x, Y: B, Z: v } = l;
      let p = n.ZERO, S = n.ZERO, R = n.ZERO;
      const C = o.a, k = n.mul(o.b, At);
      let I = n.mul(u, x), H = n.mul(d, B), $ = n.mul(g, v), F = n.add(u, d), K = n.add(x, B);
      F = n.mul(F, K), K = n.add(I, H), F = n.sub(F, K), K = n.add(u, g);
      let V = n.add(x, v);
      return K = n.mul(K, V), V = n.add(I, $), K = n.sub(K, V), V = n.add(d, g), p = n.add(B, v), V = n.mul(V, p), p = n.add(H, $), V = n.sub(V, p), R = n.mul(C, K), p = n.mul(k, $), R = n.add(p, R), p = n.sub(H, R), R = n.add(H, R), S = n.mul(p, R), H = n.add(I, I), H = n.add(H, I), $ = n.mul(C, $), K = n.mul(k, K), H = n.add(H, $), $ = n.sub(I, $), $ = n.mul(C, $), K = n.add(K, $), I = n.mul(H, K), S = n.add(S, I), I = n.mul(V, K), p = n.mul(F, p), p = n.sub(p, I), I = n.mul(F, H), R = n.mul(V, R), R = n.add(R, I), new N(p, S, R);
    }
    subtract(l) {
      return this.add(l.negate());
    }
    is0() {
      return this.equals(N.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(l) {
      const { endo: u } = t;
      if (!i.isValidNot0(l))
        throw new Error("invalid scalar: out of range");
      let d, g;
      const x = (B) => it.cached(this, B, (v) => ye(N, v));
      if (u) {
        const { k1neg: B, k1: v, k2neg: p, k2: S } = j(l), { p: R, f: C } = x(v), { p: k, f: I } = x(S);
        g = C.add(I), d = gt(u.beta, R, k, B, p);
      } else {
        const { p: B, f: v } = x(l);
        d = B, g = v;
      }
      return ye(N, [d, g])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(l) {
      const { endo: u } = t, d = this;
      if (!i.isValid(l))
        throw new Error("invalid scalar: out of range");
      if (l === J || d.is0())
        return N.ZERO;
      if (l === bt)
        return d;
      if (it.hasCache(this))
        return this.multiply(l);
      if (u) {
        const { k1neg: g, k1: x, k2neg: B, k2: v } = j(l), { p1: p, p2: S } = ir(N, d, x, v);
        return gt(u.beta, p, S, g, B);
      } else
        return it.unsafe(d, l);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(l) {
      return tt(this, l);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: l } = t;
      return s === bt ? true : l ? l(N, this) : it.unsafe(this, f).is0();
    }
    clearCofactor() {
      const { clearCofactor: l } = t;
      return s === bt ? this : l ? l(N, this) : this.multiplyUnsafe(s);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(s).is0();
    }
    toBytes(l = true) {
      return Nt(l, "isCompressed"), this.assertValidity(), y(N, this, l);
    }
    toHex(l = true) {
      return Ht(this.toBytes(l));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const vt = i.BITS, it = new rr(N, t.endo ? Math.ceil(vt / 2) : vt);
  return N.BASE.precompute(8), N;
}
function Ge(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function We(e, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: true,
    signature: 2 * t.BYTES
  };
}
function dr(e, t = {}) {
  const { Fn: r } = e, n = t.randomBytes || Kt, i = Object.assign(We(e.Fp, r), { seed: Ve(r.ORDER) });
  function o(y) {
    try {
      const E = r.fromBytes(y);
      return r.isValidNot0(E);
    } catch {
      return false;
    }
  }
  function s(y, E) {
    const { publicKey: O, publicKeyUncompressed: A } = i;
    try {
      const T = y.length;
      return E === true && T !== O || E === false && T !== A ? false : !!e.fromBytes(y);
    } catch {
      return false;
    }
  }
  function f(y = n(i.seed)) {
    return De(_(y, i.seed, "seed"), r.ORDER);
  }
  function c(y, E = true) {
    return e.BASE.multiply(r.fromBytes(y)).toBytes(E);
  }
  function a(y) {
    const { secretKey: E, publicKey: O, publicKeyUncompressed: A } = i;
    if (!te(y) || "_lengths" in r && r._lengths || E === O)
      return;
    const T = _(y, void 0, "key").length;
    return T === O || T === A;
  }
  function h(y, E, O = true) {
    if (a(y) === true)
      throw new Error("first arg must be private key");
    if (a(E) === false)
      throw new Error("second arg must be public key");
    const A = r.fromBytes(y);
    return e.fromBytes(E).multiply(A).toBytes(O);
  }
  const b = {
    isValidSecretKey: o,
    isValidPublicKey: s,
    randomSecretKey: f
  }, m = Ye(f, c);
  return Object.freeze({ getPublicKey: c, getSharedSecret: h, keygen: m, Point: e, utils: b, lengths: i });
}
function ur(e, t, r = {}) {
  Oe(t), ie(r, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), r = Object.assign({}, r);
  const n = r.randomBytes || Kt, i = r.hmac || ((u, d) => ze(t, u, d)), { Fp: o, Fn: s } = e, { ORDER: f, BITS: c } = s, { keygen: a, getPublicKey: h, getSharedSecret: b, utils: m, lengths: y } = dr(e, r), E = {
    prehash: true,
    lowS: typeof r.lowS == "boolean" ? r.lowS : true,
    format: "compact",
    extraEntropy: false
  }, O = f * Fe < o.ORDER;
  function A(u) {
    const d = f >> bt;
    return u > d;
  }
  function T(u, d) {
    if (!s.isValidNot0(d))
      throw new Error(`invalid signature ${u}: out of range 1..Point.Fn.ORDER`);
    return d;
  }
  function q() {
    if (O)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function Z(u, d) {
    Gt(d);
    const g = y.signature, x = d === "compact" ? g : d === "recovered" ? g + 1 : void 0;
    return _(u, x);
  }
  class L {
    r;
    s;
    recovery;
    constructor(d, g, x) {
      if (this.r = T("r", d), this.s = T("s", g), x != null) {
        if (q(), ![0, 1, 2, 3].includes(x))
          throw new Error("invalid recovery id");
        this.recovery = x;
      }
      Object.freeze(this);
    }
    static fromBytes(d, g = E.format) {
      Z(d, g);
      let x;
      if (g === "der") {
        const { r: S, s: R } = rt.toSig(_(d));
        return new L(S, R);
      }
      g === "recovered" && (x = d[0], g = "compact", d = d.subarray(1));
      const B = y.signature / 2, v = d.subarray(0, B), p = d.subarray(B, B * 2);
      return new L(s.fromBytes(v), s.fromBytes(p), x);
    }
    static fromHex(d, g) {
      return this.fromBytes(Pt(d), g);
    }
    assertRecovery() {
      const { recovery: d } = this;
      if (d == null)
        throw new Error("invalid recovery id: must be present");
      return d;
    }
    addRecoveryBit(d) {
      return new L(this.r, this.s, d);
    }
    recoverPublicKey(d) {
      const { r: g, s: x } = this, B = this.assertRecovery(), v = B === 2 || B === 3 ? g + f : g;
      if (!o.isValid(v))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const p = o.toBytes(v), S = e.fromBytes(W(Ge((B & 1) === 0), p)), R = s.inv(v), C = tt(_(d, void 0, "msgHash")), k = s.create(-C * R), I = s.create(x * R), H = e.BASE.multiplyUnsafe(k).add(S.multiplyUnsafe(I));
      if (H.is0())
        throw new Error("invalid recovery: point at infinify");
      return H.assertValidity(), H;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return A(this.s);
    }
    toBytes(d = E.format) {
      if (Gt(d), d === "der")
        return Pt(rt.hexFromSig(this));
      const { r: g, s: x } = this, B = s.toBytes(g), v = s.toBytes(x);
      return d === "recovered" ? (q(), W(Uint8Array.of(this.assertRecovery()), B, v)) : W(B, v);
    }
    toHex(d) {
      return Ht(this.toBytes(d));
    }
  }
  const j = r.bits2int || function(d) {
    if (d.length > 8192)
      throw new Error("input is too large");
    const g = xt(d), x = d.length * 8 - c;
    return x > 0 ? g >> BigInt(x) : g;
  }, tt = r.bits2int_modN || function(d) {
    return s.create(j(d));
  }, Ct = re(c);
  function gt(u) {
    return Mn("num < 2^" + c, u, J, Ct), s.toBytes(u);
  }
  function N(u, d) {
    return _(u, void 0, "message"), d ? _(t(u), void 0, "prehashed message") : u;
  }
  function vt(u, d, g) {
    const { lowS: x, prehash: B, extraEntropy: v } = jt(g, E);
    u = N(u, B);
    const p = tt(u), S = s.fromBytes(d);
    if (!s.isValidNot0(S))
      throw new Error("invalid private key");
    const R = [gt(S), gt(p)];
    if (v != null && v !== false) {
      const H = v === true ? n(y.secretKey) : v;
      R.push(_(H, void 0, "extraEntropy"));
    }
    const C = W(...R), k = p;
    function I(H) {
      const $ = j(H);
      if (!s.isValidNot0($))
        return;
      const F = s.inv($), K = e.BASE.multiply($).toAffine(), V = s.create(K.x);
      if (V === J)
        return;
      const Bt = s.create(F * s.create(k + V * S));
      if (Bt === J)
        return;
      let ce = (K.x === V ? 0 : 2) | Number(K.y & bt), ae = Bt;
      return x && A(Bt) && (ae = s.neg(Bt), ce ^= 1), new L(V, ae, O ? void 0 : ce);
    }
    return { seed: C, k2sig: I };
  }
  function it(u, d, g = {}) {
    const { seed: x, k2sig: B } = vt(u, d, g);
    return Yn(t.outputLen, s.BYTES, i)(x, B).toBytes(g.format);
  }
  function U(u, d, g, x = {}) {
    const { lowS: B, prehash: v, format: p } = jt(x, E);
    if (g = _(g, void 0, "publicKey"), d = N(d, v), !te(u)) {
      const S = u instanceof L ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + S);
    }
    Z(u, p);
    try {
      const S = L.fromBytes(u, p), R = e.fromBytes(g);
      if (B && S.hasHighS())
        return false;
      const { r: C, s: k } = S, I = tt(d), H = s.inv(k), $ = s.create(I * H), F = s.create(C * H), K = e.BASE.multiplyUnsafe($).add(R.multiplyUnsafe(F));
      return K.is0() ? false : s.create(K.x) === C;
    } catch {
      return false;
    }
  }
  function l(u, d, g = {}) {
    const { prehash: x } = jt(g, E);
    return d = N(d, x), L.fromBytes(u, "recovered").recoverPublicKey(d).toBytes();
  }
  return Object.freeze({
    keygen: a,
    getPublicKey: h,
    getSharedSecret: b,
    utils: m,
    lengths: y,
    Point: e,
    sign: it,
    verify: U,
    recoverPublicKey: l,
    Signature: L,
    hash: t
  });
}
const Zt = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, lr = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, hr = /* @__PURE__ */ BigInt(0), Wt = /* @__PURE__ */ BigInt(2);
function br(e) {
  const t = Zt.p, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), f = BigInt(44), c = BigInt(88), a = e * e * e % t, h = a * a * e % t, b = z(h, r, t) * h % t, m = z(b, r, t) * h % t, y = z(m, Wt, t) * a % t, E = z(y, i, t) * y % t, O = z(E, o, t) * E % t, A = z(O, f, t) * O % t, T = z(A, c, t) * A % t, q = z(T, f, t) * O % t, Z = z(q, r, t) * h % t, L = z(Z, s, t) * E % t, j = z(L, n, t) * a % t, tt = z(j, Wt, t);
  if (!_t.eql(_t.sqr(tt), e))
    throw new Error("Cannot find square root");
  return tt;
}
const _t = qt(Zt.p, { sqrt: br }), ut = /* @__PURE__ */ ar(Zt, {
  Fp: _t,
  endo: lr
}), ft = /* @__PURE__ */ ur(ut, Et), Ee = {};
function kt(e, ...t) {
  let r = Ee[e];
  if (r === void 0) {
    const n = Et(Vn(e));
    r = W(n, n), Ee[e] = r;
  }
  return Et(W(r, ...t));
}
const se = (e) => e.toBytes(true).slice(1), fe = (e) => e % Wt === hr;
function Qt(e) {
  const { Fn: t, BASE: r } = ut, n = t.fromBytes(e), i = r.multiply(n);
  return { scalar: fe(i.y) ? n : t.neg(n), bytes: se(i) };
}
function Qe(e) {
  const t = _t;
  if (!t.isValidNot0(e))
    throw new Error("invalid x: Fail if x â‰¥ p");
  const r = t.create(e * e), n = t.create(r * e + BigInt(7));
  let i = t.sqrt(n);
  fe(i) || (i = t.neg(i));
  const o = ut.fromAffine({ x: e, y: i });
  return o.assertValidity(), o;
}
const mt = xt;
function Je(...e) {
  return ut.Fn.create(mt(kt("BIP0340/challenge", ...e)));
}
function xe(e) {
  return Qt(e).bytes;
}
function yr(e, t, r = Kt(32)) {
  const { Fn: n } = ut, i = _(e, void 0, "message"), { bytes: o, scalar: s } = Qt(t), f = _(r, 32, "auxRand"), c = n.toBytes(s ^ mt(kt("BIP0340/aux", f))), a = kt("BIP0340/nonce", c, o, i), { bytes: h, scalar: b } = Qt(a), m = Je(h, o, i), y = new Uint8Array(64);
  if (y.set(h, 0), y.set(n.toBytes(n.create(b + m * s)), 32), !tn(y, i, o))
    throw new Error("sign: Invalid signature produced");
  return y;
}
function tn(e, t, r) {
  const { Fp: n, Fn: i, BASE: o } = ut, s = _(e, 64, "signature"), f = _(t, void 0, "message"), c = _(r, 32, "publicKey");
  try {
    const a = Qe(mt(c)), h = mt(s.subarray(0, 32));
    if (!n.isValidNot0(h))
      return false;
    const b = mt(s.subarray(32, 64));
    if (!i.isValidNot0(b))
      return false;
    const m = Je(i.toBytes(h), se(a), f), y = o.multiplyUnsafe(b).add(a.multiplyUnsafe(i.neg(m))), { x: E, y: O } = y.toAffine();
    return !(y.is0() || !fe(O) || E !== h);
  } catch {
    return false;
  }
}
const pt = /* @__PURE__ */ (() => {
  const r = (n = Kt(48)) => De(n, Zt.n);
  return {
    keygen: Ye(r, xe),
    getPublicKey: xe,
    sign: yr,
    verify: tn,
    Point: ut,
    utils: {
      randomSecretKey: r,
      taggedHash: kt,
      lift_x: Qe,
      pointToBytes: se
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: false,
      signature: 64,
      seed: 48
    }
  };
})(), ht = ft.Point, Ot = ht.Fn.ORDER;
function ve(e) {
  const t = e.toString(16).padStart(64, "0"), r = new Uint8Array(32);
  for (let n = 0; n < 32; n++)
    r[n] = parseInt(t.slice(n * 2, n * 2 + 2), 16);
  return r;
}
function ot(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
class gr {
  /** @inheritDoc */
  isPrivate(t) {
    return ft.utils.isValidSecretKey(t);
  }
  /** @inheritDoc */
  isPoint(t) {
    try {
      return ht.fromHex(wt(t)), true;
    } catch {
      return false;
    }
  }
  /** @inheritDoc */
  isXOnlyPoint(t) {
    if (t.length !== 32) return false;
    try {
      return pt.utils.lift_x(ot(t)), true;
    } catch {
      return false;
    }
  }
  /** @inheritDoc */
  pointFromScalar(t, r) {
    try {
      return ft.getPublicKey(t, r ?? true);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  pointCompress(t, r) {
    return ht.fromHex(wt(t)).toBytes(r ?? true);
  }
  /** @inheritDoc */
  pointAddScalar(t, r, n) {
    try {
      const i = ht.fromHex(wt(t));
      if (ot(r) === 0n)
        return i.toBytes(n ?? true);
      const s = ft.getPublicKey(r, true), f = ht.fromHex(wt(s));
      return i.add(f).toBytes(n ?? true);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t, r) {
    try {
      const n = pt.utils.lift_x(ot(t));
      if (ot(r) >= Ot) return null;
      const o = ft.getPublicKey(r, true), s = ht.fromHex(wt(o)), f = n.add(s), c = pt.utils.pointToBytes(f);
      return {
        parity: Number(f.y & 1n),
        xOnlyPubkey: c
      };
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  privateAdd(t, r) {
    const n = ot(t), i = ot(r), o = Y(n + i, Ot);
    return o === 0n ? null : ve(o);
  }
  /** @inheritDoc */
  privateNegate(t) {
    const r = ot(t), n = Y(Ot - r, Ot);
    return ve(n);
  }
  /** @inheritDoc */
  sign(t, r, n) {
    return ft.sign(t, r, {
      prehash: false,
      lowS: true,
      extraEntropy: n ?? false
    });
  }
  /** @inheritDoc */
  verify(t, r, n) {
    return ft.verify(n, t, r, {
      prehash: false,
      lowS: true
    });
  }
  /** @inheritDoc */
  signSchnorr(t, r, n) {
    return pt.sign(t, r, n);
  }
  /** @inheritDoc */
  verifySchnorr(t, r, n) {
    return pt.verify(n, t, r);
  }
}
function Nr() {
  return new gr();
}
class wr {
  #t;
  /**
   * @param ecc - Object implementing the {@link TinySecp256k1Interface}.
   */
  constructor(t) {
    this.#t = t;
  }
  /** `true` when the underlying library supports Schnorr signing. */
  get hasSchnorrSign() {
    return typeof this.#t.signSchnorr == "function";
  }
  /** `true` when the underlying library supports Schnorr verification. */
  get hasSchnorrVerify() {
    return typeof this.#t.verifySchnorr == "function";
  }
  /** @inheritDoc */
  isPrivate(t) {
    return this.#t.isPrivate(t);
  }
  /** @inheritDoc */
  isPoint(t) {
    return this.#t.isPoint(t);
  }
  /** @inheritDoc */
  isXOnlyPoint(t) {
    if (t.length !== 32) return false;
    const r = new Uint8Array(33);
    return r[0] = 2, r.set(t, 1), this.#t.isPoint(r);
  }
  /** @inheritDoc */
  pointFromScalar(t, r) {
    return this.#t.pointFromScalar(t, r);
  }
  /** @inheritDoc */
  pointCompress(t, r) {
    return this.#t.pointCompress(t, r);
  }
  /** @inheritDoc */
  pointAddScalar(t, r, n) {
    return this.#t.pointAddScalar(t, r, n);
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t, r) {
    const n = this.#t.xOnlyPointAddTweak(t, r);
    return n === null ? null : {
      parity: n.parity,
      xOnlyPubkey: n.xOnlyPubkey
    };
  }
  /** @inheritDoc */
  privateAdd(t, r) {
    return this.#t.privateAdd(t, r);
  }
  /** @inheritDoc */
  privateNegate(t) {
    return this.#t.privateNegate(t);
  }
  /** @inheritDoc */
  sign(t, r, n) {
    return this.#t.sign(t, r, n);
  }
  /** @inheritDoc */
  verify(t, r, n) {
    return this.#t.verify(t, r, n);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `signSchnorr`.
   */
  signSchnorr(t, r, n) {
    if (!this.#t.signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return this.#t.signSchnorr(t, r, n);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `verifySchnorr`.
   */
  verifySchnorr(t, r, n) {
    if (!this.#t.verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return this.#t.verifySchnorr(t, r, n);
  }
}
function Tr(e) {
  return new wr(e);
}
function w(e) {
  return en(e);
}
function P$1(e, t) {
  if (!e) throw new Error(`verifyCryptoBackend: ${t}`);
}
function _r(e) {
  P$1(
    e.isPoint(w("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPoint should accept generator point"
  ), P$1(
    !e.isPoint(w("030000000000000000000000000000000000000000000000000000000000000005")),
    "isPoint should reject invalid point"
  ), P$1(
    e.isXOnlyPoint(
      w("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "isXOnlyPoint should accept generator x-coordinate"
  ), P$1(
    !e.isXOnlyPoint(
      w("0000000000000000000000000000000000000000000000000000000000000005")
    ),
    "isXOnlyPoint should reject x-coordinate not on curve"
  ), P$1(
    !e.isXOnlyPoint(
      w("0000000000000000000000000000000000000000000000000000000000000000")
    ),
    "isXOnlyPoint should reject zero"
  ), P$1(
    !e.isXOnlyPoint(w("79be667ef9dcbbac55a06295ce870b07")),
    "isXOnlyPoint should reject wrong length"
  ), P$1(
    e.isPrivate(w("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPrivate should accept valid scalar"
  ), P$1(
    e.isPrivate(w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")),
    "isPrivate should accept n-1"
  ), P$1(
    !e.isPrivate(w("0000000000000000000000000000000000000000000000000000000000000000")),
    "isPrivate should reject zero"
  ), P$1(
    !e.isPrivate(w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")),
    "isPrivate should reject n"
  ), P$1(
    !e.isPrivate(w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")),
    "isPrivate should reject n+1"
  );
  const t = e.privateAdd(
    w("0000000000000000000000000000000000000000000000000000000000000001"),
    w("0000000000000000000000000000000000000000000000000000000000000000")
  );
  P$1(
    t !== null && M(
      t,
      w("0000000000000000000000000000000000000000000000000000000000000001")
    ),
    "privateAdd: 1 + 0 should equal 1"
  ), P$1(
    e.privateAdd(
      w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      w("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null,
    "privateAdd: (n-3) + 3 should return null (result is zero mod n)"
  );
  const r = e.privateAdd(
    w("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
    w("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
  );
  P$1(
    r !== null && M(
      r,
      w("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    ),
    "privateAdd: known vector failed"
  ), P$1(
    M(
      e.privateNegate(
        w("0000000000000000000000000000000000000000000000000000000000000001")
      ),
      w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ),
    "privateNegate(1) should equal n-1"
  ), P$1(
    M(
      e.privateNegate(
        w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      ),
      w("0000000000000000000000000000000000000000000000000000000000000003")
    ),
    "privateNegate(n-3) should equal 3"
  ), P$1(
    M(
      e.privateNegate(
        w("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      ),
      w("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    ),
    "privateNegate known vector failed"
  ), P$1(
    M(
      e.pointCompress(
        w(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        true
      ),
      w("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress uncompressed->compressed failed"
  ), P$1(
    M(
      e.pointCompress(
        w(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        false
      ),
      w(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress uncompressed->uncompressed failed"
  ), P$1(
    M(
      e.pointCompress(
        w(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        true
      ),
      w("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress compressed->compressed failed"
  ), P$1(
    M(
      e.pointCompress(
        w(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        false
      ),
      w(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress compressed->uncompressed failed"
  );
  const n = e.pointFromScalar(
    w("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
  );
  P$1(
    n !== null && M(
      n,
      w("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    ),
    "pointFromScalar known vector failed"
  ), P$1(
    e.xOnlyPointAddTweak(
      w("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null,
    "xOnlyPointAddTweak should return null for infinity result"
  );
  let i = e.xOnlyPointAddTweak(
    w("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    w("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  P$1(
    i !== null && M(
      i.xOnlyPubkey,
      w("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && i.parity === 1,
    "xOnlyPointAddTweak parity=1 case failed"
  ), i = e.xOnlyPointAddTweak(
    w("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    w("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), P$1(
    i !== null && M(
      i.xOnlyPubkey,
      w("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && i.parity === 0,
    "xOnlyPointAddTweak parity=0 case failed"
  );
  const o = e.sign(
    w("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
    w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
  );
  if (P$1(
    M(
      o,
      w(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    ),
    "sign known vector failed"
  ), P$1(
    e.verify(
      w("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      w("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      o
    ),
    "verify known vector failed"
  ), e.signSchnorr) {
    const s = e.signSchnorr(
      w("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      w("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
      w("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
    );
    P$1(
      M(
        s,
        w(
          "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
        )
      ),
      "signSchnorr known vector failed"
    );
  }
  e.verifySchnorr && P$1(
    e.verifySchnorr(
      w(
        "7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"
      ),
      w(
        "dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"
      ),
      w(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    ),
    "verifySchnorr known vector failed"
  );
}

const browser$2 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    ECPairSigner: st,
    EC_N: Jt,
    EC_P: mr,
    LegacyBackend: wr,
    NobleBackend: gr,
    SATOSHI_MAX: Be,
    SignerCapability: lt,
    assertBytes32: Ae,
    assertMessageHash: un,
    assertPrivateKey: cn,
    assertPublicKey: an,
    assertXOnlyPublicKey: dn,
    bytesEqual: M,
    compareBytes: pr,
    concatBytes: nn,
    createBytes20: Or,
    createBytes32: Ar,
    createLegacyBackend: Tr,
    createMessageHash: Ur,
    createNobleBackend: Nr,
    createPrivateKey: zt,
    createPublicKey: ln,
    createSatoshi: Pr,
    createSchnorrSignature: Ir,
    createSignature: Rr,
    createXOnlyPublicKey: hn,
    decodeWIF: Hn,
    encodeWIF: Ln,
    fromHexInternal: en,
    isBytes20: xr,
    isBytes32: Er,
    isMessageHash: Sr,
    isPrivateKey: vr,
    isPublicKey: rn,
    isSatoshi: fn,
    isSchnorrSignature: sn,
    isSignature: on,
    isXOnlyPublicKey: Br,
    isZeroBytes: Lt,
    toHex: wt,
    verifyCryptoBackend: _r
}, Symbol.toStringTag, { value: 'Module' }));

class EccContext {
  static #instance;
  #lib;
  constructor(lib) {
    this.#lib = lib;
  }
  /**
   * The underlying ECC library instance.
   */
  get lib() {
    return this.#lib;
  }
  /**
   * Initializes the ECC context with the provided library.
   * The library is verified before being set as active.
   *
   * @param lib - The CryptoBackend instance to initialize
   * @returns The initialized EccContext instance
   * @throws Error if the CryptoBackend fails verification
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   * import { createNobleBackend } from '@btc-vision/ecpair';
   *
   * const context = EccContext.init(createNobleBackend());
   * ```
   */
  static init(lib) {
    if (EccContext.#instance && EccContext.#instance.#lib === lib) {
      return EccContext.#instance;
    }
    _r(lib);
    EccContext.#instance = new EccContext(lib);
    return EccContext.#instance;
  }
  /**
   * Gets the initialized ECC context.
   *
   * @returns The EccContext instance
   * @throws Error if the context has not been initialized
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * const context = EccContext.get();
   * const tweaked = context.lib.xOnlyPointAddTweak(key, tweak);
   * ```
   */
  static get() {
    if (!EccContext.#instance) {
      throw new Error("ECC library not initialized. Call EccContext.init() or initEccLib() first.");
    }
    return EccContext.#instance;
  }
  /**
   * Clears the ECC context.
   * Useful for testing or when reinitializing with a different library.
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * EccContext.clear();
   * // Context is now uninitialized
   * ```
   */
  static clear() {
    EccContext.#instance = void 0;
  }
  /**
   * Checks if the ECC context has been initialized.
   *
   * @returns True if initialized
   *
   * @example
   * ```typescript
   * import { EccContext } from '@btc-vision/bitcoin';
   *
   * if (!EccContext.isInitialized()) {
   *     EccContext.init(createNobleBackend());
   * }
   * ```
   */
  static isInitialized() {
    return EccContext.#instance !== void 0;
  }
}
function initEccLib(eccLib) {
  if (eccLib === void 0) {
    EccContext.clear();
    return;
  }
  EccContext.init(eccLib);
}
function getEccLib() {
  return EccContext.get().lib;
}

const LEAF_VERSION_TAPSCRIPT = 0xc0;
const MAX_TAPTREE_DEPTH = 128;
const isHashBranch = (ht) => 'left' in ht && 'right' in ht;
/**
 * Calculates the root hash from a given control block and leaf hash.
 * @param controlBlock - The control block.
 * @param leafHash - The leaf hash.
 * @returns The root hash.
 * @throws {TypeError} If the control block length is less than 33.
 */
function rootHashFromPath(controlBlock, leafHash) {
    if (controlBlock.length < 33)
        throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 33.`);
    const m = (controlBlock.length - 33) / 32;
    let kj = leafHash;
    for (let j = 0; j < m; j++) {
        const ej = controlBlock.subarray(33 + 32 * j, 65 + 32 * j);
        if (compare$2(kj, ej) < 0) {
            kj = tapBranchHash(kj, ej);
        }
        else {
            kj = tapBranchHash(ej, kj);
        }
    }
    return kj;
}
/**
 * Calculates the root hash from a P2MR control block and leaf hash.
 * P2MR control blocks have no internal pubkey, so the merkle path starts at offset 1.
 * @param controlBlock - The P2MR control block: [control_byte (1)] [merkle_path (32*m)]
 * @param leafHash - The leaf hash.
 * @returns The root hash.
 * @throws {TypeError} If the control block length is less than 1.
 */
function rootHashFromPathP2MR(controlBlock, leafHash) {
    if (controlBlock.length < 1)
        throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 1.`);
    const m = (controlBlock.length - 1) / 32;
    let kj = leafHash;
    for (let j = 0; j < m; j++) {
        const ej = controlBlock.subarray(1 + 32 * j, 33 + 32 * j);
        if (compare$2(kj, ej) < 0) {
            kj = tapBranchHash(kj, ej);
        }
        else {
            kj = tapBranchHash(ej, kj);
        }
    }
    return kj;
}
/**
 * Build a hash tree of merkle nodes from the scripts binary tree.
 * @param scriptTree - the tree of scripts to pairwise hash.
 */
function toHashTree(scriptTree) {
    if (isTapleaf(scriptTree))
        return { hash: tapleafHash(scriptTree) };
    const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
    hashes.sort((a, b) => compare$2(a.hash, b.hash));
    const left = hashes[0];
    const right = hashes[1];
    return {
        hash: tapBranchHash(left.hash, right.hash),
        left,
        right,
    };
}
/**
 * Given a HashTree, finds the path from a particular hash to the root.
 * @param node - the root of the tree
 * @param hash - the hash to search for
 * @returns - array of sibling hashes, from leaf (inclusive) to root
 * (exclusive) needed to prove inclusion of the specified hash. undefined if no
 * path is found
 */
function findScriptPath(node, hash) {
    if (isHashBranch(node)) {
        const leftPath = findScriptPath(node.left, hash);
        if (leftPath !== undefined)
            return [...leftPath, node.right.hash];
        const rightPath = findScriptPath(node.right, hash);
        if (rightPath !== undefined)
            return [...rightPath, node.left.hash];
    }
    else if (equals(node.hash, hash)) {
        return [];
    }
    return undefined;
}
function tapleafHash(leaf) {
    const version = leaf.version || LEAF_VERSION_TAPSCRIPT;
    return taggedHash('TapLeaf', concat$1([new Uint8Array([version]), serializeScript(leaf.output)]));
}
function tapTweakHash$1(pubKey, h) {
    return taggedHash('TapTweak', h ? concat$1([pubKey, h]) : pubKey);
}
function tweakKey(pubKey, h) {
    if (!(pubKey instanceof Uint8Array))
        return null;
    if (pubKey.length !== 32)
        return null;
    if (h && h.length !== 32)
        return null;
    const tweakHash = tapTweakHash$1(pubKey, h);
    const res = getEccLib().xOnlyPointAddTweak(pubKey, tweakHash);
    if (!res || res.xOnlyPubkey === null)
        return null;
    return {
        parity: res.parity,
        x: new Uint8Array(res.xOnlyPubkey),
    };
}
/**
 * Computes the TapBranch tagged hash of two child hashes.
 *
 * @param a - First child hash (left branch).
 * @param b - Second child hash (right branch).
 * @returns The 32-byte TapBranch hash.
 */
function tapBranchHash(a, b) {
    return taggedHash('TapBranch', concat$1([a, b]));
}
function serializeScript(s) {
    const varintLen = encodingLength$1(s.length);
    const buffer = alloc(varintLen);
    encode$k(s.length, buffer);
    return concat$1([buffer, s]);
}

/**
 * Pay-to-Merkle-Root (P2MR) payment class.
 *
 * P2MR is a SegWit version 2 output type (BIP 360). It commits directly to
 * the Merkle root of a script tree, removing the quantum-vulnerable key-path
 * spend found in P2TR. There is no internal pubkey or tweaking.
 *
 * @packageDocumentation
 */
const OPS$6 = opcodes;
const P2MR_WITNESS_VERSION = 0x02;
const ANNEX_PREFIX$1 = 0x50;
/**
 * Pay-to-Merkle-Root (P2MR) payment class.
 *
 * Creates locking scripts of the form: `OP_2 {32-byte merkle root}`
 *
 * Script-path spending witness: `[script inputs..., script, control block]`
 *
 * @example
 * ```typescript
 * import { P2MR } from '@btc-vision/bitcoin';
 *
 * // From script tree
 * const p2mr = P2MR.fromScriptTree(scriptTree);
 * console.log(p2mr.address); // bc1z... address
 *
 * // From merkle root hash
 * const fromHash = P2MR.fromHash(merkleRoot);
 *
 * // Decode an existing output
 * const decoded = P2MR.fromOutput(scriptPubKey);
 * console.log(decoded.hash); // 32-byte merkle root
 * ```
 */
class P2MR {
    static NAME = PaymentType.P2MR;
    #network;
    #opts;
    #inputAddress;
    #inputHash;
    #inputScriptTree;
    #inputOutput;
    #inputWitness;
    #inputRedeem;
    #inputRedeemVersion;
    #address;
    #hash;
    #output;
    #redeem;
    #redeemVersion;
    #witness;
    #addressComputed = false;
    #hashComputed = false;
    #outputComputed = false;
    #redeemComputed = false;
    #redeemVersionComputed = false;
    #witnessComputed = false;
    #decodedAddress;
    #decodedAddressComputed = false;
    #witnessWithoutAnnex;
    #witnessWithoutAnnexComputed = false;
    #hashTree;
    #hashTreeComputed = false;
    /**
     * Creates a new P2MR payment instance.
     *
     * @param params - Payment parameters
     * @param params.address - Bech32m encoded address (bc1z...)
     * @param params.hash - Merkle root (32 bytes, = witness program)
     * @param params.scriptTree - Full script tree definition
     * @param params.output - The scriptPubKey
     * @param params.witness - The witness stack
     * @param params.redeem - Redeem script for script-path spending
     * @param params.redeemVersion - Leaf version (defaults to LEAF_VERSION_TAPSCRIPT)
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        this.#network = params.network ?? bitcoin$1;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputAddress = params.address;
        this.#inputHash = params.hash;
        this.#inputScriptTree = params.scriptTree;
        this.#inputOutput = params.output;
        this.#inputWitness = params.witness;
        this.#inputRedeem = params.redeem;
        this.#inputRedeemVersion = params.redeemVersion;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    /**
     * Payment type discriminant.
     *
     * @returns The P2MR payment type constant.
     */
    get name() {
        return PaymentType.P2MR;
    }
    /**
     * Network parameters used for address encoding.
     *
     * @returns The network configuration (mainnet, testnet, or regtest).
     */
    get network() {
        return this.#network;
    }
    /**
     * Bech32m encoded address (bc1z... for mainnet).
     *
     * @returns The bech32m-encoded address, or `undefined` if insufficient data.
     */
    get address() {
        if (!this.#addressComputed) {
            this.#address = this.#computeAddress();
            this.#addressComputed = true;
        }
        return this.#address;
    }
    /**
     * Merkle root hash (32 bytes). This is the witness program and directly
     * appears in the output script.
     *
     * @returns The 32-byte merkle root, or `undefined` if insufficient data.
     */
    get hash() {
        if (!this.#hashComputed) {
            this.#hash = this.#computeHash();
            this.#hashComputed = true;
        }
        return this.#hash;
    }
    /**
     * The scriptPubKey: `OP_2 <32-byte merkle root>` (34 bytes total).
     *
     * @returns The output script, or `undefined` if insufficient data.
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    /**
     * Redeem script information for script-path spending.
     *
     * @returns The redeem script data, or `undefined` if not available.
     */
    get redeem() {
        if (!this.#redeemComputed) {
            this.#redeem = this.#computeRedeem();
            this.#redeemComputed = true;
        }
        return this.#redeem;
    }
    /**
     * Leaf version used for script-path hashing.
     *
     * @returns The leaf version byte (defaults to LEAF_VERSION_TAPSCRIPT = 0xc0).
     */
    get redeemVersion() {
        if (!this.#redeemVersionComputed) {
            this.#redeemVersion = this.#computeRedeemVersion();
            this.#redeemVersionComputed = true;
        }
        return this.#redeemVersion ?? LEAF_VERSION_TAPSCRIPT;
    }
    /**
     * Witness stack for script-path spending.
     * Format: `[script inputs..., script, control block]`
     *
     * @returns The witness stack array, or `undefined` if insufficient data.
     */
    get witness() {
        if (!this.#witnessComputed) {
            this.#witness = this.#computeWitness();
            this.#witnessComputed = true;
        }
        return this.#witness;
    }
    /**
     * Creates a P2MR payment from a script tree.
     *
     * @param scriptTree - The script tree
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2MR payment instance
     */
    static fromScriptTree(scriptTree, network) {
        return new P2MR({ scriptTree, network });
    }
    /**
     * Creates a P2MR payment from a bech32m address.
     *
     * @param address - Bech32m encoded address (bc1z...)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2MR payment instance
     */
    static fromAddress(address, network) {
        return new P2MR({ address, network });
    }
    /**
     * Creates a P2MR payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2MR payment instance
     */
    static fromOutput(output, network) {
        return new P2MR({ output, network });
    }
    /**
     * Creates a P2MR payment from a merkle root hash.
     *
     * @param hash - The 32-byte merkle root
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2MR payment instance
     */
    static fromHash(hash, network) {
        return new P2MR({ hash, network });
    }
    /**
     * Converts to a plain P2MRPayment object for backwards compatibility.
     *
     * @returns A P2MRPayment object
     */
    toPayment() {
        return {
            name: this.name,
            network: this.network,
            address: this.address,
            hash: this.hash,
            scriptTree: this.#inputScriptTree,
            output: this.output,
            redeem: this.redeem,
            redeemVersion: this.redeemVersion,
            witness: this.witness,
        };
    }
    #getDecodedAddress() {
        if (!this.#decodedAddressComputed) {
            if (this.#inputAddress) {
                const decoded = fromBech32(this.#inputAddress);
                if (decoded) {
                    this.#decodedAddress = {
                        version: decoded.version,
                        prefix: decoded.prefix,
                        data: decoded.data,
                    };
                }
            }
            this.#decodedAddressComputed = true;
        }
        return this.#decodedAddress;
    }
    #getWitnessWithoutAnnex() {
        if (!this.#witnessWithoutAnnexComputed) {
            if (this.#inputWitness && this.#inputWitness.length > 0) {
                // Remove annex if present
                const lastWitness = this.#inputWitness[this.#inputWitness.length - 1];
                if (this.#inputWitness.length >= 2 &&
                    lastWitness && lastWitness[0] === ANNEX_PREFIX$1) {
                    this.#witnessWithoutAnnex = this.#inputWitness.slice(0, -1);
                }
                else {
                    this.#witnessWithoutAnnex = this.#inputWitness.slice();
                }
            }
            this.#witnessWithoutAnnexComputed = true;
        }
        return this.#witnessWithoutAnnex;
    }
    #getHashTree() {
        if (!this.#hashTreeComputed) {
            if (this.#inputScriptTree) {
                this.#hashTree = toHashTree(this.#inputScriptTree);
            }
            else if (this.#inputHash) {
                this.#hashTree = { hash: this.#inputHash };
            }
            this.#hashTreeComputed = true;
        }
        return this.#hashTree;
    }
    #computeAddress() {
        if (this.#inputAddress) {
            return this.#inputAddress;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        const words = distExports.bech32m.toWords(h);
        words.unshift(P2MR_WITNESS_VERSION);
        return distExports.bech32m.encode(this.#network.bech32, words);
    }
    #computeHash() {
        if (this.#inputHash) {
            return this.#inputHash;
        }
        const hashTree = this.#getHashTree();
        if (hashTree) {
            return hashTree.hash;
        }
        if (this.#inputOutput) {
            return this.#inputOutput.subarray(2);
        }
        if (this.#inputAddress) {
            return this.#getDecodedAddress()?.data;
        }
        const w = this.#getWitnessWithoutAnnex();
        if (w && w.length > 1) {
            const controlBlock = w[w.length - 1];
            const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;
            const script = w[w.length - 2];
            const leafHash = tapleafHash({
                output: script,
                version: leafVersion,
            });
            return rootHashFromPathP2MR(controlBlock, leafHash);
        }
        return undefined;
    }
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        return compile([OPS$6.OP_2, h]);
    }
    #computeRedeem() {
        if (this.#inputRedeem) {
            return this.#inputRedeem;
        }
        const witness = this.#getWitnessWithoutAnnex();
        if (!witness || witness.length < 2) {
            return undefined;
        }
        const lastWitness = witness[witness.length - 1];
        return {
            output: witness[witness.length - 2],
            witness: witness.slice(0, -2),
            redeemVersion: lastWitness[0] & TAPLEAF_VERSION_MASK,
        };
    }
    #computeRedeemVersion() {
        if (this.#inputRedeemVersion !== undefined) {
            return this.#inputRedeemVersion;
        }
        if (this.#inputRedeem &&
            this.#inputRedeem.redeemVersion !== undefined &&
            this.#inputRedeem.redeemVersion !== null) {
            return this.#inputRedeem.redeemVersion;
        }
        return LEAF_VERSION_TAPSCRIPT;
    }
    #computeWitness() {
        if (this.#inputWitness) {
            return this.#inputWitness;
        }
        const hashTree = this.#getHashTree();
        if (hashTree && this.#inputRedeem?.output) {
            const leafHash = tapleafHash({
                output: this.#inputRedeem.output,
                version: this.redeemVersion,
            });
            const path = findScriptPath(hashTree, leafHash);
            if (!path)
                return undefined;
            const version = this.redeemVersion ?? 0xc0;
            // P2MR control block: [version | 0x01, ...merklePath]
            // Parity bit is always 1, no internal pubkey
            const controlBlock = concat$1([
                new Uint8Array([version | 0x01]),
                ...path,
            ]);
            return [this.#inputRedeem.output, controlBlock];
        }
        return undefined;
    }
    #validate() {
        let knownHash = new Uint8Array(0);
        if (this.#inputAddress) {
            const addr = this.#getDecodedAddress();
            if (!addr) {
                throw new TypeError('Invalid address');
            }
            if (this.#network && this.#network.bech32 !== addr.prefix) {
                throw new TypeError('Invalid prefix or Network mismatch');
            }
            if (addr.version !== P2MR_WITNESS_VERSION) {
                throw new TypeError('Invalid address version');
            }
            if (addr.data.length !== 32) {
                throw new TypeError('Invalid address data');
            }
            knownHash = addr.data;
        }
        if (this.#inputOutput) {
            if (this.#inputOutput.length !== 34 ||
                this.#inputOutput[0] !== OPS$6.OP_2 ||
                this.#inputOutput[1] !== 0x20) {
                throw new TypeError('Output is invalid');
            }
            if (knownHash.length > 0 && !equals(knownHash, this.#inputOutput.subarray(2))) {
                throw new TypeError('Hash mismatch');
            }
            else {
                knownHash = this.#inputOutput.subarray(2);
            }
        }
        if (this.#inputHash) {
            if (this.#inputHash.length !== 32) {
                throw new TypeError('Invalid hash length');
            }
            if (knownHash.length > 0 && !equals(knownHash, this.#inputHash)) {
                throw new TypeError('Hash mismatch');
            }
        }
        const hashTree = this.#getHashTree();
        if (this.#inputHash && hashTree) {
            if (!equals(this.#inputHash, hashTree.hash)) {
                throw new TypeError('Hash mismatch');
            }
        }
        if (this.#inputRedeem?.output && hashTree) {
            const leafHash = tapleafHash({
                output: this.#inputRedeem.output,
                version: this.redeemVersion,
            });
            if (!findScriptPath(hashTree, leafHash)) {
                throw new TypeError('Redeem script not in tree');
            }
        }
        const witness = this.#getWitnessWithoutAnnex();
        // Compare provided redeem with computed from witness
        if (this.#inputRedeem && this.redeem) {
            if (this.#inputRedeem.redeemVersion) {
                if (this.#inputRedeem.redeemVersion !== this.redeem.redeemVersion) {
                    throw new TypeError('Redeem.redeemVersion and witness mismatch');
                }
            }
            if (this.#inputRedeem.output) {
                const decompiled = decompile(this.#inputRedeem.output);
                if (!decompiled || decompiled.length === 0) {
                    throw new TypeError('Redeem.output is invalid');
                }
                if (this.redeem.output && !equals(this.#inputRedeem.output, this.redeem.output)) {
                    throw new TypeError('Redeem.output and witness mismatch');
                }
            }
            if (this.#inputRedeem.witness) {
                if (this.redeem.witness &&
                    !stacksEqual(this.#inputRedeem.witness, this.redeem.witness)) {
                    throw new TypeError('Redeem.witness and witness mismatch');
                }
            }
        }
        if (witness && witness.length > 0) {
            // P2MR only supports script-path spending (no key-path)
            if (witness.length < 2) {
                throw new TypeError('P2MR requires at least 2 witness items (script + control block)');
            }
            const controlBlock = witness[witness.length - 1];
            if (controlBlock.length < 1) {
                throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 1.`);
            }
            if ((controlBlock.length - 1) % 32 !== 0) {
                throw new TypeError(`The control-block length of ${controlBlock.length} is incorrect!`);
            }
            const m = (controlBlock.length - 1) / 32;
            if (m > 128) {
                throw new TypeError(`The script path is too long. Got ${m}, expected max 128.`);
            }
            const controlBlockFirstByte = controlBlock[0];
            // P2MR parity bit must be 1
            if ((controlBlockFirstByte & 1) !== 1) {
                throw new TypeError('P2MR control byte parity bit must be 1');
            }
            const leafVersion = controlBlockFirstByte & TAPLEAF_VERSION_MASK;
            const script = witness[witness.length - 2];
            const leafHash = tapleafHash({
                output: script,
                version: leafVersion,
            });
            const computedHash = rootHashFromPathP2MR(controlBlock, leafHash);
            // Verify merkle root matches the witness program
            if (knownHash.length > 0 && !equals(knownHash, computedHash)) {
                throw new TypeError('Merkle root mismatch for p2mr witness');
            }
        }
    }
}
/**
 * Creates a Pay-to-Merkle-Root (P2MR) payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the P2MR class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The P2MR payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2mr } from '@btc-vision/bitcoin';
 *
 * // From script tree
 * const payment = p2mr({ scriptTree });
 *
 * // From merkle root hash
 * const fromHash = p2mr({ hash: merkleRoot });
 * ```
 */
function p2mr(a, opts) {
    if (!a.address &&
        !a.output &&
        !a.hash &&
        !a.scriptTree &&
        !(a.witness && a.witness.length > 1)) {
        throw new TypeError('Not enough data');
    }
    const instance = new P2MR({
        address: a.address,
        hash: a.hash,
        scriptTree: a.scriptTree,
        output: a.output,
        witness: a.witness,
        redeem: a.redeem,
        redeemVersion: a.redeemVersion,
        network: a.network,
    }, opts);
    // Return a merged object for backwards compatibility
    return Object.assign(instance.toPayment(), a);
}

/**
 * Pay-to-Taproot (P2TR) payment class.
 *
 * P2TR is the Taproot output type (BIP341). It supports both key-path spending
 * (single signature) and script-path spending (merkle tree of scripts).
 *
 * @packageDocumentation
 */
const OPS$5 = opcodes;
const TAPROOT_WITNESS_VERSION = 0x01;
const ANNEX_PREFIX = 0x50;
/**
 * Pay-to-Taproot (P2TR) payment class.
 *
 * Creates locking scripts of the form: `OP_1 {x-only pubkey}`
 *
 * Key-path spending witness: `[signature]`
 * Script-path spending witness: `[script inputs..., script, control block]`
 *
 * @example
 * ```typescript
 * import { P2TR } from '@btc-vision/bitcoin';
 *
 * // Key-path only (no scripts)
 * const keyOnly = P2TR.fromInternalPubkey(internalPubkey);
 * console.log(keyOnly.address); // bc1p... address
 *
 * // With script tree
 * const withScripts = P2TR.fromInternalPubkey(internalPubkey, scriptTree);
 *
 * // Decode an existing output
 * const decoded = P2TR.fromOutput(scriptPubKey);
 * console.log(decoded.pubkey); // 32-byte x-only pubkey
 * ```
 */
class P2TR {
    // Static public fields
    static NAME = PaymentType.P2TR;
    // Private instance fields
    #network;
    #opts;
    // Input data (provided by user)
    #inputAddress;
    #inputPubkey;
    #inputInternalPubkey;
    #inputHash;
    #inputScriptTree;
    #inputSignature;
    #inputOutput;
    #inputWitness;
    #inputRedeem;
    #inputRedeemVersion;
    // Cached computed values
    #address;
    #pubkey;
    #internalPubkey;
    #hash;
    #signature;
    #output;
    #redeem;
    #redeemVersion;
    #witness;
    // Cache flags
    #addressComputed = false;
    #pubkeyComputed = false;
    #internalPubkeyComputed = false;
    #hashComputed = false;
    #signatureComputed = false;
    #outputComputed = false;
    #redeemComputed = false;
    #redeemVersionComputed = false;
    #witnessComputed = false;
    // Decoded address cache
    #decodedAddress;
    #decodedAddressComputed = false;
    // Witness without annex
    #witnessWithoutAnnex;
    #witnessWithoutAnnexComputed = false;
    // Hash tree cache
    #hashTree;
    #hashTreeComputed = false;
    /**
     * Creates a new P2TR payment instance.
     *
     * @param params - Payment parameters
     * @param params.address - Bech32m encoded address (bc1p...)
     * @param params.pubkey - x-only output pubkey (32 bytes)
     * @param params.internalPubkey - x-only internal pubkey (32 bytes)
     * @param params.hash - Merkle root (32 bytes, or empty for key-path only)
     * @param params.scriptTree - Full script tree definition
     * @param params.signature - Schnorr signature (for key-path spending)
     * @param params.output - The scriptPubKey
     * @param params.witness - The witness stack
     * @param params.redeem - Redeem script for script-path spending
     * @param params.redeemVersion - Leaf version (defaults to LEAF_VERSION_TAPSCRIPT)
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        this.#network = params.network ?? bitcoin$1;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputAddress = params.address;
        this.#inputPubkey = params.pubkey;
        this.#inputInternalPubkey = params.internalPubkey;
        this.#inputHash = params.hash;
        this.#inputScriptTree = params.scriptTree;
        this.#inputSignature = params.signature;
        this.#inputOutput = params.output;
        this.#inputWitness = params.witness;
        this.#inputRedeem = params.redeem;
        this.#inputRedeemVersion = params.redeemVersion;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    // Public getters
    /**
     * Payment type discriminant.
     */
    get name() {
        return PaymentType.P2TR;
    }
    /**
     * Network parameters.
     */
    get network() {
        return this.#network;
    }
    /**
     * Bech32m encoded address (bc1p... for mainnet).
     */
    get address() {
        if (!this.#addressComputed) {
            this.#address = this.#computeAddress();
            this.#addressComputed = true;
        }
        return this.#address;
    }
    /**
     * x-only output pubkey (32 bytes).
     * This is the tweaked pubkey that appears in the output.
     */
    get pubkey() {
        if (!this.#pubkeyComputed) {
            this.#pubkey = this.#computePubkey();
            this.#pubkeyComputed = true;
        }
        return this.#pubkey;
    }
    /**
     * x-only internal pubkey (32 bytes).
     * This is the untweaked pubkey before adding the merkle root tweak.
     */
    get internalPubkey() {
        if (!this.#internalPubkeyComputed) {
            this.#internalPubkey = this.#computeInternalPubkey();
            this.#internalPubkeyComputed = true;
        }
        return this.#internalPubkey;
    }
    /**
     * Merkle root hash (32 bytes).
     * Present when a script tree is defined.
     */
    get hash() {
        if (!this.#hashComputed) {
            this.#hash = this.#computeHash();
            this.#hashComputed = true;
        }
        return this.#hash;
    }
    /**
     * Schnorr signature (for key-path spending).
     */
    get signature() {
        if (!this.#signatureComputed) {
            this.#signature = this.#computeSignature();
            this.#signatureComputed = true;
        }
        return this.#signature;
    }
    /**
     * The scriptPubKey: `OP_1 {32-byte x-only pubkey}`
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    /**
     * Redeem script information (for script-path spending).
     */
    get redeem() {
        if (!this.#redeemComputed) {
            this.#redeem = this.#computeRedeem();
            this.#redeemComputed = true;
        }
        return this.#redeem;
    }
    /**
     * Leaf version (defaults to LEAF_VERSION_TAPSCRIPT = 0xc0).
     */
    get redeemVersion() {
        if (!this.#redeemVersionComputed) {
            this.#redeemVersion = this.#computeRedeemVersion();
            this.#redeemVersionComputed = true;
        }
        return this.#redeemVersion ?? LEAF_VERSION_TAPSCRIPT;
    }
    /**
     * Witness stack.
     * Key-path: `[signature]`
     * Script-path: `[script inputs..., script, control block]`
     */
    get witness() {
        if (!this.#witnessComputed) {
            this.#witness = this.#computeWitness();
            this.#witnessComputed = true;
        }
        return this.#witness;
    }
    // Static factory methods
    /**
     * Creates a P2TR payment from an internal pubkey (key-path only).
     *
     * @param internalPubkey - x-only internal pubkey (32 bytes)
     * @param scriptTree - Optional script tree
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2TR payment instance
     *
     * @example
     * ```typescript
     * // Key-path only
     * const p2tr = P2TR.fromInternalPubkey(internalPubkey);
     *
     * // With script tree
     * const withScripts = P2TR.fromInternalPubkey(internalPubkey, scriptTree);
     * ```
     */
    static fromInternalPubkey(internalPubkey, scriptTree, network) {
        return new P2TR({ internalPubkey, scriptTree, network });
    }
    /**
     * Creates a P2TR payment from a bech32m address.
     *
     * @param address - Bech32m encoded address (bc1p...)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2TR payment instance
     */
    static fromAddress(address, network) {
        return new P2TR({ address, network });
    }
    /**
     * Creates a P2TR payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2TR payment instance
     */
    static fromOutput(output, network) {
        return new P2TR({ output, network });
    }
    /**
     * Creates a P2TR payment from a signature (for key-path spending).
     *
     * @param signature - Schnorr signature
     * @param internalPubkey - x-only internal pubkey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2TR payment instance
     */
    static fromSignature(signature, internalPubkey, network) {
        return new P2TR({ signature, internalPubkey, network });
    }
    // Private helper methods
    /**
     * Converts to a plain P2TRPayment object for backwards compatibility.
     *
     * @returns A P2TRPayment object
     */
    toPayment() {
        return {
            name: this.name,
            network: this.network,
            address: this.address,
            pubkey: this.pubkey,
            internalPubkey: this.internalPubkey,
            hash: this.hash,
            scriptTree: this.#inputScriptTree,
            signature: this.signature,
            output: this.output,
            redeem: this.redeem,
            redeemVersion: this.redeemVersion,
            witness: this.witness,
        };
    }
    #getDecodedAddress() {
        if (!this.#decodedAddressComputed) {
            if (this.#inputAddress) {
                const decoded = fromBech32(this.#inputAddress);
                if (decoded) {
                    this.#decodedAddress = {
                        version: decoded.version,
                        prefix: decoded.prefix,
                        data: decoded.data,
                    };
                }
            }
            this.#decodedAddressComputed = true;
        }
        return this.#decodedAddress;
    }
    #getWitnessWithoutAnnex() {
        if (!this.#witnessWithoutAnnexComputed) {
            if (this.#inputWitness && this.#inputWitness.length > 0) {
                // Remove annex if present
                const lastWitness = this.#inputWitness[this.#inputWitness.length - 1];
                if (this.#inputWitness.length >= 2 &&
                    lastWitness && lastWitness[0] === ANNEX_PREFIX) {
                    this.#witnessWithoutAnnex = this.#inputWitness.slice(0, -1);
                }
                else {
                    this.#witnessWithoutAnnex = this.#inputWitness.slice();
                }
            }
            this.#witnessWithoutAnnexComputed = true;
        }
        return this.#witnessWithoutAnnex;
    }
    // Private computation methods
    #getHashTree() {
        if (!this.#hashTreeComputed) {
            if (this.#inputScriptTree) {
                this.#hashTree = toHashTree(this.#inputScriptTree);
            }
            else if (this.#inputHash) {
                this.#hashTree = { hash: this.#inputHash };
            }
            this.#hashTreeComputed = true;
        }
        return this.#hashTree;
    }
    #computeAddress() {
        if (this.#inputAddress) {
            return this.#inputAddress;
        }
        const pk = this.pubkey;
        if (!pk)
            return undefined;
        const words = distExports.bech32m.toWords(pk);
        words.unshift(TAPROOT_WITNESS_VERSION);
        return distExports.bech32m.encode(this.#network.bech32, words);
    }
    #computePubkey() {
        if (this.#inputPubkey) {
            return this.#inputPubkey;
        }
        if (this.#inputOutput) {
            return this.#inputOutput.subarray(2);
        }
        if (this.#inputAddress) {
            return this.#getDecodedAddress()?.data;
        }
        const internalPk = this.internalPubkey;
        if (internalPk) {
            const tweakedKey = tweakKey(internalPk, this.hash);
            if (tweakedKey) {
                return tweakedKey.x;
            }
        }
        return undefined;
    }
    #computeInternalPubkey() {
        if (this.#inputInternalPubkey) {
            return this.#inputInternalPubkey;
        }
        const witness = this.#getWitnessWithoutAnnex();
        if (witness && witness.length > 1) {
            const lastWitness = witness[witness.length - 1];
            if (lastWitness) {
                return lastWitness.subarray(1, 33);
            }
        }
        return undefined;
    }
    #computeHash() {
        const hashTree = this.#getHashTree();
        if (hashTree) {
            return hashTree.hash;
        }
        const w = this.#getWitnessWithoutAnnex();
        if (w && w.length > 1) {
            const controlBlock = w[w.length - 1];
            const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;
            const script = w[w.length - 2];
            const leafHash = tapleafHash({
                output: script,
                version: leafVersion,
            });
            return rootHashFromPath(controlBlock, leafHash);
        }
        return undefined;
    }
    #computeSignature() {
        if (this.#inputSignature) {
            return this.#inputSignature;
        }
        const witness = this.#getWitnessWithoutAnnex();
        if (witness && witness.length === 1) {
            return witness[0];
        }
        return undefined;
    }
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        const pk = this.pubkey;
        if (!pk)
            return undefined;
        return compile([OPS$5.OP_1, pk]);
    }
    #computeRedeem() {
        if (this.#inputRedeem) {
            return this.#inputRedeem;
        }
        const witness = this.#getWitnessWithoutAnnex();
        if (!witness || witness.length < 2) {
            return undefined;
        }
        const lastWitness = witness[witness.length - 1];
        return {
            output: witness[witness.length - 2],
            witness: witness.slice(0, -2),
            redeemVersion: lastWitness[0] & TAPLEAF_VERSION_MASK,
        };
    }
    #computeRedeemVersion() {
        if (this.#inputRedeemVersion !== undefined) {
            return this.#inputRedeemVersion;
        }
        if (this.#inputRedeem &&
            this.#inputRedeem.redeemVersion !== undefined &&
            this.#inputRedeem.redeemVersion !== null) {
            return this.#inputRedeem.redeemVersion;
        }
        return LEAF_VERSION_TAPSCRIPT;
    }
    // Validation
    #computeWitness() {
        if (this.#inputWitness) {
            return this.#inputWitness;
        }
        const hashTree = this.#getHashTree();
        if (hashTree && this.#inputRedeem?.output && this.#inputInternalPubkey) {
            const leafHash = tapleafHash({
                output: this.#inputRedeem.output,
                version: this.redeemVersion,
            });
            const path = findScriptPath(hashTree, leafHash);
            if (!path)
                return undefined;
            const outputKey = tweakKey(this.#inputInternalPubkey, hashTree.hash);
            if (!outputKey)
                return undefined;
            const version = this.redeemVersion ?? 0xc0;
            const controlBlock = concat$1([
                new Uint8Array([version | outputKey.parity]),
                this.#inputInternalPubkey,
                ...path,
            ]);
            return [this.#inputRedeem.output, controlBlock];
        }
        if (this.#inputSignature) {
            return [this.#inputSignature];
        }
        return undefined;
    }
    #validate() {
        let pubkey = new Uint8Array(0);
        if (this.#inputAddress) {
            const addr = this.#getDecodedAddress();
            if (!addr) {
                throw new TypeError('Invalid address');
            }
            if (this.#network && this.#network.bech32 !== addr.prefix) {
                throw new TypeError('Invalid prefix or Network mismatch');
            }
            if (addr.version !== TAPROOT_WITNESS_VERSION) {
                throw new TypeError('Invalid address version');
            }
            if (addr.data.length !== 32) {
                throw new TypeError('Invalid address data');
            }
            pubkey = addr.data;
        }
        if (this.#inputPubkey) {
            if (pubkey.length > 0 && !equals(pubkey, this.#inputPubkey)) {
                throw new TypeError('Pubkey mismatch');
            }
            else {
                pubkey = this.#inputPubkey;
            }
        }
        if (this.#inputOutput) {
            if (this.#inputOutput.length !== 34 ||
                this.#inputOutput[0] !== OPS$5.OP_1 ||
                this.#inputOutput[1] !== 0x20) {
                throw new TypeError('Output is invalid');
            }
            if (pubkey.length > 0 && !equals(pubkey, this.#inputOutput.subarray(2))) {
                throw new TypeError('Pubkey mismatch');
            }
            else {
                pubkey = this.#inputOutput.subarray(2);
            }
        }
        if (this.#inputInternalPubkey) {
            const tweakedKey = tweakKey(this.#inputInternalPubkey, this.hash);
            if (!tweakedKey) {
                throw new TypeError('Invalid internal pubkey');
            }
            if (pubkey.length > 0 && !equals(pubkey, tweakedKey.x)) {
                throw new TypeError('Pubkey mismatch');
            }
            else {
                pubkey = tweakedKey.x;
            }
        }
        const hashTree = this.#getHashTree();
        if (this.#inputHash && hashTree) {
            if (!equals(this.#inputHash, hashTree.hash)) {
                throw new TypeError('Hash mismatch');
            }
        }
        if (this.#inputRedeem?.output && hashTree) {
            const leafHash = tapleafHash({
                output: this.#inputRedeem.output,
                version: this.redeemVersion,
            });
            if (!findScriptPath(hashTree, leafHash)) {
                throw new TypeError('Redeem script not in tree');
            }
        }
        const witness = this.#getWitnessWithoutAnnex();
        // Compare provided redeem with computed from witness
        if (this.#inputRedeem && this.redeem) {
            if (this.#inputRedeem.redeemVersion) {
                if (this.#inputRedeem.redeemVersion !== this.redeem.redeemVersion) {
                    throw new TypeError('Redeem.redeemVersion and witness mismatch');
                }
            }
            if (this.#inputRedeem.output) {
                const decompiled = decompile(this.#inputRedeem.output);
                if (!decompiled || decompiled.length === 0) {
                    throw new TypeError('Redeem.output is invalid');
                }
                if (this.redeem.output && !equals(this.#inputRedeem.output, this.redeem.output)) {
                    throw new TypeError('Redeem.output and witness mismatch');
                }
            }
            if (this.#inputRedeem.witness) {
                if (this.redeem.witness &&
                    !stacksEqual(this.#inputRedeem.witness, this.redeem.witness)) {
                    throw new TypeError('Redeem.witness and witness mismatch');
                }
            }
        }
        if (witness && witness.length > 0) {
            if (witness.length === 1) {
                // Key-path spending
                const firstWitness = witness[0];
                if (this.#inputSignature && !equals(this.#inputSignature, firstWitness)) {
                    throw new TypeError('Signature mismatch');
                }
            }
            else {
                // Script-path spending
                const controlBlock = witness[witness.length - 1];
                if (controlBlock.length < 33) {
                    throw new TypeError(`The control-block length is too small. Got ${controlBlock.length}, expected min 33.`);
                }
                if ((controlBlock.length - 33) % 32 !== 0) {
                    throw new TypeError(`The control-block length of ${controlBlock.length} is incorrect!`);
                }
                const m = (controlBlock.length - 33) / 32;
                if (m > 128) {
                    throw new TypeError(`The script path is too long. Got ${m}, expected max 128.`);
                }
                const internalPk = controlBlock.subarray(1, 33);
                if (this.#inputInternalPubkey && !equals(this.#inputInternalPubkey, internalPk)) {
                    throw new TypeError('Internal pubkey mismatch');
                }
                if (!isXOnlyPublicKey(internalPk)) {
                    throw new TypeError('Invalid internalPubkey for p2tr witness');
                }
                const controlBlockFirstByte = controlBlock[0];
                const leafVersion = controlBlockFirstByte & TAPLEAF_VERSION_MASK;
                const script = witness[witness.length - 2];
                const leafHash = tapleafHash({
                    output: script,
                    version: leafVersion,
                });
                const computedHash = rootHashFromPath(controlBlock, leafHash);
                const outputKey = tweakKey(internalPk, computedHash);
                if (!outputKey) {
                    throw new TypeError('Invalid outputKey for p2tr witness');
                }
                if (pubkey.length > 0 && !equals(pubkey, outputKey.x)) {
                    throw new TypeError('Pubkey mismatch for p2tr witness');
                }
                if (outputKey.parity !== (controlBlockFirstByte & 1)) {
                    throw new Error('Incorrect parity');
                }
            }
        }
    }
}
/**
 * Creates a Pay-to-Taproot (P2TR) payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the P2TR class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The P2TR payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2tr } from '@btc-vision/bitcoin';
 *
 * // Key-path only
 * const payment = p2tr({ internalPubkey });
 *
 * // With script tree
 * const withScripts = p2tr({ internalPubkey, scriptTree });
 * ```
 */
function p2tr(a, opts) {
    if (!a.address &&
        !a.output &&
        !a.pubkey &&
        !a.internalPubkey &&
        !(a.witness && a.witness.length > 1)) {
        throw new TypeError('Not enough data');
    }
    const instance = new P2TR({
        address: a.address,
        pubkey: a.pubkey,
        internalPubkey: a.internalPubkey,
        hash: a.hash,
        scriptTree: a.scriptTree,
        signature: a.signature,
        output: a.output,
        witness: a.witness,
        redeem: a.redeem,
        redeemVersion: a.redeemVersion,
        network: a.network,
    }, opts);
    // Return a merged object for backwards compatibility
    return Object.assign(instance.toPayment(), a);
}

/**
 * Pay-to-Witness-Public-Key-Hash (P2WPKH) payment class.
 *
 * P2WPKH is the native SegWit version of P2PKH. The witness program is
 * a 20-byte pubkey hash, and spending requires the signature and public key
 * in the witness stack (not the scriptSig).
 *
 * @packageDocumentation
 */
const OPS$4 = opcodes;
const EMPTY_BUFFER$1 = new Uint8Array(0);
/**
 * Pay-to-Witness-Public-Key-Hash (P2WPKH) payment class.
 *
 * Creates locking scripts of the form: `OP_0 {hash160(pubkey)}`
 * Spending witness: `[{signature}, {pubkey}]`
 *
 * @example
 * ```typescript
 * import { P2WPKH } from '@btc-vision/bitcoin';
 *
 * // Create from public key
 * const payment = P2WPKH.fromPubkey(pubkey);
 * console.log(payment.address); // bc1q... bech32 address
 * console.log(payment.output); // scriptPubKey
 *
 * // Create from bech32 address
 * const fromAddr = P2WPKH.fromAddress('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
 * console.log(fromAddr.hash); // 20-byte witness program
 * ```
 */
class P2WPKH {
    // Static public fields
    static NAME = PaymentType.P2WPKH;
    // Private instance fields
    #network;
    #opts;
    // Input data (provided by user)
    #inputAddress;
    #inputHash;
    #inputPubkey;
    #inputSignature;
    #inputOutput;
    #inputWitness;
    // Cached computed values
    #address;
    #hash;
    #pubkey;
    #signature;
    #output;
    #input;
    #witness;
    // Cache flags
    #addressComputed = false;
    #hashComputed = false;
    #pubkeyComputed = false;
    #signatureComputed = false;
    #outputComputed = false;
    #inputComputed = false;
    #witnessComputed = false;
    // Decoded address cache
    #decodedAddress;
    #decodedAddressComputed = false;
    /**
     * Creates a new P2WPKH payment instance.
     *
     * @param params - Payment parameters
     * @param params.address - Bech32 encoded address
     * @param params.hash - 20-byte witness program (pubkey hash)
     * @param params.pubkey - The public key (must be 33 bytes compressed)
     * @param params.signature - DER-encoded signature
     * @param params.output - The scriptPubKey
     * @param params.witness - The witness stack [signature, pubkey]
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        this.#network = params.network ?? bitcoin$1;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputAddress = params.address;
        this.#inputHash = params.hash;
        this.#inputPubkey = params.pubkey;
        this.#inputSignature = params.signature;
        this.#inputOutput = params.output;
        this.#inputWitness = params.witness;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    // Public getters
    /**
     * Payment type discriminant.
     */
    get name() {
        return PaymentType.P2WPKH;
    }
    /**
     * Network parameters.
     */
    get network() {
        return this.#network;
    }
    /**
     * Bech32 encoded address (bc1q... for mainnet).
     */
    get address() {
        if (!this.#addressComputed) {
            this.#address = this.#computeAddress();
            this.#addressComputed = true;
        }
        return this.#address;
    }
    /**
     * 20-byte witness program (RIPEMD160(SHA256(pubkey))).
     */
    get hash() {
        if (!this.#hashComputed) {
            this.#hash = this.#computeHash();
            this.#hashComputed = true;
        }
        return this.#hash;
    }
    /**
     * The public key (33 bytes compressed).
     */
    get pubkey() {
        if (!this.#pubkeyComputed) {
            this.#pubkey = this.#computePubkey();
            this.#pubkeyComputed = true;
        }
        return this.#pubkey;
    }
    /**
     * The DER-encoded signature.
     */
    get signature() {
        if (!this.#signatureComputed) {
            this.#signature = this.#computeSignature();
            this.#signatureComputed = true;
        }
        return this.#signature;
    }
    /**
     * The scriptPubKey: `OP_0 {20-byte hash}`
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    /**
     * The scriptSig (always empty for native SegWit).
     */
    get input() {
        if (!this.#inputComputed) {
            this.#input = this.#computeInput();
            this.#inputComputed = true;
        }
        return this.#input;
    }
    /**
     * Witness stack: `[signature, pubkey]`
     */
    get witness() {
        if (!this.#witnessComputed) {
            this.#witness = this.#computeWitness();
            this.#witnessComputed = true;
        }
        return this.#witness;
    }
    // Static factory methods
    /**
     * Creates a P2WPKH payment from a compressed public key.
     *
     * @param pubkey - The public key (must be 33 bytes compressed)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2WPKH payment instance
     *
     * @example
     * ```typescript
     * const payment = P2WPKH.fromPubkey(pubkey);
     * const address = payment.address; // bc1q...
     * ```
     */
    static fromPubkey(pubkey, network) {
        return new P2WPKH({ pubkey, network });
    }
    /**
     * Creates a P2WPKH payment from a bech32 address.
     *
     * @param address - Bech32 encoded address
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2WPKH payment instance
     *
     * @example
     * ```typescript
     * const payment = P2WPKH.fromAddress('bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4');
     * const hash = payment.hash;
     * ```
     */
    static fromAddress(address, network) {
        return new P2WPKH({ address, network });
    }
    /**
     * Creates a P2WPKH payment from a 20-byte witness program.
     *
     * @param hash - 20-byte witness program (pubkey hash)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2WPKH payment instance
     */
    static fromHash(hash, network) {
        return new P2WPKH({ hash, network });
    }
    /**
     * Creates a P2WPKH payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2WPKH payment instance
     */
    static fromOutput(output, network) {
        return new P2WPKH({ output, network });
    }
    // Private helper methods
    /**
     * Converts to a plain P2WPKHPayment object for backwards compatibility.
     *
     * @returns A P2WPKHPayment object
     */
    toPayment() {
        return {
            name: this.name,
            network: this.network,
            address: this.address,
            hash: this.hash,
            pubkey: this.pubkey,
            signature: this.signature,
            output: this.output,
            input: this.input,
            witness: this.witness,
        };
    }
    // Private computation methods
    #getDecodedAddress() {
        if (!this.#decodedAddressComputed) {
            if (this.#inputAddress) {
                const result = distExports.bech32.decode(this.#inputAddress);
                const version = result.words.shift();
                const data = distExports.bech32.fromWords(result.words);
                this.#decodedAddress = {
                    version: version ?? 0,
                    prefix: result.prefix,
                    data: new Uint8Array(data),
                };
            }
            this.#decodedAddressComputed = true;
        }
        return this.#decodedAddress;
    }
    #computeAddress() {
        if (this.#inputAddress) {
            return this.#inputAddress;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        const words = distExports.bech32.toWords(h);
        words.unshift(0x00);
        return distExports.bech32.encode(this.#network.bech32, words);
    }
    #computeHash() {
        if (this.#inputHash) {
            return this.#inputHash;
        }
        if (this.#inputOutput) {
            return this.#inputOutput.subarray(2, 22);
        }
        if (this.#inputAddress) {
            return this.#getDecodedAddress()?.data;
        }
        const pk = this.#inputPubkey ?? this.pubkey;
        if (pk) {
            return hash160(pk);
        }
        return undefined;
    }
    #computePubkey() {
        if (this.#inputPubkey) {
            return this.#inputPubkey;
        }
        if (this.#inputWitness && this.#inputWitness.length >= 2) {
            return this.#inputWitness[1];
        }
        return undefined;
    }
    #computeSignature() {
        if (this.#inputSignature) {
            return this.#inputSignature;
        }
        if (this.#inputWitness && this.#inputWitness.length >= 1) {
            return this.#inputWitness[0];
        }
        return undefined;
    }
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        return compile([OPS$4.OP_0, h]);
    }
    #computeInput() {
        if (this.witness) {
            return EMPTY_BUFFER$1;
        }
        return undefined;
    }
    // Validation
    #computeWitness() {
        if (this.#inputWitness) {
            return this.#inputWitness;
        }
        if (!this.#inputPubkey || !this.#inputSignature) {
            return undefined;
        }
        return [this.#inputSignature, this.#inputPubkey];
    }
    #validate() {
        let hash = new Uint8Array(0);
        if (this.#inputAddress) {
            const addr = this.#getDecodedAddress();
            if (!addr) {
                throw new TypeError('Invalid address');
            }
            if (this.#network && this.#network.bech32 !== addr.prefix) {
                throw new TypeError('Invalid prefix or Network mismatch');
            }
            if (addr.version !== 0x00) {
                throw new TypeError('Invalid address version');
            }
            if (addr.data.length !== 20) {
                throw new TypeError('Invalid address data');
            }
            hash = addr.data;
        }
        if (this.#inputHash) {
            if (hash.length > 0 && !equals(hash, this.#inputHash)) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = this.#inputHash;
            }
        }
        if (this.#inputOutput) {
            if (this.#inputOutput.length !== 22 ||
                this.#inputOutput[0] !== OPS$4.OP_0 ||
                this.#inputOutput[1] !== 0x14) {
                throw new TypeError('Output is invalid');
            }
            if (hash.length > 0 && !equals(hash, this.#inputOutput.subarray(2))) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = this.#inputOutput.subarray(2);
            }
        }
        if (this.#inputPubkey) {
            const pkh = hash160(this.#inputPubkey);
            if (hash.length > 0 && !equals(hash, pkh)) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = pkh;
            }
            if (!isPoint(this.#inputPubkey) || this.#inputPubkey.length !== 33) {
                throw new TypeError('Invalid pubkey for p2wpkh');
            }
        }
        if (this.#inputWitness) {
            if (this.#inputWitness.length !== 2) {
                throw new TypeError('Witness is invalid');
            }
            const witnessSig = this.#inputWitness[0];
            const witnessPubkey = this.#inputWitness[1];
            if (!isCanonicalScriptSignature(witnessSig)) {
                throw new TypeError('Witness has invalid signature');
            }
            if (!isPoint(witnessPubkey) || witnessPubkey.length !== 33) {
                throw new TypeError('Witness has invalid pubkey');
            }
            if (this.#inputSignature && !equals(this.#inputSignature, witnessSig)) {
                throw new TypeError('Signature mismatch');
            }
            if (this.#inputPubkey && !equals(this.#inputPubkey, witnessPubkey)) {
                throw new TypeError('Pubkey mismatch');
            }
            const pkh = hash160(witnessPubkey);
            if (hash.length > 0 && !equals(hash, pkh)) {
                throw new TypeError('Hash mismatch');
            }
        }
    }
}
/**
 * Creates a Pay-to-Witness-Public-Key-Hash (P2WPKH) payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the P2WPKH class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The P2WPKH payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2wpkh } from '@btc-vision/bitcoin';
 *
 * // Create from public key
 * const payment = p2wpkh({ pubkey });
 *
 * // Create from address
 * const fromAddr = p2wpkh({ address: 'bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4' });
 * ```
 */
function p2wpkh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness) {
        throw new TypeError('Not enough data');
    }
    const instance = new P2WPKH({
        address: a.address,
        hash: a.hash,
        pubkey: a.pubkey,
        signature: a.signature,
        output: a.output,
        witness: a.witness,
        network: a.network,
    }, opts);
    // Return a merged object for backwards compatibility
    return Object.assign(instance.toPayment(), a);
}

/**
 * Pay-to-Witness-Script-Hash (P2WSH) payment class.
 *
 * P2WSH is the native SegWit version of P2SH. The witness program is
 * a 32-byte SHA256 hash of the script, and spending requires the witness
 * stack with the script and its inputs.
 *
 * @packageDocumentation
 */
const OPS$3 = opcodes;
const EMPTY_BUFFER = new Uint8Array(0);
/**
 * Checks if a stack element is an uncompressed public key.
 */
function chunkHasUncompressedPubkey(chunk) {
    if (chunk instanceof Uint8Array && chunk.length === 65 && chunk[0] === 0x04 && isPoint(chunk)) {
        return true;
    }
    return false;
}
/**
 * Pay-to-Witness-Script-Hash (P2WSH) payment class.
 *
 * Creates locking scripts of the form: `OP_0 {sha256(redeemScript)}`
 * Spending witness: `[{redeemScriptSig...}, {redeemScript}]`
 *
 * @example
 * ```typescript
 * import { P2WSH, P2MS } from '@btc-vision/bitcoin';
 *
 * // Wrap a multisig in P2WSH
 * const multisig = P2MS.fromPubkeys(2, [pubkey1, pubkey2, pubkey3]);
 * const p2wsh = P2WSH.fromRedeem({ output: multisig.output });
 * console.log(p2wsh.address); // bc1q... bech32 address
 *
 * // Decode an existing output
 * const decoded = P2WSH.fromOutput(scriptPubKey);
 * console.log(decoded.hash); // 32-byte witness program
 * ```
 */
class P2WSH {
    // Static public fields
    static NAME = PaymentType.P2WSH;
    // Private instance fields
    #network;
    #opts;
    // Input data (provided by user)
    #inputAddress;
    #inputHash;
    #inputOutput;
    #inputRedeem;
    #inputWitness;
    // Cached computed values
    #address;
    #hash;
    #output;
    #input;
    #redeem;
    #witness;
    // Cache flags
    #addressComputed = false;
    #hashComputed = false;
    #outputComputed = false;
    #inputComputed = false;
    #redeemComputed = false;
    #witnessComputed = false;
    // Decoded address cache
    #decodedAddress;
    #decodedAddressComputed = false;
    // Decoded redeem chunks cache
    #redeemChunks;
    #redeemChunksComputed = false;
    /**
     * Creates a new P2WSH payment instance.
     *
     * @param params - Payment parameters
     * @param params.address - Bech32 encoded address
     * @param params.hash - 32-byte witness program (SHA256 of script)
     * @param params.output - The scriptPubKey
     * @param params.redeem - The redeem script information
     * @param params.witness - The witness stack
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        // Derive network from redeem if not specified
        let network = params.network;
        if (!network) {
            network = (params.redeem && params.redeem.network) || bitcoin$1;
        }
        this.#network = network;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputAddress = params.address;
        this.#inputHash = params.hash;
        this.#inputOutput = params.output;
        this.#inputRedeem = params.redeem;
        this.#inputWitness = params.witness;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    // Public getters
    /**
     * Payment type discriminant.
     */
    get name() {
        const r = this.redeem;
        if (r !== undefined && r.name !== undefined) {
            return `p2wsh-${r.name}`;
        }
        return PaymentType.P2WSH;
    }
    /**
     * Network parameters.
     */
    get network() {
        return this.#network;
    }
    /**
     * Bech32 encoded address (bc1q... for mainnet).
     */
    get address() {
        if (!this.#addressComputed) {
            this.#address = this.#computeAddress();
            this.#addressComputed = true;
        }
        return this.#address;
    }
    /**
     * 32-byte witness program (SHA256 of redeem script).
     */
    get hash() {
        if (!this.#hashComputed) {
            this.#hash = this.#computeHash();
            this.#hashComputed = true;
        }
        return this.#hash;
    }
    /**
     * The scriptPubKey: `OP_0 {32-byte hash}`
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    /**
     * The scriptSig (always empty for native SegWit).
     */
    get input() {
        if (!this.#inputComputed) {
            this.#input = this.#computeInput();
            this.#inputComputed = true;
        }
        return this.#input;
    }
    /**
     * The redeem script information.
     */
    get redeem() {
        if (!this.#redeemComputed) {
            this.#redeem = this.#computeRedeem();
            this.#redeemComputed = true;
        }
        return this.#redeem;
    }
    /**
     * Witness stack: `[{scriptSig...}, {redeemScript}]`
     */
    get witness() {
        if (!this.#witnessComputed) {
            this.#witness = this.#computeWitness();
            this.#witnessComputed = true;
        }
        return this.#witness;
    }
    // Static factory methods
    /**
     * Creates a P2WSH payment from a redeem script.
     *
     * @param redeem - The redeem script information
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2WSH payment instance
     *
     * @example
     * ```typescript
     * const p2wsh = P2WSH.fromRedeem({ output: redeemScript });
     * ```
     */
    static fromRedeem(redeem, network) {
        return new P2WSH({ redeem, network });
    }
    /**
     * Creates a P2WSH payment from a bech32 address.
     *
     * @param address - Bech32 encoded address
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2WSH payment instance
     */
    static fromAddress(address, network) {
        return new P2WSH({ address, network });
    }
    /**
     * Creates a P2WSH payment from a 32-byte witness program.
     *
     * @param hash - 32-byte witness program (SHA256 of script)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2WSH payment instance
     */
    static fromHash(hash, network) {
        return new P2WSH({ hash, network });
    }
    /**
     * Creates a P2WSH payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2WSH payment instance
     */
    static fromOutput(output, network) {
        return new P2WSH({ output, network });
    }
    // Private helper methods
    /**
     * Converts to a plain P2WSHPayment object for backwards compatibility.
     *
     * @returns A P2WSHPayment object
     */
    toPayment() {
        // Access witness first as it may modify redeem (transform input to witness)
        const witness = this.witness;
        const redeem = this.redeem;
        return {
            name: this.name,
            network: this.network,
            address: this.address,
            hash: this.hash,
            output: this.output,
            input: this.input,
            redeem,
            witness,
        };
    }
    #getDecodedAddress() {
        if (!this.#decodedAddressComputed) {
            if (this.#inputAddress) {
                const result = distExports.bech32.decode(this.#inputAddress);
                const version = result.words.shift();
                const data = distExports.bech32.fromWords(result.words);
                this.#decodedAddress = {
                    version: version ?? 0,
                    prefix: result.prefix,
                    data: new Uint8Array(data),
                };
            }
            this.#decodedAddressComputed = true;
        }
        return this.#decodedAddress;
    }
    // Private computation methods
    #getRedeemChunks() {
        if (!this.#redeemChunksComputed) {
            if (this.#inputRedeem?.input) {
                this.#redeemChunks = decompile(this.#inputRedeem.input) ?? undefined;
            }
            this.#redeemChunksComputed = true;
        }
        return this.#redeemChunks;
    }
    #computeAddress() {
        if (this.#inputAddress) {
            return this.#inputAddress;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        const words = distExports.bech32.toWords(h);
        words.unshift(0x00);
        return distExports.bech32.encode(this.#network.bech32, words);
    }
    #computeHash() {
        if (this.#inputHash) {
            return this.#inputHash;
        }
        if (this.#inputOutput) {
            return this.#inputOutput.subarray(2);
        }
        if (this.#inputAddress) {
            return this.#getDecodedAddress()?.data;
        }
        const r = this.redeem;
        if (r && r.output) {
            return sha256$1(r.output);
        }
        return undefined;
    }
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        const h = this.hash;
        if (!h)
            return undefined;
        return compile([OPS$3.OP_0, h]);
    }
    #computeInput() {
        if (this.witness) {
            return EMPTY_BUFFER;
        }
        return undefined;
    }
    #computeRedeem() {
        if (this.#inputRedeem) {
            return this.#inputRedeem;
        }
        if (this.#inputWitness && this.#inputWitness.length > 0) {
            return {
                output: this.#inputWitness[this.#inputWitness.length - 1],
                input: EMPTY_BUFFER,
                witness: this.#inputWitness.slice(0, -1),
            };
        }
        return undefined;
    }
    // Validation
    #computeWitness() {
        if (this.#inputWitness) {
            return this.#inputWitness;
        }
        const r = this.#inputRedeem;
        if (r) {
            // Transform redeem input to witness stack
            if (r.input && r.input.length > 0 && r.output && r.output.length > 0) {
                const chunks = this.#getRedeemChunks();
                if (chunks) {
                    const stack = toStack(chunks);
                    // Assign, and blank the existing input
                    this.#redeem = Object.assign({ witness: stack }, r, { input: EMPTY_BUFFER });
                    this.#redeemComputed = true;
                    return [].concat(stack, r.output);
                }
            }
            if (!r.output)
                return undefined;
            if (!r.witness)
                return undefined;
            return [].concat(r.witness, r.output);
        }
        return undefined;
    }
    #validate() {
        let hash = new Uint8Array(0);
        if (this.#inputAddress) {
            const addr = this.#getDecodedAddress();
            if (!addr) {
                throw new TypeError('Invalid address');
            }
            if (addr.prefix !== this.#network.bech32) {
                throw new TypeError('Invalid prefix or Network mismatch');
            }
            if (addr.version !== 0x00) {
                throw new TypeError('Invalid address version');
            }
            if (addr.data.length !== 32) {
                throw new TypeError('Invalid address data');
            }
            hash = addr.data;
        }
        if (this.#inputHash) {
            if (hash.length > 0 && !equals(hash, this.#inputHash)) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = this.#inputHash;
            }
        }
        if (this.#inputOutput) {
            if (this.#inputOutput.length !== 34 ||
                this.#inputOutput[0] !== OPS$3.OP_0 ||
                this.#inputOutput[1] !== 0x20) {
                throw new TypeError('Output is invalid');
            }
            const hash2 = this.#inputOutput.subarray(2);
            if (hash.length > 0 && !equals(hash, hash2)) {
                throw new TypeError('Hash mismatch');
            }
            else {
                hash = hash2;
            }
        }
        if (this.#inputRedeem) {
            if (this.#inputRedeem.network && this.#inputRedeem.network !== this.#network) {
                throw new TypeError('Network mismatch');
            }
            // Is there two redeem sources?
            if (this.#inputRedeem.input &&
                this.#inputRedeem.input.length > 0 &&
                this.#inputRedeem.witness &&
                this.#inputRedeem.witness.length > 0) {
                throw new TypeError('Ambiguous witness source');
            }
            // Is the redeem output non-empty/valid?
            if (this.#inputRedeem.output) {
                const decompile$1 = decompile(this.#inputRedeem.output);
                if (!decompile$1 || decompile$1.length < 1) {
                    throw new TypeError('Redeem.output is invalid');
                }
                if (this.#inputRedeem.output.byteLength > 3600) {
                    throw new TypeError('Redeem.output unspendable if larger than 3600 bytes');
                }
                if (countNonPushOnlyOPs(decompile$1) > 201) {
                    throw new TypeError('Redeem.output unspendable with more than 201 non-push ops');
                }
                // Match hash against other sources
                const hash2 = sha256$1(this.#inputRedeem.output);
                if (hash.length > 0 && !equals(hash, hash2)) {
                    throw new TypeError('Hash mismatch');
                }
                else {
                    hash = hash2;
                }
            }
            const chunks = this.#getRedeemChunks();
            if (this.#inputRedeem.input && chunks && !isPushOnly(chunks)) {
                throw new TypeError('Non push-only scriptSig');
            }
            if (this.#inputWitness &&
                this.#inputRedeem.witness &&
                !stacksEqual(this.#inputWitness, this.#inputRedeem.witness)) {
                throw new TypeError('Witness and redeem.witness mismatch');
            }
            if ((this.#inputRedeem.input && chunks?.some(chunkHasUncompressedPubkey)) ||
                (this.#inputRedeem.output &&
                    (decompile(this.#inputRedeem.output) || []).some(chunkHasUncompressedPubkey))) {
                throw new TypeError('redeem.input or redeem.output contains uncompressed pubkey');
            }
        }
        if (this.#inputWitness && this.#inputWitness.length > 0) {
            const wScript = this.#inputWitness[this.#inputWitness.length - 1];
            if (this.#inputRedeem &&
                this.#inputRedeem.output &&
                !equals(this.#inputRedeem.output, wScript)) {
                throw new TypeError('Witness and redeem.output mismatch');
            }
            if (this.#inputWitness.some(chunkHasUncompressedPubkey) ||
                (decompile(wScript) || []).some(chunkHasUncompressedPubkey)) {
                throw new TypeError('Witness contains uncompressed pubkey');
            }
        }
    }
}
/**
 * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the P2WSH class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The P2WSH payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2wsh, p2ms } from '@btc-vision/bitcoin';
 *
 * // Wrap a multisig in P2WSH
 * const multisig = p2ms({ m: 2, pubkeys: [pk1, pk2, pk3] });
 * const payment = p2wsh({ redeem: multisig });
 * ```
 */
function p2wsh(a, opts) {
    if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness) {
        throw new TypeError('Not enough data');
    }
    const instance = new P2WSH({
        address: a.address,
        hash: a.hash,
        output: a.output,
        redeem: a.redeem,
        witness: a.witness,
        network: a.network,
    }, opts);
    // Return the computed payment
    // Note: We don't use Object.assign(toPayment(), a) because that would
    // overwrite computed properties (like modified redeem) with original values
    return instance.toPayment();
}

/**
 * bitcoin address decode and encode tools, include base58ã€bech32 and output script
 *
 * networks support bitcoinã€bitcoin testnet and bitcoin regtest
 *
 * addresses support P2PKHã€P2SHã€P2WPKHã€P2WSHã€P2TR and so on
 *
 * @packageDocumentation
 */
const FUTURE_SEGWIT_MAX_SIZE = 40;
const FUTURE_SEGWIT_MIN_SIZE = 2;
const FUTURE_SEGWIT_MAX_VERSION = 15;
const FUTURE_MAX_VERSION = 16;
const FUTURE_OPNET_VERSION = 16;
const FUTURE_SEGWIT_MIN_VERSION = 2;
const FUTURE_SEGWIT_VERSION_DIFF = 0x50;
const FUTURE_SEGWIT_VERSION_WARNING = 'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +
    'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +
    'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +
    'then decide when it is safe to use which version of segwit.';
const isUnknownSegwitVersion = (output) => {
    try {
        const data = output.subarray(2);
        if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE) {
            throw new TypeError('Invalid program length for segwit address');
        }
        const firstByte = output[0];
        if (firstByte === undefined)
            throw new TypeError('Empty output');
        const version = firstByte - FUTURE_SEGWIT_VERSION_DIFF;
        if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION + 1) {
            throw new TypeError('Invalid version for segwit address');
        }
        if (version === 1)
            throw new TypeError('taproot');
        return true;
    }
    catch (e) { }
    return false;
};
/**
 * Encode a future Taproot-style segwit address (SegWit v2 - v16) using bech32m.
 * Only for versions not yet assigned specific meanings (future use).
 *
 * @param output - Output script buffer containing the version and witness program
 * @param network - Network object containing bech32 and optional bech32Opnet prefix
 * @returns Bech32m-encoded future Taproot-style address
 */
function toFutureOPNetAddress(output, network) {
    if (!(output instanceof Uint8Array))
        throw new TypeError('output must be a Uint8Array');
    if (!network.bech32Opnet)
        throw new Error('Network does not support opnet');
    const opcode = output[0];
    // work out where the push-data really starts
    let pushPos = 1, progLen;
    const byte1 = output[1];
    const byte2 = output[2];
    if (byte1 !== undefined && byte1 < 0x4c) {
        progLen = byte1;
        pushPos = 2;
    }
    else if (byte1 === 0x4c && byte2 !== undefined) {
        progLen = byte2;
        pushPos = 3;
    }
    else {
        throw new TypeError('Unsupported push opcode in script');
    }
    const program = output.subarray(pushPos, pushPos + progLen);
    if (program.length < FUTURE_SEGWIT_MIN_SIZE || program.length > FUTURE_SEGWIT_MAX_SIZE)
        throw new TypeError('Invalid program length for segwit address');
    const version = opcode === opcodes.OP_0
        ? 0
        : opcode !== undefined && opcode >= opcodes.OP_1 && opcode <= opcodes.OP_16
            ? opcode - (opcodes.OP_1 - 1)
            : -1;
    if (version < FUTURE_SEGWIT_MAX_VERSION || version > FUTURE_MAX_VERSION)
        throw new TypeError(`Invalid segwit version ${version}`);
    const words = [version, ...distExports.bech32m.toWords(program)];
    return distExports.bech32m.encode(network.bech32Opnet, words);
}
function _toFutureSegwitAddress(output, network) {
    const data = output.subarray(2);
    if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE) {
        throw new TypeError('Invalid program length for segwit address');
    }
    const firstByte = output[0];
    if (firstByte === undefined)
        throw new TypeError('Empty output');
    const version = firstByte - FUTURE_SEGWIT_VERSION_DIFF;
    if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION) {
        throw new TypeError('Invalid version for segwit address');
    }
    if (output[1] !== data.length) {
        throw new TypeError(`Invalid script for segwit address ${output[1]} !== ${data.length}`);
    }
    return toBech32(data, version, network.bech32, network.bech32Opnet);
}
/**
 * decode address with base58 specification,  return address version and address hash if valid
 */
function fromBase58Check(address) {
    const payload = new Uint8Array(decode$i(address));
    // TODO: 4.0.0, move to "toOutputScript"
    if (payload.length < 21)
        throw new TypeError(address + ' is too short');
    if (payload.length > 21)
        throw new TypeError(address + ' is too long');
    const version = payload[0]; // Safe: length validated above
    const hash = payload.subarray(1);
    return { version, hash };
}
/**
 * encode address hash to base58 address with version
 */
function toBase58Check(hash, version) {
    if (!isBytes20(hash))
        throw new TypeError('Expected 20 bytes hash');
    if (!isUInt8(version))
        throw new TypeError('Expected UInt8 version');
    const payload = alloc(21);
    payload[0] = version;
    payload.set(hash, 1);
    return encode$j(payload);
}
/**
 * encode address hash to bech32 address with version and prefix
 */
function toBech32(data, version, prefix, prefixOpnet) {
    const words = distExports.bech32.toWords(data);
    words.unshift(version);
    if (version === FUTURE_OPNET_VERSION && prefixOpnet) {
        return distExports.bech32m.encode(prefixOpnet, words);
    }
    return version === 0 ? distExports.bech32.encode(prefix, words) : distExports.bech32m.encode(prefix, words);
}
/**
 * decode address from output script with network, return address if matched.
 *
 * Uses fast byte-pattern matching for common script types (P2PKH, P2SH,
 * P2WPKH, P2WSH, P2TR) to avoid constructing payment objects and catching
 * exceptions. Falls back to payment constructors for exotic types.
 */
function fromOutputScript(output, network) {
    network = network || bitcoin$1;
    const len = output.length;
    // P2PKH: OP_DUP(0x76) OP_HASH160(0xa9) 0x14 <20-byte hash> OP_EQUALVERIFY(0x88) OP_CHECKSIG(0xac)
    if (len === 25 &&
        output[0] === 0x76 &&
        output[1] === 0xa9 &&
        output[2] === 0x14 &&
        output[23] === 0x88 &&
        output[24] === 0xac) {
        return toBase58Check(output.subarray(3, 23), network.pubKeyHash);
    }
    // P2SH: OP_HASH160(0xa9) 0x14 <20-byte hash> OP_EQUAL(0x87)
    if (len === 23 && output[0] === 0xa9 && output[1] === 0x14 && output[22] === 0x87) {
        return toBase58Check(output.subarray(2, 22), network.scriptHash);
    }
    // P2WPKH: OP_0(0x00) 0x14 <20-byte hash>
    if (len === 22 && output[0] === 0x00 && output[1] === 0x14) {
        return toBech32(output.subarray(2, 22), 0, network.bech32);
    }
    // P2WSH: OP_0(0x00) 0x20 <32-byte hash>
    if (len === 34 && output[0] === 0x00 && output[1] === 0x20) {
        return toBech32(output.subarray(2, 34), 0, network.bech32);
    }
    // P2TR: OP_1(0x51) 0x20 <32-byte x-only pubkey>
    if (len === 34 && output[0] === 0x51 && output[1] === 0x20) {
        const words = distExports.bech32m.toWords(output.subarray(2, 34));
        words.unshift(1);
        return distExports.bech32m.encode(network.bech32, words);
    }
    // P2MR: OP_2(0x52) 0x20 <32-byte merkle root>
    if (len === 34 && output[0] === 0x52 && output[1] === 0x20) {
        const words = distExports.bech32m.toWords(output.subarray(2, 34));
        words.unshift(2);
        return distExports.bech32m.encode(network.bech32, words);
    }
    // Fallback for exotic types
    try {
        return toFutureOPNetAddress(output, network);
    }
    catch (e) { }
    try {
        return _toFutureSegwitAddress(output, network);
    }
    catch (e) { }
    throw new Error(toASM(output) + ' has no matching Address');
}
/**
 * Encodes address to output script with network, return output script if address matched.
 * @param address - The address to encode
 * @param networkOrOptions - Network or options object
 * @returns The output script
 */
function toOutputScript(address, networkOrOptions) {
    let network;
    let onFutureSegwitWarning;
    if (networkOrOptions && 'bech32' in networkOrOptions) {
        // It's a Network object
        network = networkOrOptions;
    }
    else if (networkOrOptions && typeof networkOrOptions === 'object') {
        // It's an options object
        network = networkOrOptions.network || bitcoin$1;
        onFutureSegwitWarning = networkOrOptions.onFutureSegwitWarning;
    }
    else {
        network = bitcoin$1;
    }
    let decodeBase58;
    let decodeBech32;
    try {
        decodeBase58 = fromBase58Check(address);
    }
    catch (e) { }
    if (decodeBase58) {
        if (decodeBase58.version === network.pubKeyHash)
            return p2pkh({ hash: decodeBase58.hash }).output;
        if (decodeBase58.version === network.scriptHash)
            return p2sh({ hash: decodeBase58.hash }).output;
    }
    else {
        try {
            decodeBech32 = fromBech32(address);
        }
        catch (e) { }
        if (decodeBech32) {
            if (decodeBech32.prefix !== network.bech32 &&
                network.bech32Opnet &&
                decodeBech32.prefix !== network.bech32Opnet)
                throw new Error(address + ' has an invalid prefix');
            if (decodeBech32.version === 0) {
                if (decodeBech32.data.length === 20)
                    return p2wpkh({ hash: toBytes20(decodeBech32.data) }).output;
                if (decodeBech32.data.length === 32)
                    return p2wsh({ hash: toBytes32(decodeBech32.data) }).output;
            }
            else if (decodeBech32.version === 1) {
                if (decodeBech32.data.length === 32)
                    return p2tr({ pubkey: decodeBech32.data })
                        .output;
            }
            else if (decodeBech32.version === 2 && decodeBech32.data.length === 32) {
                return p2mr({ hash: toBytes32(decodeBech32.data) }).output;
            }
            else if (decodeBech32.version === FUTURE_OPNET_VERSION) {
                if (!network.bech32Opnet)
                    throw new Error(address + ' has an invalid prefix');
                return p2op({
                    program: decodeBech32.data,
                    network,
                }).output;
            }
            else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&
                decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&
                decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&
                decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
                if (decodeBech32.version !== FUTURE_OPNET_VERSION && onFutureSegwitWarning) {
                    onFutureSegwitWarning(FUTURE_SEGWIT_VERSION_WARNING);
                }
                return compile([
                    decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
                    decodeBech32.data,
                ]);
            }
        }
    }
    throw new TypeError(address + ' has no matching Script');
}

/**
 * Pay-to-Public-Key (P2PK) payment class.
 *
 * P2PK is one of the simplest Bitcoin payment types where the output script
 * contains a public key directly, and spending requires a signature from that key.
 *
 * @packageDocumentation
 */
const OPS$2 = opcodes;
/**
 * Pay-to-Public-Key (P2PK) payment class.
 *
 * Creates locking scripts of the form: `{pubKey} OP_CHECKSIG`
 * Spending requires providing: `{signature}`
 *
 * @example
 * ```typescript
 * import { P2PK } from '@btc-vision/bitcoin';
 *
 * // Create from public key
 * const payment = P2PK.fromPubkey(pubkey);
 * console.log(payment.output); // scriptPubKey
 *
 * // Create from output script
 * const decoded = P2PK.fromOutput(scriptPubKey);
 * console.log(decoded.pubkey); // extracted public key
 *
 * // Legacy factory function still works
 * const legacy = p2pk({ pubkey });
 * ```
 */
class P2PK {
    // Static public fields
    static NAME = PaymentType.P2PK;
    // Private instance fields
    #network;
    #opts;
    // Input data (provided by user)
    #inputPubkey;
    #inputSignature;
    #inputOutput;
    #inputInput;
    // Cached computed values
    #pubkey;
    #signature;
    #output;
    #input;
    #witness;
    // Cache flags
    #pubkeyComputed = false;
    #signatureComputed = false;
    #outputComputed = false;
    #inputComputed = false;
    #witnessComputed = false;
    /**
     * Creates a new P2PK payment instance.
     *
     * @param params - Payment parameters
     * @param params.pubkey - The public key (33 or 65 bytes)
     * @param params.signature - DER-encoded signature
     * @param params.output - The scriptPubKey
     * @param params.input - The scriptSig
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        this.#network = params.network ?? bitcoin$1;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputPubkey = params.pubkey;
        this.#inputSignature = params.signature;
        this.#inputOutput = params.output;
        this.#inputInput = params.input;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    // Public getters
    /**
     * Payment type discriminant.
     */
    get name() {
        return PaymentType.P2PK;
    }
    /**
     * Network parameters.
     */
    get network() {
        return this.#network;
    }
    /**
     * The public key (33 or 65 bytes).
     * Computed lazily from output if not provided directly.
     */
    get pubkey() {
        if (!this.#pubkeyComputed) {
            this.#pubkey = this.#computePubkey();
            this.#pubkeyComputed = true;
        }
        return this.#pubkey;
    }
    /**
     * The DER-encoded signature.
     * Computed lazily from input if not provided directly.
     */
    get signature() {
        if (!this.#signatureComputed) {
            this.#signature = this.#computeSignature();
            this.#signatureComputed = true;
        }
        return this.#signature;
    }
    /**
     * The scriptPubKey: `{pubKey} OP_CHECKSIG`
     * Computed lazily from pubkey if not provided directly.
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    /**
     * The scriptSig: `{signature}`
     * Computed lazily from signature if not provided directly.
     */
    get input() {
        if (!this.#inputComputed) {
            this.#input = this.#computeInput();
            this.#inputComputed = true;
        }
        return this.#input;
    }
    /**
     * Witness stack (empty for P2PK as it's not a SegWit type).
     */
    get witness() {
        if (!this.#witnessComputed) {
            this.#witness = this.#computeWitness();
            this.#witnessComputed = true;
        }
        return this.#witness;
    }
    // Static factory methods
    /**
     * Creates a P2PK payment from a public key.
     *
     * @param pubkey - The public key (33 or 65 bytes)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2PK payment instance
     *
     * @example
     * ```typescript
     * const payment = P2PK.fromPubkey(pubkey);
     * const scriptPubKey = payment.output;
     * ```
     */
    static fromPubkey(pubkey, network) {
        return new P2PK({ pubkey, network });
    }
    /**
     * Creates a P2PK payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2PK payment instance
     *
     * @example
     * ```typescript
     * const payment = P2PK.fromOutput(scriptPubKey);
     * const pubkey = payment.pubkey;
     * ```
     */
    static fromOutput(output, network) {
        return new P2PK({ output, network });
    }
    /**
     * Creates a P2PK payment from a signature (for spending).
     *
     * @param signature - The DER-encoded signature
     * @param pubkey - The public key (optional, for validation)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2PK payment instance
     *
     * @example
     * ```typescript
     * const payment = P2PK.fromSignature(signature, pubkey);
     * const scriptSig = payment.input;
     * ```
     */
    static fromSignature(signature, pubkey, network) {
        return new P2PK({ signature, pubkey, network });
    }
    // Private computation methods
    /**
     * Converts to a plain P2PKPayment object for backwards compatibility.
     *
     * @returns A P2PKPayment object
     */
    toPayment() {
        return {
            name: this.name,
            network: this.network,
            pubkey: this.pubkey,
            signature: this.signature,
            output: this.output,
            input: this.input,
            witness: this.witness,
        };
    }
    #computePubkey() {
        if (this.#inputPubkey) {
            return this.#inputPubkey;
        }
        if (this.#inputOutput) {
            // Extract pubkey from output: {pubkey} OP_CHECKSIG
            return this.#inputOutput.subarray(1, -1);
        }
        return undefined;
    }
    #computeSignature() {
        if (this.#inputSignature) {
            return this.#inputSignature;
        }
        if (this.#inputInput) {
            const chunks = decompile(this.#inputInput);
            if (chunks && chunks.length > 0) {
                return chunks[0];
            }
        }
        return undefined;
    }
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        const pubkey = this.#inputPubkey;
        if (pubkey) {
            return compile([pubkey, OPS$2.OP_CHECKSIG]);
        }
        return undefined;
    }
    #computeInput() {
        if (this.#inputInput) {
            return this.#inputInput;
        }
        const signature = this.#inputSignature;
        if (signature) {
            return compile([signature]);
        }
        return undefined;
    }
    // Validation
    #computeWitness() {
        if (this.input) {
            return [];
        }
        return undefined;
    }
    #validate() {
        if (this.#inputOutput) {
            if (this.#inputOutput[this.#inputOutput.length - 1] !== OPS$2.OP_CHECKSIG) {
                throw new TypeError('Output is invalid');
            }
            const extractedPubkey = this.pubkey;
            if (!isPoint(extractedPubkey)) {
                throw new TypeError('Output pubkey is invalid');
            }
            if (this.#inputPubkey &&
                extractedPubkey &&
                !equals(this.#inputPubkey, extractedPubkey)) {
                throw new TypeError('Pubkey mismatch');
            }
        }
        if (this.#inputSignature) {
            const computedInput = this.input;
            if (this.#inputInput && computedInput && !equals(this.#inputInput, computedInput)) {
                throw new TypeError('Signature mismatch');
            }
        }
        if (this.#inputInput) {
            const chunks = decompile(this.#inputInput);
            if (!chunks || chunks.length !== 1) {
                throw new TypeError('Input is invalid');
            }
            const sig = this.signature;
            if (!sig || !isCanonicalScriptSignature(sig)) {
                throw new TypeError('Input has invalid signature');
            }
        }
    }
}
/**
 * Creates a Pay-to-Public-Key (P2PK) payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the P2PK class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The P2PK payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2pk } from '@btc-vision/bitcoin';
 *
 * // Create from public key
 * const payment = p2pk({ pubkey });
 *
 * // Create from output
 * const decoded = p2pk({ output: scriptPubKey });
 * ```
 */
function p2pk(a, opts) {
    if (!a.input && !a.output && !a.pubkey && !a.signature) {
        throw new TypeError('Not enough data');
    }
    const instance = new P2PK({
        pubkey: a.pubkey,
        signature: a.signature,
        output: a.output,
        input: a.input,
        network: a.network,
    }, opts);
    // Return a merged object for backwards compatibility
    return Object.assign(instance.toPayment(), a);
}

/**
 * OP_RETURN Embed payment class.
 *
 * Embed payments use OP_RETURN to store arbitrary data in the blockchain.
 * These outputs are provably unspendable.
 *
 * @packageDocumentation
 */
const OPS$1 = opcodes;
/**
 * OP_RETURN Embed payment class.
 *
 * Creates outputs of the form: `OP_RETURN {data1} {data2} ...`
 * These outputs are provably unspendable and used for data storage.
 *
 * @example
 * ```typescript
 * import { Embed } from '@btc-vision/bitcoin';
 *
 * // Create from data
 * const payment = Embed.fromData([Buffer.from('Hello, Bitcoin!')]);
 * console.log(payment.output); // scriptPubKey with OP_RETURN
 *
 * // Decode an existing output
 * const decoded = Embed.fromOutput(scriptPubKey);
 * console.log(decoded.data); // array of data chunks
 * ```
 */
class Embed {
    // Static public fields
    static NAME = PaymentType.Embed;
    // Private instance fields
    #network;
    #opts;
    // Input data (provided by user)
    #inputData;
    #inputOutput;
    // Cached computed values
    #data;
    #output;
    // Cache flags
    #dataComputed = false;
    #outputComputed = false;
    /**
     * Creates a new Embed payment instance.
     *
     * @param params - Payment parameters
     * @param params.data - Array of data chunks to embed
     * @param params.output - The scriptPubKey
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        this.#network = params.network ?? bitcoin$1;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputData = params.data;
        this.#inputOutput = params.output;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    // Public getters
    /**
     * Payment type discriminant.
     */
    get name() {
        return PaymentType.Embed;
    }
    /**
     * Network parameters.
     */
    get network() {
        return this.#network;
    }
    /**
     * The embedded data chunks.
     */
    get data() {
        if (!this.#dataComputed) {
            this.#data = this.#computeData();
            this.#dataComputed = true;
        }
        return this.#data ?? [];
    }
    /**
     * The scriptPubKey: `OP_RETURN {data...}`
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    // Static factory methods
    /**
     * Creates an Embed payment from data chunks.
     *
     * @param data - Array of data chunks to embed
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new Embed payment instance
     *
     * @example
     * ```typescript
     * const payment = Embed.fromData([
     *   new TextEncoder().encode('Hello'),
     *   new TextEncoder().encode('Bitcoin')
     * ]);
     * ```
     */
    static fromData(data, network) {
        return new Embed({ data, network });
    }
    /**
     * Creates an Embed payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new Embed payment instance
     */
    static fromOutput(output, network) {
        return new Embed({ output, network });
    }
    // Private computation methods
    /**
     * Converts to a plain EmbedPayment object for backwards compatibility.
     *
     * @returns An EmbedPayment object
     */
    toPayment() {
        return {
            name: this.name,
            network: this.network,
            data: this.data,
            output: this.output,
        };
    }
    #computeData() {
        if (this.#inputData) {
            return this.#inputData;
        }
        if (this.#inputOutput) {
            const script$1 = decompile(this.#inputOutput);
            if (script$1 === null || script$1 === undefined) {
                return undefined;
            }
            return script$1.slice(1);
        }
        return undefined;
    }
    // Validation
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        if (!this.#inputData) {
            return undefined;
        }
        return compile([OPS$1.OP_RETURN].concat(this.#inputData));
    }
    #validate() {
        if (this.#inputOutput) {
            const chunks = decompile(this.#inputOutput);
            if (!chunks) {
                throw new TypeError('Output is invalid');
            }
            if (chunks[0] !== OPS$1.OP_RETURN) {
                throw new TypeError('Output is invalid');
            }
            if (!chunks.slice(1).every((c) => c instanceof Uint8Array)) {
                throw new TypeError('Output is invalid');
            }
            if (this.#inputData && !stacksEqual(this.#inputData, this.data)) {
                throw new TypeError('Data mismatch');
            }
        }
    }
}
/**
 * Creates an OP_RETURN Embed payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the Embed class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The Embed payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2data } from '@btc-vision/bitcoin';
 *
 * // Create from data
 * const payment = p2data({ data: [Buffer.from('Hello')] });
 *
 * // Decode from output
 * const decoded = p2data({ output: scriptPubKey });
 * ```
 */
function p2data(a, opts) {
    if (!a.data && !a.output) {
        throw new TypeError('Not enough data');
    }
    const instance = new Embed({
        data: a.data,
        output: a.output,
        network: a.network,
    }, opts);
    // Return a merged object for backwards compatibility
    return Object.assign(instance.toPayment(), a);
}

/**
 * Pay-to-Multisig (P2MS) payment class.
 *
 * P2MS is a bare multisig script where M-of-N signatures are required
 * to spend the output. The public keys are embedded directly in the script.
 *
 * @packageDocumentation
 */
const OPS = opcodes;
const OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1
/**
 * Pay-to-Multisig (P2MS) payment class.
 *
 * Creates locking scripts of the form:
 * `m {pubKey1} {pubKey2} ... {pubKeyN} n OP_CHECKMULTISIG`
 *
 * Spending requires: `OP_0 {sig1} {sig2} ... {sigM}`
 *
 * @example
 * ```typescript
 * import { P2MS } from '@btc-vision/bitcoin';
 *
 * // Create a 2-of-3 multisig
 * const payment = P2MS.fromPubkeys(2, [pubkey1, pubkey2, pubkey3]);
 * console.log(payment.output); // scriptPubKey
 * console.log(payment.m); // 2
 * console.log(payment.n); // 3
 *
 * // Decode an existing output
 * const decoded = P2MS.fromOutput(scriptPubKey);
 * console.log(decoded.pubkeys); // array of public keys
 * ```
 */
class P2MS {
    // Static public fields
    static NAME = PaymentType.P2MS;
    // Private instance fields
    #network;
    #opts;
    // Input data (provided by user)
    #inputM;
    #inputN;
    #inputPubkeys;
    #inputSignatures;
    #inputOutput;
    #inputInput;
    // Cached computed values
    #m;
    #n;
    #pubkeys;
    #signatures;
    #output;
    #input;
    #witness;
    // Cache flags
    #mComputed = false;
    #nComputed = false;
    #pubkeysComputed = false;
    #signaturesComputed = false;
    #outputComputed = false;
    #inputComputed = false;
    #witnessComputed = false;
    // Decoded chunks cache
    #decodedChunks;
    #decoded = false;
    /**
     * Creates a new P2MS payment instance.
     *
     * @param params - Payment parameters
     * @param params.m - Required number of signatures
     * @param params.n - Total number of public keys (optional, derived from pubkeys)
     * @param params.pubkeys - Array of public keys
     * @param params.signatures - Array of signatures
     * @param params.output - The scriptPubKey
     * @param params.input - The scriptSig
     * @param params.network - Network parameters (defaults to mainnet)
     * @param opts - Payment options
     * @param opts.validate - Whether to validate inputs (default: true)
     * @param opts.allowIncomplete - Allow incomplete signatures (default: false)
     *
     * @throws {TypeError} If validation is enabled and data is invalid
     */
    constructor(params, opts) {
        this.#network = params.network ?? bitcoin$1;
        this.#opts = {
            validate: opts?.validate ?? true,
            allowIncomplete: opts?.allowIncomplete ?? false,
        };
        // Store input data
        this.#inputM = params.m;
        this.#inputN = params.n;
        this.#inputPubkeys = params.pubkeys;
        this.#inputSignatures = params.signatures;
        this.#inputOutput = params.output;
        this.#inputInput = params.input;
        // Validate if requested
        if (this.#opts.validate) {
            this.#validate();
        }
    }
    // Public getters
    /**
     * Payment type discriminant.
     */
    get name() {
        const m = this.m;
        const n = this.n;
        if (m !== undefined && n !== undefined) {
            return `p2ms(${m} of ${n})`;
        }
        return PaymentType.P2MS;
    }
    /**
     * Network parameters.
     */
    get network() {
        return this.#network;
    }
    /**
     * Required number of signatures (M in M-of-N).
     */
    get m() {
        if (!this.#mComputed) {
            this.#m = this.#computeM();
            this.#mComputed = true;
        }
        return this.#m;
    }
    /**
     * Total number of public keys (N in M-of-N).
     */
    get n() {
        if (!this.#nComputed) {
            this.#n = this.#computeN();
            this.#nComputed = true;
        }
        return this.#n;
    }
    /**
     * Array of public keys.
     */
    get pubkeys() {
        if (!this.#pubkeysComputed) {
            this.#pubkeys = this.#computePubkeys();
            this.#pubkeysComputed = true;
        }
        return this.#pubkeys;
    }
    /**
     * Array of signatures.
     */
    get signatures() {
        if (!this.#signaturesComputed) {
            this.#signatures = this.#computeSignatures();
            this.#signaturesComputed = true;
        }
        return this.#signatures;
    }
    /**
     * The scriptPubKey: `m {pubkeys} n OP_CHECKMULTISIG`
     */
    get output() {
        if (!this.#outputComputed) {
            this.#output = this.#computeOutput();
            this.#outputComputed = true;
        }
        return this.#output;
    }
    /**
     * The scriptSig: `OP_0 {signatures}`
     */
    get input() {
        if (!this.#inputComputed) {
            this.#input = this.#computeInput();
            this.#inputComputed = true;
        }
        return this.#input;
    }
    /**
     * Witness stack (empty for P2MS as it's not a SegWit type).
     */
    get witness() {
        if (!this.#witnessComputed) {
            this.#witness = this.#computeWitness();
            this.#witnessComputed = true;
        }
        return this.#witness;
    }
    // Static factory methods
    /**
     * Creates a P2MS payment from public keys.
     *
     * @param m - Required number of signatures
     * @param pubkeys - Array of public keys
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2MS payment instance
     *
     * @example
     * ```typescript
     * // Create a 2-of-3 multisig
     * const payment = P2MS.fromPubkeys(2, [pubkey1, pubkey2, pubkey3]);
     * ```
     */
    static fromPubkeys(m, pubkeys, network) {
        return new P2MS({ m, pubkeys, network });
    }
    /**
     * Creates a P2MS payment from a scriptPubKey.
     *
     * @param output - The scriptPubKey
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2MS payment instance
     */
    static fromOutput(output, network) {
        return new P2MS({ output, network });
    }
    /**
     * Creates a P2MS payment from signatures (for spending).
     *
     * @param signatures - Array of signatures
     * @param m - Required number of signatures (optional)
     * @param pubkeys - Array of public keys (optional, for validation)
     * @param network - Network parameters (defaults to mainnet)
     * @returns A new P2MS payment instance
     */
    static fromSignatures(signatures, m, pubkeys, network) {
        return new P2MS({ signatures, m, pubkeys, network });
    }
    // Private helper methods
    /**
     * Converts to a plain P2MSPayment object for backwards compatibility.
     *
     * @returns A P2MSPayment object
     */
    toPayment() {
        return {
            name: this.name,
            network: this.network,
            m: this.m,
            n: this.n,
            pubkeys: this.pubkeys,
            signatures: this.signatures,
            output: this.output,
            input: this.input,
            witness: this.witness,
        };
    }
    // Private computation methods
    #decode(output) {
        if (this.#decoded)
            return;
        this.#decoded = true;
        this.#decodedChunks = (decompile(output) ?? []);
        this.#m = this.#decodedChunks[0] - OP_INT_BASE;
        this.#n = this.#decodedChunks[this.#decodedChunks.length - 2] - OP_INT_BASE;
        this.#pubkeys = this.#decodedChunks.slice(1, -2);
        this.#mComputed = true;
        this.#nComputed = true;
        this.#pubkeysComputed = true;
    }
    #computeM() {
        if (this.#inputM !== undefined) {
            return this.#inputM;
        }
        const output = this.#inputOutput ?? this.output;
        if (output) {
            this.#decode(output);
            return this.#m;
        }
        return undefined;
    }
    #computeN() {
        if (this.#inputN !== undefined) {
            return this.#inputN;
        }
        if (this.#inputPubkeys) {
            return this.#inputPubkeys.length;
        }
        if (this.#inputOutput) {
            this.#decode(this.#inputOutput);
            return this.#n;
        }
        return undefined;
    }
    #computePubkeys() {
        if (this.#inputPubkeys) {
            return this.#inputPubkeys;
        }
        if (this.#inputOutput) {
            this.#decode(this.#inputOutput);
            return this.#pubkeys;
        }
        return undefined;
    }
    #computeSignatures() {
        if (this.#inputSignatures) {
            return this.#inputSignatures;
        }
        if (this.#inputInput) {
            const decompiled = decompile(this.#inputInput);
            if (decompiled === null || decompiled === undefined) {
                return undefined;
            }
            return decompiled.slice(1);
        }
        return undefined;
    }
    #computeOutput() {
        if (this.#inputOutput) {
            return this.#inputOutput;
        }
        const m = this.#inputM;
        const n = this.n;
        const pubkeys = this.#inputPubkeys;
        if (m === undefined || n === undefined || !pubkeys) {
            return undefined;
        }
        return compile([].concat(OP_INT_BASE + m, pubkeys, OP_INT_BASE + n, OPS.OP_CHECKMULTISIG));
    }
    #computeInput() {
        if (this.#inputInput) {
            return this.#inputInput;
        }
        if (!this.#inputSignatures) {
            return undefined;
        }
        return compile([OPS.OP_0].concat(this.#inputSignatures));
    }
    // Validation
    #computeWitness() {
        if (this.input) {
            return [];
        }
        return undefined;
    }
    #isAcceptableSignature(x) {
        return (isCanonicalScriptSignature(x) ||
            (this.#opts.allowIncomplete && x === OPS.OP_0));
    }
    #validate() {
        if (this.#inputOutput) {
            this.#decode(this.#inputOutput);
            const chunks = this.#decodedChunks;
            if (!chunks) {
                throw new TypeError('Output is invalid');
            }
            if (typeof chunks[0] !== 'number') {
                throw new TypeError('Output is invalid');
            }
            if (typeof chunks[chunks.length - 2] !== 'number') {
                throw new TypeError('Output is invalid');
            }
            if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG) {
                throw new TypeError('Output is invalid');
            }
            const m = this.#m;
            const n = this.#n;
            const pubkeys = this.#pubkeys;
            if (m === undefined || n === undefined || !pubkeys) {
                throw new TypeError('Output is invalid');
            }
            if (m <= 0 || n > 16 || m > n || n !== chunks.length - 3) {
                throw new TypeError('Output is invalid');
            }
            if (!pubkeys.every((x) => isPoint(x))) {
                throw new TypeError('Output is invalid');
            }
            if (this.#inputM !== undefined && this.#inputM !== m) {
                throw new TypeError('m mismatch');
            }
            if (this.#inputN !== undefined && this.#inputN !== n) {
                throw new TypeError('n mismatch');
            }
            if (this.#inputPubkeys && !stacksEqual(this.#inputPubkeys, pubkeys)) {
                throw new TypeError('Pubkeys mismatch');
            }
        }
        if (this.#inputPubkeys) {
            if (this.#inputN !== undefined && this.#inputN !== this.#inputPubkeys.length) {
                throw new TypeError('Pubkey count mismatch');
            }
            this.#n = this.#inputPubkeys.length;
            this.#nComputed = true;
            if (this.#m !== undefined && this.#n < this.#m) {
                throw new TypeError('Pubkey count cannot be less than m');
            }
        }
        if (this.#inputSignatures) {
            if (this.#m !== undefined && this.#inputSignatures.length < this.#m) {
                throw new TypeError('Not enough signatures provided');
            }
            if (this.#m !== undefined && this.#inputSignatures.length > this.#m) {
                throw new TypeError('Too many signatures provided');
            }
        }
        if (this.#inputInput) {
            if (this.#inputInput[0] !== OPS.OP_0) {
                throw new TypeError('Input is invalid');
            }
            const sigs = this.signatures;
            if (!sigs || sigs.length === 0 || !sigs.every((s) => this.#isAcceptableSignature(s))) {
                throw new TypeError('Input has invalid signature(s)');
            }
            if (this.#inputSignatures && !stacksEqual(this.#inputSignatures, sigs)) {
                throw new TypeError('Signature mismatch');
            }
            if (this.#inputM !== undefined &&
                this.#inputSignatures &&
                this.#inputM !== this.#inputSignatures.length) {
                throw new TypeError('Signature count mismatch');
            }
        }
    }
}
/**
 * Creates a Pay-to-Multisig (P2MS) payment object.
 *
 * This is the legacy factory function for backwards compatibility.
 * For new code, prefer using the P2MS class directly.
 *
 * @param a - The payment object containing the necessary data
 * @param opts - Optional payment options
 * @returns The P2MS payment object
 * @throws {TypeError} If the required data is not provided or if the data is invalid
 *
 * @example
 * ```typescript
 * import { p2ms } from '@btc-vision/bitcoin';
 *
 * // Create a 2-of-3 multisig
 * const payment = p2ms({ m: 2, pubkeys: [pubkey1, pubkey2, pubkey3] });
 * ```
 */
function p2ms(a, opts) {
    if (!a.input && !a.output && !(a.pubkeys && a.m !== undefined) && !a.signatures) {
        throw new TypeError('Not enough data');
    }
    const instance = new P2MS({
        m: a.m,
        n: a.n,
        pubkeys: a.pubkeys,
        signatures: a.signatures,
        output: a.output,
        input: a.input,
        network: a.network,
    }, opts);
    // Return a merged object for backwards compatibility
    return Object.assign(instance.toPayment(), a);
}

/**
 * Represents a payment object, which is used to create a payment.
 *
 * Supports P2PKHã€P2SHã€P2WPKHã€P2WSHã€P2TR and so on
 *
 * @packageDocumentation
 */
// Type exports

const payments = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    Embed,
    LEAF_VERSION_TAPSCRIPT,
    MAX_TAPTREE_DEPTH,
    P2MR,
    P2MS,
    P2OP,
    P2PK,
    P2PKH,
    P2SH,
    P2TR,
    P2WPKH,
    P2WSH,
    PaymentType,
    findScriptPath,
    p2data,
    p2mr,
    p2ms,
    p2op,
    p2pk,
    p2pkh,
    p2sh,
    p2tr,
    p2wpkh,
    p2wsh,
    rootHashFromPath,
    rootHashFromPathP2MR,
    tapBranchHash,
    tapleafHash,
    toHashTree,
    tweakKey
}, Symbol.toStringTag, { value: 'Module' }));

function varSliceSize(someScript) {
    const length = someScript.length;
    return encodingLength$1(length) + length;
}
function vectorSize(someVector) {
    const length = someVector.length;
    return (encodingLength$1(length) +
        someVector.reduce((sum, witness) => {
            return sum + varSliceSize(witness);
        }, 0));
}
const EMPTY_BYTES = new Uint8Array(0);
const EMPTY_WITNESS = [];
const ZERO$1 = fromHex$1('0000000000000000000000000000000000000000000000000000000000000000');
const ONE$1 = toMessageHash(fromHex$1('0000000000000000000000000000000000000000000000000000000000000001'));
/** Maximum value for SIGHASH_SINGLE blank outputs (0xFFFFFFFFFFFFFFFF) */
const BLANK_OUTPUT_VALUE = 0xffffffffffffffffn;
/**
 * Represents a Bitcoin transaction.
 *
 * @example
 * ```typescript
 * import { Transaction, fromHex } from '@btc-vision/bitcoin';
 *
 * // Parse a transaction from hex
 * const tx = Transaction.fromHex('0100000001...');
 *
 * // Create a new transaction
 * const newTx = new Transaction();
 * newTx.version = 2;
 * newTx.addInput(prevTxHash, 0);
 * newTx.addOutput(scriptPubKey, 50000n);
 * ```
 */
class Transaction {
    static DEFAULT_SEQUENCE = 0xffffffff;
    static SIGHASH_DEFAULT = 0x00;
    static SIGHASH_ALL = 0x01;
    static SIGHASH_NONE = 0x02;
    static SIGHASH_SINGLE = 0x03;
    static SIGHASH_ANYONECANPAY = 0x80;
    static SIGHASH_OUTPUT_MASK = 0x03;
    static SIGHASH_INPUT_MASK = 0x80;
    static ADVANCED_TRANSACTION_MARKER = 0x00;
    static ADVANCED_TRANSACTION_FLAG = 0x01;
    static TRUC_VERSION = 3;
    static TRUC_MAX_VSIZE = 10000;
    static TRUC_CHILD_MAX_VSIZE = 1000;
    version = 1;
    locktime = 0;
    ins = [];
    outs = [];
    /**
     * Parse a transaction from a Uint8Array buffer.
     *
     * @param buffer - The raw transaction bytes
     * @param _NO_STRICT - If true, allow extra data after transaction
     * @returns Parsed Transaction instance
     */
    static fromBuffer(buffer, _NO_STRICT) {
        const bufferReader = new BinaryReader$1(buffer);
        const tx = new Transaction();
        tx.version = bufferReader.readInt32LE();
        const marker = bufferReader.readUInt8();
        const flag = bufferReader.readUInt8();
        let hasWitnesses = false;
        if (marker === Transaction.ADVANCED_TRANSACTION_MARKER &&
            flag === Transaction.ADVANCED_TRANSACTION_FLAG) {
            hasWitnesses = true;
        }
        else {
            bufferReader.offset -= 2;
        }
        const vinLen = bufferReader.readVarInt();
        for (let i = 0; i < vinLen; ++i) {
            const hash = bufferReader.readBytes(32);
            const index = bufferReader.readUInt32LE();
            const script = bufferReader.readVarBytes();
            const sequence = bufferReader.readUInt32LE();
            tx.ins.push({
                hash: hash,
                index: index,
                script: script,
                sequence: sequence,
                witness: EMPTY_WITNESS,
            });
        }
        const voutLen = bufferReader.readVarInt();
        for (let i = 0; i < voutLen; ++i) {
            tx.outs.push({
                value: bufferReader.readUInt64LE(),
                script: bufferReader.readVarBytes(),
            });
        }
        if (hasWitnesses) {
            for (let i = 0; i < vinLen; ++i) {
                tx.ins[i].witness = bufferReader.readVector();
            }
            // was this pointless?
            if (!tx.hasWitnesses())
                throw new Error('Transaction has superfluous witness data');
        }
        tx.locktime = bufferReader.readUInt32LE();
        if (_NO_STRICT)
            return tx;
        if (bufferReader.offset !== buffer.length)
            throw new Error('Transaction has unexpected data');
        return tx;
    }
    /**
     * Parse a transaction from a hex string.
     *
     * @param hex - The transaction as a hex string
     * @returns Parsed Transaction instance
     */
    static fromHex(hex) {
        return Transaction.fromBuffer(fromHex$1(hex), false);
    }
    /**
     * Check if a hash is a coinbase hash (all zeros).
     *
     * @param hash - 32-byte hash to check
     * @returns true if hash is all zeros (coinbase)
     */
    static isCoinbaseHash(hash) {
        if (hash.length !== 32) {
            throw new TypeError('Expected 32-byte hash');
        }
        for (let i = 0; i < 32; ++i) {
            if (hash[i] !== 0)
                return false;
        }
        return true;
    }
    isCoinbase() {
        const firstIn = this.ins[0];
        return this.ins.length === 1 && firstIn !== undefined && Transaction.isCoinbaseHash(firstIn.hash);
    }
    /**
     * Add an input to this transaction.
     *
     * @param hash - 32-byte hash of the previous transaction
     * @param index - Output index in the previous transaction
     * @param sequence - Sequence number (defaults to 0xffffffff)
     * @param scriptSig - Input script (defaults to empty)
     * @returns The index of the newly added input
     */
    addInput(hash, index, sequence, scriptSig) {
        if (hash.length !== 32) {
            throw new TypeError('Expected 32-byte hash');
        }
        if (!Number.isInteger(index) || index < 0 || index > 0xffffffff) {
            throw new TypeError('Expected unsigned 32-bit integer for index');
        }
        if (sequence !== undefined &&
            sequence !== null &&
            (!Number.isInteger(sequence) || sequence < 0 || sequence > 0xffffffff)) {
            throw new TypeError('Expected unsigned 32-bit integer for sequence');
        }
        if (sequence === undefined || sequence === null) {
            sequence = Transaction.DEFAULT_SEQUENCE;
        }
        // Add the input and return the input's index
        return (this.ins.push({
            hash,
            index,
            script: scriptSig || EMPTY_BYTES,
            sequence: sequence,
            witness: EMPTY_WITNESS,
        }) - 1);
    }
    /**
     * Add an output to this transaction.
     *
     * @param scriptPubKey - Output script (locking script)
     * @param value - Output value in satoshis (bigint)
     * @returns The index of the newly added output
     */
    addOutput(scriptPubKey, value) {
        if (!(scriptPubKey instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array for scriptPubKey');
        }
        if (typeof value !== 'bigint' || value < 0n || value > 0x7fffffffffffffffn) {
            throw new TypeError('Expected bigint satoshi value (0 to 2^63-1)');
        }
        // Add the output and return the output's index
        return (this.outs.push({
            script: scriptPubKey,
            value,
        }) - 1);
    }
    hasWitnesses() {
        return this.ins.some((x) => {
            return x.witness.length !== 0;
        });
    }
    weight() {
        const base = this.byteLength(false);
        const total = this.byteLength(true);
        return base * 3 + total;
    }
    virtualSize() {
        return Math.ceil(this.weight() / 4);
    }
    byteLength(_ALLOW_WITNESS = true) {
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        return ((hasWitnesses ? 10 : 8) +
            encodingLength$1(this.ins.length) +
            encodingLength$1(this.outs.length) +
            this.ins.reduce((sum, input) => {
                return sum + 40 + varSliceSize(input.script);
            }, 0) +
            this.outs.reduce((sum, output) => {
                return sum + 8 + varSliceSize(output.script);
            }, 0) +
            (hasWitnesses
                ? this.ins.reduce((sum, input) => {
                    return sum + vectorSize(input.witness);
                }, 0)
                : 0));
    }
    clone() {
        const newTx = new Transaction();
        newTx.version = this.version;
        newTx.locktime = this.locktime;
        newTx.ins = this.ins.map((txIn) => {
            return {
                hash: txIn.hash,
                index: txIn.index,
                script: txIn.script,
                sequence: txIn.sequence,
                witness: txIn.witness,
            };
        });
        newTx.outs = this.outs.map((txOut) => {
            return {
                script: txOut.script,
                value: txOut.value,
            };
        });
        return newTx;
    }
    /**
     * Hash transaction for signing a specific input.
     *
     * Bitcoin uses a different hash for each signed transaction input.
     * This method copies the transaction, makes the necessary changes based on the
     * hashType, and then hashes the result.
     * This hash can then be used to sign the provided transaction input.
     *
     * @param inIndex - Index of the input being signed
     * @param prevOutScript - The script of the output being spent
     * @param hashType - Signature hash type
     * @returns 32-byte hash for signing
     */
    hashForSignature(inIndex, prevOutScript, hashType) {
        if (!Number.isInteger(inIndex) || inIndex < 0) {
            throw new TypeError('Expected non-negative integer for inIndex');
        }
        if (!(prevOutScript instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array for prevOutScript');
        }
        if (!Number.isInteger(hashType)) {
            throw new TypeError('Expected integer for hashType');
        }
        // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29
        if (inIndex >= this.ins.length)
            return ONE$1;
        // ignore OP_CODESEPARATOR
        const decompiled = decompile(prevOutScript);
        if (!decompiled)
            throw new Error('Could not decompile prevOutScript');
        const ourScript = compile(decompiled.filter((x) => {
            return x !== opcodes.OP_CODESEPARATOR;
        }));
        const txTmp = this.clone();
        // SIGHASH_NONE: ignore all outputs? (wildcard payee)
        if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
            txTmp.outs = [];
            // ignore sequence numbers (except at inIndex)
            txTmp.ins.forEach((input, i) => {
                if (i === inIndex)
                    return;
                input.sequence = 0;
            });
            // SIGHASH_SINGLE: ignore all outputs, except at the same index?
        }
        else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
            // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60
            if (inIndex >= this.outs.length)
                return ONE$1;
            // truncate outputs after
            txTmp.outs.length = inIndex + 1;
            // "blank" outputs before (value = 0xFFFFFFFFFFFFFFFF, empty script)
            for (let i = 0; i < inIndex; i++) {
                txTmp.outs[i] = {
                    script: EMPTY_BYTES,
                    value: BLANK_OUTPUT_VALUE,
                };
            }
            // ignore sequence numbers (except at inIndex)
            txTmp.ins.forEach((input, y) => {
                if (y === inIndex)
                    return;
                input.sequence = 0;
            });
        }
        // SIGHASH_ANYONECANPAY: ignore inputs entirely?
        if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
            txTmp.ins = [txTmp.ins[inIndex]];
            txTmp.ins[0].script = ourScript;
            // SIGHASH_ALL: only ignore input scripts
        }
        else {
            // "blank" others input scripts
            txTmp.ins.forEach((input) => {
                input.script = EMPTY_BYTES;
            });
            txTmp.ins[inIndex].script = ourScript;
        }
        // serialize and hash
        const buffer = alloc(txTmp.byteLength(false) + 4);
        const writer = new BinaryWriter$1(buffer, txTmp.byteLength(false));
        writer.writeInt32LE(hashType);
        txTmp.#toBuffer(buffer, 0, false);
        return toMessageHash(hash256(buffer));
    }
    /**
     * Hash transaction for signing a Taproot (witness v1) input.
     *
     * @param inIndex - Index of the input being signed
     * @param prevOutScripts - Scripts of all inputs being spent
     * @param values - Values of all inputs being spent (bigint satoshis)
     * @param hashType - Signature hash type
     * @param leafHash - Optional leaf hash for script path spending
     * @param annex - Optional annex data
     * @returns 32-byte hash for signing
     */
    hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex, taprootCache) {
        // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message
        if (!Number.isInteger(inIndex) || inIndex < 0 || inIndex > 0xffffffff) {
            throw new TypeError('Expected unsigned 32-bit integer for inIndex');
        }
        if (!Array.isArray(prevOutScripts) ||
            !prevOutScripts.every((s) => s instanceof Uint8Array)) {
            throw new TypeError('Expected array of Uint8Array for prevOutScripts');
        }
        if (!Array.isArray(values) || !values.every((v) => typeof v === 'bigint')) {
            throw new TypeError('Expected array of bigint for values');
        }
        if (!Number.isInteger(hashType) || hashType < 0 || hashType > 0xffffffff) {
            throw new TypeError('Expected unsigned 32-bit integer for hashType');
        }
        if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
            throw new Error('Must supply prevout script and value for all inputs');
        }
        const outputType = hashType === Transaction.SIGHASH_DEFAULT
            ? Transaction.SIGHASH_ALL
            : hashType & Transaction.SIGHASH_OUTPUT_MASK;
        const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;
        const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;
        const isNone = outputType === Transaction.SIGHASH_NONE;
        const isSingle = outputType === Transaction.SIGHASH_SINGLE;
        let hashPrevouts = EMPTY_BYTES;
        let hashAmounts = EMPTY_BYTES;
        let hashScriptPubKeys = EMPTY_BYTES;
        let hashSequences = EMPTY_BYTES;
        let hashOutputs = EMPTY_BYTES;
        // Use cache if provided (for SIGHASH_ALL, these are identical for all inputs)
        if (!isAnyoneCanPay) {
            if (taprootCache) {
                hashPrevouts = taprootCache.hashPrevouts;
                hashAmounts = taprootCache.hashAmounts;
                hashScriptPubKeys = taprootCache.hashScriptPubKeys;
                hashSequences = taprootCache.hashSequences;
            }
            else {
                let bufferWriter = new BinaryWriter$1(36 * this.ins.length);
                this.ins.forEach((txIn) => {
                    bufferWriter.writeBytes(txIn.hash);
                    bufferWriter.writeUInt32LE(txIn.index);
                });
                hashPrevouts = sha256$1(bufferWriter.finish());
                bufferWriter = new BinaryWriter$1(8 * this.ins.length);
                values.forEach((value) => bufferWriter.writeUInt64LE(value));
                hashAmounts = sha256$1(bufferWriter.finish());
                bufferWriter = new BinaryWriter$1(prevOutScripts.map(varSliceSize).reduce((a, b) => a + b));
                prevOutScripts.forEach((prevOutScript) => bufferWriter.writeVarBytes(prevOutScript));
                hashScriptPubKeys = sha256$1(bufferWriter.finish());
                bufferWriter = new BinaryWriter$1(4 * this.ins.length);
                this.ins.forEach((txIn) => bufferWriter.writeUInt32LE(txIn.sequence));
                hashSequences = sha256$1(bufferWriter.finish());
            }
        }
        if (!(isNone || isSingle)) {
            if (taprootCache) {
                hashOutputs = taprootCache.hashOutputs;
            }
            else {
                if (!this.outs.length)
                    throw new Error('Add outputs to the transaction before signing.');
                const txOutsSize = this.outs
                    .map((output) => 8 + varSliceSize(output.script))
                    .reduce((a, b) => a + b);
                const bufferWriter = new BinaryWriter$1(txOutsSize);
                this.outs.forEach((out) => {
                    bufferWriter.writeUInt64LE(out.value);
                    bufferWriter.writeVarBytes(out.script);
                });
                hashOutputs = sha256$1(bufferWriter.finish());
            }
        }
        else if (isSingle && inIndex < this.outs.length) {
            const output = this.outs[inIndex];
            const bufferWriter = new BinaryWriter$1(8 + varSliceSize(output.script));
            bufferWriter.writeUInt64LE(output.value);
            bufferWriter.writeVarBytes(output.script);
            hashOutputs = sha256$1(bufferWriter.finish());
        }
        const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
        // Length calculation from:
        // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14
        // With extension from:
        // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation
        const sigMsgSize = 174 -
            (isAnyoneCanPay ? 49 : 0) -
            (isNone ? 32 : 0) +
            (annex ? 32 : 0) +
            (leafHash ? 37 : 0);
        const sigMsgWriter = new BinaryWriter$1(sigMsgSize);
        sigMsgWriter.writeUInt8(hashType);
        // Transaction
        sigMsgWriter.writeInt32LE(this.version);
        sigMsgWriter.writeUInt32LE(this.locktime);
        sigMsgWriter.writeBytes(hashPrevouts);
        sigMsgWriter.writeBytes(hashAmounts);
        sigMsgWriter.writeBytes(hashScriptPubKeys);
        sigMsgWriter.writeBytes(hashSequences);
        if (!(isNone || isSingle)) {
            sigMsgWriter.writeBytes(hashOutputs);
        }
        // Input
        sigMsgWriter.writeUInt8(spendType);
        if (isAnyoneCanPay) {
            const input = this.ins[inIndex];
            sigMsgWriter.writeBytes(input.hash);
            sigMsgWriter.writeUInt32LE(input.index);
            sigMsgWriter.writeUInt64LE(values[inIndex]);
            sigMsgWriter.writeVarBytes(prevOutScripts[inIndex]);
            sigMsgWriter.writeUInt32LE(input.sequence);
        }
        else {
            sigMsgWriter.writeUInt32LE(inIndex);
        }
        if (annex) {
            const bufferWriter = new BinaryWriter$1(varSliceSize(annex));
            bufferWriter.writeVarBytes(annex);
            sigMsgWriter.writeBytes(sha256$1(bufferWriter.finish()));
        }
        // Output
        if (isSingle) {
            sigMsgWriter.writeBytes(hashOutputs);
        }
        // BIP342 extension
        if (leafHash) {
            sigMsgWriter.writeBytes(leafHash);
            sigMsgWriter.writeUInt8(0);
            sigMsgWriter.writeUInt32LE(0xffffffff);
        }
        // Extra zero byte because:
        // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19
        const prefix = new Uint8Array([0x00]);
        const sigMsg = sigMsgWriter.finish();
        const combined = new Uint8Array(1 + sigMsg.length);
        combined.set(prefix);
        combined.set(sigMsg, 1);
        return toMessageHash(taggedHash('TapSighash', combined));
    }
    /**
     * Pre-compute intermediate hashes for Taproot signing.
     * Call this once before signing multiple inputs to avoid O(n^2) performance.
     *
     * @param prevOutScripts - Array of previous output scripts for all inputs
     * @param values - Array of previous output values for all inputs
     * @returns Cache object to pass to hashForWitnessV1
     */
    getTaprootHashCache(prevOutScripts, values) {
        // hashPrevouts
        let bufferWriter = new BinaryWriter$1(36 * this.ins.length);
        for (const txIn of this.ins) {
            bufferWriter.writeBytes(txIn.hash);
            bufferWriter.writeUInt32LE(txIn.index);
        }
        const hashPrevouts = sha256$1(bufferWriter.finish());
        // hashAmounts
        bufferWriter = new BinaryWriter$1(8 * values.length);
        for (const value of values) {
            bufferWriter.writeUInt64LE(value);
        }
        const hashAmounts = sha256$1(bufferWriter.finish());
        // hashScriptPubKeys - compute size without intermediate array
        let scriptPubKeysSize = 0;
        for (const script of prevOutScripts) {
            scriptPubKeysSize += varSliceSize(script);
        }
        bufferWriter = new BinaryWriter$1(scriptPubKeysSize);
        for (const script of prevOutScripts) {
            bufferWriter.writeVarBytes(script);
        }
        const hashScriptPubKeys = sha256$1(bufferWriter.finish());
        // hashSequences
        bufferWriter = new BinaryWriter$1(4 * this.ins.length);
        for (const txIn of this.ins) {
            bufferWriter.writeUInt32LE(txIn.sequence);
        }
        const hashSequences = sha256$1(bufferWriter.finish());
        // hashOutputs - compute size without intermediate array
        let txOutsSize = 0;
        for (const out of this.outs) {
            txOutsSize += 8 + varSliceSize(out.script);
        }
        bufferWriter = new BinaryWriter$1(txOutsSize);
        for (const out of this.outs) {
            bufferWriter.writeUInt64LE(out.value);
            bufferWriter.writeVarBytes(out.script);
        }
        const hashOutputs = this.outs.length ? sha256$1(bufferWriter.finish()) : ZERO$1;
        return { hashPrevouts, hashAmounts, hashScriptPubKeys, hashSequences, hashOutputs };
    }
    /**
     * Hash transaction for signing a SegWit v0 (P2WPKH/P2WSH) input.
     *
     * @param inIndex - Index of the input being signed
     * @param prevOutScript - The script of the output being spent
     * @param value - Value of the output being spent (bigint satoshis)
     * @param hashType - Signature hash type
     * @returns 32-byte hash for signing
     */
    hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
        if (!Number.isInteger(inIndex) || inIndex < 0 || inIndex > 0xffffffff) {
            throw new TypeError('Expected unsigned 32-bit integer for inIndex');
        }
        if (!(prevOutScript instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array for prevOutScript');
        }
        if (typeof value !== 'bigint') {
            throw new TypeError('Expected bigint for value');
        }
        if (!Number.isInteger(hashType) || hashType < 0 || hashType > 0xffffffff) {
            throw new TypeError('Expected unsigned 32-bit integer for hashType');
        }
        let tbuffer;
        let bufferWriter;
        let hashOutputs = ZERO$1;
        let hashPrevouts = ZERO$1;
        let hashSequence = ZERO$1;
        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
            tbuffer = alloc(36 * this.ins.length);
            bufferWriter = new BinaryWriter$1(tbuffer, 0);
            this.ins.forEach((txIn) => {
                bufferWriter.writeBytes(txIn.hash);
                bufferWriter.writeUInt32LE(txIn.index);
            });
            hashPrevouts = hash256(tbuffer);
        }
        if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) &&
            (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
            (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
            tbuffer = alloc(4 * this.ins.length);
            bufferWriter = new BinaryWriter$1(tbuffer, 0);
            this.ins.forEach((txIn) => {
                bufferWriter.writeUInt32LE(txIn.sequence);
            });
            hashSequence = hash256(tbuffer);
        }
        if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&
            (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
            const txOutsSize = this.outs.reduce((sum, output) => {
                return sum + 8 + varSliceSize(output.script);
            }, 0);
            tbuffer = alloc(txOutsSize);
            bufferWriter = new BinaryWriter$1(tbuffer, 0);
            this.outs.forEach((out) => {
                bufferWriter.writeUInt64LE(out.value);
                bufferWriter.writeVarBytes(out.script);
            });
            hashOutputs = hash256(tbuffer);
        }
        else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
            const output = this.outs[inIndex];
            tbuffer = alloc(8 + varSliceSize(output.script));
            bufferWriter = new BinaryWriter$1(tbuffer, 0);
            bufferWriter.writeUInt64LE(output.value);
            bufferWriter.writeVarBytes(output.script);
            hashOutputs = hash256(tbuffer);
        }
        tbuffer = alloc(156 + varSliceSize(prevOutScript));
        bufferWriter = new BinaryWriter$1(tbuffer, 0);
        const input = this.ins[inIndex];
        bufferWriter.writeInt32LE(this.version);
        bufferWriter.writeBytes(hashPrevouts);
        bufferWriter.writeBytes(hashSequence);
        bufferWriter.writeBytes(input.hash);
        bufferWriter.writeUInt32LE(input.index);
        bufferWriter.writeVarBytes(prevOutScript);
        bufferWriter.writeUInt64LE(value);
        bufferWriter.writeUInt32LE(input.sequence);
        bufferWriter.writeBytes(hashOutputs);
        bufferWriter.writeUInt32LE(this.locktime);
        bufferWriter.writeUInt32LE(hashType);
        return toMessageHash(hash256(tbuffer));
    }
    /**
     * Get the transaction hash.
     *
     * @param forWitness - If true, include witness data (wtxid)
     * @returns 32-byte transaction hash
     */
    getHash(forWitness) {
        // wtxid for coinbase is always 32 bytes of 0x00
        if (forWitness && this.isCoinbase())
            return new Uint8Array(32);
        return hash256(this.#toBuffer(undefined, undefined, forWitness));
    }
    /**
     * Get the transaction ID (txid) as a hex string.
     *
     * @returns Transaction ID in reversed hex format
     */
    getId() {
        // transaction hash's are displayed in reverse order
        return toHex$1(reverse(this.getHash(false)));
    }
    /**
     * Serialize the transaction to a Uint8Array buffer.
     *
     * @param buffer - Optional pre-allocated buffer
     * @param initialOffset - Optional starting offset in buffer
     * @returns Serialized transaction bytes
     */
    toBuffer(buffer, initialOffset) {
        return this.#toBuffer(buffer, initialOffset, true);
    }
    /**
     * Serialize the transaction to a hex string.
     *
     * @returns Transaction as hex string
     */
    toHex() {
        return toHex$1(this.toBuffer(undefined, undefined));
    }
    /**
     * Set the input script for a specific input.
     *
     * @param index - Input index
     * @param scriptSig - The script to set
     */
    setInputScript(index, scriptSig) {
        if (!Number.isInteger(index) || index < 0) {
            throw new TypeError('Expected non-negative integer for index');
        }
        if (!(scriptSig instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array for scriptSig');
        }
        this.ins[index].script = scriptSig;
    }
    /**
     * Set the witness data for a specific input.
     *
     * @param index - Input index
     * @param witness - Array of witness elements
     */
    setWitness(index, witness) {
        if (!Number.isInteger(index) || index < 0) {
            throw new TypeError('Expected non-negative integer for index');
        }
        if (!Array.isArray(witness) || !witness.every((w) => w instanceof Uint8Array)) {
            throw new TypeError('Expected array of Uint8Array for witness');
        }
        this.ins[index].witness = witness;
    }
    /**
     * Internal method to serialize the transaction.
     *
     * @param buffer - Optional pre-allocated buffer
     * @param initialOffset - Optional starting offset
     * @param _ALLOW_WITNESS - Whether to include witness data
     * @returns Serialized transaction bytes
     */
    #toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
        if (!buffer)
            buffer = alloc(this.byteLength(_ALLOW_WITNESS));
        const bufferWriter = new BinaryWriter$1(buffer, initialOffset || 0);
        bufferWriter.writeInt32LE(this.version);
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        if (hasWitnesses) {
            bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
            bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
        }
        bufferWriter.writeVarInt(this.ins.length);
        this.ins.forEach((txIn) => {
            bufferWriter.writeBytes(txIn.hash);
            bufferWriter.writeUInt32LE(txIn.index);
            bufferWriter.writeVarBytes(txIn.script);
            bufferWriter.writeUInt32LE(txIn.sequence);
        });
        bufferWriter.writeVarInt(this.outs.length);
        this.outs.forEach((txOut) => {
            bufferWriter.writeUInt64LE(txOut.value);
            bufferWriter.writeVarBytes(txOut.script);
        });
        if (hasWitnesses) {
            this.ins.forEach((input) => {
                bufferWriter.writeVector(input.witness);
            });
        }
        bufferWriter.writeUInt32LE(this.locktime);
        // avoid slicing unless necessary
        if (initialOffset !== undefined)
            return buffer.subarray(initialOffset, bufferWriter.offset);
        return buffer;
    }
}

var GlobalTypes;
(function(GlobalTypes2) {
  GlobalTypes2[GlobalTypes2["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
  GlobalTypes2[GlobalTypes2["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
})(GlobalTypes || (GlobalTypes = {}));
var InputTypes;
(function(InputTypes2) {
  InputTypes2[InputTypes2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
  InputTypes2[InputTypes2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
  InputTypes2[InputTypes2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
  InputTypes2[InputTypes2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
  InputTypes2[InputTypes2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
  InputTypes2[InputTypes2["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
  InputTypes2[InputTypes2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
  InputTypes2[InputTypes2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
  InputTypes2[InputTypes2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
  InputTypes2[InputTypes2["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
  InputTypes2[InputTypes2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
  InputTypes2[InputTypes2["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
  InputTypes2[InputTypes2["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
  InputTypes2[InputTypes2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
  InputTypes2[InputTypes2["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
  InputTypes2[InputTypes2["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
})(InputTypes || (InputTypes = {}));
var OutputTypes;
(function(OutputTypes2) {
  OutputTypes2[OutputTypes2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
  OutputTypes2[OutputTypes2["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
  OutputTypes2[OutputTypes2["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
  OutputTypes2[OutputTypes2["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
  OutputTypes2[OutputTypes2["TAP_TREE"] = 6] = "TAP_TREE";
  OutputTypes2[OutputTypes2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
})(OutputTypes || (OutputTypes = {}));

const HEX_STRINGS = "0123456789abcdefABCDEF";
const HEX_CODES = HEX_STRINGS.split("").map((c) => c.codePointAt(0));
const HEX_CODEPOINTS = Array(256)
    .fill(true)
    .map((_, i) => {
    const s = String.fromCodePoint(i);
    const index = HEX_STRINGS.indexOf(s);
    // ABCDEF will use 10 - 15
    return index < 0 ? undefined : index < 16 ? index : index - 6;
});
const ENCODER = new TextEncoder();
const DECODER = new TextDecoder();
function toUtf8(bytes) {
    return DECODER.decode(bytes);
}
function fromUtf8(s) {
    return ENCODER.encode(s);
}
function concat(arrays) {
    const totalLength = arrays.reduce((a, b) => a + b.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays) {
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}
// There are two implementations.
// One optimizes for length of the bytes, and uses TextDecoder.
// One optimizes for iteration count, and appends strings.
// This removes the overhead of TextDecoder.
function toHex(bytes) {
    const b = bytes || new Uint8Array();
    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);
}
function _toHexIterPerf(bytes) {
    let s = "";
    for (let i = 0; i < bytes.length; ++i) {
        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];
        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];
    }
    return s;
}
function _toHexLengthPerf(bytes) {
    const hexBytes = new Uint8Array(bytes.length * 2);
    for (let i = 0; i < bytes.length; ++i) {
        hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];
        hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];
    }
    return DECODER.decode(hexBytes);
}
// Mimics Buffer.from(x, 'hex') logic
// Stops on first non-hex string and returns
// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261
function fromHex(hexString) {
    const hexBytes = ENCODER.encode(hexString || "");
    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));
    let i;
    for (i = 0; i < resultBytes.length; i++) {
        const a = HEX_CODEPOINTS[hexBytes[i * 2]];
        const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];
        if (a === undefined || b === undefined) {
            break;
        }
        resultBytes[i] = (a << 4) | b;
    }
    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);
}
function toBase64(bytes) {
    return btoa(String.fromCharCode(...bytes));
}
function fromBase64(base64) {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
}
// Same behavior as Buffer.compare()
function compare$1(v1, v2) {
    const minLength = Math.min(v1.length, v2.length);
    for (let i = 0; i < minLength; ++i) {
        if (v1[i] !== v2[i]) {
            return v1[i] < v2[i] ? -1 : 1;
        }
    }
    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;
}
function writeUInt8(buffer, offset, value) {
    if (offset + 1 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0xff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xff}. Received ${value}`);
    }
    buffer[offset] = value;
    return offset + 1;
}
function writeUInt16(buffer, offset, value, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffff}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
    }
    else {
        buffer[offset] = (value >> 8) & 0xff;
        buffer[offset + 1] = value & 0xff;
    }
    return offset + 2;
}
function writeUInt32(buffer, offset, value, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffffffff) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffff}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
        buffer[offset + 2] = (value >> 16) & 0xff;
        buffer[offset + 3] = (value >> 24) & 0xff;
    }
    else {
        buffer[offset] = (value >> 24) & 0xff;
        buffer[offset + 1] = (value >> 16) & 0xff;
        buffer[offset + 2] = (value >> 8) & 0xff;
        buffer[offset + 3] = value & 0xff;
    }
    return offset + 4;
}
function writeUInt64(buffer, offset, value, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (value > 0xffffffffffffffffn) {
        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);
    }
    if (littleEndian === "LE") {
        buffer[offset] = Number(value & 0xffn);
        buffer[offset + 1] = Number((value >> 8n) & 0xffn);
        buffer[offset + 2] = Number((value >> 16n) & 0xffn);
        buffer[offset + 3] = Number((value >> 24n) & 0xffn);
        buffer[offset + 4] = Number((value >> 32n) & 0xffn);
        buffer[offset + 5] = Number((value >> 40n) & 0xffn);
        buffer[offset + 6] = Number((value >> 48n) & 0xffn);
        buffer[offset + 7] = Number((value >> 56n) & 0xffn);
    }
    else {
        buffer[offset] = Number((value >> 56n) & 0xffn);
        buffer[offset + 1] = Number((value >> 48n) & 0xffn);
        buffer[offset + 2] = Number((value >> 40n) & 0xffn);
        buffer[offset + 3] = Number((value >> 32n) & 0xffn);
        buffer[offset + 4] = Number((value >> 24n) & 0xffn);
        buffer[offset + 5] = Number((value >> 16n) & 0xffn);
        buffer[offset + 6] = Number((value >> 8n) & 0xffn);
        buffer[offset + 7] = Number(value & 0xffn);
    }
    return offset + 8;
}
function readUInt8(buffer, offset) {
    if (offset + 1 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    return buffer[offset];
}
function readUInt16(buffer, offset, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0;
        num = (num << 8) + buffer[offset + 1];
        num = (num << 8) + buffer[offset];
        return num;
    }
    else {
        let num = 0;
        num = (num << 8) + buffer[offset];
        num = (num << 8) + buffer[offset + 1];
        return num;
    }
}
function readUInt32(buffer, offset, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0;
        num = ((num << 8) + buffer[offset + 3]) >>> 0;
        num = ((num << 8) + buffer[offset + 2]) >>> 0;
        num = ((num << 8) + buffer[offset + 1]) >>> 0;
        num = ((num << 8) + buffer[offset]) >>> 0;
        return num;
    }
    else {
        let num = 0;
        num = ((num << 8) + buffer[offset]) >>> 0;
        num = ((num << 8) + buffer[offset + 1]) >>> 0;
        num = ((num << 8) + buffer[offset + 2]) >>> 0;
        num = ((num << 8) + buffer[offset + 3]) >>> 0;
        return num;
    }
}
function readUInt64(buffer, offset, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset]);
        return num;
    }
    else {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        return num;
    }
}
function writeInt8(buffer, offset, value) {
    if (offset + 1 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0x7f || value < -128) {
        throw new Error(`The value of "value" is out of range. It must be >= ${ -128} and <= ${0x7f}. Received ${value}`);
    }
    buffer[offset] = value;
    return offset + 1;
}
function writeInt16(buffer, offset, value, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0x7fff || value < -32768) {
        throw new Error(`The value of "value" is out of range. It must be >= ${ -32768} and <= ${0x7fff}. Received ${value}`);
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
    }
    else {
        buffer[offset] = (value >> 8) & 0xff;
        buffer[offset + 1] = value & 0xff;
    }
    return offset + 2;
}
function writeInt32(buffer, offset, value, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0x7fffffff || value < -2147483648) {
        throw new Error(`The value of "value" is out of range. It must be >= ${ -2147483648} and <= ${0x7fffffff}. Received ${value}`);
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        buffer[offset] = value & 0xff;
        buffer[offset + 1] = (value >> 8) & 0xff;
        buffer[offset + 2] = (value >> 16) & 0xff;
        buffer[offset + 3] = (value >> 24) & 0xff;
    }
    else {
        buffer[offset] = (value >> 24) & 0xff;
        buffer[offset + 1] = (value >> 16) & 0xff;
        buffer[offset + 2] = (value >> 8) & 0xff;
        buffer[offset + 3] = value & 0xff;
    }
    return offset + 4;
}
function writeInt64(buffer, offset, value, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    if (value > 0x7fffffffffffffffn || value < -0x8000000000000000n) {
        throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${value}`);
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        buffer[offset] = Number(value & 0xffn);
        buffer[offset + 1] = Number((value >> 8n) & 0xffn);
        buffer[offset + 2] = Number((value >> 16n) & 0xffn);
        buffer[offset + 3] = Number((value >> 24n) & 0xffn);
        buffer[offset + 4] = Number((value >> 32n) & 0xffn);
        buffer[offset + 5] = Number((value >> 40n) & 0xffn);
        buffer[offset + 6] = Number((value >> 48n) & 0xffn);
        buffer[offset + 7] = Number((value >> 56n) & 0xffn);
    }
    else {
        buffer[offset] = Number((value >> 56n) & 0xffn);
        buffer[offset + 1] = Number((value >> 48n) & 0xffn);
        buffer[offset + 2] = Number((value >> 40n) & 0xffn);
        buffer[offset + 3] = Number((value >> 32n) & 0xffn);
        buffer[offset + 4] = Number((value >> 24n) & 0xffn);
        buffer[offset + 5] = Number((value >> 16n) & 0xffn);
        buffer[offset + 6] = Number((value >> 8n) & 0xffn);
        buffer[offset + 7] = Number(value & 0xffn);
    }
    return offset + 8;
}
function readInt8(buffer, offset) {
    if (offset + 1 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    const val = buffer[offset];
    if (val <= 0x7f) {
        return val;
    }
    else {
        return val - 0x100;
    }
}
function readInt16(buffer, offset, littleEndian) {
    if (offset + 2 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        const val = buffer[offset] + (buffer[offset + 1] << 8);
        return buffer[offset + 1] <= 0x7f ? val : val - 0x10000;
    }
    else {
        const val = (buffer[offset] << 8) + buffer[offset + 1];
        return buffer[offset] <= 0x7f ? val : val - 0x10000;
    }
}
function readInt32(buffer, offset, littleEndian) {
    if (offset + 4 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    if (littleEndian === "LE") {
        const val = buffer[offset] +
            (buffer[offset + 1] << 8) +
            (buffer[offset + 2] << 16) +
            ((buffer[offset + 3] << 24) >>> 0);
        return buffer[offset + 3] <= 0x7f ? val : val - 0x100000000;
    }
    else {
        const val = ((buffer[offset] << 24) >>> 0) +
            (buffer[offset + 1] << 16) +
            (buffer[offset + 2] << 8) +
            buffer[offset + 3];
        return buffer[offset] <= 0x7f ? val : val - 0x100000000;
    }
}
function readInt64(buffer, offset, littleEndian) {
    if (offset + 8 > buffer.length) {
        throw new Error("Offset is outside the bounds of Uint8Array");
    }
    littleEndian = littleEndian.toUpperCase();
    let num = 0n;
    if (littleEndian === "LE") {
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset]);
        return buffer[offset + 7] <= 0x7f ? num : num - 0x10000000000000000n;
    }
    else {
        let num = 0n;
        num = (num << 8n) + BigInt(buffer[offset]);
        num = (num << 8n) + BigInt(buffer[offset + 1]);
        num = (num << 8n) + BigInt(buffer[offset + 2]);
        num = (num << 8n) + BigInt(buffer[offset + 3]);
        num = (num << 8n) + BigInt(buffer[offset + 4]);
        num = (num << 8n) + BigInt(buffer[offset + 5]);
        num = (num << 8n) + BigInt(buffer[offset + 6]);
        num = (num << 8n) + BigInt(buffer[offset + 7]);
        return buffer[offset] <= 0x7f ? num : num - 0x10000000000000000n;
    }
}

const browser$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    compare: compare$1,
    concat,
    fromBase64,
    fromHex,
    fromUtf8,
    readInt16,
    readInt32,
    readInt64,
    readInt8,
    readUInt16,
    readUInt32,
    readUInt64,
    readUInt8,
    toBase64,
    toHex,
    toUtf8,
    writeInt16,
    writeInt32,
    writeInt64,
    writeInt8,
    writeUInt16,
    writeUInt32,
    writeUInt64,
    writeUInt8
}, Symbol.toStringTag, { value: 'Module' }));

const range$4 = (n) => [...Array(n).keys()];
function decode$d(keyVal) {
  if (keyVal.key[0] !== GlobalTypes.GLOBAL_XPUB) {
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + toHex(keyVal.key)
    );
  }
  if (keyVal.value.length / 4 % 1 !== 0) {
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  }
  const extendedPubkey = keyVal.key.slice(1);
  const data = {
    masterFingerprint: keyVal.value.slice(0, 4),
    extendedPubkey,
    path: "m"
  };
  for (const i of range$4(keyVal.value.length / 4 - 1)) {
    const val = readUInt32(keyVal.value, i * 4 + 4, "LE");
    const isHard = !!(val & 2147483648);
    const idx = val & 2147483647;
    data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
  }
  return data;
}
function encode$e(data) {
  const head = new Uint8Array([GlobalTypes.GLOBAL_XPUB]);
  const key = concat([head, data.extendedPubkey]);
  const splitPath = data.path.split("/");
  const value = new Uint8Array(splitPath.length * 4);
  value.set(data.masterFingerprint, 0);
  let offset = 4;
  splitPath.slice(1).forEach((level) => {
    const isHard = level.slice(-1) === "'";
    let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
    if (isHard) num += 2147483648;
    writeUInt32(value, offset, num, "LE");
    offset += 4;
  });
  return {
    key,
    value
  };
}
const expected$c = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function check$c(data) {
  const epk = data.extendedPubkey;
  const mfp = data.masterFingerprint;
  const p = data.path;
  return epk instanceof Uint8Array && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && mfp instanceof Uint8Array && mfp.length === 4 && typeof p === "string" && !!p.match(/^m(\/\d+'?)*$/);
}
function canAddToArray$3(array, item, dupeSet) {
  const dupeString = toHex(item.extendedPubkey);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return array.filter((v) => compare$1(v.extendedPubkey, item.extendedPubkey)).length === 0;
}

const globalXpub = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAddToArray: canAddToArray$3,
    check: check$c,
    decode: decode$d,
    encode: encode$e,
    expected: expected$c
}, Symbol.toStringTag, { value: 'Module' }));

function encode$d(data) {
  return {
    key: new Uint8Array([GlobalTypes.UNSIGNED_TX]),
    value: data.toBuffer(),
  };
}

const unsignedTx = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    encode: encode$d
}, Symbol.toStringTag, { value: 'Module' }));

function decode$c(keyVal) {
  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTSIG) {
    throw new Error(
      'Decode Error: could not decode finalScriptSig with key 0x' +
        toHex(keyVal.key),
    );
  }
  return keyVal.value;
}
function encode$c(data) {
  const key = new Uint8Array([InputTypes.FINAL_SCRIPTSIG]);
  return {
    key,
    value: data,
  };
}
const expected$b = 'Uint8Array';
function check$b(data) {
  return data instanceof Uint8Array;
}
function canAdd$8(currentData, newData) {
  return !!currentData && !!newData && currentData.finalScriptSig === undefined;
}

const finalScriptSig = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAdd: canAdd$8,
    check: check$b,
    decode: decode$c,
    encode: encode$c,
    expected: expected$b
}, Symbol.toStringTag, { value: 'Module' }));

function decode$b(keyVal) {
  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTWITNESS) {
    throw new Error(
      'Decode Error: could not decode finalScriptWitness with key 0x' +
        toHex(keyVal.key),
    );
  }
  return keyVal.value;
}
function encode$b(data) {
  const key = new Uint8Array([InputTypes.FINAL_SCRIPTWITNESS]);
  return {
    key,
    value: data,
  };
}
const expected$a = 'Uint8Array';
function check$a(data) {
  return data instanceof Uint8Array;
}
function canAdd$7(currentData, newData) {
  return (
    !!currentData && !!newData && currentData.finalScriptWitness === undefined
  );
}

const finalScriptWitness = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAdd: canAdd$7,
    check: check$a,
    decode: decode$b,
    encode: encode$b,
    expected: expected$a
}, Symbol.toStringTag, { value: 'Module' }));

function decode$a(keyVal) {
  if (keyVal.key[0] !== InputTypes.NON_WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode nonWitnessUtxo with key 0x' +
        toHex(keyVal.key),
    );
  }
  return keyVal.value;
}
function encode$a(data) {
  return {
    key: new Uint8Array([InputTypes.NON_WITNESS_UTXO]),
    value: data,
  };
}
const expected$9 = 'Uint8Array';
function check$9(data) {
  return data instanceof Uint8Array;
}
function canAdd$6(currentData, newData) {
  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;
}

const nonWitnessUtxo = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAdd: canAdd$6,
    check: check$9,
    decode: decode$a,
    encode: encode$a,
    expected: expected$9
}, Symbol.toStringTag, { value: 'Module' }));

function decode$9(keyVal) {
  if (keyVal.key[0] !== InputTypes.PARTIAL_SIG) {
    throw new Error(
      'Decode Error: could not decode partialSig with key 0x' +
        toHex(keyVal.key),
    );
  }
  if (
    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||
    ![2, 3, 4].includes(keyVal.key[1])
  ) {
    throw new Error(
      'Decode Error: partialSig has invalid pubkey in key 0x' +
        toHex(keyVal.key),
    );
  }
  const pubkey = keyVal.key.slice(1);
  return {
    pubkey,
    signature: keyVal.value,
  };
}
function encode$9(pSig) {
  const head = new Uint8Array([InputTypes.PARTIAL_SIG]);
  return {
    key: concat([head, pSig.pubkey]),
    value: pSig.signature,
  };
}
const expected$8 = '{ pubkey: Uint8Array; signature: Uint8Array; }';
function check$8(data) {
  return (
    data.pubkey instanceof Uint8Array &&
    data.signature instanceof Uint8Array &&
    [33, 65].includes(data.pubkey.length) &&
    [2, 3, 4].includes(data.pubkey[0]) &&
    isDerSigWithSighash(data.signature)
  );
}
function isDerSigWithSighash(buf) {
  if (!(buf instanceof Uint8Array) || buf.length < 9) return false;
  if (buf[0] !== 0x30) return false;
  if (buf.length !== buf[1] + 3) return false;
  if (buf[2] !== 0x02) return false;
  const rLen = buf[3];
  if (rLen > 33 || rLen < 1) return false;
  if (buf[3 + rLen + 1] !== 0x02) return false;
  const sLen = buf[3 + rLen + 2];
  if (sLen > 33 || sLen < 1) return false;
  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
  return true;
}
function canAddToArray$2(array, item, dupeSet) {
  const dupeString = toHex(item.pubkey);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(v => compare$1(v.pubkey, item.pubkey) === 0).length === 0
  );
}

const partialSig = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAddToArray: canAddToArray$2,
    check: check$8,
    decode: decode$9,
    encode: encode$9,
    expected: expected$8
}, Symbol.toStringTag, { value: 'Module' }));

function decode$8(keyVal) {
  if (keyVal.key[0] !== InputTypes.POR_COMMITMENT) {
    throw new Error(
      'Decode Error: could not decode porCommitment with key 0x' +
        toHex(keyVal.key),
    );
  }
  return toUtf8(keyVal.value);
}
function encode$8(data) {
  const key = new Uint8Array([InputTypes.POR_COMMITMENT]);
  return {
    key,
    value: fromUtf8(data),
  };
}
const expected$7 = 'string';
function check$7(data) {
  return typeof data === 'string';
}
function canAdd$5(currentData, newData) {
  return !!currentData && !!newData && currentData.porCommitment === undefined;
}

const porCommitment = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAdd: canAdd$5,
    check: check$7,
    decode: decode$8,
    encode: encode$8,
    expected: expected$7
}, Symbol.toStringTag, { value: 'Module' }));

function decode$7(keyVal) {
  if (keyVal.key[0] !== InputTypes.SIGHASH_TYPE) {
    throw new Error(
      'Decode Error: could not decode sighashType with key 0x' +
        toHex(keyVal.key),
    );
  }
  return Number(readUInt32(keyVal.value, 0, 'LE'));
}
function encode$7(data) {
  const key = Uint8Array.from([InputTypes.SIGHASH_TYPE]);
  const value = new Uint8Array(4);
  writeUInt32(value, 0, data, 'LE');
  return {
    key,
    value,
  };
}
const expected$6 = 'number';
function check$6(data) {
  return typeof data === 'number';
}
function canAdd$4(currentData, newData) {
  return !!currentData && !!newData && currentData.sighashType === undefined;
}

const sighashType = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAdd: canAdd$4,
    check: check$6,
    decode: decode$7,
    encode: encode$7,
    expected: expected$6
}, Symbol.toStringTag, { value: 'Module' }));

function decode$6(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
    throw new Error(
      'Decode Error: could not decode tapKeySig with key 0x' +
        toHex(keyVal.key),
    );
  }
  if (!check$5(keyVal.value)) {
    throw new Error(
      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',
    );
  }
  return keyVal.value;
}
function encode$6(value) {
  const key = Uint8Array.from([InputTypes.TAP_KEY_SIG]);
  return { key, value };
}
const expected$5 = 'Uint8Array';
function check$5(data) {
  return (
    data instanceof Uint8Array && (data.length === 64 || data.length === 65)
  );
}
function canAdd$3(currentData, newData) {
  return !!currentData && !!newData && currentData.tapKeySig === undefined;
}

const tapKeySig = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAdd: canAdd$3,
    check: check$5,
    decode: decode$6,
    encode: encode$6,
    expected: expected$5
}, Symbol.toStringTag, { value: 'Module' }));

function decode$5(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_LEAF_SCRIPT) {
    throw new Error(
      'Decode Error: could not decode tapLeafScript with key 0x' +
        toHex(keyVal.key),
    );
  }
  if ((keyVal.key.length - 2) % 32 !== 0) {
    throw new Error(
      'Decode Error: tapLeafScript has invalid control block in key 0x' +
        toHex(keyVal.key),
    );
  }
  const leafVersion = keyVal.value[keyVal.value.length - 1];
  if ((keyVal.key[1] & 0xfe) !== leafVersion) {
    throw new Error(
      'Decode Error: tapLeafScript bad leaf version in key 0x' +
        toHex(keyVal.key),
    );
  }
  const script = keyVal.value.slice(0, -1);
  const controlBlock = keyVal.key.slice(1);
  return { controlBlock, script, leafVersion };
}
function encode$5(tScript) {
  const head = Uint8Array.from([InputTypes.TAP_LEAF_SCRIPT]);
  const verBuf = Uint8Array.from([tScript.leafVersion]);
  return {
    key: concat([head, tScript.controlBlock]),
    value: concat([tScript.script, verBuf]),
  };
}
const expected$4 =
  '{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }';
function check$4(data) {
  return (
    data.controlBlock instanceof Uint8Array &&
    (data.controlBlock.length - 1) % 32 === 0 &&
    (data.controlBlock[0] & 0xfe) === data.leafVersion &&
    data.script instanceof Uint8Array
  );
}
function canAddToArray$1(array, item, dupeSet) {
  const dupeString = toHex(item.controlBlock);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(v => compare$1(v.controlBlock, item.controlBlock) === 0)
      .length === 0
  );
}

const tapLeafScript = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAddToArray: canAddToArray$1,
    check: check$4,
    decode: decode$5,
    encode: encode$5,
    expected: expected$4
}, Symbol.toStringTag, { value: 'Module' }));

function decode$4(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
    throw new Error(
      'Decode Error: could not decode tapMerkleRoot with key 0x' +
        toHex(keyVal.key),
    );
  }
  if (!check$3(keyVal.value)) {
    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');
  }
  return keyVal.value;
}
function encode$4(value) {
  const key = Uint8Array.from([InputTypes.TAP_MERKLE_ROOT]);
  return { key, value };
}
const expected$3 = 'Uint8Array';
function check$3(data) {
  return data instanceof Uint8Array && data.length === 32;
}
function canAdd$2(currentData, newData) {
  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;
}

const tapMerkleRoot = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAdd: canAdd$2,
    check: check$3,
    decode: decode$4,
    encode: encode$4,
    expected: expected$3
}, Symbol.toStringTag, { value: 'Module' }));

function decode$3(keyVal) {
  if (keyVal.key[0] !== InputTypes.TAP_SCRIPT_SIG) {
    throw new Error(
      'Decode Error: could not decode tapScriptSig with key 0x' +
        toHex(keyVal.key),
    );
  }
  if (keyVal.key.length !== 65) {
    throw new Error(
      'Decode Error: tapScriptSig has invalid key 0x' + toHex(keyVal.key),
    );
  }
  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
    throw new Error(
      'Decode Error: tapScriptSig has invalid signature in key 0x' +
        toHex(keyVal.key),
    );
  }
  const pubkey = keyVal.key.slice(1, 33);
  const leafHash = keyVal.key.slice(33);
  return {
    pubkey,
    leafHash,
    signature: keyVal.value,
  };
}
function encode$3(tSig) {
  const head = Uint8Array.from([InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: concat([head, tSig.pubkey, tSig.leafHash]),
    value: tSig.signature,
  };
}
const expected$2 =
  '{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }';
function check$2(data) {
  return (
    data.pubkey instanceof Uint8Array &&
    data.leafHash instanceof Uint8Array &&
    data.signature instanceof Uint8Array &&
    data.pubkey.length === 32 &&
    data.leafHash.length === 32 &&
    (data.signature.length === 64 || data.signature.length === 65)
  );
}
function canAddToArray(array, item, dupeSet) {
  const dupeString = toHex(item.pubkey) + toHex(item.leafHash);
  if (dupeSet.has(dupeString)) return false;
  dupeSet.add(dupeString);
  return (
    array.filter(
      v =>
        compare$1(v.pubkey, item.pubkey) === 0 &&
        compare$1(v.leafHash, item.leafHash) === 0,
    ).length === 0
  );
}

const tapScriptSig = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAddToArray,
    check: check$2,
    decode: decode$3,
    encode: encode$3,
    expected: expected$2
}, Symbol.toStringTag, { value: 'Module' }));

function decode$2(keyVal) {
  if (keyVal.key[0] !== InputTypes.WITNESS_UTXO) {
    throw new Error(
      'Decode Error: could not decode witnessUtxo with key 0x' +
        toHex(keyVal.key),
    );
  }
  const value = readInt64(keyVal.value, 0, 'LE');
  let _offset = 8;
  const { numberValue: scriptLen, bytes } = decode$j(
    keyVal.value,
    _offset,
  );
  _offset += bytes;
  const script = keyVal.value.slice(_offset);
  if (script.length !== scriptLen) {
    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');
  }
  return {
    script,
    value,
  };
}
function encode$2(data) {
  const { script, value } = data;
  const varuintlen = encodingLength$1(script.length);
  const result = new Uint8Array(8 + varuintlen + script.length);
  writeInt64(result, 0, BigInt(value), 'LE');
  encode$k(script.length, result, 8);
  result.set(script, 8 + varuintlen);
  return {
    key: Uint8Array.from([InputTypes.WITNESS_UTXO]),
    value: result,
  };
}
const expected$1 = '{ script: Uint8Array; value: bigint; }';
function check$1(data) {
  return data.script instanceof Uint8Array && typeof data.value === 'bigint';
}
function canAdd$1(currentData, newData) {
  return !!currentData && !!newData && currentData.witnessUtxo === undefined;
}

const witnessUtxo = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAdd: canAdd$1,
    check: check$1,
    decode: decode$2,
    encode: encode$2,
    expected: expected$1
}, Symbol.toStringTag, { value: 'Module' }));

function decode$1(keyVal) {
  if (keyVal.key[0] !== OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
    throw new Error(
      'Decode Error: could not decode tapTree with key 0x' +
        toHex(keyVal.key),
    );
  }
  let _offset = 0;
  const data = [];
  while (_offset < keyVal.value.length) {
    const depth = keyVal.value[_offset++];
    const leafVersion = keyVal.value[_offset++];
    const { numberValue: scriptLen, bytes } = decode$j(
      keyVal.value,
      _offset,
    );
    _offset += bytes;
    data.push({
      depth,
      leafVersion,
      script: keyVal.value.slice(_offset, _offset + scriptLen),
    });
    _offset += scriptLen;
  }
  return { leaves: data };
}
function encode$1(tree) {
  const key = Uint8Array.from([OutputTypes.TAP_TREE]);
  const bufs = [].concat(
    ...tree.leaves.map(tapLeaf => [
      Uint8Array.of(tapLeaf.depth, tapLeaf.leafVersion),
      encode$k(BigInt(tapLeaf.script.length)).buffer,
      tapLeaf.script,
    ]),
  );
  return {
    key,
    value: concat(bufs),
  };
}
const expected =
  '{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }';
function check(data) {
  return (
    Array.isArray(data.leaves) &&
    data.leaves.every(
      tapLeaf =>
        tapLeaf.depth >= 0 &&
        tapLeaf.depth <= 128 &&
        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&
        tapLeaf.script instanceof Uint8Array,
    )
  );
}
function canAdd(currentData, newData) {
  return !!currentData && !!newData && currentData.tapTree === undefined;
}

const tapTree = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    canAdd,
    check,
    decode: decode$1,
    encode: encode$1,
    expected
}, Symbol.toStringTag, { value: 'Module' }));

const range$3 = n => [...Array(n).keys()];
const isValidDERKey = pubkey =>
  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||
  (pubkey.length === 65 && 4 === pubkey[0]);
function makeConverter$4(TYPE_BYTE, isValidPubkey = isValidDERKey) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode bip32Derivation with key 0x' +
          toHex(keyVal.key),
      );
    }
    const pubkey = keyVal.key.slice(1);
    if (!isValidPubkey(pubkey)) {
      throw new Error(
        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +
          toHex(keyVal.key),
      );
    }
    if ((keyVal.value.length / 4) % 1 !== 0) {
      throw new Error(
        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',
      );
    }
    const data = {
      masterFingerprint: keyVal.value.slice(0, 4),
      pubkey,
      path: 'm',
    };
    for (const i of range$3(keyVal.value.length / 4 - 1)) {
      const val = readUInt32(keyVal.value, i * 4 + 4, 'LE');
      const isHard = !!(val & 0x80000000);
      const idx = val & 0x7fffffff;
      data.path += '/' + idx.toString(10) + (isHard ? "'" : '');
    }
    return data;
  }
  function encode(data) {
    const head = Uint8Array.from([TYPE_BYTE]);
    const key = concat([head, data.pubkey]);
    const splitPath = data.path.split('/');
    const value = new Uint8Array(splitPath.length * 4);
    value.set(data.masterFingerprint, 0);
    let offset = 4;
    splitPath.slice(1).forEach(level => {
      const isHard = level.slice(-1) === "'";
      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);
      if (isHard) num += 0x80000000;
      writeUInt32(value, offset, num, 'LE');
      offset += 4;
    });
    return {
      key,
      value,
    };
  }
  const expected =
    '{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }';
  function check(data) {
    return (
      data.pubkey instanceof Uint8Array &&
      data.masterFingerprint instanceof Uint8Array &&
      typeof data.path === 'string' &&
      isValidPubkey(data.pubkey) &&
      data.masterFingerprint.length === 4
    );
  }
  function canAddToArray(array, item, dupeSet) {
    const dupeString = toHex(item.pubkey);
    if (dupeSet.has(dupeString)) return false;
    dupeSet.add(dupeString);
    return (
      array.filter(v => compare$1(v.pubkey, item.pubkey) === 0).length === 0
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAddToArray,
  };
}

function makeChecker(pubkeyTypes) {
  return checkPubkey;
  function checkPubkey(keyVal) {
    let pubkey;
    if (pubkeyTypes.includes(keyVal.key[0])) {
      pubkey = keyVal.key.slice(1);
      if (
        !(pubkey.length === 33 || pubkey.length === 65) ||
        ![2, 3, 4].includes(pubkey[0])
      ) {
        throw new Error(
          'Format Error: invalid pubkey in key 0x' + toHex(keyVal.key),
        );
      }
    }
    return pubkey;
  }
}

function makeConverter$3(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode redeemScript with key 0x' +
          toHex(keyVal.key),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Uint8Array.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Uint8Array';
  function check(data) {
    return data instanceof Uint8Array;
  }
  function canAdd(currentData, newData) {
    return !!currentData && !!newData && currentData.redeemScript === undefined;
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}

const isValidBIP340Key = pubkey => pubkey.length === 32;
function makeConverter$2(TYPE_BYTE) {
  const parent = makeConverter$4(TYPE_BYTE, isValidBIP340Key);
  function decode(keyVal) {
    const { numberValue: nHashes, bytes: nHashesLen } = decode$j(
      keyVal.value,
    );
    const base = parent.decode({
      key: keyVal.key,
      value: keyVal.value.slice(nHashesLen + Number(nHashes) * 32),
    });
    const leafHashes = new Array(Number(nHashes));
    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {
      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);
    }
    return { ...base, leafHashes };
  }
  function encode(data) {
    const base = parent.encode(data);
    const nHashesLen = encodingLength$1(data.leafHashes.length);
    const nHashesBuf = new Uint8Array(nHashesLen);
    encode$k(data.leafHashes.length, nHashesBuf);
    const value = concat([nHashesBuf, ...data.leafHashes, base.value]);
    return { ...base, value };
  }
  const expected =
    '{ ' +
    'masterFingerprint: Uint8Array; ' +
    'pubkey: Uint8Array; ' +
    'path: string; ' +
    'leafHashes: Uint8Array[]; ' +
    '}';
  function check(data) {
    return (
      Array.isArray(data.leafHashes) &&
      data.leafHashes.every(
        leafHash => leafHash instanceof Uint8Array && leafHash.length === 32,
      ) &&
      parent.check(data)
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAddToArray: parent.canAddToArray,
  };
}

function makeConverter$1(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
      throw new Error(
        'Decode Error: could not decode tapInternalKey with key 0x' +
          toHex(keyVal.key),
      );
    }
    if (keyVal.value.length !== 32) {
      throw new Error(
        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',
      );
    }
    return keyVal.value;
  }
  function encode(value) {
    const key = Uint8Array.from([TYPE_BYTE]);
    return { key, value };
  }
  const expected = 'Uint8Array';
  function check(data) {
    return data instanceof Uint8Array && data.length === 32;
  }
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.tapInternalKey === undefined
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}

function makeConverter(TYPE_BYTE) {
  function decode(keyVal) {
    if (keyVal.key[0] !== TYPE_BYTE) {
      throw new Error(
        'Decode Error: could not decode witnessScript with key 0x' +
          toHex(keyVal.key),
      );
    }
    return keyVal.value;
  }
  function encode(data) {
    const key = Uint8Array.from([TYPE_BYTE]);
    return {
      key,
      value: data,
    };
  }
  const expected = 'Uint8Array';
  function check(data) {
    return data instanceof Uint8Array;
  }
  function canAdd(currentData, newData) {
    return (
      !!currentData && !!newData && currentData.witnessScript === undefined
    );
  }
  return {
    decode,
    encode,
    check,
    expected,
    canAdd,
  };
}

const globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: makeChecker([])
};
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: makeConverter$4(InputTypes.BIP32_DERIVATION),
  redeemScript: makeConverter$3(InputTypes.REDEEM_SCRIPT),
  witnessScript: makeConverter(InputTypes.WITNESS_SCRIPT),
  checkPubkey: makeChecker([
    InputTypes.PARTIAL_SIG,
    InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: makeConverter$2(
    InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: makeConverter$1(InputTypes.TAP_INTERNAL_KEY),
  tapMerkleRoot
};
const outputs = {
  bip32Derivation: makeConverter$4(OutputTypes.BIP32_DERIVATION),
  redeemScript: makeConverter$3(OutputTypes.REDEEM_SCRIPT),
  witnessScript: makeConverter(OutputTypes.WITNESS_SCRIPT),
  checkPubkey: makeChecker([OutputTypes.BIP32_DERIVATION]),
  tapBip32Derivation: makeConverter$2(
    OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: makeConverter$1(OutputTypes.TAP_INTERNAL_KEY)
};

const converter = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    globals,
    inputs,
    outputs
}, Symbol.toStringTag, { value: 'Module' }));

const range$2 = n => [...Array(n).keys()];
function keyValsToBuffer(keyVals) {
  const buffers = keyVals.map(keyValToBuffer);
  buffers.push(Uint8Array.from([0]));
  return concat(buffers);
}
function keyValToBuffer(keyVal) {
  const keyLen = keyVal.key.length;
  const valLen = keyVal.value.length;
  const keyVarIntLen = encodingLength$1(keyLen);
  const valVarIntLen = encodingLength$1(valLen);
  const buffer = new Uint8Array(keyVarIntLen + keyLen + valVarIntLen + valLen);
  encode$k(keyLen, buffer, 0);
  buffer.set(keyVal.key, keyVarIntLen);
  encode$k(valLen, buffer, keyVarIntLen + keyLen);
  buffer.set(keyVal.value, keyVarIntLen + keyLen + valVarIntLen);
  return buffer;
}

function psbtFromBuffer(buffer, txGetter) {
  let offset = 0;
  function varSlice() {
    const { numberValue: keyLen, bytes } = decode$j(buffer, offset);
    offset += bytes;
    const key = buffer.slice(offset, offset + Number(keyLen));
    offset += Number(keyLen);
    return key;
  }
  function readUInt32BE() {
    const num = readUInt32(buffer, offset, "BE");
    offset += 4;
    return num;
  }
  function readUInt8$1() {
    const num = readUInt8(buffer, offset);
    offset += 1;
    return num;
  }
  function getKeyValue() {
    const key = varSlice();
    const value = varSlice();
    return {
      key,
      value
    };
  }
  function checkEndOfKeyValPairs() {
    if (offset >= buffer.length) {
      throw new Error("Format Error: Unexpected End of PSBT");
    }
    const isEnd = readUInt8(buffer, offset) === 0;
    if (isEnd) {
      offset++;
    }
    return isEnd;
  }
  if (readUInt32BE() !== 1886610036) {
    throw new Error("Format Error: Invalid Magic Number");
  }
  if (readUInt8$1() !== 255) {
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  }
  const globalMapKeyVals = [];
  const globalKeyIndex = {};
  while (!checkEndOfKeyValPairs()) {
    const keyVal = getKeyValue();
    const hexKey = toHex(keyVal.key);
    if (globalKeyIndex[hexKey]) {
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + hexKey
      );
    }
    globalKeyIndex[hexKey] = 1;
    globalMapKeyVals.push(keyVal);
  }
  const unsignedTxMaps = globalMapKeyVals.filter(
    (keyVal) => keyVal.key[0] === GlobalTypes.UNSIGNED_TX
  );
  if (unsignedTxMaps.length !== 1) {
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  }
  const unsignedTx = txGetter(unsignedTxMaps[0].value);
  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
  const inputKeyVals = [];
  const outputKeyVals = [];
  for (const index of range$2(inputCount)) {
    const inputKeyIndex = {};
    const input = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = toHex(keyVal.key);
      if (inputKeyIndex[hexKey]) {
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey
        );
      }
      inputKeyIndex[hexKey] = 1;
      input.push(keyVal);
    }
    inputKeyVals.push(input);
  }
  for (const index of range$2(outputCount)) {
    const outputKeyIndex = {};
    const output = [];
    while (!checkEndOfKeyValPairs()) {
      const keyVal = getKeyValue();
      const hexKey = toHex(keyVal.key);
      if (outputKeyIndex[hexKey]) {
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey
        );
      }
      outputKeyIndex[hexKey] = 1;
      output.push(keyVal);
    }
    outputKeyVals.push(output);
  }
  return psbtFromKeyVals(unsignedTx, {
    globalMapKeyVals,
    inputKeyVals,
    outputKeyVals
  });
}
function checkKeyBuffer(type, keyBuf, keyNum) {
  if (compare$1(keyBuf, Uint8Array.from([keyNum]))) {
    throw new Error(
      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      `Format Error: Invalid ${type} key: ${toHex(keyBuf)}`
    );
  }
}
function psbtFromKeyVals(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
  const globalMap = {
    unsignedTx
  };
  let txCount = 0;
  for (const keyVal of globalMapKeyVals) {
    switch (keyVal.key[0]) {
      case GlobalTypes.UNSIGNED_TX:
        checkKeyBuffer("global", keyVal.key, GlobalTypes.UNSIGNED_TX);
        if (txCount > 0) {
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        }
        txCount++;
        break;
      case GlobalTypes.GLOBAL_XPUB:
        if (globalMap.globalXpub === void 0) {
          globalMap.globalXpub = [];
        }
        globalMap.globalXpub.push(globals.globalXpub.decode(keyVal));
        break;
      default:
        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
        globalMap.unknownKeyVals.push(keyVal);
    }
  }
  const inputCount = inputKeyVals.length;
  const outputCount = outputKeyVals.length;
  const inputs$1 = [];
  const outputs$1 = [];
  for (const index of range$2(inputCount)) {
    const input = {};
    for (const keyVal of inputKeyVals[index]) {
      inputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case InputTypes.NON_WITNESS_UTXO:
          checkKeyBuffer("input", keyVal.key, InputTypes.NON_WITNESS_UTXO);
          if (input.nonWitnessUtxo !== void 0) {
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          }
          input.nonWitnessUtxo = inputs.nonWitnessUtxo.decode(keyVal);
          break;
        case InputTypes.WITNESS_UTXO:
          checkKeyBuffer("input", keyVal.key, InputTypes.WITNESS_UTXO);
          if (input.witnessUtxo !== void 0) {
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          }
          input.witnessUtxo = inputs.witnessUtxo.decode(keyVal);
          break;
        case InputTypes.PARTIAL_SIG:
          if (input.partialSig === void 0) {
            input.partialSig = [];
          }
          input.partialSig.push(inputs.partialSig.decode(keyVal));
          break;
        case InputTypes.SIGHASH_TYPE:
          checkKeyBuffer("input", keyVal.key, InputTypes.SIGHASH_TYPE);
          if (input.sighashType !== void 0) {
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          }
          input.sighashType = inputs.sighashType.decode(keyVal);
          break;
        case InputTypes.REDEEM_SCRIPT:
          checkKeyBuffer("input", keyVal.key, InputTypes.REDEEM_SCRIPT);
          if (input.redeemScript !== void 0) {
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          }
          input.redeemScript = inputs.redeemScript.decode(keyVal);
          break;
        case InputTypes.WITNESS_SCRIPT:
          checkKeyBuffer("input", keyVal.key, InputTypes.WITNESS_SCRIPT);
          if (input.witnessScript !== void 0) {
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          }
          input.witnessScript = inputs.witnessScript.decode(keyVal);
          break;
        case InputTypes.BIP32_DERIVATION:
          if (input.bip32Derivation === void 0) {
            input.bip32Derivation = [];
          }
          input.bip32Derivation.push(
            inputs.bip32Derivation.decode(keyVal)
          );
          break;
        case InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer("input", keyVal.key, InputTypes.FINAL_SCRIPTSIG);
          input.finalScriptSig = inputs.finalScriptSig.decode(keyVal);
          break;
        case InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer("input", keyVal.key, InputTypes.FINAL_SCRIPTWITNESS);
          input.finalScriptWitness = inputs.finalScriptWitness.decode(
            keyVal
          );
          break;
        case InputTypes.POR_COMMITMENT:
          checkKeyBuffer("input", keyVal.key, InputTypes.POR_COMMITMENT);
          input.porCommitment = inputs.porCommitment.decode(keyVal);
          break;
        case InputTypes.TAP_KEY_SIG:
          checkKeyBuffer("input", keyVal.key, InputTypes.TAP_KEY_SIG);
          input.tapKeySig = inputs.tapKeySig.decode(keyVal);
          break;
        case InputTypes.TAP_SCRIPT_SIG:
          if (input.tapScriptSig === void 0) {
            input.tapScriptSig = [];
          }
          input.tapScriptSig.push(inputs.tapScriptSig.decode(keyVal));
          break;
        case InputTypes.TAP_LEAF_SCRIPT:
          if (input.tapLeafScript === void 0) {
            input.tapLeafScript = [];
          }
          input.tapLeafScript.push(inputs.tapLeafScript.decode(keyVal));
          break;
        case InputTypes.TAP_BIP32_DERIVATION:
          if (input.tapBip32Derivation === void 0) {
            input.tapBip32Derivation = [];
          }
          input.tapBip32Derivation.push(
            inputs.tapBip32Derivation.decode(keyVal)
          );
          break;
        case InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer("input", keyVal.key, InputTypes.TAP_INTERNAL_KEY);
          input.tapInternalKey = inputs.tapInternalKey.decode(keyVal);
          break;
        case InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer("input", keyVal.key, InputTypes.TAP_MERKLE_ROOT);
          input.tapMerkleRoot = inputs.tapMerkleRoot.decode(keyVal);
          break;
        default:
          if (!input.unknownKeyVals) input.unknownKeyVals = [];
          input.unknownKeyVals.push(keyVal);
      }
    }
    inputs$1.push(input);
  }
  for (const index of range$2(outputCount)) {
    const output = {};
    for (const keyVal of outputKeyVals[index]) {
      outputs.checkPubkey(keyVal);
      switch (keyVal.key[0]) {
        case OutputTypes.REDEEM_SCRIPT:
          checkKeyBuffer("output", keyVal.key, OutputTypes.REDEEM_SCRIPT);
          if (output.redeemScript !== void 0) {
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          }
          output.redeemScript = outputs.redeemScript.decode(keyVal);
          break;
        case OutputTypes.WITNESS_SCRIPT:
          checkKeyBuffer("output", keyVal.key, OutputTypes.WITNESS_SCRIPT);
          if (output.witnessScript !== void 0) {
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          }
          output.witnessScript = outputs.witnessScript.decode(keyVal);
          break;
        case OutputTypes.BIP32_DERIVATION:
          if (output.bip32Derivation === void 0) {
            output.bip32Derivation = [];
          }
          output.bip32Derivation.push(
            outputs.bip32Derivation.decode(keyVal)
          );
          break;
        case OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer("output", keyVal.key, OutputTypes.TAP_INTERNAL_KEY);
          output.tapInternalKey = outputs.tapInternalKey.decode(keyVal);
          break;
        case OutputTypes.TAP_TREE:
          checkKeyBuffer("output", keyVal.key, OutputTypes.TAP_TREE);
          output.tapTree = outputs.tapTree.decode(keyVal);
          break;
        case OutputTypes.TAP_BIP32_DERIVATION:
          if (output.tapBip32Derivation === void 0) {
            output.tapBip32Derivation = [];
          }
          output.tapBip32Derivation.push(
            outputs.tapBip32Derivation.decode(keyVal)
          );
          break;
        default:
          if (!output.unknownKeyVals) output.unknownKeyVals = [];
          output.unknownKeyVals.push(keyVal);
      }
    }
    outputs$1.push(output);
  }
  return { globalMap, inputs: inputs$1, outputs: outputs$1 };
}

function psbtToBuffer({ globalMap, inputs, outputs }) {
  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
    globalMap,
    inputs,
    outputs
  });
  const globalBuffer = keyValsToBuffer(globalKeyVals);
  const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [Uint8Array.from([0])] : keyVals.map(keyValsToBuffer);
  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
  const header = new Uint8Array(5);
  header.set([112, 115, 98, 116, 255], 0);
  return concat(
    [header, globalBuffer].concat(inputBuffers, outputBuffers)
  );
}
const sortKeyVals = (a, b) => {
  return compare$1(a.key, b.key);
};
function keyValsFromMap(keyValMap, converterFactory) {
  const keyHexSet = /* @__PURE__ */ new Set();
  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
    if (key === "unknownKeyVals") return result;
    const converter = converterFactory[key];
    if (converter === void 0) return result;
    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
      converter.encode
    );
    const keyHexes = encodedKeyVals.map((kv) => toHex(kv.key));
    keyHexes.forEach((hex) => {
      if (keyHexSet.has(hex))
        throw new Error("Serialize Error: Duplicate key: " + hex);
      keyHexSet.add(hex);
    });
    return result.concat(encodedKeyVals);
  }, []);
  const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal) => {
    return !keyHexSet.has(toHex(keyVal.key));
  }) : [];
  return keyVals.concat(otherKeyVals).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap, inputs: inputs$1, outputs: outputs$1 }) {
  return {
    globalKeyVals: keyValsFromMap(globalMap, globals),
    inputKeyVals: inputs$1.map((i) => keyValsFromMap(i, inputs)),
    outputKeyVals: outputs$1.map((o) => keyValsFromMap(o, outputs))
  };
}

function combine(psbts) {
  const self = psbts[0];
  const selfKeyVals = psbtToKeyVals(self);
  const others = psbts.slice(1);
  if (others.length === 0) throw new Error("Combine: Nothing to combine");
  const selfTx = getTx(self);
  if (selfTx === void 0) {
    throw new Error("Combine: Self missing transaction");
  }
  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
  for (const other of others) {
    const otherTx = getTx(other);
    if (otherTx === void 0 || compare$1(otherTx.toBuffer(), selfTx.toBuffer()) !== 0) {
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    }
    const otherKeyVals = psbtToKeyVals(other);
    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
    otherGlobalSet.forEach(
      keyPusher(
        selfGlobalSet,
        selfKeyVals.globalKeyVals,
        otherKeyVals.globalKeyVals
      )
    );
    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
    otherInputSets.forEach(
      (inputSet, idx) => inputSet.forEach(
        keyPusher(
          selfInputSets[idx],
          selfKeyVals.inputKeyVals[idx],
          otherKeyVals.inputKeyVals[idx]
        )
      )
    );
    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
    otherOutputSets.forEach(
      (outputSet, idx) => outputSet.forEach(
        keyPusher(
          selfOutputSets[idx],
          selfKeyVals.outputKeyVals[idx],
          otherKeyVals.outputKeyVals[idx]
        )
      )
    );
  }
  return psbtFromKeyVals(selfTx, {
    globalMapKeyVals: selfKeyVals.globalKeyVals,
    inputKeyVals: selfKeyVals.inputKeyVals,
    outputKeyVals: selfKeyVals.outputKeyVals
  });
}
function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
  return (key) => {
    if (selfSet.has(key)) return;
    const newKv = otherKeyVals.filter((kv) => toHex(kv.key) === key)[0];
    selfKeyVals.push(newKv);
    selfSet.add(key);
  };
}
function getTx(psbt) {
  return psbt.globalMap.unsignedTx;
}
function getKeySet(keyVals) {
  const set = /* @__PURE__ */ new Set();
  keyVals.forEach((keyVal) => {
    const hex = toHex(keyVal.key);
    if (set.has(hex))
      throw new Error("Combine: KeyValue Map keys should be unique");
    set.add(hex);
  });
  return set;
}

function checkForInput(inputs, inputIndex) {
  const input = inputs[inputIndex];
  if (input === void 0) throw new Error(`No input #${inputIndex}`);
  return input;
}
function checkForOutput(outputs, outputIndex) {
  const output = outputs[outputIndex];
  if (output === void 0) throw new Error(`No output #${outputIndex}`);
  return output;
}
function checkHasKey(checkKeyVal, keyVals, enumLength) {
  if (checkKeyVal.key[0] < enumLength) {
    throw new Error(
      `Use the method for your specific key instead of addUnknownKeyVal*`
    );
  }
  if (keyVals && keyVals.filter((kv) => compare$1(kv.key, checkKeyVal.key) === 0).length !== 0) {
    throw new Error(`Duplicate Key: ${toHex(checkKeyVal.key)}`);
  }
}
function getEnumLength(myenum) {
  let count = 0;
  Object.keys(myenum).forEach((val) => {
    if (Number(isNaN(Number(val)))) {
      count++;
    }
  });
  return count;
}
function inputCheckUncleanFinalized(inputIndex, input) {
  let result = false;
  if (input.nonWitnessUtxo || input.witnessUtxo) {
    const needScriptSig = !!input.redeemScript;
    const needWitnessScript = !!input.witnessScript;
    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
    result = scriptSigOK && witnessScriptOK && hasOneFinal;
  }
  if (result === false) {
    throw new Error(
      `Input #${inputIndex} has too much or too little data to clean`
    );
  }
}
function throwForUpdateMaker(typeName, name, expected, data) {
  throw new Error(
    `Data for ${typeName} key ${name} is incorrect: Expected ${expected} and got ${JSON.stringify(data)}`
  );
}
function updateMaker(typeName) {
  return (updateData, mainData) => {
    for (const name of Object.keys(updateData)) {
      const data = updateData[name];
      const { canAdd, canAddToArray, check, expected } = (
        // @ts-ignore
        converter[typeName + "s"][name] || {}
      );
      const isArray = !!canAddToArray;
      if (check) {
        if (isArray) {
          if (!Array.isArray(data) || // @ts-ignore
          mainData[name] && !Array.isArray(mainData[name])) {
            throw new Error(`Key type ${name} must be an array`);
          }
          if (!data.every(check)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          const arr = mainData[name] || [];
          const dupeCheckSet = /* @__PURE__ */ new Set();
          if (!data.every((v) => canAddToArray(arr, v, dupeCheckSet))) {
            throw new Error("Can not add duplicate data to array");
          }
          mainData[name] = arr.concat(data);
        } else {
          if (!check(data)) {
            throwForUpdateMaker(typeName, name, expected, data);
          }
          if (!canAdd(mainData, data)) {
            throw new Error(`Can not add duplicate data to ${typeName}`);
          }
          mainData[name] = data;
        }
      }
    }
  };
}
const updateGlobal = updateMaker("global");
const updateInput = updateMaker("input");
const updateOutput = updateMaker("output");
function addInputAttributes(inputs, data) {
  const index = inputs.length - 1;
  const input = checkForInput(inputs, index);
  updateInput(data, input);
}
function addOutputAttributes(outputs, data) {
  const index = outputs.length - 1;
  const output = checkForOutput(outputs, index);
  updateOutput(data, output);
}

let Psbt$1 = class Psbt {
  constructor(tx) {
    this.inputs = [];
    this.outputs = [];
    this.globalMap = {
      unsignedTx: tx
    };
  }
  static fromBase64(data, txFromBuffer) {
    const buffer = fromBase64(data);
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromHex(data, txFromBuffer) {
    const buffer = fromHex(data);
    return this.fromBuffer(buffer, txFromBuffer);
  }
  static fromBuffer(buffer, txFromBuffer) {
    const results = psbtFromBuffer(buffer, txFromBuffer);
    const psbt = new this(results.globalMap.unsignedTx);
    Object.assign(psbt, results);
    return psbt;
  }
  toBase64() {
    const buffer = this.toBuffer();
    return toBase64(buffer);
  }
  toHex() {
    const buffer = this.toBuffer();
    return toHex(buffer);
  }
  toBuffer() {
    return psbtToBuffer(this);
  }
  updateGlobal(updateData) {
    updateGlobal(updateData, this.globalMap);
    return this;
  }
  updateInput(inputIndex, updateData) {
    const input = checkForInput(this.inputs, inputIndex);
    updateInput(updateData, input);
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const output = checkForOutput(this.outputs, outputIndex);
    updateOutput(updateData, output);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    checkHasKey(
      keyVal,
      this.globalMap.unknownKeyVals,
      getEnumLength(GlobalTypes)
    );
    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
    this.globalMap.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    const input = checkForInput(this.inputs, inputIndex);
    checkHasKey(keyVal, input.unknownKeyVals, getEnumLength(InputTypes));
    if (!input.unknownKeyVals) input.unknownKeyVals = [];
    input.unknownKeyVals.push(keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    const output = checkForOutput(this.outputs, outputIndex);
    checkHasKey(keyVal, output.unknownKeyVals, getEnumLength(OutputTypes));
    if (!output.unknownKeyVals) output.unknownKeyVals = [];
    output.unknownKeyVals.push(keyVal);
    return this;
  }
  addInput(inputData) {
    this.globalMap.unsignedTx.addInput(inputData);
    this.inputs.push({
      unknownKeyVals: []
    });
    const addKeyVals = inputData.unknownKeyVals || [];
    const inputIndex = this.inputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error("unknownKeyVals must be an Array");
    }
    addKeyVals.forEach(
      (keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal)
    );
    addInputAttributes(this.inputs, inputData);
    return this;
  }
  addOutput(outputData) {
    this.globalMap.unsignedTx.addOutput(outputData);
    this.outputs.push({
      unknownKeyVals: []
    });
    const addKeyVals = outputData.unknownKeyVals || [];
    const outputIndex = this.outputs.length - 1;
    if (!Array.isArray(addKeyVals)) {
      throw new Error("unknownKeyVals must be an Array");
    }
    addKeyVals.forEach(
      (keyVal) => this.addUnknownKeyValToOutput(outputIndex, keyVal)
    );
    addOutputAttributes(this.outputs, outputData);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    const input = checkForInput(this.inputs, inputIndex);
    inputCheckUncleanFinalized(inputIndex, input);
    for (const key of Object.keys(input)) {
      if (![
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(key)) {
        delete input[key];
      }
    }
    return this;
  }
  combine(...those) {
    const result = combine([this].concat(those));
    Object.assign(this, result);
    return this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};

function isPaymentFactory(payment) {
    return (script) => {
        try {
            payment({ output: script });
            return true;
        }
        catch {
            return false;
        }
    };
}
const isP2MS = isPaymentFactory(p2ms);
const isP2PK = isPaymentFactory(p2pk);
const isP2PKH = isPaymentFactory(p2pkh);
const isP2WPKH = isPaymentFactory(p2wpkh);
const isP2WSHScript = isPaymentFactory(p2wsh);
const isP2SHScript = isPaymentFactory(p2sh);
const isP2TR = isPaymentFactory(p2tr);
const isP2MR = isPaymentFactory(p2mr);
const isP2A = (script) => {
    return (script.length === 4 &&
        script[0] === 0x51 && // OP_1
        script[1] === 0x02 && // push 2 bytes
        script[2] === 0x4e &&
        script[3] === 0x73);
};
/**
 * Converts a witness stack to a script witness.
 * @param witness The witness stack to convert.
 * @returns The script witness as a Uint8Array.
 */
function witnessStackToScriptWitness$1(witness) {
    const chunks = [];
    function writeSlice(slice) {
        chunks.push(slice);
    }
    function writeVarInt(i) {
        const varintLen = encodingLength$1(i);
        const buf = alloc(varintLen);
        encode$k(i, buf, 0);
        chunks.push(buf);
    }
    function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
    }
    function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
    }
    writeVector(witness);
    return concat$1(chunks);
}
/**
 * Finds the position of a public key in a script.
 * @param pubkey The public key to search for.
 * @param script The script to search in.
 * @returns The index of the public key in the script, or -1 if not found.
 * @throws {Error} If there is an unknown script error.
 */
function pubkeyPositionInScript(pubkey, script$1) {
    const decompiled = decompile(script$1);
    if (decompiled === null)
        throw new Error('Unknown script error');
    // For P2PKH or P2PK
    const pubkeyHash = hash160(pubkey);
    // For Taproot or some cases, we might also check the x-only
    const pubkeyXOnly = toXOnly(pubkey);
    const uncompressed = decompressPublicKey(pubkey);
    const pubkeyHybridHash = uncompressed?.hybrid ? hash160(uncompressed.hybrid) : undefined;
    const pubkeyUncompressedHash = uncompressed?.uncompressed
        ? hash160(uncompressed.uncompressed)
        : undefined;
    return decompiled.findIndex((element) => {
        if (typeof element === 'number')
            return false;
        if (pubkeysMatch(element, pubkey))
            return true;
        if (pubkeysMatch(element, pubkeyXOnly))
            return true;
        if (equals(element, pubkeyHash)) {
            return true;
        }
        if (uncompressed) {
            if (pubkeysMatch(element, uncompressed.uncompressed))
                return true;
            if (pubkeysMatch(element, uncompressed.hybrid))
                return true;
            if ((pubkeyHybridHash && equals(element, pubkeyHybridHash)) ||
                (pubkeyUncompressedHash && equals(element, pubkeyUncompressedHash))) {
                return true;
            }
        }
        return false;
    });
}
/**
 * Checks if a public key is present in a script.
 * @param pubkey The public key to check.
 * @param script The script to search in.
 * @returns A boolean indicating whether the public key is present in the script.
 */
function pubkeyInScript$1(pubkey, script) {
    return pubkeyPositionInScript(pubkey, script) !== -1;
}
/**
 * Checks if an input contains a signature for a specific action.
 * @param input - The input to check.
 * @param action - The action to check for.
 * @returns A boolean indicating whether the input contains a signature for the specified action.
 */
function checkInputForSig(input, action) {
    const pSigs = extractPartialSigs(input);
    return pSigs.some((pSig) => signatureBlocksAction(pSig, signature.decode, action));
}
/**
 * Determines if a given action is allowed for a signature block.
 * @param signature - The signature block.
 * @param signatureDecodeFn - The function used to decode the signature.
 * @param action - The action to be checked.
 * @returns True if the action is allowed, false otherwise.
 */
function signatureBlocksAction(signature, signatureDecodeFn, action) {
    const { hashType } = signatureDecodeFn(signature);
    const whitelist = [];
    const isAnyoneCanPay = hashType & Transaction.SIGHASH_ANYONECANPAY;
    if (isAnyoneCanPay)
        whitelist.push('addInput');
    const hashMod = hashType & 0x1f;
    switch (hashMod) {
        case Transaction.SIGHASH_ALL:
            break;
        case Transaction.SIGHASH_SINGLE:
        case Transaction.SIGHASH_NONE:
            whitelist.push('addOutput');
            whitelist.push('setInputSequence');
            break;
    }
    return whitelist.indexOf(action) === -1;
}
/**
 * Extracts the signatures from a PsbtInput object.
 * If the input has partial signatures, it returns an array of the signatures.
 * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.
 * If it does, it extracts the signatures from the final scripts and returns them.
 * If none of the above conditions are met, it returns an empty array.
 *
 * @param input - The PsbtInput object from which to extract the signatures.
 * @returns An array of signatures extracted from the PsbtInput object.
 */
function extractPartialSigs(input) {
    const { partialSig } = input;
    let pSigs;
    if (!partialSig || partialSig.length === 0) {
        if (!input.finalScriptSig && !input.finalScriptWitness)
            return [];
        pSigs = getPsigsFromInputFinalScripts(input);
    }
    else {
        pSigs = partialSig;
    }
    return pSigs.map((p) => new Uint8Array(p.signature));
}
/**
 * Retrieves the partial signatures (Psigs) from the input's final scripts.
 * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.
 * Only canonical script signatures are considered.
 *
 * @param input - The PsbtInput object representing the input.
 * @returns An array of PartialSig objects containing the extracted Psigs.
 */
function getPsigsFromInputFinalScripts(input) {
    const scriptItems = !input.finalScriptSig
        ? []
        : decompile(new Uint8Array(input.finalScriptSig)) || [];
    const witnessItems = !input.finalScriptWitness
        ? []
        : decompile(new Uint8Array(input.finalScriptWitness)) || [];
    return scriptItems
        .concat(witnessItems)
        .filter((item) => {
        return item instanceof Uint8Array && isCanonicalScriptSignature(item);
    })
        .map((sig) => ({ signature: sig }));
}

/**
 * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.
 * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.
 * @param inputIndex the position of the PSBT input.
 * @param input the PSBT input.
 * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash
 *                              and will try to build the finalScriptWitness.
 * @returns the finalScriptWitness or throws an exception if no tapleaf found.
 */
function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
    const tapLeaf = findTapLeafToFinalize(input, inputIndex, tapLeafHashToFinalize);
    try {
        const sigs = sortSignatures(input, tapLeaf);
        const witness = sigs
            .concat(new Uint8Array(tapLeaf.script))
            .concat(new Uint8Array(tapLeaf.controlBlock));
        return { finalScriptWitness: witnessStackToScriptWitness$1(witness) };
    }
    catch (err) {
        throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`, { cause: err });
    }
}
/**
 * Serializes a taproot (Schnorr) signature, optionally appending the sighash type byte.
 * If sighashType is SIGHASH_DEFAULT (0x00) or not provided, no byte is appended (per BIP 341).
 * Used for both P2TR key-path/script-path and P2MR script-path signatures.
 * @param sig - The 64-byte Schnorr signature.
 * @param sighashType - Optional sighash type. Omit or pass 0 for SIGHASH_DEFAULT.
 * @returns The serialized signature (64 or 65 bytes).
 */
function serializeTaprootSignature(sig, sighashType) {
    const sighashTypeByte = sighashType ? new Uint8Array([sighashType]) : new Uint8Array(0);
    return concat$1([sig, sighashTypeByte]);
}
/**
 * Determines whether a PSBT input should be handled as a taproot-style input.
 * Returns true for both P2TR (SegWit v1, BIP 341) and P2MR (SegWit v2, BIP 360) inputs.
 * This is the gateway check that routes inputs to taproot signing and finalization logic.
 * @param input - The PSBT input to check.
 * @returns True if the input has taproot/P2MR fields or a P2TR/P2MR witnessUtxo script.
 */
function isTaprootInput$1(input) {
    return (input &&
        !!(input.tapInternalKey ||
            input.tapMerkleRoot ||
            (input.tapLeafScript && input.tapLeafScript.length) ||
            (input.tapBip32Derivation && input.tapBip32Derivation.length) ||
            (input.witnessUtxo &&
                (isP2TR(new Uint8Array(input.witnessUtxo.script)) ||
                    isP2MR(new Uint8Array(input.witnessUtxo.script))))));
}
/**
 * Checks if the input is spending a P2MR (Pay-to-Merkle-Root, BIP 360) output.
 * Requires `witnessUtxo` to be set on the input; returns false otherwise.
 * P2MR uses SegWit version 2 with scriptPubKey: `OP_2 <32-byte merkle_root>`.
 * @param input - The PSBT input to check.
 * @returns True if the witnessUtxo script is a valid P2MR output.
 */
function isP2MRInput(input) {
    return !!(input.witnessUtxo && isP2MR(new Uint8Array(input.witnessUtxo.script)));
}
/**
 * Determines whether a PSBT output should be handled as a taproot-style output.
 * Returns true for both P2TR (BIP 341) and P2MR (BIP 360) outputs.
 * @param output - The PSBT output to check.
 * @param script - Optional output script to test against P2TR/P2MR patterns.
 * @returns True if the output has taproot fields or a P2TR/P2MR script.
 */
function isTaprootOutput(output, script) {
    return (output &&
        !!(output.tapInternalKey ||
            output.tapTree ||
            (output.tapBip32Derivation && output.tapBip32Derivation.length) ||
            (script)));
}
function checkTaprootInputFields(inputData, newInputData, action) {
    checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
    checkIfTapLeafInTree(inputData, newInputData, action);
}
function checkTaprootOutputFields(outputData, newOutputData, action) {
    checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
    checkTaprootScriptPubkey(outputData, newOutputData);
}
function checkTaprootScriptPubkey(outputData, newOutputData) {
    if (!newOutputData.tapTree && !newOutputData.tapInternalKey)
        return;
    const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
    const tapTree = newOutputData.tapTree || outputData.tapTree;
    if (tapInternalKey) {
        const scriptPubkey = outputData.script;
        const script = getTaprootScripPubkey(tapInternalKey, tapTree);
        if (scriptPubkey && !equals(scriptPubkey, script))
            throw new Error('Error adding output. Script or address missmatch.');
    }
}
function getTaprootScripPubkey(tapInternalKey, tapTree) {
    const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
    const { output } = p2tr({
        internalPubkey: new Uint8Array(tapInternalKey),
        scriptTree,
    });
    if (!output)
        throw new Error('Failed to generate taproot script pubkey');
    return output;
}
/**
 * Convert a BIP371 TapLeaf list to a TapTree (binary).
 * @param leaves a list of tapleaves where each element of the list is (according to BIP371):
 * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,
 * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that
 * the tree is correctly reconstructed.
 * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed
 */
function tapTreeFromList(leaves = []) {
    const firstLeaf = leaves[0];
    if (leaves.length === 1 && firstLeaf && firstLeaf.depth === 0)
        return {
            output: new Uint8Array(firstLeaf.script),
            version: firstLeaf.leafVersion,
        };
    return insertLeavesInTree(leaves);
}
function checkTaprootInputForSigs(input, action) {
    const sigs = extractTaprootSigs(input);
    return sigs.some((sig) => signatureBlocksAction(sig, decodeSchnorrSignature, action));
}
function decodeSchnorrSignature(signature) {
    return {
        signature: signature.subarray(0, 64),
        hashType: signature.subarray(64)[0] || Transaction.SIGHASH_DEFAULT,
    };
}
function extractTaprootSigs(input) {
    const sigs = [];
    if (input.tapKeySig)
        sigs.push(new Uint8Array(input.tapKeySig));
    if (input.tapScriptSig)
        sigs.push(...input.tapScriptSig.map((s) => new Uint8Array(s.signature)));
    if (!sigs.length) {
        const finalTapKeySig = getTapKeySigFromWitness(input.finalScriptWitness ? new Uint8Array(input.finalScriptWitness) : undefined);
        if (finalTapKeySig)
            sigs.push(finalTapKeySig);
    }
    return sigs;
}
function getTapKeySigFromWitness(finalScriptWitness) {
    if (!finalScriptWitness)
        return;
    const witness = finalScriptWitness.subarray(2);
    // todo: add schnorr signature validation
    if (witness.length === 64 || witness.length === 65)
        return witness;
    return undefined;
}
function insertLeavesInTree(leaves) {
    let tree;
    for (const leaf of leaves) {
        tree = insertLeafInTree(leaf, tree);
        if (!tree)
            throw new Error(`No room left to insert tapleaf in tree`);
    }
    return tree;
}
function insertLeafInTree(leaf, tree, depth = 0) {
    if (depth > MAX_TAPTREE_DEPTH)
        throw new Error('Max taptree depth exceeded.');
    if (leaf.depth === depth) {
        if (!tree)
            return {
                output: new Uint8Array(leaf.script),
                version: leaf.leafVersion,
            };
        return;
    }
    if (isTapleaf(tree))
        return;
    const leftSide = insertLeafInTree(leaf, tree && tree[0], depth + 1);
    if (leftSide)
        return [leftSide, tree && tree[1]];
    const rightSide = insertLeafInTree(leaf, tree && tree[1], depth + 1);
    if (rightSide)
        return [tree && tree[0], rightSide];
    return undefined;
}
function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
    const isBadTaprootUpdate = isTaprootInput$1(inputData) && hasNonTaprootFields(newInputData);
    const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput$1(newInputData);
    const hasMixedFields = inputData === newInputData &&
        isTaprootInput$1(newInputData) &&
        hasNonTaprootFields(newInputData); // todo: bad? use !===
    if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(`Invalid arguments for Psbt.${action}. ` +
            `Cannot use both taproot and non-taproot fields.`);
}
function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
    const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
    const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
    const hasMixedFields = inputData === newInputData &&
        isTaprootOutput(newInputData) &&
        hasNonTaprootFields(newInputData);
    if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(`Invalid arguments for Psbt.${action}. ` +
            `Cannot use both taproot and non-taproot fields.`);
}
/**
 * Checks if the tap leaf is part of the tap tree for the given input data.
 * Throws an error if the tap leaf is not part of the tap tree.
 * @param inputData - The original PsbtInput data.
 * @param newInputData - The new PsbtInput data.
 * @param action - The action being performed.
 * @throws {Error} - If the tap leaf is not part of the tap tree.
 */
function checkIfTapLeafInTree(inputData, newInputData, action) {
    const p2mrInput = isP2MRInput(inputData) || isP2MRInput(newInputData);
    if (newInputData.tapMerkleRoot) {
        const merkleRoot = new Uint8Array(newInputData.tapMerkleRoot);
        const newLeafsInTree = (newInputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, merkleRoot, p2mrInput));
        const oldLeafsInTree = (inputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, merkleRoot, p2mrInput));
        if (!newLeafsInTree || !oldLeafsInTree)
            throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);
    }
    else if (inputData.tapMerkleRoot) {
        const merkleRoot = new Uint8Array(inputData.tapMerkleRoot);
        const newLeafsInTree = (newInputData.tapLeafScript || []).every((l) => isTapLeafInTree(l, merkleRoot, p2mrInput));
        if (!newLeafsInTree)
            throw new Error(`Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`);
    }
}
/**
 * Checks if a TapLeafScript is present in a Merkle tree by recomputing the root
 * from the control block's merkle path.
 *
 * Handles both P2TR and P2MR control block formats:
 * - P2TR: 33 + 32*m bytes (1 control byte + 32-byte internal pubkey + merkle path)
 * - P2MR: 1 + 32*m bytes (1 control byte + merkle path, no internal pubkey)
 *
 * When `p2mr` is explicitly true, only the P2MR format is tried. When false and
 * the input type is unknown (witnessUtxo not yet set), both formats are tried as
 * their lengths overlap at 33, 65, 97... bytes. The merkle root is used to
 * disambiguate which interpretation is correct.
 *
 * @param tapLeaf - The TapLeafScript to check (includes script, leafVersion, controlBlock).
 * @param merkleRoot - The expected Merkle root. If not provided, returns true (no validation).
 * @param p2mr - If true, use P2MR control block format exclusively.
 * @returns True if the leaf's control block produces the expected merkle root.
 */
function isTapLeafInTree(tapLeaf, merkleRoot, p2mr = false) {
    if (!merkleRoot)
        return true;
    const leafHash = tapleafHash({
        output: new Uint8Array(tapLeaf.script),
        version: tapLeaf.leafVersion,
    });
    const controlBlock = new Uint8Array(tapLeaf.controlBlock);
    if (p2mr) {
        return equals(rootHashFromPathP2MR(controlBlock, leafHash), merkleRoot);
    }
    // When the input type isn't known yet (witnessUtxo not set), try P2TR first,
    // then fall back to P2MR. Control block lengths overlap (33, 65, ...) between
    // P2TR (33 + 32*m) and P2MR (1 + 32*m), so we verify against the merkle root.
    const isValidP2TRLength = controlBlock.length >= 33 && (controlBlock.length - 33) % 32 === 0;
    const isValidP2MRLength = controlBlock.length >= 1 && (controlBlock.length - 1) % 32 === 0;
    if (isValidP2TRLength) {
        const rootHash = rootHashFromPath(controlBlock, leafHash);
        if (equals(rootHash, merkleRoot))
            return true;
    }
    if (isValidP2MRLength) {
        const rootHash = rootHashFromPathP2MR(controlBlock, leafHash);
        if (equals(rootHash, merkleRoot))
            return true;
    }
    return false;
}
/**
 * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.
 *
 * @param input - The PsbtInput object.
 * @param tapLeaf - The TapLeafScript object.
 * @returns An array of sorted signatures as Uint8Arrays.
 */
function sortSignatures(input, tapLeaf) {
    const tapLeafScript = new Uint8Array(tapLeaf.script);
    const leafHash = tapleafHash({
        output: tapLeafScript,
        version: tapLeaf.leafVersion,
    });
    return (input.tapScriptSig || [])
        .filter((tss) => equals(new Uint8Array(tss.leafHash), leafHash))
        .map((tss) => addPubkeyPositionInScript(tapLeafScript, tss))
        .sort((t1, t2) => t2.positionInScript - t1.positionInScript)
        .map((t) => new Uint8Array(t.signature));
}
/**
 * Adds the position of a public key in a script to a TapScriptSig object.
 * @param script The script in which to find the position of the public key.
 * @param tss The TapScriptSig object to add the position to.
 * @returns A TapScriptSigWitPosition object with the added position.
 */
function addPubkeyPositionInScript(script, tss) {
    return Object.assign({
        positionInScript: pubkeyPositionInScript(new Uint8Array(tss.pubkey), script),
    }, tss);
}
/**
 * Find tapleaf by hash, or get the signed tapleaf with the shortest path.
 */
function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
    const { tapScriptSig } = input;
    if (!tapScriptSig || !tapScriptSig.length)
        throw new Error(`Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`);
    const tapLeaf = (input.tapLeafScript || [])
        .sort((a, b) => a.controlBlock.length - b.controlBlock.length)
        .find((leaf) => canFinalizeLeaf(leaf, tapScriptSig, leafHashToFinalize));
    if (!tapLeaf)
        throw new Error(`Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`);
    return tapLeaf;
}
/**
 * Determines whether a TapLeafScript can be finalized.
 *
 * @param leaf - The TapLeafScript to check.
 * @param tapScriptSig - The array of TapScriptSig objects.
 * @param hash - The optional hash to compare with the leaf hash.
 * @returns A boolean indicating whether the TapLeafScript can be finalized.
 */
function canFinalizeLeaf(leaf, tapScriptSig, hash) {
    const leafHash = tapleafHash({
        output: new Uint8Array(leaf.script),
        version: leaf.leafVersion,
    });
    const whiteListedHash = !hash || equals(hash, leafHash);
    return (whiteListedHash &&
        tapScriptSig.find((tss) => equals(new Uint8Array(tss.leafHash), leafHash)) !== undefined);
}
/**
 * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.
 * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.
 * @param io The PsbtInput or PsbtOutput to check.
 * @returns A boolean indicating whether the given input or output has non-taproot fields.
 */
function hasNonTaprootFields(io) {
    return (io &&
        !!(io.redeemScript || io.witnessScript || (io.bip32Derivation && io.bip32Derivation.length)));
}

/**
 * PSBT validation utilities
 * @packageDocumentation
 */
/**
 * Validates that a number is a valid 32-bit unsigned integer.
 * @param num - The number to validate
 * @throws {Error} If the number is not a valid 32-bit integer
 */
function check32Bit(num) {
    if (typeof num !== 'number' || num !== Math.floor(num) || num > 0xffffffff || num < 0) {
        throw new Error('Invalid 32 bit integer');
    }
}
/**
 * Checks if the cache is in a valid state for export.
 * @param cache - The PSBT cache to check
 * @throws {Error} If the cache is not BIP174 compliant
 */
function checkCache(cache) {
    if (cache.unsafeSignNonSegwit) {
        throw new Error('Not BIP174 compliant, can not export');
    }
}
/**
 * Checks if a PSBT input has been finalized.
 * @param input - The PSBT input to check
 * @returns True if the input has finalScriptSig or finalScriptWitness
 */
function isFinalized(input) {
    return !!input.finalScriptSig || !!input.finalScriptWitness;
}
/**
 * Validates that a transaction has empty scriptSigs and witnesses.
 * @param tx - The transaction to check
 * @throws {Error} If any input has non-empty scripts
 */
function checkTxEmpty(tx) {
    const isEmpty = tx.ins.every((input) => input.script &&
        input.script.length === 0 &&
        input.witness &&
        input.witness.length === 0);
    if (!isEmpty) {
        throw new Error('Format Error: Transaction ScriptSigs are not empty');
    }
}
/**
 * Checks and caches a transaction input to detect duplicates.
 * @param cache - The PSBT cache
 * @param input - The input to check
 * @throws {Error} If a duplicate input is detected
 */
function checkTxInputCache(cache, input) {
    const reversed = reverse(new Uint8Array(input.hash));
    const key = `${toHex$1(reversed)}:${input.index}`;
    if (cache.txInCache[key])
        throw new Error('Duplicate input detected.');
    cache.txInCache[key] = 1;
}
/**
 * Checks all transaction inputs for duplicates.
 * @param tx - The transaction to check
 * @param cache - The PSBT cache
 * @throws {Error} If duplicate inputs are detected
 */
function checkTxForDupeIns(tx, cache) {
    tx.ins.forEach((input) => {
        checkTxInputCache(cache, input);
    });
}
/**
 * Checks if any inputs have partial signatures that would prevent modification.
 * @param inputs - The PSBT inputs to check
 * @param action - The action being attempted (for error message)
 * @param hasSignaturesCache - Optional cached flag (true = definitely has sigs, false = check needed)
 * @throws {Error} If signatures exist and prevent modification
 */
function checkInputsForPartialSig(inputs, action, hasSignaturesCache) {
    // Fast path: if cache says no signatures, skip entirely (O(1))
    if (hasSignaturesCache === false) {
        return;
    }
    // Only do full validation if signatures might exist
    inputs.forEach((input) => {
        const throws = isTaprootInput$1(input)
            ? checkTaprootInputForSigs(input, action)
            : checkInputForSig(input, action);
        if (throws)
            throw new Error('Can not modify transaction, signatures exist.');
    });
}
/**
 * Validates that partial signature sighash types match the input's sighash type.
 * @param input - The PSBT input to check
 * @throws {Error} If sighash types don't match
 */
function checkPartialSigSighashes(input) {
    if (!input.sighashType || !input.partialSig)
        return;
    const { partialSig, sighashType } = input;
    partialSig.forEach((pSig) => {
        const { hashType } = signature.decode(pSig.signature);
        if (sighashType !== hashType) {
            throw new Error('Signature sighash does not match input sighash type');
        }
    });
}
/**
 * Validates that a pubkey exists in a script.
 * @param pubkey - The pubkey to find
 * @param script - The script to search
 * @param action - The action being attempted (for error message)
 * @throws {Error} If the pubkey is not found in the script
 */
function checkScriptForPubkey(pubkey, script, action) {
    if (!pubkeyInScript$1(pubkey, script)) {
        throw new Error(`Can not ${action} for this input with the key ${toHex$1(pubkey)}`);
    }
}
/**
 * Creates a script checker function for validating redeem/witness scripts.
 * @param payment - The payment function to use (p2sh or p2wsh)
 * @param paymentScriptName - Name for error messages
 * @returns A function that validates scripts match
 */
function scriptCheckerFactory(payment, paymentScriptName) {
    return (inputIndex, scriptPubKey, redeemScript, ioType) => {
        const redeemScriptOutput = payment({
            redeem: { output: redeemScript },
        }).output;
        if (!equals(scriptPubKey, redeemScriptOutput)) {
            throw new Error(`${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`);
        }
    };
}
/**
 * Validates that a redeem script matches the scriptPubKey.
 */
const checkRedeemScript = scriptCheckerFactory(p2sh, 'Redeem script');
/**
 * Validates that a witness script matches the scriptPubKey.
 */
const checkWitnessScript = scriptCheckerFactory(p2wsh, 'Witness script');

/**
 * PSBT utility functions
 * @packageDocumentation
 */
/**
 * Converts a witness script buffer to an array of witness stack items.
 * @param buffer - The witness script buffer
 * @returns Array of witness stack items
 */
function scriptWitnessToWitnessStack(buffer) {
    let offset = 0;
    function readSlice(n) {
        offset += n;
        return buffer.subarray(offset - n, offset);
    }
    function readVarInt() {
        const vi = decode$j(buffer, offset);
        offset += vi.bytes;
        return vi.numberValue || 0;
    }
    function readVarSlice() {
        return readSlice(readVarInt());
    }
    function readVector() {
        const count = readVarInt();
        const vector = [];
        for (let i = 0; i < count; i++)
            vector.push(readVarSlice());
        return vector;
    }
    return readVector();
}
/**
 * Converts a sighash type to a human-readable string.
 * @param sighashType - The sighash type value
 * @returns Human-readable sighash type string
 */
function sighashTypeToString(sighashType) {
    let text = sighashType & Transaction.SIGHASH_ANYONECANPAY ? 'SIGHASH_ANYONECANPAY | ' : '';
    const sigMod = sighashType & 0x1f;
    switch (sigMod) {
        case Transaction.SIGHASH_ALL:
            text += 'SIGHASH_ALL';
            break;
        case Transaction.SIGHASH_SINGLE:
            text += 'SIGHASH_SINGLE';
            break;
        case Transaction.SIGHASH_NONE:
            text += 'SIGHASH_NONE';
            break;
    }
    return text;
}
/**
 * Compresses an uncompressed public key to compressed form.
 * @param pubkey - The public key (33 or 65 bytes)
 * @returns Compressed public key (33 bytes)
 */
function compressPubkey(pubkey) {
    if (pubkey.length === 65) {
        const parity = pubkey[64] & 1;
        const newKey = new Uint8Array(pubkey.subarray(0, 33));
        newKey[0] = 2 | parity;
        return newKey;
    }
    return new Uint8Array(pubkey);
}
/**
 * Checks if a buffer looks like a public key.
 * @param buf - The buffer to check
 * @returns True if the buffer is a valid compressed public key format
 */
function isPubkeyLike(buf) {
    return buf.length === 33 && isCanonicalPubKey(buf);
}
/**
 * Checks if a buffer looks like a signature.
 * @param buf - The buffer to check
 * @returns True if the buffer is a valid canonical signature format
 */
function isSigLike(buf) {
    return isCanonicalScriptSignature(buf);
}
/**
 * Classifies a script into a known script type.
 * @param script - The script to classify
 * @returns The script type
 */
function classifyScript(script) {
    if (isP2WPKH(script))
        return 'witnesspubkeyhash';
    if (isP2PKH(script))
        return 'pubkeyhash';
    if (isP2MS(script))
        return 'multisig';
    if (isP2PK(script))
        return 'pubkey';
    return 'nonstandard';
}
/**
 * Creates an array of numbers from 0 to n-1.
 * @param n - The length of the array
 * @returns Array of numbers [0, 1, 2, ..., n-1]
 */
function range$1(n) {
    return [...Array(n).keys()];
}
/**
 * Validates that a script is not P2WPKH or P2SH (invalid for P2WSH).
 * @param script - The script to check
 * @throws {Error} If the script is P2WPKH or P2SH
 */
function checkInvalidP2WSH(script) {
    if (isP2WPKH(script) || isP2SHScript(script)) {
        throw new Error('P2WPKH or P2SH can not be contained within P2WSH');
    }
}
/**
 * Extracts the meaningful script from a potentially wrapped script.
 * Handles P2SH, P2WSH, and P2SH-P2WSH wrapping.
 * @param script - The script to analyze
 * @param index - The input/output index (for error messages)
 * @param ioType - Whether this is an input or output
 * @param redeemScript - Optional redeem script for P2SH
 * @param witnessScript - Optional witness script for P2WSH
 * @returns The meaningful script and its type
 */
function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
    const isP2SH = isP2SHScript(script);
    const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);
    const isP2WSH = isP2WSHScript(script);
    if (isP2SH && redeemScript === undefined)
        throw new Error('scriptPubkey is P2SH but redeemScript missing');
    let meaningfulScript;
    if (isP2SHP2WSH) {
        if (!witnessScript)
            throw new Error('scriptPubkey or redeemScript is P2WSH but witnessScript missing');
        if (!redeemScript)
            throw new Error('P2SH-P2WSH requires redeemScript');
        meaningfulScript = witnessScript;
        checkRedeemScript(index, script, redeemScript, ioType);
        checkWitnessScript(index, redeemScript, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
    }
    else if (isP2WSH) {
        if (!witnessScript)
            throw new Error('scriptPubkey or redeemScript is P2WSH but witnessScript missing');
        meaningfulScript = witnessScript;
        checkWitnessScript(index, script, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
    }
    else if (isP2SH) {
        if (!redeemScript)
            throw new Error('P2SH requires redeemScript');
        meaningfulScript = redeemScript;
        checkRedeemScript(index, script, redeemScript, ioType);
    }
    else {
        meaningfulScript = script;
    }
    return {
        meaningfulScript,
        type: isP2SHP2WSH ? 'p2sh-p2wsh' : isP2SH ? 'p2sh' : isP2WSH ? 'p2wsh' : 'raw',
    };
}

/**
 * Internal PSBT cache for computed values.
 * Wraps all cache management previously handled by a plain interface + scattered helper functions.
 */
class PsbtCache {
    nonWitnessUtxoTxCache;
    nonWitnessUtxoBufCache;
    txInCache;
    tx;
    unsafeSignNonSegwit;
    hasSignatures;
    fee;
    feeRate;
    extractedTx;
    prevOuts;
    signingScripts;
    values;
    taprootHashCache;
    constructor(tx) {
        this.nonWitnessUtxoTxCache = [];
        this.nonWitnessUtxoBufCache = [];
        this.txInCache = {};
        this.tx = tx;
        this.unsafeSignNonSegwit = false;
        this.hasSignatures = false;
    }
    /**
     * Invalidates cached computed values.
     * @param scope - 'full' clears everything (for input changes), 'outputs' clears fee/extract/taproot caches
     */
    invalidate(scope) {
        this.fee = undefined;
        this.feeRate = undefined;
        this.extractedTx = undefined;
        this.taprootHashCache = undefined;
        if (scope === 'full') {
            this.prevOuts = undefined;
            this.signingScripts = undefined;
            this.values = undefined;
        }
    }
    addNonWitnessTxCache(input, inputIndex, txFromBuffer) {
        if (!input.nonWitnessUtxo)
            throw new Error('nonWitnessUtxo is required');
        if (input === null || input === Object.prototype) {
            throw new Error('Invalid input object');
        }
        const nonWitnessUtxoBuf = input.nonWitnessUtxo;
        this.nonWitnessUtxoBufCache[inputIndex] = nonWitnessUtxoBuf;
        this.nonWitnessUtxoTxCache[inputIndex] = txFromBuffer(nonWitnessUtxoBuf);
    }
    getNonWitnessUtxoTx(input, inputIndex, txFromBuffer) {
        const cached = this.nonWitnessUtxoTxCache[inputIndex];
        if (!cached) {
            this.addNonWitnessTxCache(input, inputIndex, txFromBuffer);
        }
        return this.nonWitnessUtxoTxCache[inputIndex];
    }
    getScriptFromUtxo(inputIndex, input, txFromBuffer) {
        const { script } = this.getScriptAndAmountFromUtxo(inputIndex, input, txFromBuffer);
        return script;
    }
    getScriptAndAmountFromUtxo(inputIndex, input, txFromBuffer) {
        if (input.witnessUtxo !== undefined) {
            return {
                script: input.witnessUtxo.script,
                value: input.witnessUtxo.value,
            };
        }
        else if (input.nonWitnessUtxo !== undefined) {
            const nonWitnessUtxoTx = this.getNonWitnessUtxoTx(input, inputIndex, txFromBuffer);
            const txIn = this.tx.ins[inputIndex];
            const o = nonWitnessUtxoTx.outs[txIn.index];
            return { script: o.script, value: o.value };
        }
        else {
            throw new Error("Can't find pubkey in input without Utxo data");
        }
    }
    computeFee(inputs, disableOutputChecks = false, txFromBuffer) {
        if (!inputs.every(isFinalized))
            throw new Error('PSBT must be finalized to calculate fee');
        if (this.fee !== undefined)
            return this.fee;
        let tx;
        let mustFinalize = true;
        if (this.extractedTx) {
            tx = this.extractedTx;
            mustFinalize = false;
        }
        else {
            tx = this.tx.clone();
        }
        const { fee } = this.finalizeAndComputeAmounts(inputs, tx, mustFinalize, disableOutputChecks, txFromBuffer);
        return fee;
    }
    computeFeeRate(inputs, disableOutputChecks = false, txFromBuffer) {
        if (!inputs.every(isFinalized))
            throw new Error('PSBT must be finalized to calculate fee rate');
        if (this.feeRate !== undefined)
            return this.feeRate;
        let tx;
        let mustFinalize = true;
        if (this.extractedTx) {
            tx = this.extractedTx;
            mustFinalize = false;
        }
        else {
            tx = this.tx.clone();
        }
        const { feeRate } = this.finalizeAndComputeAmounts(inputs, tx, mustFinalize, disableOutputChecks, txFromBuffer);
        return feeRate;
    }
    checkFees(opts) {
        const feeRate = this.feeRate;
        if (!this.extractedTx)
            throw new Error('Transaction not extracted');
        if (feeRate === undefined)
            throw new Error('Fee rate not computed');
        const vsize = this.extractedTx.virtualSize();
        const satoshis = feeRate * vsize;
        if (feeRate >= opts.maximumFeeRate) {
            throw new Error(`Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +
                `fees, which is ${feeRate} satoshi per byte for a transaction ` +
                `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +
                `byte). Use setMaximumFeeRate method to raise your threshold, or ` +
                `pass true to the first arg of extractTransaction.`);
        }
    }
    pubkeyInInput(pubkey, input, inputIndex, txFromBuffer) {
        const script = this.getScriptFromUtxo(inputIndex, input, txFromBuffer);
        const { meaningfulScript } = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript, input.witnessScript);
        return pubkeyInScript$1(pubkey, meaningfulScript);
    }
    pubkeyInOutput(pubkey, output, outputIndex) {
        const script = this.tx.outs[outputIndex].script;
        const { meaningfulScript } = getMeaningfulScript(script, outputIndex, 'output', output.redeemScript, output.witnessScript);
        return pubkeyInScript$1(pubkey, meaningfulScript);
    }
    redeemFromFinalScriptSig(finalScript) {
        if (!finalScript)
            return;
        const decomp = decompile(finalScript);
        if (!decomp)
            return;
        const lastItem = decomp[decomp.length - 1];
        if (!(lastItem instanceof Uint8Array) || isPubkeyLike(lastItem) || isSigLike(lastItem))
            return;
        const sDecomp = decompile(lastItem);
        if (!sDecomp)
            return;
        return lastItem;
    }
    redeemFromFinalWitnessScript(finalScript) {
        if (!finalScript)
            return;
        const decomp = scriptWitnessToWitnessStack(finalScript);
        const lastItem = decomp[decomp.length - 1];
        if (!lastItem)
            return;
        if (isPubkeyLike(lastItem))
            return;
        const sDecomp = decompile(lastItem);
        if (!sDecomp)
            return;
        return lastItem;
    }
    /**
     * Finalize transaction inputs and compute fee amounts.
     * Returns computed values instead of mutating cache parameters directly.
     */
    finalizeAndComputeAmounts(inputs, tx, mustFinalize, disableOutputChecks, txFromBuffer) {
        let inputAmount = 0n;
        inputs.forEach((input, idx) => {
            const txIn = tx.ins[idx];
            if (mustFinalize && input.finalScriptSig)
                txIn.script = input.finalScriptSig;
            if (mustFinalize && input.finalScriptWitness) {
                txIn.witness = scriptWitnessToWitnessStack(input.finalScriptWitness);
            }
            if (input.witnessUtxo) {
                inputAmount += input.witnessUtxo.value;
            }
            else if (input.nonWitnessUtxo) {
                if (!txFromBuffer)
                    throw new Error('txFromBuffer is required for nonWitnessUtxo inputs');
                const nwTx = this.getNonWitnessUtxoTx(input, idx, txFromBuffer);
                const vout = txIn.index;
                const out = nwTx.outs[vout];
                inputAmount += out.value;
            }
        });
        const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0n);
        const feeValue = inputAmount - outputAmount;
        if (!disableOutputChecks) {
            if (feeValue < 0n) {
                throw new Error(`Outputs are spending more than Inputs ${inputAmount} < ${outputAmount}`);
            }
        }
        const bytes = tx.virtualSize();
        const fee = Number(feeValue);
        const feeRate = Math.floor(fee / bytes);
        this.fee = fee;
        this.extractedTx = tx;
        this.feeRate = feeRate;
        return { fee, feeRate };
    }
    getScriptFromInput(inputIndex, input, txFromBuffer) {
        const res = {
            script: null,
            isSegwit: false,
            isP2SH: false,
            isP2WSH: false,
        };
        res.isP2SH = !!input.redeemScript;
        res.isP2WSH = !!input.witnessScript;
        if (input.witnessScript) {
            res.script = input.witnessScript;
        }
        else if (input.redeemScript) {
            res.script = input.redeemScript;
        }
        else {
            if (input.nonWitnessUtxo) {
                const nonWitnessUtxoTx = this.getNonWitnessUtxoTx(input, inputIndex, txFromBuffer);
                const prevoutIndex = this.tx.ins[inputIndex].index;
                res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
            }
            else if (input.witnessUtxo) {
                res.script = input.witnessUtxo.script;
            }
        }
        if (input.witnessScript || (res.script && isP2WPKH(res.script))) {
            res.isSegwit = true;
        }
        else {
            if (res.script && isUnknownSegwitVersion(res.script)) {
                res.isSegwit = true;
            }
        }
        return res;
    }
    getPrevoutTaprootKey(inputIndex, input, txFromBuffer) {
        const { script } = this.getScriptAndAmountFromUtxo(inputIndex, input, txFromBuffer);
        return isP2TR(script) ? script.subarray(2, 34) : null;
    }
}

/**
 * Class wrapping all signing-related logic for PSBT.
 */
class PsbtSigner {
    #cache;
    #txFromBuffer;
    constructor(cache, txFromBuffer) {
        this.#cache = cache;
        this.#txFromBuffer = txFromBuffer;
    }
    getHashAndSighashType(inputs, inputIndex, pubkey, sighashTypes) {
        const input = checkForInput(inputs, inputIndex);
        const { hash, sighashType, script } = this.getHashForSig(inputIndex, input, false, sighashTypes);
        checkScriptForPubkey(pubkey, script, 'sign');
        return { hash, sighashType };
    }
    getHashForSig(inputIndex, input, forValidate, sighashTypes) {
        const unsignedTx = this.#cache.tx;
        const sighashType = input.sighashType || Transaction.SIGHASH_ALL;
        checkSighashTypeAllowed(sighashType, sighashTypes);
        let hash;
        let prevout;
        if (input.nonWitnessUtxo) {
            const nonWitnessUtxoTx = this.#cache.getNonWitnessUtxoTx(input, inputIndex, this.#txFromBuffer);
            const txIn = unsignedTx.ins[inputIndex];
            const prevoutHash = txIn.hash;
            const utxoHash = nonWitnessUtxoTx.getHash();
            if (!equals(prevoutHash, utxoHash)) {
                throw new Error(`Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`);
            }
            const prevoutIndex = txIn.index;
            prevout = nonWitnessUtxoTx.outs[prevoutIndex];
        }
        else if (input.witnessUtxo) {
            prevout = {
                script: input.witnessUtxo.script,
                value: input.witnessUtxo.value,
            };
        }
        else {
            throw new Error('Need a Utxo input item for signing');
        }
        const { meaningfulScript, type } = getMeaningfulScript(prevout.script, inputIndex, 'input', input.redeemScript, input.witnessScript);
        const script = meaningfulScript;
        if (['p2sh-p2wsh', 'p2wsh'].includes(type)) {
            hash = unsignedTx.hashForWitnessV0(inputIndex, script, prevout.value, sighashType);
        }
        else if (isP2WPKH(meaningfulScript)) {
            const p2pkhPayment = p2pkh({
                hash: meaningfulScript.subarray(2),
            });
            if (!p2pkhPayment.output)
                throw new Error('Unable to create signing script');
            hash = unsignedTx.hashForWitnessV0(inputIndex, p2pkhPayment.output, prevout.value, sighashType);
        }
        else {
            // non-segwit
            if (input.nonWitnessUtxo === undefined && !this.#cache.unsafeSignNonSegwit)
                throw new Error(`Input #${inputIndex} has witnessUtxo but non-segwit script: ` +
                    toHex$1(meaningfulScript));
            if (!forValidate && this.#cache.unsafeSignNonSegwit)
                console.warn('Warning: Signing non-segwit inputs without the full parent transaction ' +
                    'means there is a chance that a miner could feed you incorrect information ' +
                    "to trick you into paying large fees. This behavior is the same as Psbt's predecessor " +
                    '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +
                    'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +
                    'BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n' +
                    '*********************');
            hash = unsignedTx.hashForSignature(inputIndex, script, sighashType);
        }
        return { script, sighashType, hash };
    }
    getTaprootHashesForSig(inputIndex, input, inputs, pubkey, tapLeafHashToSign, allowedSighashTypes) {
        const unsignedTx = this.#cache.tx;
        const sighashType = input.sighashType || Transaction.SIGHASH_DEFAULT;
        checkSighashTypeAllowed(sighashType, allowedSighashTypes);
        if (!this.#cache.prevOuts) {
            const prevOuts = inputs.map((i, index) => this.#cache.getScriptAndAmountFromUtxo(index, i, this.#txFromBuffer));
            this.#cache.prevOuts = prevOuts;
            this.#cache.signingScripts = prevOuts.map((o) => o.script);
            this.#cache.values = prevOuts.map((o) => o.value);
        }
        const signingScripts = this.#cache.signingScripts;
        const values = this.#cache.values;
        if (!this.#cache.taprootHashCache) {
            this.#cache.taprootHashCache = unsignedTx.getTaprootHashCache(signingScripts, values);
        }
        const taprootCache = this.#cache.taprootHashCache;
        const hashes = [];
        if (input.tapInternalKey && !tapLeafHashToSign) {
            const outputKey = this.#cache.getPrevoutTaprootKey(inputIndex, input, this.#txFromBuffer) ||
                new Uint8Array(0);
            if (equals(toXOnly(pubkey), outputKey)) {
                const tapKeyHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType, undefined, undefined, taprootCache);
                hashes.push({ pubkey: pubkey, hash: tapKeyHash });
            }
        }
        const tapLeafHashes = (input.tapLeafScript || [])
            .filter((tapLeaf) => pubkeyInScript$1(pubkey, tapLeaf.script))
            .map((tapLeaf) => {
            const hash = tapleafHash({
                output: tapLeaf.script,
                version: tapLeaf.leafVersion,
            });
            return Object.assign({ hash }, tapLeaf);
        })
            .filter((tapLeaf) => !tapLeafHashToSign || equals(tapLeafHashToSign, tapLeaf.hash))
            .map((tapLeaf) => {
            const tapScriptHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType, tapLeaf.hash, undefined, taprootCache);
            return {
                pubkey: pubkey,
                hash: tapScriptHash,
                leafHash: tapLeaf.hash,
            };
        });
        return hashes.concat(tapLeafHashes);
    }
    getAllTaprootHashesForSig(inputIndex, input, inputs) {
        const allPublicKeys = [];
        if (input.tapInternalKey) {
            const key = this.#cache.getPrevoutTaprootKey(inputIndex, input, this.#txFromBuffer);
            if (key) {
                allPublicKeys.push(key);
            }
        }
        if (input.tapScriptSig) {
            const tapScriptPubkeys = input.tapScriptSig.map((tss) => tss.pubkey);
            allPublicKeys.push(...tapScriptPubkeys);
        }
        const allHashes = allPublicKeys.map((pubicKey) => this.getTaprootHashesForSig(inputIndex, input, inputs, pubicKey));
        return allHashes.flat();
    }
    trimTaprootSig(signature) {
        return signature.length === 64 ? signature : signature.subarray(0, 64);
    }
    getSignersFromHD(inputIndex, inputs, hdKeyPair) {
        const input = checkForInput(inputs, inputIndex);
        if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
            throw new Error('Need bip32Derivation to sign with HD');
        }
        const myDerivations = input.bip32Derivation
            .map((bipDv) => {
            if (equals(bipDv.masterFingerprint, hdKeyPair.fingerprint)) {
                return bipDv;
            }
            else {
                return;
            }
        })
            .filter((v) => !!v);
        if (myDerivations.length === 0) {
            throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');
        }
        return myDerivations.map((bipDv) => {
            const node = hdKeyPair.derivePath(bipDv.path);
            if (!equals(bipDv.pubkey, node.publicKey)) {
                throw new Error('pubkey did not match bip32Derivation');
            }
            return node;
        });
    }
    bip32DerivationIsMine(root) {
        return (d) => {
            const fingerprint = root.fingerprint instanceof Uint8Array
                ? root.fingerprint
                : new Uint8Array(root.fingerprint);
            if (!equals(d.masterFingerprint, fingerprint))
                return false;
            const derivedPubkey = root.derivePath(d.path).publicKey;
            const pubkey = derivedPubkey instanceof Uint8Array ? derivedPubkey : new Uint8Array(derivedPubkey);
            if (!equals(pubkey, d.pubkey))
                return false;
            return true;
        };
    }
}
function checkSighashTypeAllowed(sighashType, sighashTypes) {
    if (sighashTypes && !sighashTypes.includes(sighashType)) {
        const str = sighashTypeToString(sighashType);
        throw new Error(`Sighash type is not allowed. Retry the sign method passing the ` +
            `sighashTypes array of whitelisted types. Sighash type: ${str}`);
    }
}

/**
 * Class wrapping all finalization logic for PSBT.
 */
class PsbtFinalizer {
    #cache;
    #txFromBuffer;
    constructor(cache, txFromBuffer) {
        this.#cache = cache;
        this.#txFromBuffer = txFromBuffer;
    }
    getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
        const scriptType = classifyScript(script);
        if (!canFinalize(input, script, scriptType) && canRunChecks) {
            throw new Error(`Can not finalize input #${inputIndex}`);
        }
        if (!input.partialSig)
            throw new Error('Input missing partial signatures');
        return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH, solution);
    }
    getScriptFromInput(inputIndex, input) {
        return this.#cache.getScriptFromInput(inputIndex, input, this.#txFromBuffer);
    }
}
function getFinalScripts$1(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
    const scriptType = classifyScript(script);
    if (!canFinalize(input, script, scriptType) && canRunChecks) {
        throw new Error(`Can not finalize input #${inputIndex}`);
    }
    if (!input.partialSig)
        throw new Error('Input missing partial signatures');
    return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH, solution);
}
function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH, solution) {
    let finalScriptSig;
    let finalScriptWitness;
    const payment = getPayment(script, scriptType, partialSig);
    const p2wsh$1 = !isP2WSH ? null : p2wsh({ redeem: payment });
    const p2sh$1 = !isP2SH ? null : p2sh({ redeem: p2wsh$1 || payment });
    if (isSegwit) {
        if (p2wsh$1 && p2wsh$1.witness) {
            finalScriptWitness = witnessStackToScriptWitness$1(p2wsh$1.witness);
        }
        else if (payment && payment.witness) {
            finalScriptWitness = witnessStackToScriptWitness$1(payment.witness);
        }
        else {
            finalScriptWitness = witnessStackToScriptWitness$1(solution ?? [new Uint8Array([0x00])]);
        }
        if (p2sh$1) {
            finalScriptSig = p2sh$1?.input;
        }
    }
    else {
        if (p2sh$1) {
            finalScriptSig = p2sh$1?.input;
        }
        else {
            if (!payment) {
                finalScriptSig = (Array.isArray(solution) && solution[0] ? solution[0] : new Uint8Array([0x01]));
            }
            else {
                finalScriptSig = payment.input;
            }
        }
    }
    return { finalScriptSig, finalScriptWitness };
}
function canFinalize(input, script, scriptType) {
    switch (scriptType) {
        case 'pubkey':
        case 'pubkeyhash':
        case 'witnesspubkeyhash':
            return hasSigs(1, input.partialSig);
        case 'multisig': {
            const p2ms$1 = p2ms({
                output: script,
            });
            if (p2ms$1.m === undefined)
                throw new Error('Cannot determine m for multisig');
            return hasSigs(p2ms$1.m, input.partialSig, p2ms$1.pubkeys);
        }
        case 'nonstandard':
            return true;
        default:
            return false;
    }
}
function hasSigs(neededSigs, partialSig, pubkeys) {
    if (!partialSig)
        return false;
    let sigs;
    if (pubkeys) {
        sigs = pubkeys
            .map((pkey) => {
            const pubkey = compressPubkey(pkey);
            return partialSig.find((pSig) => equals(pSig.pubkey, pubkey));
        })
            .filter((v) => !!v);
    }
    else {
        sigs = partialSig;
    }
    if (sigs.length > neededSigs)
        throw new Error('Too many signatures');
    return sigs.length === neededSigs;
}
function getPayment(script, scriptType, partialSig) {
    const scriptBranded = script;
    switch (scriptType) {
        case 'multisig': {
            const sigs = getSortedSigs(script, partialSig);
            return p2ms({
                output: scriptBranded,
                signatures: sigs,
            });
        }
        case 'pubkey': {
            const sig0 = partialSig[0];
            return p2pk({
                output: scriptBranded,
                signature: sig0.signature,
            });
        }
        case 'pubkeyhash': {
            const sig0 = partialSig[0];
            return p2pkh({
                output: scriptBranded,
                pubkey: sig0.pubkey,
                signature: sig0.signature,
            });
        }
        case 'witnesspubkeyhash': {
            const sig0 = partialSig[0];
            return p2wpkh({
                output: scriptBranded,
                pubkey: sig0.pubkey,
                signature: sig0.signature,
            });
        }
        default:
            throw new Error(`Unknown script type: ${scriptType}`);
    }
}
function getSortedSigs(script, partialSig) {
    const p2ms$1 = p2ms({ output: script });
    if (!p2ms$1.pubkeys)
        throw new Error('Cannot extract pubkeys from multisig script');
    const result = [];
    for (const pk of p2ms$1.pubkeys) {
        const matched = partialSig.filter((ps) => {
            return equals(ps.pubkey, pk);
        })[0];
        if (matched) {
            result.push(new Uint8Array(matched.signature));
        }
    }
    return result;
}

/**
 * Empty version-2 transaction with zero inputs and zero outputs.
 * Used as the default buffer when constructing a new PsbtTransaction.
 *
 * Layout: [version(4LE)] [inputCount(varint)] [outputCount(varint)] [locktime(4LE)]
 *         [02 00 00 00]  [00]                 [00]                  [00 00 00 00]
 */
const EMPTY_TX_V2 = new Uint8Array([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
/**
 * This class implements the Transaction interface from bip174 library.
 * It contains a bitcoinjs-lib Transaction object.
 */
class PsbtTransaction {
    tx;
    constructor(buffer = EMPTY_TX_V2) {
        this.tx = Transaction.fromBuffer(buffer);
        checkTxEmpty(this.tx);
        Object.defineProperty(this, 'tx', {
            enumerable: false,
            writable: true,
        });
    }
    getInputOutputCounts() {
        return {
            inputCount: this.tx.ins.length,
            outputCount: this.tx.outs.length,
        };
    }
    addInput(input) {
        if (input.hash === undefined ||
            input.index === undefined ||
            (!(input.hash instanceof Uint8Array) && typeof input.hash !== 'string') ||
            typeof input.index !== 'number') {
            throw new Error('Error adding input.');
        }
        const hash = (typeof input.hash === 'string' ? reverse(fromHex$1(input.hash)) : input.hash);
        this.tx.addInput(hash, input.index, input.sequence);
    }
    addOutput(output) {
        if (output.script === undefined ||
            output.value === undefined ||
            !(output.script instanceof Uint8Array) ||
            typeof output.value !== 'bigint') {
            throw new Error('Error adding output.');
        }
        this.tx.addOutput(output.script, output.value);
    }
    toBuffer() {
        return this.tx.toBuffer();
    }
}
/**
 * This function is needed to pass to the bip174 base class's fromBuffer.
 * It takes the "transaction buffer" portion of the psbt buffer and returns a
 * Transaction (From the bip174 library) interface.
 */
const transactionFromBuffer = (buffer) => new PsbtTransaction(buffer);

const DEFAULT_OPTS = {
  network: bitcoin$1,
  maximumFeeRate: 5e3
};
function txFromBuffer(buf) {
  return Transaction.fromBuffer(buf);
}
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
  return getFinalScripts$1(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks, solution);
}
class Psbt {
  data;
  #cache;
  #signer;
  #finalizer;
  #opts;
  constructor(opts = {}, data = new Psbt$1(new PsbtTransaction())) {
    this.data = data;
    this.#opts = Object.assign({}, DEFAULT_OPTS, opts);
    const tx = this.data.globalMap.unsignedTx.tx;
    this.#cache = new PsbtCache(tx);
    if (opts.version === 3) {
      this.setVersionTRUC();
    } else if (this.data.inputs.length === 0)
      this.setVersion(2);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.#cache.tx.version;
  }
  set version(version) {
    this.setVersion(version);
  }
  get locktime() {
    return this.#cache.tx.locktime;
  }
  set locktime(locktime) {
    this.setLocktime(locktime);
  }
  get txInputs() {
    return this.#cache.tx.ins.map((input) => ({
      hash: clone$1(input.hash),
      index: input.index,
      sequence: input.sequence
    }));
  }
  get txOutputs() {
    return this.#cache.tx.outs.map((output) => {
      let address;
      try {
        address = fromOutputScript(output.script, this.#opts.network);
      } catch (_) {
      }
      return {
        script: clone$1(output.script),
        value: output.value,
        address
      };
    });
  }
  /** Lazily initialized signer - created on first access */
  get #lazySigner() {
    if (!this.#signer) {
      this.#signer = new PsbtSigner(this.#cache, txFromBuffer);
    }
    return this.#signer;
  }
  /** Lazily initialized finalizer - created on first access */
  get #lazyFinalizer() {
    if (!this.#finalizer) {
      this.#finalizer = new PsbtFinalizer(this.#cache, txFromBuffer);
    }
    return this.#finalizer;
  }
  static fromBase64(data, opts = {}) {
    const buffer = fromBase64$1(data);
    return this.fromBuffer(buffer, opts);
  }
  static fromHex(data, opts = {}) {
    const buffer = fromHex$1(data);
    return this.fromBuffer(buffer, opts);
  }
  static fromBuffer(buffer, opts = {}) {
    const psbtBase = Psbt$1.fromBuffer(buffer, transactionFromBuffer);
    const psbt = new Psbt(opts, psbtBase);
    checkTxForDupeIns(psbt.#cache.tx, psbt.#cache);
    psbt.#cache.hasSignatures = psbt.data.inputs.some((input) => input.partialSig?.length || input.tapKeySig || input.tapScriptSig?.length || input.finalScriptSig || input.finalScriptWitness);
    return psbt;
  }
  combine(...those) {
    this.data.combine(...those.map((o) => o.data));
    return this;
  }
  clone() {
    const clonedOpts = structuredClone(this.#opts);
    return Psbt.fromBuffer(new Uint8Array(this.data.toBuffer()), clonedOpts);
  }
  get maximumFeeRate() {
    return this.#opts.maximumFeeRate;
  }
  setMaximumFeeRate(satoshiPerByte) {
    check32Bit(satoshiPerByte);
    this.#opts.maximumFeeRate = satoshiPerByte;
  }
  setVersion(version) {
    check32Bit(version);
    checkInputsForPartialSig(this.data.inputs, "setVersion", this.#cache.hasSignatures);
    this.#cache.tx.version = version;
    this.#cache.invalidate("outputs");
    return this;
  }
  setVersionTRUC() {
    return this.setVersion(Transaction.TRUC_VERSION);
  }
  setLocktime(locktime) {
    check32Bit(locktime);
    checkInputsForPartialSig(this.data.inputs, "setLocktime", this.#cache.hasSignatures);
    this.#cache.tx.locktime = locktime;
    this.#cache.invalidate("outputs");
    return this;
  }
  setInputSequence(inputIndex, sequence) {
    check32Bit(sequence);
    checkInputsForPartialSig(this.data.inputs, "setInputSequence", this.#cache.hasSignatures);
    if (this.#cache.tx.ins.length <= inputIndex) {
      throw new Error("Input index too high");
    }
    this.#cache.tx.ins[inputIndex].sequence = sequence;
    this.#cache.invalidate("outputs");
    return this;
  }
  addInputs(inputDatas, checkPartialSigs = true) {
    inputDatas.forEach((inputData) => this.addInput(inputData, checkPartialSigs));
    return this;
  }
  addInput(inputData, checkPartialSigs = true) {
    if (!inputData || inputData.hash === void 0 || inputData.index === void 0) {
      throw new Error(`Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]`);
    }
    checkTaprootInputFields(inputData, inputData, "addInput");
    if (checkPartialSigs) {
      checkInputsForPartialSig(this.data.inputs, "addInput", this.#cache.hasSignatures);
    }
    if (inputData.witnessScript)
      checkInvalidP2WSH(inputData.witnessScript);
    const normalizedInputData = inputData.witnessUtxo ? {
      ...inputData,
      witnessUtxo: {
        script: inputData.witnessUtxo.script,
        value: typeof inputData.witnessUtxo.value === "bigint" ? inputData.witnessUtxo.value : BigInt(inputData.witnessUtxo.value)
      }
    } : inputData;
    this.data.addInput(normalizedInputData);
    const txIn = this.#cache.tx.ins[this.#cache.tx.ins.length - 1];
    checkTxInputCache(this.#cache, txIn);
    const inputIndex = this.data.inputs.length - 1;
    const input = this.data.inputs[inputIndex];
    if (input.nonWitnessUtxo) {
      this.#cache.addNonWitnessTxCache(input, inputIndex, txFromBuffer);
    }
    this.#cache.invalidate("full");
    return this;
  }
  addOutputs(outputDatas, checkPartialSigs = true) {
    outputDatas.forEach((outputData) => this.addOutput(outputData, checkPartialSigs));
    return this;
  }
  addOutput(outputData, checkPartialSigs = true) {
    const hasAddress = "address" in outputData;
    const hasScript = "script" in outputData;
    if (!outputData || outputData.value === void 0 || !hasAddress && !hasScript) {
      throw new Error(`Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]`);
    }
    if (checkPartialSigs) {
      checkInputsForPartialSig(this.data.inputs, "addOutput", this.#cache.hasSignatures);
    }
    if (hasAddress) {
      const { address } = outputData;
      const { network } = this.#opts;
      const script = toOutputScript(address, network);
      outputData = Object.assign({}, outputData, { script });
    }
    checkTaprootOutputFields(outputData, outputData, "addOutput");
    this.data.addOutput(outputData);
    this.#cache.invalidate("outputs");
    return this;
  }
  extractTransaction(disableFeeCheck, disableOutputChecks) {
    if (disableOutputChecks) {
      this.data.inputs = this.data.inputs.filter((i) => !i.partialSig);
    }
    if (!this.data.inputs.every(isFinalized))
      throw new Error("Not finalized");
    if (!disableFeeCheck) {
      this.#cache.computeFeeRate(this.data.inputs, disableOutputChecks, txFromBuffer);
      this.#cache.checkFees(this.#opts);
    }
    if (this.#cache.extractedTx)
      return this.#cache.extractedTx;
    const tx = this.#cache.tx.clone();
    this.#cache.finalizeAndComputeAmounts(this.data.inputs, tx, true, disableOutputChecks, txFromBuffer);
    return tx;
  }
  getFeeRate(disableOutputChecks = false) {
    return this.#cache.computeFeeRate(this.data.inputs, disableOutputChecks, txFromBuffer);
  }
  getFee(disableOutputChecks = false) {
    return this.#cache.computeFee(this.data.inputs, disableOutputChecks, txFromBuffer);
  }
  finalizeAllInputs() {
    checkForInput(this.data.inputs, 0);
    range$1(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
    return this;
  }
  finalizeInput(inputIndex, finalScriptsFunc, canRunChecks) {
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input)) {
      return this.#finalizeTaprootInput(inputIndex, input, void 0, finalScriptsFunc);
    }
    return this.#finalizeInput(inputIndex, input, finalScriptsFunc, canRunChecks ?? true);
  }
  finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = tapScriptFinalizer) {
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input))
      return this.#finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc);
    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
  }
  getInputType(inputIndex) {
    const input = checkForInput(this.data.inputs, inputIndex);
    const script = this.#cache.getScriptFromUtxo(inputIndex, input, txFromBuffer);
    const result = getMeaningfulScript(script, inputIndex, "input", input.redeemScript || this.#cache.redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript || this.#cache.redeemFromFinalWitnessScript(input.finalScriptWitness));
    const type = result.type === "raw" ? "" : result.type + "-";
    const mainType = classifyScript(result.meaningfulScript);
    return type + mainType;
  }
  inputHasPubkey(inputIndex, pubkey) {
    const input = checkForInput(this.data.inputs, inputIndex);
    return this.#cache.pubkeyInInput(pubkey, input, inputIndex, txFromBuffer);
  }
  inputHasHDKey(inputIndex, root) {
    const input = checkForInput(this.data.inputs, inputIndex);
    const derivationIsMine = this.#lazySigner.bip32DerivationIsMine(root);
    return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
  }
  outputHasPubkey(outputIndex, pubkey) {
    const output = checkForOutput(this.data.outputs, outputIndex);
    return this.#cache.pubkeyInOutput(pubkey, output, outputIndex);
  }
  outputHasHDKey(outputIndex, root) {
    const output = checkForOutput(this.data.outputs, outputIndex);
    const derivationIsMine = this.#lazySigner.bip32DerivationIsMine(root);
    return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
  }
  validateSignaturesOfAllInputs(validator) {
    checkForInput(this.data.inputs, 0);
    const results = range$1(this.data.inputs.length).map((idx) => this.validateSignaturesOfInput(idx, validator));
    return results.every((res) => res);
  }
  validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    if (isTaprootInput$1(input))
      return this.#validateSignaturesOfTaprootInput(inputIndex, validator, pubkey);
    return this.#validateSignaturesOfInput(inputIndex, validator, pubkey);
  }
  signAllInputsHD(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const results = [];
    for (const i of range$1(this.data.inputs.length)) {
      try {
        this.signInputHD(i, hdKeyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
    return this;
  }
  async signAllInputsHDAsync(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const results = [];
    const promises = [];
    for (const i of range$1(this.data.inputs.length)) {
      promises.push(this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(() => {
        results.push(true);
      }, () => {
        results.push(false);
      }));
    }
    await Promise.all(promises);
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
  }
  signInputHD(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const signers = this.#lazySigner.getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
    signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
    return this;
  }
  async signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
      throw new Error("Need HDSigner to sign input");
    }
    const signers = this.#lazySigner.getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
    const promises = signers.map((signer) => this.signInputAsync(inputIndex, signer, sighashTypes));
    await Promise.all(promises);
  }
  signAllInputs(keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error("Need Signer to sign input");
    const results = [];
    for (const i of range$1(this.data.inputs.length)) {
      try {
        this.signInput(i, keyPair, sighashTypes);
        results.push(true);
      } catch (err) {
        results.push(false);
      }
    }
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
    return this;
  }
  async signAllInputsAsync(keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error("Need Signer to sign input");
    const results = [];
    const promises = [];
    for (const [i] of this.data.inputs.entries()) {
      promises.push(this.signInputAsync(i, keyPair, sighashTypes).then(() => {
        results.push(true);
      }, () => {
        results.push(false);
      }));
    }
    await Promise.all(promises);
    if (results.every((v) => !v)) {
      throw new Error("No inputs were signed");
    }
  }
  signInput(inputIndex, keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey) {
      throw new Error("Need Signer to sign input");
    }
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input)) {
      return this.#signTaprootInput(inputIndex, input, keyPair, void 0, sighashTypes);
    }
    return this.#signInput(inputIndex, keyPair, sighashTypes);
  }
  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
    if (!keyPair || !keyPair.publicKey) {
      throw new Error("Need Signer to sign input");
    }
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input)) {
      return this.#signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, sighashTypes);
    }
    throw new Error(`Input #${inputIndex} is not of type Taproot.`);
  }
  async signInputAsync(inputIndex, keyPair, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error("Need Signer to sign input");
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input))
      return this.#signTaprootInputAsync(inputIndex, input, keyPair, void 0, sighashTypes);
    return this.#signInputAsync(inputIndex, keyPair, sighashTypes);
  }
  async signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
    if (!keyPair || !keyPair.publicKey)
      throw new Error("Need Signer to sign input");
    const input = checkForInput(this.data.inputs, inputIndex);
    if (isTaprootInput$1(input))
      return this.#signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
    throw new Error(`Input #${inputIndex} is not of type Taproot.`);
  }
  toBuffer() {
    checkCache(this.#cache);
    return new Uint8Array(this.data.toBuffer());
  }
  toHex() {
    checkCache(this.#cache);
    return this.data.toHex();
  }
  toBase64() {
    checkCache(this.#cache);
    return this.data.toBase64();
  }
  updateGlobal(updateData) {
    this.data.updateGlobal(updateData);
    return this;
  }
  updateInput(inputIndex, updateData) {
    if (updateData.witnessScript)
      checkInvalidP2WSH(updateData.witnessScript);
    checkTaprootInputFields(this.data.inputs[inputIndex], updateData, "updateInput");
    const normalizedUpdate = updateData.witnessUtxo ? {
      ...updateData,
      witnessUtxo: {
        script: updateData.witnessUtxo.script,
        value: typeof updateData.witnessUtxo.value === "bigint" ? updateData.witnessUtxo.value : BigInt(updateData.witnessUtxo.value)
      }
    } : updateData;
    this.data.updateInput(inputIndex, normalizedUpdate);
    if (updateData.nonWitnessUtxo) {
      this.#cache.addNonWitnessTxCache(this.data.inputs[inputIndex], inputIndex, txFromBuffer);
    }
    return this;
  }
  updateOutput(outputIndex, updateData) {
    const outputData = this.data.outputs[outputIndex];
    checkTaprootOutputFields(outputData, updateData, "updateOutput");
    this.data.updateOutput(outputIndex, updateData);
    return this;
  }
  addUnknownKeyValToGlobal(keyVal) {
    this.data.addUnknownKeyValToGlobal(keyVal);
    return this;
  }
  addUnknownKeyValToInput(inputIndex, keyVal) {
    this.data.addUnknownKeyValToInput(inputIndex, keyVal);
    return this;
  }
  addUnknownKeyValToOutput(outputIndex, keyVal) {
    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
    return this;
  }
  clearFinalizedInput(inputIndex) {
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
    if (!("signSchnorr" in keyPair) || typeof keyPair.signSchnorr !== "function")
      throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
    const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
    const hashesForSig = this.#lazySigner.getTaprootHashesForSig(inputIndex, input, this.data.inputs, pubkey, tapLeafHashToSign, allowedSighashTypes);
    if (!hashesForSig || !hashesForSig.length)
      throw new Error(`Can not sign for input #${inputIndex} with the key ${toHex$1(pubkey)}`);
    return hashesForSig;
  }
  #finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts, canRunChecks = true) {
    const { script, isP2SH, isP2WSH, isSegwit } = this.#lazyFinalizer.getScriptFromInput(inputIndex, input);
    if (!script)
      throw new Error(`No script found for input #${inputIndex}`);
    checkPartialSigSighashes(input);
    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks);
    if (finalScriptSig)
      this.data.updateInput(inputIndex, { finalScriptSig });
    if (finalScriptWitness)
      this.data.updateInput(inputIndex, { finalScriptWitness });
    if (!finalScriptSig && !finalScriptWitness)
      throw new Error(`Unknown error finalizing input #${inputIndex}`);
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  #finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = tapScriptFinalizer) {
    if (!input.witnessUtxo)
      throw new Error(`Cannot finalize input #${inputIndex}. Missing witness utxo.`);
    if (input.tapKeySig && !isP2MRInput(input)) {
      const payment = p2tr({
        output: input.witnessUtxo.script,
        signature: input.tapKeySig
      });
      if (!payment.witness)
        throw new Error("Cannot finalize taproot key spend");
      const finalScriptWitness = witnessStackToScriptWitness$1(payment.witness);
      this.data.updateInput(inputIndex, { finalScriptWitness });
    } else {
      const { finalScriptWitness } = finalScriptsFunc(inputIndex, input, tapLeafHashToFinalize);
      this.data.updateInput(inputIndex, { finalScriptWitness });
    }
    this.data.clearFinalizedInput(inputIndex);
    return this;
  }
  #validateSignaturesOfInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const partialSig = input?.partialSig;
    if (!input || !partialSig || partialSig.length < 1)
      throw new Error("No signatures to validate");
    if (typeof validator !== "function")
      throw new Error("Need validator function to validate signatures");
    const mySigs = pubkey ? partialSig.filter((sig) => equals(sig.pubkey, pubkey)) : partialSig;
    if (mySigs.length < 1)
      throw new Error("No signatures for this pubkey");
    const results = [];
    let hashCache;
    let scriptCache;
    let sighashCache;
    for (const pSig of mySigs) {
      const pSigSignature = pSig.signature;
      const pSigPubkey = pSig.pubkey;
      const sig = signature.decode(pSigSignature);
      const { hash, script: script$1 } = sighashCache !== sig.hashType || !hashCache || !scriptCache ? this.#lazySigner.getHashForSig(inputIndex, Object.assign({}, input, {
        sighashType: sig.hashType
      }), true) : { hash: hashCache, script: scriptCache };
      sighashCache = sig.hashType;
      hashCache = hash;
      scriptCache = script$1;
      checkScriptForPubkey(pSigPubkey, script$1, "verify");
      results.push(validator(pSigPubkey, hash, sig.signature));
    }
    return results.every((res) => res);
  }
  #validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
    const input = this.data.inputs[inputIndex];
    const tapKeySig = input?.tapKeySig;
    const tapScriptSig = input?.tapScriptSig;
    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
      throw new Error("No signatures to validate");
    if (typeof validator !== "function")
      throw new Error("Need validator function to validate signatures");
    const xPubkey = pubkey ? toXOnly(pubkey) : void 0;
    const allHashses = xPubkey ? this.#lazySigner.getTaprootHashesForSig(inputIndex, input, this.data.inputs, xPubkey) : this.#lazySigner.getAllTaprootHashesForSig(inputIndex, input, this.data.inputs);
    if (!allHashses.length)
      throw new Error("No signatures for this pubkey");
    const tapKeyHash = allHashses.find((h) => !h.leafHash);
    let validationResultCount = 0;
    if (tapKeySig && tapKeyHash) {
      const isValidTapkeySig = validator(tapKeyHash.pubkey, tapKeyHash.hash, this.#lazySigner.trimTaprootSig(tapKeySig));
      if (!isValidTapkeySig)
        return false;
      validationResultCount++;
    }
    if (tapScriptSig) {
      for (const tapSig of tapScriptSig) {
        const tapSigPubkey = tapSig.pubkey;
        const tapSigHash = allHashses.find((h) => equals(tapSigPubkey, h.pubkey));
        if (tapSigHash) {
          const isValidTapScriptSig = validator(tapSigPubkey, tapSigHash.hash, this.#lazySigner.trimTaprootSig(tapSig.signature));
          if (!isValidTapScriptSig)
            return false;
          validationResultCount++;
        }
      }
    }
    return validationResultCount > 0;
  }
  #signInput(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
    const { hash, sighashType } = this.#lazySigner.getHashAndSighashType(this.data.inputs, inputIndex, pubkey, sighashTypes);
    const sig = keyPair.sign(hash);
    const partialSig = [
      {
        pubkey,
        signature: signature.encode(sig instanceof Uint8Array ? sig : new Uint8Array(sig), sighashType)
      }
    ];
    this.data.updateInput(inputIndex, { partialSig });
    this.#cache.hasSignatures = true;
    return this;
  }
  #signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [Transaction.SIGHASH_DEFAULT]) {
    const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
    if (!("signSchnorr" in keyPair) || typeof keyPair.signSchnorr !== "function")
      throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
    const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes);
    const signSchnorr = keyPair.signSchnorr.bind(keyPair);
    const tapKeySig = hashesForSig.filter((h) => !h.leafHash).map((h) => serializeTaprootSignature(signSchnorr(h.hash), input.sighashType))[0];
    const tapScriptSig = hashesForSig.filter((h) => !!h.leafHash).map((h) => ({
      pubkey: toXOnly(pubkey),
      signature: serializeTaprootSignature(signSchnorr(h.hash), input.sighashType),
      leafHash: h.leafHash
    }));
    if (tapKeySig) {
      this.data.updateInput(inputIndex, { tapKeySig });
      this.#cache.hasSignatures = true;
    }
    if (tapScriptSig.length) {
      this.data.updateInput(inputIndex, { tapScriptSig });
      this.#cache.hasSignatures = true;
    }
    return this;
  }
  async #signInputAsync(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
    const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
    const { hash, sighashType } = this.#lazySigner.getHashAndSighashType(this.data.inputs, inputIndex, pubkey, sighashTypes);
    const signature$1 = await keyPair.sign(hash);
    const sig = signature$1 instanceof Uint8Array ? signature$1 : new Uint8Array(signature$1);
    const partialSig = [
      {
        pubkey,
        signature: signature.encode(sig, sighashType)
      }
    ];
    this.data.updateInput(inputIndex, { partialSig });
    this.#cache.hasSignatures = true;
  }
  async #signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [Transaction.SIGHASH_DEFAULT]) {
    const pubkey = keyPair.publicKey instanceof Uint8Array ? keyPair.publicKey : new Uint8Array(keyPair.publicKey);
    if (!("signSchnorr" in keyPair) || typeof keyPair.signSchnorr !== "function")
      throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
    const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
    const signSchnorr = keyPair.signSchnorr.bind(keyPair);
    const tapKeyHash = hashesForSig.find((h) => !h.leafHash);
    if (tapKeyHash) {
      const sig = await signSchnorr(tapKeyHash.hash);
      const tapKeySig = serializeTaprootSignature(sig, input.sighashType);
      this.data.updateInput(inputIndex, { tapKeySig });
      this.#cache.hasSignatures = true;
    }
    const tapScriptHashes = hashesForSig.filter((h) => !!h.leafHash);
    if (tapScriptHashes.length) {
      const tapScriptSigs = await Promise.all(tapScriptHashes.map(async (tsh) => {
        const signature = await signSchnorr(tsh.hash);
        return {
          pubkey: toXOnly(pubkey),
          signature: serializeTaprootSignature(signature, input.sighashType),
          leafHash: tsh.leafHash
        };
      }));
      this.data.updateInput(inputIndex, { tapScriptSig: tapScriptSigs });
      this.#cache.hasSignatures = true;
    }
  }
}

/**
 * Worker thread types for parallel signing operations.
 *
 * SECURITY NOTES:
 * - Private keys are NEVER shared via SharedArrayBuffer
 * - Keys are cloned via postMessage (isolated per worker)
 * - Keys are zeroed immediately after signing
 * - Workers are pooled for performance but keys don't persist
 *
 * @packageDocumentation
 */
/**
 * Signature type enum for worker operations.
 */
const SignatureType$1 = {
    /** ECDSA signature (secp256k1) */
    ECDSA: 0,
    /** Schnorr signature (BIP340) */
    Schnorr: 1,
};
/**
 * Type guard for batch result responses.
 */
function isBatchResult(response) {
    return response.type === 'batchResult';
}
/**
 * Type guard for ready responses.
 */
function isWorkerReady(response) {
    return response.type === 'ready';
}
/**
 * Worker state for pool management.
 */
const WorkerState = {
    /** Worker is initializing */
    Initializing: 0,
    /** Worker is ready and idle */
    Idle: 1,
    /** Worker is processing a task */
    Busy: 2,
    /** Worker is shutting down */
    ShuttingDown: 3,
    /** Worker has terminated */
    Terminated: 4,
};

const ECC_BUNDLE = '"use strict";var nobleBundle=(()=>{var rt=Object.defineProperty;var _e=Object.getOwnPropertyDescriptor;var Ce=Object.getOwnPropertyNames;var ke=Object.prototype.hasOwnProperty;var Ve=(e,t,n)=>t in e?rt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var Ct=(e,t)=>{for(var n in t)rt(e,n,{get:t[n],enumerable:!0})},Te=(e,t,n,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of Ce(t))!ke.call(e,r)&&r!==n&&rt(e,r,{get:()=>t[r],enumerable:!(s=_e(t,r))||s.enumerable});return e};var Ge=e=>Te(rt({},"__esModule",{value:!0}),e);var l=(e,t,n)=>Ve(e,typeof t!="symbol"?t+"":t,n);var yn={};Ct(yn,{hmac:()=>lt,secp:()=>Lt,sha256:()=>ht});var Lt={};Ct(Lt,{Point:()=>U,Signature:()=>R,etc:()=>sn,getPublicKey:()=>Pt,getSharedSecret:()=>en,hash:()=>je,hashes:()=>K,keygen:()=>nn,recoverPublicKey:()=>Qe,recoverPublicKeyAsync:()=>tn,schnorr:()=>un,sign:()=>We,signAsync:()=>ze,utils:()=>rn,verify:()=>qe,verifyAsync:()=>Je});var Nt={p:0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn,n:0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n,h:1n,a:0n,b:7n,Gx:0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n,Gy:0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n},{p:D,n:v,Gx:Fe,Gy:De,b:Zt}=Nt,w=32,Z=64,et={publicKey:w+1,publicKeyUncompressed:Z+1,signature:Z,seed:w+w/2},Ke=(...e)=>{"captureStackTrace"in Error&&typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(...e)},b=(e="")=>{let t=new Error(e);throw Ke(t,b),t},Oe=e=>typeof e=="bigint",Ne=e=>typeof e=="string",Ze=e=>e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array",A=(e,t,n="")=>{let s=Ze(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`"${n}" `,i=o?` of length ${t}`:"",u=s?`length=${r}`:`type=${typeof e}`;b(c+"expected Uint8Array"+i+", got "+u)}return e},k=e=>new Uint8Array(e),jt=(e,t)=>e.toString(16).padStart(t,"0"),wt=e=>Array.from(A(e)).map(t=>jt(t,2)).join(""),V={_0:48,_9:57,A:65,F:70,a:97,f:102},kt=e=>{if(e>=V._0&&e<=V._9)return e-V._0;if(e>=V.A&&e<=V.F)return e-(V.A-10);if(e>=V.a&&e<=V.f)return e-(V.a-10)},mt=e=>{let t="hex invalid";if(!Ne(e))return b(t);let n=e.length,s=n/2;if(n%2)return b(t);let r=k(s);for(let o=0,c=0;o<s;o++,c+=2){let i=kt(e.charCodeAt(c)),u=kt(e.charCodeAt(c+1));if(i===void 0||u===void 0)return b(t);r[o]=i*16+u}return r},Rt=()=>globalThis?.crypto,Vt=()=>Rt()?.subtle??b("crypto.subtle must be defined, consider polyfill"),L=(...e)=>{let t=k(e.reduce((s,r)=>s+A(r).length,0)),n=0;return e.forEach(s=>{t.set(s,n),n+=s.length}),t},nt=(e=w)=>Rt().getRandomValues(k(e)),Y=BigInt,j=(e,t,n,s="bad number: out of range")=>Oe(e)&&t<=e&&e<n?e:b(s),a=(e,t=D)=>{let n=e%t;return n>=0n?n:t+n},E=e=>a(e,v),st=(e,t)=>{(e===0n||t<=0n)&&b("no inverse n="+e+" mod="+t);let n=a(e,t),s=t,r=0n,o=1n,c=1n,i=0n;for(;n!==0n;){let u=s/n,d=s%n,f=r-c*u,h=o-i*u;s=n,n=d,r=c,o=i,c=f,i=h}return s===1n?a(r,t):b("no inverse")},it=e=>{let t=K[e];return typeof t!="function"&&b("hashes."+e+" not set"),t},je=e=>it("sha256")(e),xt=e=>e instanceof U?e:b("Point expected"),Xt=e=>a(a(e*e)*e+Zt),Tt=e=>j(e,0n,D),tt=e=>j(e,1n,D),bt=e=>j(e,1n,v),M=e=>(e&1n)===0n,ft=e=>Uint8Array.of(e),Yt=e=>ft(M(e)?2:3),Mt=e=>{let t=Xt(tt(e)),n=1n;for(let s=t,r=(D+1n)/4n;r>0n;r>>=1n)r&1n&&(n=n*s%D),s=s*s%D;return a(n*n)===t?n:b("sqrt invalid")},C=class C{constructor(t,n,s){l(this,"X");l(this,"Y");l(this,"Z");this.X=Tt(t),this.Y=tt(n),this.Z=Tt(s),Object.freeze(this)}static CURVE(){return Nt}static fromAffine(t){let{x:n,y:s}=t;return n===0n&&s===0n?N:new C(n,s,1n)}static fromBytes(t){A(t);let{publicKey:n,publicKeyUncompressed:s}=et,r,o=t.length,c=t[0],i=t.subarray(1),u=P(i,0,w);if(o===n&&(c===2||c===3)){let d=Mt(u),f=M(d);M(Y(c))!==f&&(d=a(-d)),r=new C(u,d,1n)}return o===s&&c===4&&(r=new C(u,P(i,w,Z),1n)),r?r.assertValidity():b("bad point: not on curve")}static fromHex(t){return C.fromBytes(mt(t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}equals(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=a(n*i),d=a(o*r),f=a(s*i),h=a(c*r);return u===d&&f===h}is0(){return this.equals(N)}negate(){return new C(this.X,a(-this.Y),this.Z)}double(){return this.add(this)}add(t){let{X:n,Y:s,Z:r}=this,{X:o,Y:c,Z:i}=xt(t),u=0n,d=Zt,f=0n,h=0n,x=0n,y=a(d*3n),p=a(n*o),g=a(s*c),H=a(r*i),I=a(n+s),m=a(o+c);I=a(I*m),m=a(p+g),I=a(I-m),m=a(n+r);let S=a(o+i);return m=a(m*S),S=a(p+H),m=a(m-S),S=a(s+r),f=a(c+i),S=a(S*f),f=a(g+H),S=a(S-f),x=a(u*m),f=a(y*H),x=a(f+x),f=a(g-x),x=a(g+x),h=a(f*x),g=a(p+p),g=a(g+p),H=a(u*H),m=a(y*m),g=a(g+H),H=a(p-H),H=a(u*H),m=a(m+H),p=a(g*m),h=a(h+p),p=a(S*m),f=a(I*f),f=a(f-p),p=a(I*g),x=a(S*x),x=a(x+p),new C(f,h,x)}subtract(t){return this.add(xt(t).negate())}multiply(t,n=!0){if(!n&&t===0n)return N;if(bt(t),t===1n)return this;if(this.equals(T))return ln(t).p;let s=N,r=T;for(let o=this;t>0n;o=o.double(),t>>=1n)t&1n?s=s.add(o):n&&(r=r.add(o));return s}multiplyUnsafe(t){return this.multiply(t,!1)}toAffine(){let{X:t,Y:n,Z:s}=this;if(this.equals(N))return{x:0n,y:0n};if(s===1n)return{x:t,y:n};let r=st(s,D);return a(s*r)!==1n&&b("inverse invalid"),{x:a(t*r),y:a(n*r)}}assertValidity(){let{x:t,y:n}=this.toAffine();return tt(t),tt(n),a(n*n)===Xt(t)?this:b("bad point: not on curve")}toBytes(t=!0){let{x:n,y:s}=this.assertValidity().toAffine(),r=B(n);return t?L(Yt(s),r):L(ft(4),r,B(s))}toHex(t){return wt(this.toBytes(t))}};l(C,"BASE"),l(C,"ZERO");var U=C,T=new U(Fe,De,1n),N=new U(0n,1n,0n);U.BASE=T;U.ZERO=N;var At=(e,t,n)=>T.multiply(t,!1).add(e.multiply(n,!1)).assertValidity(),G=e=>Y("0x"+(wt(e)||"0")),P=(e,t,n)=>G(e.subarray(t,n)),Re=2n**256n,B=e=>mt(jt(j(e,0n,Re),Z)),W=e=>{let t=G(A(e,w,"secret key"));return j(t,1n,v,"invalid secret key: outside of range")},Ht=e=>e>v>>1n,Pt=(e,t=!0)=>T.multiply(W(e)).toBytes(t),Xe=e=>{try{return!!W(e)}catch{return!1}},Ye=(e,t)=>{let{publicKey:n,publicKeyUncompressed:s}=et;try{let r=e.length;return t===!0&&r!==n||t===!1&&r!==s?!1:!!U.fromBytes(e)}catch{return!1}},$t=e=>{[0,1,2,3].includes(e)||b("recovery id must be valid and present")},Me=e=>{e!=null&&!Gt.includes(e)&&b(`Signature format must be one of: ${Gt.join(", ")}`),e===qt&&b(\'Signature format "der" is not supported: switch to noble-curves\')},Wt=(e,t=$)=>{Me(t);let n=et.signature,s=n+1,r=`Signature format "${t}" expects Uint8Array with length `;t===$&&e.length!==n&&b(r+n),t===ot&&e.length!==s&&b(r+s)},R=class e{constructor(t,n,s){l(this,"r");l(this,"s");l(this,"recovery");this.r=bt(t),this.s=bt(n),s!=null&&(this.recovery=s),Object.freeze(this)}static fromBytes(t,n=$){Wt(t,n);let s;n===ot&&(s=t[0],t=t.subarray(1));let r=P(t,0,w),o=P(t,w,Z);return new e(r,o,s)}addRecoveryBit(t){return new e(this.r,this.s,t)}hasHighS(){return Ht(this.s)}toBytes(t=$){let{r:n,s,recovery:r}=this,o=L(B(n),B(s));return t===ot?($t(r),L(Uint8Array.of(r),o)):o}},zt=e=>{let t=e.length*8-256;t>1024&&b("msg invalid");let n=G(e);return t>0?n>>Y(t):n},St=e=>E(zt(A(e))),$="compact",ot="recovered",qt="der",Gt=[$,ot,qt],Ft={lowS:!0,prehash:!0,format:$,extraEntropy:!1},Dt="SHA-256",K={hmacSha256Async:async(e,t)=>{let n=Vt(),s="HMAC",r=await n.importKey("raw",e,{name:s,hash:{name:Dt}},!1,["sign"]);return k(await n.sign(s,r,t))},hmacSha256:void 0,sha256Async:async e=>k(await Vt().digest(Dt,e)),sha256:void 0},z=(e,t,n)=>(A(e,void 0,"message"),t.prehash?n?K.sha256Async(e):it("sha256")(e):e),Jt=k(0),Qt=ft(0),te=ft(1),ee=1e3,ne="drbg: tried max amount of iterations",Pe=(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>it("hmacSha256")(s,L(n,...f)),i=(f=Jt)=>{s=c(Qt,f),n=c(),f.length!==0&&(s=c(te,f),n=c())},u=()=>(r++>=ee&&b(ne),n=c(),n);o(),i(e);let d;for(;!(d=t(u()));)i();return o(),d},$e=async(e,t)=>{let n=k(w),s=k(w),r=0,o=()=>{n.fill(1),s.fill(0)},c=(...f)=>K.hmacSha256Async(s,L(n,...f)),i=async(f=Jt)=>{s=await c(Qt,f),n=await c(),f.length!==0&&(s=await c(te,f),n=await c())},u=async()=>(r++>=ee&&b(ne),n=await c(),n);o(),await i(e);let d;for(;!(d=t(await u()));)await i();return o(),d},se=(e,t,n,s)=>{let{lowS:r,extraEntropy:o}=n,c=B,i=St(e),u=c(i),d=W(t),f=[c(d),u];if(o!=null&&o!==!1){let p=o===!0?nt(w):o;f.push(A(p,void 0,"extraEntropy"))}let h=L(...f),x=i;return s(h,p=>{let g=zt(p);if(!(1n<=g&&g<v))return;let H=st(g,v),I=T.multiply(g).toAffine(),m=E(I.x);if(m===0n)return;let S=E(H*E(x+m*d));if(S===0n)return;let vt=(I.x===m?0:2)|Number(I.y&1n),_t=S;return r&&Ht(S)&&(_t=E(-S),vt^=1),new R(m,_t,vt).toBytes(n.format)})},re=(e,t,n,s={})=>{let{lowS:r,format:o}=s;e instanceof R&&b("Signature must be in Uint8Array, use .toBytes()"),Wt(e,o),A(n,void 0,"publicKey");try{let{r:c,s:i}=R.fromBytes(e,o),u=St(t),d=U.fromBytes(n);if(r&&Ht(i))return!1;let f=st(i,v),h=E(u*f),x=E(c*f),y=At(d,h,x).toAffine();return E(y.x)===c}catch{return!1}},q=e=>{let t={};return Object.keys(Ft).forEach(n=>{t[n]=e[n]??Ft[n]}),t},We=(e,t,n={})=>(n=q(n),e=z(e,n,!1),se(e,t,n,Pe)),ze=async(e,t,n={})=>(n=q(n),e=await z(e,n,!0),se(e,t,n,$e)),qe=(e,t,n,s={})=>(s=q(s),t=z(t,s,!1),re(e,t,n,s)),Je=async(e,t,n,s={})=>(s=q(s),t=await z(t,s,!0),re(e,t,n,s)),oe=(e,t)=>{let n=R.fromBytes(e,"recovered"),{r:s,s:r,recovery:o}=n;$t(o);let c=St(A(t,w)),i=o===2||o===3?s+v:s;tt(i);let u=Yt(Y(o)),d=L(u,B(i)),f=U.fromBytes(d),h=st(i,v),x=E(-c*h),y=E(r*h);return At(f,x,y).toBytes()},Qe=(e,t,n={})=>(t=z(t,q(n),!1),oe(e,t)),tn=async(e,t,n={})=>(t=await z(t,q(n),!0),oe(e,t)),en=(e,t,n=!0)=>U.fromBytes(t).multiply(W(e)).toBytes(n),ce=(e=nt(et.seed))=>{A(e),(e.length<et.seed||e.length>1024)&&b("expected 40-1024b");let t=a(G(e),v-1n);return B(t+1n)},ie=e=>t=>{let n=ce(t);return{secretKey:n,publicKey:e(n)}},nn=ie(Pt),sn={hexToBytes:mt,bytesToHex:wt,concatBytes:L,bytesToNumberBE:G,numberToBytesBE:B,mod:a,invert:st,randomBytes:nt,secretKeyToScalar:W,abytes:A},rn={isValidSecretKey:Xe,isValidPublicKey:Ye,randomSecretKey:ce},fe=e=>Uint8Array.from("BIP0340/"+e,t=>t.charCodeAt(0)),ae="aux",ue="nonce",he="challenge",yt=(e,...t)=>{let n=it("sha256"),s=n(fe(e));return n(L(s,s,...t))},pt=async(e,...t)=>{let n=K.sha256Async,s=await n(fe(e));return await n(L(s,s,...t))},Bt=e=>{let t=W(e),n=T.multiply(t),{x:s,y:r}=n.assertValidity().toAffine(),o=M(r)?t:E(-t),c=B(s);return{d:o,px:c}},Et=e=>E(G(e)),de=(...e)=>Et(yt(he,...e)),le=async(...e)=>Et(await pt(he,...e)),xe=e=>Bt(e).px,on=ie(xe),be=(e,t,n)=>{let{px:s,d:r}=Bt(t);return{m:A(e),px:s,d:r,a:A(n,w)}},ye=e=>{let t=Et(e);t===0n&&b("sign failed: k is zero");let{px:n,d:s}=Bt(B(t));return{rx:n,k:s}},pe=(e,t,n,s)=>L(t,B(E(e+n*s))),ge="invalid signature produced",cn=(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=yt(ae,c),u=B(o^G(i)),d=yt(ue,u,r,s),{rx:f,k:h}=ye(d),x=de(f,r,s),y=pe(h,f,x,o);return me(y,s,r)||b(ge),y},fn=async(e,t,n=nt(w))=>{let{m:s,px:r,d:o,a:c}=be(e,t,n),i=await pt(ae,c),u=B(o^G(i)),d=await pt(ue,u,r,s),{rx:f,k:h}=ye(d),x=await le(f,r,s),y=pe(h,f,x,o);return await Ae(y,s,r)||b(ge),y},an=(e,t)=>e instanceof Promise?e.then(t):t(e),we=(e,t,n,s)=>{let r=A(e,Z,"signature"),o=A(t,void 0,"message"),c=A(n,w,"publicKey");try{let i=G(c),u=Mt(i),d=M(u)?u:a(-u),f=new U(i,d,1n).assertValidity(),h=B(f.toAffine().x),x=P(r,0,w);j(x,1n,D);let y=P(r,w,Z);j(y,1n,v);let p=L(B(x),h,o);return an(s(p),g=>{let{x:H,y:I}=At(f,y,E(-g)).toAffine();return!(!M(I)||H!==x)})}catch{return!1}},me=(e,t,n)=>we(e,t,n,de),Ae=async(e,t,n)=>we(e,t,n,le),un={keygen:on,getPublicKey:xe,sign:cn,verify:me,signAsync:fn,verifyAsync:Ae},ct=8,hn=256,He=Math.ceil(hn/ct)+1,gt=2**(ct-1),dn=()=>{let e=[],t=T,n=t;for(let s=0;s<He;s++){n=t,e.push(n);for(let r=1;r<gt;r++)n=n.add(t),e.push(n);t=n.double()}return e},Kt,Ot=(e,t)=>{let n=t.negate();return e?n:t},ln=e=>{let t=Kt||(Kt=dn()),n=N,s=T,r=2**ct,o=r,c=Y(r-1),i=Y(ct);for(let u=0;u<He;u++){let d=Number(e&c);e>>=i,d>gt&&(d-=o,e+=1n);let f=u*gt,h=f,x=f+Math.abs(d)-1,y=u%2!==0,p=d<0;d===0?s=s.add(Ot(y,t[h])):n=n.add(Ot(p,t[x]))}return e!==0n&&b("invalid wnaf"),{p:n,f:s}};function xn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Se(e,t=""){if(!Number.isSafeInteger(e)||e<0){let n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function J(e,t,n=""){let s=xn(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){let c=n&&`"${n}" `,i=o?` of length ${t}`:"",u=s?`length=${r}`:`type=${typeof e}`;throw new Error(c+"expected Uint8Array"+i+", got "+u)}return e}function Be(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Se(e.outputLen),Se(e.blockLen)}function Q(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Ee(e,t){J(e,void 0,"digestInto() output");let n=t.outputLen;if(e.length<n)throw new Error(\'"digestInto() output" expected to be of length >=\'+n)}function X(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function at(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function _(e,t){return e<<32-t|e>>>t}function Le(e,t={}){let n=(r,o)=>e(o).update(r).digest(),s=e(void 0);return n.outputLen=s.outputLen,n.blockLen=s.blockLen,n.create=r=>e(r),Object.assign(n,t),Object.freeze(n)}var Ue=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function Ie(e,t,n){return e&t^~e&n}function ve(e,t,n){return e&t^e&n^t&n}var ut=class{constructor(t,n,s,r){l(this,"blockLen");l(this,"outputLen");l(this,"padOffset");l(this,"isLE");l(this,"buffer");l(this,"view");l(this,"finished",!1);l(this,"length",0);l(this,"pos",0);l(this,"destroyed",!1);this.blockLen=t,this.outputLen=n,this.padOffset=s,this.isLE=r,this.buffer=new Uint8Array(t),this.view=at(this.buffer)}update(t){Q(this),J(t);let{view:n,buffer:s,blockLen:r}=this,o=t.length;for(let c=0;c<o;){let i=Math.min(r-this.pos,o-c);if(i===r){let u=at(t);for(;r<=o-c;c+=r)this.process(u,c);continue}s.set(t.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Q(this),Ee(t,this),this.finished=!0;let{buffer:n,view:s,blockLen:r,isLE:o}=this,{pos:c}=this;n[c++]=128,X(this.buffer.subarray(c)),this.padOffset>r-c&&(this.process(s,0),c=0);for(let h=c;h<r;h++)n[h]=0;s.setBigUint64(r-8,BigInt(this.length*8),o),this.process(s,0);let i=at(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen must be aligned to 32bit");let d=u/4,f=this.get();if(d>f.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<d;h++)i.setUint32(4*h,f[h],o)}digest(){let{buffer:t,outputLen:n}=this;this.digestInto(t);let s=t.slice(0,n);return this.destroy(),s}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());let{blockLen:n,buffer:s,length:r,finished:o,destroyed:c,pos:i}=this;return t.destroyed=c,t.finished=o,t.length=r,t.pos=i,r%n&&t.buffer.set(s),t}clone(){return this._cloneInto()}},F=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var bn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),O=new Uint32Array(64),Ut=class extends ut{constructor(t){super(64,t,8,!1)}get(){let{A:t,B:n,C:s,D:r,E:o,F:c,G:i,H:u}=this;return[t,n,s,r,o,c,i,u]}set(t,n,s,r,o,c,i,u){this.A=t|0,this.B=n|0,this.C=s|0,this.D=r|0,this.E=o|0,this.F=c|0,this.G=i|0,this.H=u|0}process(t,n){for(let h=0;h<16;h++,n+=4)O[h]=t.getUint32(n,!1);for(let h=16;h<64;h++){let x=O[h-15],y=O[h-2],p=_(x,7)^_(x,18)^x>>>3,g=_(y,17)^_(y,19)^y>>>10;O[h]=g+O[h-7]+p+O[h-16]|0}let{A:s,B:r,C:o,D:c,E:i,F:u,G:d,H:f}=this;for(let h=0;h<64;h++){let x=_(i,6)^_(i,11)^_(i,25),y=f+x+Ie(i,u,d)+bn[h]+O[h]|0,g=(_(s,2)^_(s,13)^_(s,22))+ve(s,r,o)|0;f=d,d=u,u=i,i=c+y|0,c=o,o=r,r=s,s=y+g|0}s=s+this.A|0,r=r+this.B|0,o=o+this.C|0,c=c+this.D|0,i=i+this.E|0,u=u+this.F|0,d=d+this.G|0,f=f+this.H|0,this.set(s,r,o,c,i,u,d,f)}roundClean(){X(O)}destroy(){this.set(0,0,0,0,0,0,0,0),X(this.buffer)}},It=class extends Ut{constructor(){super(32);l(this,"A",F[0]|0);l(this,"B",F[1]|0);l(this,"C",F[2]|0);l(this,"D",F[3]|0);l(this,"E",F[4]|0);l(this,"F",F[5]|0);l(this,"G",F[6]|0);l(this,"H",F[7]|0)}};var ht=Le(()=>new It,Ue(1));var dt=class{constructor(t,n){l(this,"oHash");l(this,"iHash");l(this,"blockLen");l(this,"outputLen");l(this,"finished",!1);l(this,"destroyed",!1);if(Be(t),J(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let s=this.blockLen,r=new Uint8Array(s);r.set(n.length>s?t.create().update(n).digest():n);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r),this.oHash=t.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r),X(r)}update(t){return Q(this),this.iHash.update(t),this}digestInto(t){Q(this),J(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:n,iHash:s,finished:r,destroyed:o,blockLen:c,outputLen:i}=this;return t=t,t.finished=r,t.destroyed=o,t.blockLen=c,t.outputLen=i,t.oHash=n._cloneInto(t.oHash),t.iHash=s._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},lt=(e,t,n)=>new dt(e,t).update(n).digest();lt.create=(e,t)=>new dt(e,t);K.sha256=ht;K.hmacSha256=(e,...t)=>{let n=new Uint8Array(t.reduce((r,o)=>r+o.length,0)),s=0;for(let r of t)n.set(r,s),s+=r.length;return lt(ht,e,n)};return Ge(yn);})();\n/*! Bundled license information:\n\n@noble/secp256k1/index.js:\n  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)\n\n@noble/hashes/utils.js:\n  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n*/\n';

/**
 * Inline signing worker code.
 *
 * This module generates the worker code as a string that can be
 * loaded via Blob URL. The worker uses the bundled @noble/secp256k1
 * library embedded at compile time - no network requests required.
 *
 * SECURITY CRITICAL:
 * - Private keys are zeroed immediately after signing
 * - No key data is logged or stored
 * - Worker only holds key during active signing operation
 * - ECC library is bundled at compile time (no CDN dependency)
 *
 * @packageDocumentation
 */
/**
 * Generates the inline worker code as a string.
 *
 * The worker uses the bundled @noble/secp256k1 library directly,
 * eliminating any network dependencies.
 *
 * @returns Worker code as a string for Blob URL creation
 */
function generateWorkerCode() {
    // This code runs inside the worker
    return `
'use strict';

/**
 * Zero out a Uint8Array to clear sensitive data.
 * @param {Uint8Array} arr - Array to zero
 */
function secureZero(arr) {
    if (arr && arr.fill) {
        arr.fill(0);
        // Double-write to prevent optimization
        for (let i = 0; i < arr.length; i++) {
            arr[i] = 0;
        }
    }
}

/**
 * Bundled @noble/secp256k1 + hashes library (embedded at compile time).
 */
const eccBundle = ${JSON.stringify(ECC_BUNDLE)};

/**
 * Initialize the ECC library from the bundle.
 * The bundle exports nobleBundle with { secp, sha256, hmac }.
 */
const eccModule = (function() {
    // Execute the IIFE and return the nobleBundle object
    const fn = new Function(eccBundle + '; return nobleBundle;');
    return fn();
})();

/**
 * ECC library wrapper with the interface we need.
 * Uses eccModule.secp which has hashes pre-configured.
 */
const eccLib = {
    sign: (hash, privateKey) => {
        // noble's sign returns Signature object, we need compact 64-byte format
        const sig = eccModule.secp.sign(hash, privateKey, { lowS: true });
        return sig.toCompactRawBytes();
    },
    signSchnorr: (hash, privateKey) => {
        return eccModule.secp.schnorr.sign(hash, privateKey);
    }
};

/**
 * Whether initialization is complete.
 */
let initialized = false;

/**
 * Pending messages received before init completes.
 */
const pendingMessages = [];

/**
 * Handle incoming messages from main thread.
 */
self.onmessage = async function(event) {
    const msg = event.data;

    // Queue messages until initialized (except init)
    if (!initialized && msg.type !== 'init') {
        pendingMessages.push(msg);
        return;
    }

    await handleMessage(msg);
};

/**
 * Process a message.
 */
async function handleMessage(msg) {
    switch (msg.type) {
        case 'init':
            handleInit(msg);
            break;
        case 'sign':
            handleSign(msg);
            break;
        case 'signBatch':
            handleSignBatch(msg);
            break;
        case 'shutdown':
            handleShutdown();
            break;
        default:
            self.postMessage({
                type: 'error',
                taskId: msg.taskId || 'unknown',
                error: 'Unknown message type: ' + msg.type,
                inputIndex: msg.inputIndex || -1
            });
    }
}

/**
 * Initialize the worker.
 * ECC library is already bundled, so this just marks as ready.
 */
function handleInit(msg) {
    initialized = true;

    // Signal ready
    self.postMessage({ type: 'ready' });

    // Process pending messages
    while (pendingMessages.length > 0) {
        handleMessage(pendingMessages.shift());
    }
}

/**
 * Handle a signing request.
 *
 * SECURITY: Private key is zeroed immediately after use.
 *
 * @param {Object} msg - Signing task message
 */
function handleSign(msg) {
    const {
        taskId,
        hash,
        privateKey,
        publicKey,
        signatureType,
        lowR,
        inputIndex,
        sighashType,
        leafHash
    } = msg;

    // Validate inputs
    if (!hash || hash.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: 'Invalid hash: must be 32 bytes',
            inputIndex: inputIndex
        });
        return;
    }

    if (!privateKey || privateKey.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: 'Invalid private key: must be 32 bytes',
            inputIndex: inputIndex
        });
        return;
    }

    let signature;

    try {
        if (signatureType === 1) {
            // Schnorr signature (BIP340)
            if (typeof eccLib.signSchnorr !== 'function') {
                throw new Error('ECC library does not support Schnorr signatures');
            }
            signature = eccLib.signSchnorr(hash, privateKey);
        } else {
            // ECDSA signature
            if (typeof eccLib.sign !== 'function') {
                throw new Error('ECC library does not support ECDSA signatures');
            }
            signature = eccLib.sign(hash, privateKey, { lowR: lowR || false });
        }

        if (!signature) {
            throw new Error('Signing returned null or undefined');
        }

    } catch (error) {
        // ALWAYS zero the key, even on error
        secureZero(privateKey);

        self.postMessage({
            type: 'error',
            taskId: taskId,
            error: error.message || 'Signing failed',
            inputIndex: inputIndex
        });
        return;
    }

    // CRITICAL: Zero the private key immediately after signing
    secureZero(privateKey);

    // Send result back
    const result = {
        type: 'result',
        taskId: taskId,
        signature: signature,
        inputIndex: inputIndex,
        publicKey: publicKey,
        signatureType: signatureType
    };

    if (leafHash) {
        result.leafHash = leafHash;
    }

    self.postMessage(result);
}

/**
 * Handle a batch signing request.
 * Signs multiple tasks and returns all results in a single message.
 *
 * SECURITY: Private key is zeroed immediately after all signatures.
 *
 * @param {Object} msg - Batch signing message with tasks array
 */
function handleSignBatch(msg) {
    const { batchId, tasks, privateKey } = msg;
    const results = [];
    const errors = [];

    // Validate private key once
    if (!privateKey || privateKey.length !== 32) {
        secureZero(privateKey);
        self.postMessage({
            type: 'batchResult',
            batchId: batchId,
            results: [],
            errors: [{ inputIndex: -1, error: 'Invalid private key: must be 32 bytes' }]
        });
        return;
    }

    // Process all tasks
    for (const task of tasks) {
        const { taskId, hash, publicKey, signatureType, lowR, inputIndex, sighashType, leafHash } = task;

        // Validate hash
        if (!hash || hash.length !== 32) {
            errors.push({ taskId, inputIndex, error: 'Invalid hash: must be 32 bytes' });
            continue;
        }

        try {
            let signature;
            if (signatureType === 1) {
                // Schnorr signature (BIP340)
                signature = eccLib.signSchnorr(hash, privateKey);
            } else {
                // ECDSA signature
                signature = eccLib.sign(hash, privateKey, { lowR: lowR || false });
            }

            if (!signature) {
                throw new Error('Signing returned null or undefined');
            }

            const result = {
                taskId: taskId,
                signature: signature,
                inputIndex: inputIndex,
                publicKey: publicKey,
                signatureType: signatureType
            };

            if (leafHash) {
                result.leafHash = leafHash;
            }

            results.push(result);
        } catch (error) {
            errors.push({ taskId, inputIndex, error: error.message || 'Signing failed' });
        }
    }

    // CRITICAL: Zero the private key after processing all tasks
    secureZero(privateKey);

    // Send batch result back
    self.postMessage({
        type: 'batchResult',
        batchId: batchId,
        results: results,
        errors: errors
    });
}

/**
 * Handle shutdown request.
 */
function handleShutdown() {
    initialized = false;
    pendingMessages.length = 0;

    self.postMessage({ type: 'shutdown-ack' });

    // Close the worker
    self.close();
}
`;
}
/**
 * Creates a Blob URL for the worker code.
 *
 * @returns Blob URL that can be used with new Worker()
 */
function createWorkerBlobUrl() {
    const code = generateWorkerCode();
    const blob = new Blob([code], { type: 'application/javascript' });
    return URL.createObjectURL(blob);
}
/**
 * Revokes a previously created worker Blob URL.
 *
 * @param url - The Blob URL to revoke
 */
function revokeWorkerBlobUrl(url) {
    URL.revokeObjectURL(url);
}

/**
 * Worker-based parallel signing pool.
 *
 * Provides secure parallel signature computation using worker threads.
 * Private keys are isolated per-worker and zeroed immediately after signing.
 *
 * SECURITY ARCHITECTURE:
 * - Keys are NEVER shared via SharedArrayBuffer
 * - Each key is cloned to ONE worker via postMessage
 * - Keys are zeroed in worker immediately after signing
 * - Workers can be preserved for performance or terminated for security
 *
 * @example
 * ```typescript
 * import { WorkerSigningPool } from '@btc-vision/bitcoin';
 *
 * // Get singleton pool instance
 * const pool = WorkerSigningPool.getInstance();
 *
 * // Preserve workers for multiple signing operations (faster)
 * pool.preserveWorkers();
 *
 * // Sign multiple inputs in parallel
 * const result = await pool.signBatch(tasks, keyPair);
 *
 * // Shutdown when done (optional - cleans up workers)
 * await pool.shutdown();
 * ```
 *
 * @packageDocumentation
 */
/**
 * Default configuration values.
 */
const DEFAULT_CONFIG = {
    workerCount: typeof navigator !== 'undefined' ? navigator.hardwareConcurrency || 4 : 4,
    taskTimeoutMs: 30000,
    maxKeyHoldTimeMs: 5000,
    verifySignatures: true,
    preserveWorkers: false,
};
/**
 * Worker-based parallel signing pool.
 *
 * Manages a pool of worker threads for parallel signature computation.
 * Provides secure key handling with immediate zeroing after use.
 *
 * @example
 * ```typescript
 * // Initialize pool at app startup
 * const pool = WorkerSigningPool.getInstance({ workerCount: 4 });
 * pool.preserveWorkers();
 *
 * // Use for PSBT signing
 * const tasks = prepareSigningTasks(psbt, keyPair);
 * const result = await pool.signBatch(tasks, keyPair);
 *
 * // Apply signatures to PSBT
 * applySignatures(psbt, result.signatures);
 * ```
 */
class WorkerSigningPool {
    /**
     * Singleton instance.
     */
    static #instance = null;
    /**
     * Pool configuration.
     */
    #config;
    /**
     * Worker pool.
     */
    #workers = [];
    /**
     * Pending batches awaiting completion.
     */
    #pendingBatches = new Map();
    /**
     * Worker blob URL (shared across all workers).
     */
    #workerBlobUrl = null;
    /**
     * Whether workers are preserved between batches.
     */
    #preserveWorkers = false;
    /**
     * Next worker ID counter.
     */
    #nextWorkerId = 0;
    /**
     * Next task ID counter.
     */
    #nextTaskId = 0;
    /**
     * Whether the pool is initialized.
     */
    #initialized = false;
    /**
     * Whether the pool is shutting down.
     */
    #shuttingDown = false;
    /**
     * Creates a new WorkerSigningPool.
     *
     * @param config - Pool configuration
     */
    constructor(config = {}) {
        this.#config = { ...DEFAULT_CONFIG, ...config };
        this.#preserveWorkers = this.#config.preserveWorkers;
    }
    /**
     * Number of workers in the pool.
     */
    get workerCount() {
        return this.#workers.length;
    }
    /**
     * Number of idle workers available.
     */
    get idleWorkerCount() {
        return this.#workers.filter((w) => w.state === WorkerState.Idle).length;
    }
    /**
     * Number of busy workers.
     */
    get busyWorkerCount() {
        return this.#workers.filter((w) => w.state === WorkerState.Busy).length;
    }
    /**
     * Whether workers are being preserved between batches.
     */
    get isPreservingWorkers() {
        return this.#preserveWorkers;
    }
    /**
     * Gets the singleton pool instance.
     *
     * @param config - Optional configuration (only used on first call)
     * @returns The singleton pool instance
     *
     * @example
     * ```typescript
     * const pool = WorkerSigningPool.getInstance({ workerCount: 8 });
     * ```
     */
    static getInstance(config) {
        if (!WorkerSigningPool.#instance) {
            WorkerSigningPool.#instance = new WorkerSigningPool(config);
        }
        return WorkerSigningPool.#instance;
    }
    /**
     * Resets the singleton instance (for testing).
     */
    static resetInstance() {
        if (WorkerSigningPool.#instance) {
            WorkerSigningPool.#instance.shutdown().catch(() => { });
            WorkerSigningPool.#instance = null;
        }
    }
    /**
     * Enables worker preservation between signing batches.
     *
     * When enabled, workers remain alive after completing a batch,
     * ready for the next signing operation. This is faster but
     * keeps workers in memory.
     *
     * Call shutdown() when done to terminate all workers.
     *
     * @example
     * ```typescript
     * const pool = WorkerSigningPool.getInstance();
     * pool.preserveWorkers(); // Enable at app startup
     *
     * // ... do many signing operations ...
     *
     * await pool.shutdown(); // Cleanup at app shutdown
     * ```
     */
    preserveWorkers() {
        this.#preserveWorkers = true;
    }
    /**
     * Disables worker preservation.
     *
     * Workers will be terminated after each signing batch.
     * More secure (no persistent workers) but slower for multiple batches.
     */
    releaseWorkers() {
        this.#preserveWorkers = false;
    }
    /**
     * Initializes the worker pool.
     *
     * Creates workers and waits for them to be ready.
     * Called automatically on first signBatch() if not called manually.
     *
     * @returns Promise that resolves when all workers are ready
     */
    async initialize() {
        if (this.#initialized) {
            return;
        }
        if (this.#shuttingDown) {
            throw new Error('Cannot initialize pool while shutting down');
        }
        // Create worker blob URL (ECC library is bundled at compile time)
        this.#workerBlobUrl = createWorkerBlobUrl();
        // Create workers
        const workerPromises = [];
        for (let i = 0; i < this.#config.workerCount; i++) {
            workerPromises.push(this.#createWorker());
        }
        await Promise.all(workerPromises);
        this.#initialized = true;
    }
    /**
     * Signs a batch of tasks in parallel.
     *
     * SECURITY: Private keys are obtained via keyPair.getPrivateKey() and
     * cloned to workers. Keys are zeroed in workers immediately after signing.
     *
     * Tasks are distributed across workers and processed in batches for efficiency.
     *
     * @param tasks - Signing tasks (hashes, input indices, etc.)
     * @param keyPair - Key pair with getPrivateKey() method
     * @returns Promise resolving to signing results
     *
     * @example
     * ```typescript
     * const tasks: SigningTask[] = [
     *     { taskId: '1', inputIndex: 0, hash: hash0, signatureType: SignatureType.ECDSA, sighashType: 0x01 },
     *     { taskId: '2', inputIndex: 1, hash: hash1, signatureType: SignatureType.Schnorr, sighashType: 0x00 },
     * ];
     *
     * const result = await pool.signBatch(tasks, keyPair);
     *
     * if (result.success) {
     *     for (const [inputIndex, sig] of result.signatures) {
     *         console.log(`Input ${inputIndex}: ${sig.signature}`);
     *     }
     * }
     * ```
     */
    async signBatch(tasks, keyPair) {
        const startTime = performance.now();
        // Initialize if needed
        if (!this.#initialized) {
            await this.initialize();
        }
        if (tasks.length === 0) {
            return {
                success: true,
                signatures: new Map(),
                errors: new Map(),
                durationMs: performance.now() - startTime,
            };
        }
        // Distribute tasks across workers
        const workerCount = Math.min(this.#workers.length, tasks.length);
        const taskBatches = Array.from({ length: workerCount }, () => []);
        for (let i = 0; i < tasks.length; i++) {
            taskBatches[i % workerCount].push(tasks[i]);
        }
        // Get private key once
        const privateKey = keyPair.getPrivateKey();
        try {
            // Send batches to workers in parallel
            const batchResults = await Promise.allSettled(taskBatches.map((batch, index) => this.#signBatchOnWorker(batch, privateKey, keyPair.publicKey, index)));
            // Collect all results
            const signatures = new Map();
            const errors = new Map();
            for (let i = 0; i < batchResults.length; i++) {
                const result = batchResults[i];
                if (result.status === 'fulfilled') {
                    const batchResult = result.value;
                    // Add successful signatures
                    for (const sig of batchResult.results) {
                        signatures.set(sig.inputIndex, {
                            type: 'result',
                            taskId: sig.taskId,
                            signature: sig.signature,
                            inputIndex: sig.inputIndex,
                            publicKey: sig.publicKey,
                            signatureType: sig.signatureType,
                            leafHash: sig.leafHash,
                        });
                    }
                    // Add errors
                    for (const err of batchResult.errors) {
                        errors.set(err.inputIndex, err.error);
                    }
                }
                else {
                    // Entire batch failed - mark all tasks in batch as failed
                    const reason = result.reason;
                    const errorMsg = reason?.message ?? 'Batch signing failed';
                    // Add error for each task in the failed batch
                    const failedBatch = taskBatches[i];
                    for (const task of failedBatch) {
                        errors.set(task.inputIndex, errorMsg);
                    }
                }
            }
            // Cleanup workers if not preserving
            if (!this.#preserveWorkers) {
                await this.#terminateIdleWorkers();
            }
            return {
                success: errors.size === 0,
                signatures,
                errors,
                durationMs: performance.now() - startTime,
            };
        }
        finally {
            // SECURITY: Zero the key in main thread
            privateKey.fill(0);
        }
    }
    /**
     * Disposes of the pool by shutting down all workers.
     *
     * Enables `await using pool = ...` syntax for automatic cleanup.
     */
    async [Symbol.asyncDispose]() {
        await this.shutdown();
    }
    /**
     * Shuts down the pool and terminates all workers.
     *
     * Call this when the application is done with signing operations.
     *
     * @returns Promise that resolves when all workers are terminated
     */
    async shutdown() {
        if (this.#shuttingDown) {
            return;
        }
        this.#shuttingDown = true;
        // Terminate all workers
        const terminatePromises = this.#workers.map((worker) => this.#terminateWorker(worker));
        await Promise.all(terminatePromises);
        // Clear state
        this.#workers.length = 0;
        this.#pendingBatches.clear();
        // Revoke blob URL
        if (this.#workerBlobUrl) {
            revokeWorkerBlobUrl(this.#workerBlobUrl);
            this.#workerBlobUrl = null;
        }
        this.#initialized = false;
        this.#shuttingDown = false;
    }
    [Symbol.dispose]() {
        void this.shutdown();
    }
    /**
     * Creates a new worker and adds it to the pool.
     */
    async #createWorker() {
        if (!this.#workerBlobUrl) {
            throw new Error('Worker blob URL not created');
        }
        const workerId = this.#nextWorkerId++;
        // Create worker from blob URL
        const worker = new Worker(this.#workerBlobUrl, {
            name: `signing-worker-${workerId}`,
        });
        const pooledWorker = {
            id: workerId,
            state: WorkerState.Initializing,
            worker,
            currentTaskId: null,
            taskStartTime: null,
        };
        this.#workers.push(pooledWorker);
        // Wait for worker to be ready
        await new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error(`Worker ${workerId} initialization timeout`));
            }, 10000);
            const messageHandler = (event) => {
                if (isWorkerReady(event.data)) {
                    clearTimeout(timeout);
                    worker.removeEventListener('message', messageHandler);
                    pooledWorker.state = WorkerState.Idle;
                    resolve();
                }
            };
            worker.addEventListener('message', messageHandler);
            worker.addEventListener('error', (error) => {
                clearTimeout(timeout);
                reject(new Error(`Worker ${workerId} error: ${error.message}`));
            });
            // Send init message (ECC library is bundled in worker code)
            worker.postMessage({
                type: 'init',
            });
        });
        // Set up message handler for signing results
        worker.addEventListener('message', (event) => {
            this.#handleWorkerMessage(pooledWorker, event.data);
        });
    }
    /**
     * Signs a batch of tasks on a specific worker.
     */
    async #signBatchOnWorker(tasks, privateKey, publicKey, workerIndex) {
        if (tasks.length === 0) {
            return { type: 'batchResult', batchId: '', results: [], errors: [] };
        }
        // Get worker at index (or wait for idle)
        const worker = this.#workers[workerIndex] ?? (await this.#getIdleWorker());
        // Generate unique batch ID
        const batchId = `batch-${this.#nextTaskId++}`;
        return new Promise((resolve, reject) => {
            // Set up timeout
            const timeoutId = setTimeout(() => {
                this.#pendingBatches.delete(batchId);
                worker.state = WorkerState.Idle;
                worker.currentTaskId = null;
                worker.taskStartTime = null;
                // SECURITY: Terminate worker that exceeded key hold time
                this.#terminateWorker(worker).catch(() => { });
                this.#createWorker().catch(() => { });
                reject(new Error(`Batch signing timeout for ${tasks.length} tasks`));
            }, this.#config.maxKeyHoldTimeMs);
            // Store pending batch
            const pendingBatch = {
                batchId,
                resolve,
                reject,
                timeoutId,
            };
            this.#pendingBatches.set(batchId, pendingBatch);
            // Mark worker as busy
            worker.state = WorkerState.Busy;
            worker.currentTaskId = batchId;
            worker.taskStartTime = Date.now();
            // Convert tasks to batch format
            const batchTasks = tasks.map((task) => ({
                taskId: task.taskId,
                hash: task.hash,
                publicKey,
                signatureType: task.signatureType,
                lowR: task.lowR,
                inputIndex: task.inputIndex,
                sighashType: task.sighashType,
                leafHash: task.leafHash,
            }));
            // Create batch message
            // SECURITY: privateKey is cloned via postMessage, NOT shared
            const message = {
                type: 'signBatch',
                batchId,
                tasks: batchTasks,
                privateKey, // Cloned to worker, zeroed there after all signatures
            };
            // Send to worker
            worker.worker.postMessage(message);
        });
    }
    /**
     * Gets an idle worker, creating one if necessary.
     */
    async #getIdleWorker() {
        // Find idle worker
        let worker = this.#workers.find((w) => w.state === WorkerState.Idle);
        if (worker) {
            return worker;
        }
        // No idle workers - wait for one to become available
        // or create a new one if under limit
        if (this.#workers.length < this.#config.workerCount) {
            await this.#createWorker();
            worker = this.#workers.find((w) => w.state === WorkerState.Idle);
            if (worker) {
                return worker;
            }
        }
        // Wait for any worker to become idle
        return new Promise((resolve) => {
            const checkInterval = setInterval(() => {
                const idleWorker = this.#workers.find((w) => w.state === WorkerState.Idle);
                if (idleWorker) {
                    clearInterval(checkInterval);
                    resolve(idleWorker);
                }
            }, 10);
        });
    }
    /**
     * Handles a message from a worker.
     */
    #handleWorkerMessage(worker, response) {
        if (isBatchResult(response)) {
            const pending = this.#pendingBatches.get(response.batchId);
            if (pending) {
                clearTimeout(pending.timeoutId);
                this.#pendingBatches.delete(response.batchId);
                worker.state = WorkerState.Idle;
                worker.currentTaskId = null;
                worker.taskStartTime = null;
                pending.resolve(response);
            }
        }
        // Ignore ready and shutdown-ack messages here (handled elsewhere)
    }
    /**
     * Terminates a worker.
     */
    async #terminateWorker(worker) {
        if (worker.state === WorkerState.Terminated) {
            return;
        }
        worker.state = WorkerState.ShuttingDown;
        // Send shutdown message
        worker.worker.postMessage({ type: 'shutdown' });
        // Wait briefly for acknowledgment, then terminate
        await new Promise((resolve) => {
            const timeout = setTimeout(() => {
                worker.worker.terminate();
                worker.state = WorkerState.Terminated;
                resolve();
            }, 1000);
            const handler = (event) => {
                if (event.data.type === 'shutdown-ack') {
                    clearTimeout(timeout);
                    worker.worker.removeEventListener('message', handler);
                    worker.worker.terminate();
                    worker.state = WorkerState.Terminated;
                    resolve();
                }
            };
            worker.worker.addEventListener('message', handler);
        });
        // Remove from pool
        const index = this.#workers.indexOf(worker);
        if (index >= 0) {
            this.#workers.splice(index, 1);
        }
    }
    /**
     * Terminates all idle workers.
     */
    async #terminateIdleWorkers() {
        const idleWorkers = this.#workers.filter((w) => w.state === WorkerState.Idle);
        await Promise.all(idleWorkers.map((w) => this.#terminateWorker(w)));
    }
}

/**
 * PSBT parallel signing integration.
 *
 * Provides helper functions to sign PSBT inputs in parallel using worker threads.
 *
 * @example
 * ```typescript
 * import { Psbt } from '@btc-vision/bitcoin';
 * import { signPsbtParallel, WorkerSigningPool } from '@btc-vision/bitcoin/workers';
 *
 * // Initialize pool once at app startup
 * const pool = WorkerSigningPool.getInstance();
 * pool.preserveWorkers();
 *
 * // Create and populate PSBT
 * const psbt = new Psbt();
 * psbt.addInput(...);
 * psbt.addOutput(...);
 *
 * // Sign all inputs in parallel
 * await signPsbtParallel(psbt, keyPair, pool);
 *
 * // Finalize and extract
 * psbt.finalizeAllInputs();
 * const tx = psbt.extractTransaction();
 * ```
 *
 * @packageDocumentation
 */
/**
 * Prepares signing tasks from a PSBT.
 *
 * Analyzes each input and creates a signing task for inputs
 * that can be signed with the provided key pair.
 *
 * @param psbt - The PSBT to analyze
 * @param keyPair - Key pair to check against
 * @param options - Signing options
 * @returns Array of signing tasks
 */
function prepareSigningTasks(psbt, keyPair, options = {}) {
    const tasks = [];
    const inputs = psbt.data.inputs;
    const pubkey = keyPair.publicKey;
    for (let i = 0; i < inputs.length; i++) {
        const input = inputs[i];
        // Check if this input can be signed with this key
        if (!psbt.inputHasPubkey(i, pubkey)) {
            continue;
        }
        // Determine if Taproot
        if (isTaprootInput$1(input)) {
            // Get Taproot hashes for signing
            const taprootTasks = prepareTaprootTasks(psbt, i, input, keyPair, options);
            tasks.push(...taprootTasks);
        }
        else {
            // Legacy/SegWit signing
            const legacyTask = prepareLegacyTask(psbt, i, input, keyPair, options);
            if (legacyTask) {
                tasks.push(legacyTask);
            }
        }
    }
    return tasks;
}
/**
 * Prepares signing tasks for a Taproot input.
 */
function prepareTaprootTasks(psbt, inputIndex, input, keyPair, options) {
    const tasks = [];
    try {
        const hashesForSig = psbt.checkTaprootHashesForSig(inputIndex, input, keyPair, options.tapLeafHash, options.sighashTypes);
        for (const { hash, leafHash } of hashesForSig) {
            tasks.push({
                taskId: `taproot-${inputIndex}-${leafHash ? 'script' : 'key'}`,
                inputIndex,
                hash,
                signatureType: SignatureType$1.Schnorr,
                sighashType: input.sighashType ?? Transaction.SIGHASH_DEFAULT,
                leafHash,
            });
        }
    }
    catch {
        // Input cannot be signed with this key
    }
    return tasks;
}
/**
 * Prepares a signing task for a legacy/SegWit input.
 */
function prepareLegacyTask(_psbt, _inputIndex, input, _keyPair, options) {
    try {
        // Get hash for signing - we need to access the internal method
        // This is a simplified version; full implementation would need cache access
        const sighashType = input.sighashType ?? Transaction.SIGHASH_ALL;
        const allowedTypes = options.sighashTypes ?? [Transaction.SIGHASH_ALL];
        if (!allowedTypes.includes(sighashType)) {
            return null;
        }
        // Note: In production, we'd need to compute the hash properly
        // This requires access to PSBT internals (cache, etc.)
        // For now, we return a placeholder - the actual implementation
        // would integrate with psbt._signInput internals
        return null; // Placeholder - full implementation needs PSBT internals
    }
    catch {
        return null;
    }
}
/**
 * Applies parallel signing results to a PSBT.
 *
 * @param psbt - The PSBT to update
 * @param result - Signing results from parallel signing
 * @param keyPair - Key pair used for signing
 */
function applySignaturesToPsbt(psbt, result, keyPair) {
    const pubkey = keyPair.publicKey;
    for (const [inputIndex, sigResult] of result.signatures) {
        const input = psbt.data.inputs[inputIndex];
        if (sigResult.signatureType === SignatureType$1.Schnorr) {
            // Taproot signature
            if (sigResult.leafHash) {
                // Script-path signature
                const tapScriptSig = [
                    {
                        pubkey: toXOnly(pubkey),
                        signature: serializeTaprootSignature(sigResult.signature, input.sighashType),
                        leafHash: sigResult.leafHash,
                    },
                ];
                psbt.data.updateInput(inputIndex, { tapScriptSig: tapScriptSig });
            }
            else {
                // Key-path signature
                const tapKeySig = serializeTaprootSignature(sigResult.signature, input.sighashType);
                psbt.data.updateInput(inputIndex, { tapKeySig: tapKeySig });
            }
        }
        else {
            // ECDSA signature
            const encodedSig = signature.encode(sigResult.signature, input.sighashType ?? Transaction.SIGHASH_ALL);
            const partialSig = [
                {
                    pubkey: Uint8Array.from(pubkey),
                    signature: encodedSig,
                },
            ];
            psbt.data.updateInput(inputIndex, { partialSig });
        }
    }
}
// Transaction is already imported above for sighash constants

const bitcoin = {
    payments,
    script,
    crypto: crypto$2};

const S = Symbol;
if (typeof S.dispose !== "symbol") {
  S.dispose = /* @__PURE__ */ Symbol.for("Symbol.dispose");
}
if (typeof S.asyncDispose !== "symbol") {
  S.asyncDispose = /* @__PURE__ */ Symbol.for("Symbol.asyncDispose");
}

/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
const send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
const send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
const bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
const gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
const bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
const smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
const pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
const compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
const build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
const _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
const zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
const fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
const deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1};
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1};
const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};

function gzipSync(data, options = {}) {
    return Buffer.from(pako.gzip(data, { level: options.level || 6 }));
}

function gunzipSync(data) {
    return Buffer.from(pako.ungzip(data));
}

const zlib = {
    gzipSync,
    gunzipSync,
};

/** Compressor class for compressing and decompressing data. */
class Compressor {
    static zlibOptions = {
        level: 9,
        maxOutputLength: 1024 * 1024 * 16, // 16mb, limit it to 16mb.
    };
    /**
     * Compresses the data using gzip.
     * @param {Uint8Array} data The data to compress.
     * @returns {Uint8Array} The compressed data.
     */
    static compress(data) {
        return new Uint8Array(zlib.gzipSync(data, Compressor.zlibOptions));
    }
    /**
     * Decompresses the data using gunzip.
     * @param {Uint8Array} data The data to decompress.
     * @returns {Uint8Array} The decompressed data.
     */
    static decompress(data) {
        return new Uint8Array(zlib.gunzipSync(data, Compressor.zlibOptions));
    }
}

/**
 * Shared noble-curves backend for all EC operations.
 * Instantiated once and reused across the entire library.
 */
const backend = Nr();
/**
 * EccLib is now a type alias for CryptoBackend.
 * The backend can be used directly.
 */
const eccLib = backend;
// Initialize the ECC library once at module load
initEccLib(eccLib);

var cjs = {};

var bip32$1 = {};

var crypto$1 = {};

var hasRequiredCrypto;

function requireCrypto () {
	if (hasRequiredCrypto) return crypto$1;
	hasRequiredCrypto = 1;
	Object.defineProperty(crypto$1, "__esModule", { value: true });
	crypto$1.hash160 = hash160;
	crypto$1.hash256 = hash256;
	crypto$1.hmacSHA512 = hmacSHA512;
	const hmac_js_1 = require$$0$3;
	const legacy_js_1 = require$$1$1;
	const sha2_js_1 = require$$2$2;
	function hash160(buffer) {
	    return (0, legacy_js_1.ripemd160)((0, sha2_js_1.sha256)(buffer));
	}
	function hash256(buffer) {
	    return (0, sha2_js_1.sha256)(buffer);
	}
	function hmacSHA512(key, data) {
	    return (0, hmac_js_1.hmac)(sha2_js_1.sha512, key, data);
	}
	return crypto$1;
}

var testecc = {};

const require$$2$1 = /*@__PURE__*/getAugmentedNamespace(browser$1);

var hasRequiredTestecc;

function requireTestecc () {
	if (hasRequiredTestecc) return testecc;
	hasRequiredTestecc = 1;
	var __createBinding = (testecc && testecc.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (testecc && testecc.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (testecc && testecc.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(testecc, "__esModule", { value: true });
	testecc.testEcc = testEcc;
	const tools = __importStar(require$$2$1);
	const h = (hex) => tools.fromHex(hex);
	function testEcc(ecc) {
	    assert(ecc.isPoint(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
	    assert(!ecc.isPoint(h('030000000000000000000000000000000000000000000000000000000000000005')));
	    assert(ecc.isPrivate(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
	    // order - 1
	    assert(ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
	    // 0
	    assert(!ecc.isPrivate(h('0000000000000000000000000000000000000000000000000000000000000000')));
	    // order
	    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141')));
	    // order + 1
	    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142')));
	    assert(tools.compare(ecc.pointFromScalar(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99')) === 0);
	    if (ecc.xOnlyPointAddTweak) {
	        assert(ecc.xOnlyPointAddTweak(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === null);
	        let xOnlyRes = ecc.xOnlyPointAddTweak(h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'), h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'));
	        assert(tools.compare(xOnlyRes.xOnlyPubkey, h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) === 0 && xOnlyRes.parity === 1);
	        xOnlyRes = ecc.xOnlyPointAddTweak(h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'), h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'));
	    }
	    assert(tools.compare(ecc.pointAddScalar(h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('0000000000000000000000000000000000000000000000000000000000000003')), h('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')) === 0);
	    assert(tools.compare(ecc.privateAdd(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'), h('0000000000000000000000000000000000000000000000000000000000000002')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);
	    if (ecc.privateNegate) {
	        assert(tools.compare(ecc.privateNegate(h('0000000000000000000000000000000000000000000000000000000000000001')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);
	        assert(tools.compare(ecc.privateNegate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e')), h('0000000000000000000000000000000000000000000000000000000000000003')) === 0);
	        assert(tools.compare(ecc.privateNegate(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792')) === 0);
	    }
	    assert(tools.compare(ecc.sign(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')) === 0);
	    assert(ecc.verify(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
	    if (ecc.signSchnorr) {
	        assert(tools.compare(ecc.signSchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'), h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906')), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')) === 0);
	    }
	    if (ecc.verifySchnorr) {
	        assert(ecc.verifySchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
	    }
	}
	function assert(bool) {
	    if (!bool)
	        throw new Error('ecc library invalid');
	}
	return testecc;
}

const require$$4$2 = /*@__PURE__*/getAugmentedNamespace(build$1);

var types$1 = {};

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types$1;
	hasRequiredTypes$1 = 1;
	Object.defineProperty(types$1, "__esModule", { value: true });
	types$1.validateBip32Path = validateBip32Path;
	types$1.validateBytes32 = validateBytes32;
	types$1.validateBytes33 = validateBytes33;
	const BIP32_PATH_REGEX = /^(m\/)?(\d+'?\/)*\d+'?$/;
	function validateBip32Path(path) {
	    if (typeof path !== 'string' || !BIP32_PATH_REGEX.test(path)) {
	        throw new TypeError('Expected BIP32 derivation path');
	    }
	}
	function validateBytes32(buf) {
	    if (!(buf instanceof Uint8Array) || buf.length !== 32) {
	        throw new TypeError('Expected Uint8Array of length 32');
	    }
	}
	function validateBytes33(buf) {
	    if (!(buf instanceof Uint8Array) || buf.length !== 33) {
	        throw new TypeError('Expected Uint8Array of length 33');
	    }
	}
	return types$1;
}

function decodeRaw(buffer, version) {
    if (version !== undefined && buffer[0] !== version) {
        throw new Error('Invalid network version');
    }
    if (buffer.length === 33) {
        return {
            version: buffer[0],
            privateKey: buffer.slice(1, 33),
            compressed: false,
        };
    }
    if (buffer.length !== 34) {
        throw new Error('Invalid WIF length');
    }
    if (buffer[33] !== 0x01) {
        throw new Error('Invalid compression flag');
    }
    return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: true,
    };
}
function encodeRaw(version, privateKey, compressed) {
    if (privateKey.length !== 32) {
        throw new TypeError('Invalid privateKey length');
    }
    const result = new Uint8Array(compressed ? 34 : 33);
    const view = new DataView(result.buffer);
    view.setUint8(0, version);
    result.set(privateKey, 1);
    if (compressed) {
        result[33] = 0x01;
    }
    return result;
}
function decode(str, version) {
    return decodeRaw(bs58check.decode(str), version);
}
function encode(wif) {
    return bs58check.encode(encodeRaw(wif.version, wif.privateKey, wif.compressed));
}

const build = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    decode,
    decodeRaw,
    encode,
    encodeRaw
}, Symbol.toStringTag, { value: 'Module' }));

const require$$4$1 = /*@__PURE__*/getAugmentedNamespace(build);

var networks = {};

var hasRequiredNetworks;

function requireNetworks () {
	if (hasRequiredNetworks) return networks;
	hasRequiredNetworks = 1;
	Object.defineProperty(networks, "__esModule", { value: true });
	networks.REGTEST = networks.TESTNET = networks.BITCOIN = void 0;
	/**
	 * Bitcoin mainnet network configuration
	 */
	networks.BITCOIN = {
	    messagePrefix: '\x18Bitcoin Signed Message:\n',
	    bech32: 'bc',
	    bip32: {
	        public: 0x0488b21e,
	        private: 0x0488ade4,
	    },
	    pubKeyHash: 0x00,
	    scriptHash: 0x05,
	    wif: 0x80,
	};
	/**
	 * Bitcoin testnet network configuration
	 */
	networks.TESTNET = {
	    messagePrefix: '\x18Bitcoin Signed Message:\n',
	    bech32: 'tb',
	    bip32: {
	        public: 0x043587cf,
	        private: 0x04358394,
	    },
	    pubKeyHash: 0x6f,
	    scriptHash: 0xc4,
	    wif: 0xef,
	};
	/**
	 * Bitcoin regtest network configuration
	 */
	networks.REGTEST = {
	    messagePrefix: '\x18Bitcoin Signed Message:\n',
	    bech32: 'bcrt',
	    bip32: {
	        public: 0x043587cf,
	        private: 0x04358394,
	    },
	    pubKeyHash: 0x6f,
	    scriptHash: 0xc4,
	    wif: 0xef,
	};
	return networks;
}

const require$$7$1 = /*@__PURE__*/getAugmentedNamespace(browser$2);

var hasRequiredBip32;

function requireBip32 () {
	if (hasRequiredBip32) return bip32$1;
	hasRequiredBip32 = 1;
	var __createBinding = (bip32$1 && bip32$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (bip32$1 && bip32$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (bip32$1 && bip32$1.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(bip32$1, "__esModule", { value: true });
	bip32$1.BIP32Factory = BIP32Factory;
	const crypto = __importStar(requireCrypto());
	const testecc_js_1 = requireTestecc();
	const bs58check = __importStar(require$$4$2);
	const types_js_1 = requireTypes$1();
	const wif = __importStar(require$$4$1);
	const tools = __importStar(require$$2$1);
	const networks_js_1 = requireNetworks();
	const ecpair_1 = require$$7$1;
	const BITCOIN_SEED = tools.fromUtf8('Bitcoin seed');
	const testedLibs = new WeakSet();
	/**
	 * Creates a BIP32 HD wallet factory.
	 *
	 * Accepts either a raw `tiny-secp256k1` object ({@link TinySecp256k1Interface})
	 * or a {@link CryptoBackend} from `@btc-vision/ecpair` (e.g. `createNobleBackend()`
	 * or `createLegacyBackend(ecc)`).
	 */
	function BIP32Factory(ecc) {
	    // At runtime, CryptoBackend branded-type parameters ARE Uint8Array,
	    // so we can safely normalize to TinySecp256k1Interface.
	    const lib = ecc;
	    if (!testedLibs.has(lib)) {
	        (0, testecc_js_1.testEcc)(lib);
	        testedLibs.add(lib);
	    }
	    const HIGHEST_BIT = 0x80000000;
	    function toXOnly(pubKey) {
	        return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
	    }
	    class Bip32Signer {
	        __D;
	        __Q;
	        network;
	        lowR = false;
	        constructor(__D, __Q, network) {
	            this.__D = __D;
	            this.__Q = __Q;
	            this.network = network;
	        }
	        get publicKey() {
	            if (this.__Q === undefined)
	                this.__Q = lib.pointFromScalar(this.__D, true);
	            return this.__Q;
	        }
	        get xOnlyPublicKey() {
	            return toXOnly(this.publicKey);
	        }
	        get privateKey() {
	            return this.__D;
	        }
	        get compressed() {
	            return true;
	        }
	        get capabilities() {
	            let caps = ecpair_1.SignerCapability.EcdsaVerify | ecpair_1.SignerCapability.PublicKeyTweak;
	            if (this.__D !== undefined) {
	                caps |= ecpair_1.SignerCapability.EcdsaSign | ecpair_1.SignerCapability.PrivateKeyExport;
	            }
	            if (lib.signSchnorr && this.__D !== undefined) {
	                caps |= ecpair_1.SignerCapability.SchnorrSign;
	            }
	            if (lib.verifySchnorr) {
	                caps |= ecpair_1.SignerCapability.SchnorrVerify;
	            }
	            return caps;
	        }
	        hasCapability(cap) {
	            return (this.capabilities & cap) !== 0;
	        }
	        sign(hash, lowR) {
	            if (!this.privateKey)
	                throw new Error('Missing private key');
	            if (lowR === undefined)
	                lowR = this.lowR;
	            if (!lowR) {
	                return lib.sign(hash, this.privateKey);
	            }
	            else {
	                let sig = lib.sign(hash, this.privateKey);
	                const extraData = new Uint8Array(32);
	                let counter = 0;
	                // if first try is lowR, skip the loop
	                // for second try and on, add extra entropy counting up
	                while (sig[0] > 0x7f) {
	                    counter++;
	                    tools.writeUInt32(extraData, 0, counter, 'LE');
	                    sig = lib.sign(hash, this.privateKey, extraData);
	                }
	                return sig;
	            }
	        }
	        signSchnorr(hash) {
	            if (!this.privateKey)
	                throw new Error('Missing private key');
	            if (!lib.signSchnorr)
	                throw new Error('signSchnorr not supported by ecc library');
	            return lib.signSchnorr(hash, this.privateKey);
	        }
	        verify(hash, signature) {
	            return lib.verify(hash, this.publicKey, signature);
	        }
	        verifySchnorr(hash, signature) {
	            if (!lib.verifySchnorr)
	                throw new Error('verifySchnorr not supported by ecc library');
	            return lib.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
	        }
	        tweak(t) {
	            if (this.privateKey)
	                return this.tweakFromPrivateKey(t);
	            return this.tweakFromPublicKey(t);
	        }
	        toWIF() {
	            if (!this.privateKey)
	                throw new TypeError('Missing private key');
	            return wif.encode({
	                version: this.network.wif,
	                privateKey: this.privateKey,
	                compressed: true,
	            });
	        }
	        tweakFromPublicKey(t) {
	            const xOnlyPubKey = toXOnly(this.publicKey);
	            // Runtime guard: lib may lack xOnlyPointAddTweak despite interface contract
	            const xOnlyPointAddTweak = lib.xOnlyPointAddTweak;
	            if (!xOnlyPointAddTweak)
	                throw new Error('xOnlyPointAddTweak not supported by ecc library');
	            const tweakedPublicKey = xOnlyPointAddTweak(xOnlyPubKey, t);
	            if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
	                throw new Error('Cannot tweak public key!');
	            const parityByte = Uint8Array.from([
	                tweakedPublicKey.parity === 0 ? 0x02 : 0x03,
	            ]);
	            const tweakedPublicKeyCompresed = tools.concat([
	                parityByte,
	                tweakedPublicKey.xOnlyPubkey,
	            ]);
	            return new Bip32Signer(undefined, tweakedPublicKeyCompresed, this.network);
	        }
	        tweakFromPrivateKey(t) {
	            const hasOddY = this.publicKey[0] === 3 ||
	                (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);
	            const privateKey = (() => {
	                if (!hasOddY)
	                    return this.privateKey;
	                else if (!lib.privateNegate)
	                    throw new Error('privateNegate not supported by ecc library');
	                else
	                    return lib.privateNegate(this.privateKey);
	            })();
	            const tweakedPrivateKey = lib.privateAdd(privateKey, t);
	            if (!tweakedPrivateKey)
	                throw new Error('Invalid tweaked private key!');
	            return new Bip32Signer(tweakedPrivateKey, undefined, this.network);
	        }
	    }
	    class BIP32 extends Bip32Signer {
	        chainCode;
	        __DEPTH;
	        __INDEX;
	        __PARENT_FINGERPRINT;
	        constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {
	            super(__D, __Q, network);
	            this.chainCode = chainCode;
	            this.__DEPTH = __DEPTH;
	            this.__INDEX = __INDEX;
	            this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
	        }
	        #ID;
	        get capabilities() {
	            return super.capabilities | ecpair_1.SignerCapability.HdDerivation;
	        }
	        get depth() {
	            return this.__DEPTH;
	        }
	        get index() {
	            return this.__INDEX;
	        }
	        get parentFingerprint() {
	            return this.__PARENT_FINGERPRINT;
	        }
	        get identifier() {
	            if (this.#ID === undefined)
	                this.#ID = crypto.hash160(this.publicKey);
	            return this.#ID;
	        }
	        get fingerprint() {
	            return this.identifier.subarray(0, 4);
	        }
	        // Private === not neutered
	        // Public === neutered
	        isNeutered() {
	            return this.__D === undefined;
	        }
	        neutered() {
	            return new BIP32(undefined, this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
	        }
	        toBase58() {
	            const network = this.network;
	            const version = !this.isNeutered()
	                ? network.bip32.private
	                : network.bip32.public;
	            const buffer = new Uint8Array(78);
	            // 4 bytes: version bytes
	            tools.writeUInt32(buffer, 0, version, 'BE');
	            // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
	            tools.writeUInt8(buffer, 4, this.depth);
	            // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
	            tools.writeUInt32(buffer, 5, this.parentFingerprint, 'BE');
	            // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
	            // This is encoded in big endian. (0x00000000 if master key)
	            tools.writeUInt32(buffer, 9, this.index, 'BE');
	            // 32 bytes: the chain code
	            buffer.set(this.chainCode, 13);
	            // 33 bytes: the public key or private key data
	            if (!this.isNeutered()) {
	                // 0x00 + k for private keys
	                tools.writeUInt8(buffer, 45, 0);
	                buffer.set(this.privateKey, 46);
	                // 33 bytes: the public key
	            }
	            else {
	                // X9.62 encoding for public keys
	                buffer.set(this.publicKey, 45);
	            }
	            return bs58check.encode(buffer);
	        }
	        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
	        derive(index) {
	            if (index !== (index >>> 0))
	                throw new TypeError('Expected UInt32, got ' + index);
	            const isHardened = index >= HIGHEST_BIT;
	            const data = new Uint8Array(37);
	            // Hardened child
	            if (isHardened) {
	                if (this.isNeutered())
	                    throw new TypeError('Missing private key for hardened child key');
	                // data = 0x00 || ser256(kpar) || ser32(index)
	                data[0] = 0x00;
	                data.set(this.privateKey, 1);
	                tools.writeUInt32(data, 33, index, 'BE');
	                // Normal child
	            }
	            else {
	                // data = serP(point(kpar)) || ser32(index)
	                //      = serP(Kpar) || ser32(index)
	                data.set(this.publicKey, 0);
	                tools.writeUInt32(data, 33, index, 'BE');
	            }
	            const I = crypto.hmacSHA512(this.chainCode, data);
	            const IL = I.slice(0, 32);
	            const IR = I.slice(32);
	            // if parse256(IL) >= n, proceed with the next value for i
	            if (!lib.isPrivate(IL))
	                return this.derive(index + 1);
	            const parentFp = tools.readUInt32(this.fingerprint, 0, 'BE');
	            const nextDepth = this.depth + 1;
	            // Private parent key -> private child key
	            if (!this.isNeutered()) {
	                // ki = parse256(IL) + kpar (mod n)
	                const ki = lib.privateAdd(this.privateKey, IL);
	                // In case ki == 0, proceed with the next value for i
	                if (ki == null)
	                    return this.derive(index + 1);
	                return new BIP32(ki, undefined, IR, this.network, nextDepth, index, parentFp);
	                // Public parent key -> public child key
	            }
	            else {
	                // Ki = point(parse256(IL)) + Kpar
	                //    = G*IL + Kpar
	                const Ki = lib.pointAddScalar(this.publicKey, IL, true);
	                // In case Ki is the point at infinity, proceed with the next value for i
	                if (Ki === null)
	                    return this.derive(index + 1);
	                return new BIP32(undefined, Ki, IR, this.network, nextDepth, index, parentFp);
	            }
	        }
	        deriveHardened(index) {
	            if (!Number.isInteger(index) ||
	                index < 0 ||
	                index > 0x7fffffff)
	                throw new TypeError('Expected UInt31, got ' + index);
	            // Only derives hardened private keys by default
	            return this.derive(index + HIGHEST_BIT);
	        }
	        derivePath(path) {
	            (0, types_js_1.validateBip32Path)(path);
	            let splitPath = path.split('/');
	            if (splitPath[0] === 'm') {
	                if (this.parentFingerprint)
	                    throw new TypeError('Expected master, got child');
	                splitPath = splitPath.slice(1);
	            }
	            return splitPath.reduce((prevHd, indexStr) => {
	                let index;
	                if (indexStr.slice(-1) === `'`) {
	                    index = parseInt(indexStr.slice(0, -1), 10);
	                    return prevHd.deriveHardened(index);
	                }
	                else {
	                    index = parseInt(indexStr, 10);
	                    return prevHd.derive(index);
	                }
	            }, this);
	        }
	    }
	    function fromBase58(inString, network) {
	        const buffer = bs58check.decode(inString);
	        if (buffer.length !== 78)
	            throw new TypeError('Invalid buffer length');
	        network = network || networks_js_1.BITCOIN;
	        // 4 bytes: version bytes
	        const version = tools.readUInt32(buffer, 0, 'BE');
	        if (version !== network.bip32.private && version !== network.bip32.public)
	            throw new TypeError('Invalid network version');
	        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
	        const depth = buffer[4];
	        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
	        const parentFingerprint = tools.readUInt32(buffer, 5, 'BE');
	        if (depth === 0) {
	            if (parentFingerprint !== 0x00000000)
	                throw new TypeError('Invalid parent fingerprint');
	        }
	        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
	        // This is encoded in MSB order. (0x00000000 if master key)
	        const index = tools.readUInt32(buffer, 9, 'BE');
	        if (depth === 0 && index !== 0)
	            throw new TypeError('Invalid index');
	        // 32 bytes: the chain code
	        const chainCode = buffer.slice(13, 45);
	        let hd;
	        // 33 bytes: private key data (0x00 + k)
	        if (version === network.bip32.private) {
	            if (buffer[45] !== 0x00)
	                throw new TypeError('Invalid private key');
	            const k = buffer.slice(46, 78);
	            hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
	            // 33 bytes: public key data (0x02 + X or 0x03 + X)
	        }
	        else {
	            const X = buffer.slice(45, 78);
	            hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
	        }
	        return hd;
	    }
	    function fromPrivateKey(privateKey, chainCode, network) {
	        return fromPrivateKeyLocal(privateKey, chainCode, network);
	    }
	    function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
	        (0, types_js_1.validateBytes32)(privateKey);
	        (0, types_js_1.validateBytes32)(chainCode);
	        network = network || networks_js_1.BITCOIN;
	        if (!lib.isPrivate(privateKey))
	            throw new TypeError('Private key not in range [1, n)');
	        return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
	    }
	    function fromPublicKey(publicKey, chainCode, network) {
	        return fromPublicKeyLocal(publicKey, chainCode, network);
	    }
	    function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
	        (0, types_js_1.validateBytes33)(publicKey);
	        (0, types_js_1.validateBytes32)(chainCode);
	        network = network || networks_js_1.BITCOIN;
	        // verify the X coordinate is a point on the curve
	        if (!lib.isPoint(publicKey))
	            throw new TypeError('Point is not on the curve');
	        return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
	    }
	    function fromSeed(seed, network) {
	        if (!(seed instanceof Uint8Array))
	            throw new TypeError('Expected Uint8Array');
	        if (seed.length < 16)
	            throw new TypeError('Seed should be at least 128 bits');
	        if (seed.length > 64)
	            throw new TypeError('Seed should be at most 512 bits');
	        network = network || networks_js_1.BITCOIN;
	        const I = crypto.hmacSHA512(BITCOIN_SEED, seed);
	        const IL = I.slice(0, 32);
	        const IR = I.slice(32);
	        return fromPrivateKey(IL, IR, network);
	    }
	    function fromPrecomputed(privateKey, publicKey, chainCode, depth, index, parentFingerprint, network) {
	        return new BIP32(privateKey, publicKey, chainCode, network || networks_js_1.BITCOIN, depth, index, parentFingerprint);
	    }
	    return {
	        fromSeed,
	        fromBase58,
	        fromPublicKey,
	        fromPrivateKey,
	        fromPrecomputed,
	    };
	}
	return bip32$1;
}

var quantum = {};

var mldsa = {};

/**
 * Utilities for hex, bytearray and number handling.
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const randomBytes = randomBytes$1;
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
// copy bytes to new u8a (aligned). Because Buffer.slice is broken.
function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}
function validateOpts(opts) {
    // We try to catch u8a, since it was previously valid argument at this position
    if (typeof opts !== 'object' || opts === null || isBytes$1(opts))
        throw new Error('expected opts to be an object');
}
function validateVerOpts(opts) {
    validateOpts(opts);
    if (opts.context !== undefined)
        abytes$1(opts.context, undefined, 'opts.context');
}
function validateSigOpts(opts) {
    validateVerOpts(opts);
    if (opts.extraEntropy !== false && opts.extraEntropy !== undefined)
        abytes$1(opts.extraEntropy, undefined, 'opts.extraEntropy');
}
function splitCoder(label, ...lengths) {
    const getLength = (c) => (typeof c === 'number' ? c : c.bytesLen);
    const bytesLen = lengths.reduce((sum, a) => sum + getLength(a), 0);
    return {
        bytesLen,
        encode: (bufs) => {
            const res = new Uint8Array(bytesLen);
            for (let i = 0, pos = 0; i < lengths.length; i++) {
                const c = lengths[i];
                const l = getLength(c);
                const b = typeof c === 'number' ? bufs[i] : c.encode(bufs[i]);
                abytes$1(b, l, label);
                res.set(b, pos);
                if (typeof c !== 'number')
                    b.fill(0); // clean
                pos += l;
            }
            return res;
        },
        decode: (buf) => {
            abytes$1(buf, bytesLen, label);
            const res = [];
            for (const c of lengths) {
                const l = getLength(c);
                const b = buf.subarray(0, l);
                res.push(typeof c === 'number' ? b : c.decode(b));
                buf = buf.subarray(l);
            }
            return res;
        },
    };
}
// nano-packed.array (fixed size)
function vecCoder(c, vecLen) {
    const bytesLen = vecLen * c.bytesLen;
    return {
        bytesLen,
        encode: (u) => {
            if (u.length !== vecLen)
                throw new Error(`vecCoder.encode: wrong length=${u.length}. Expected: ${vecLen}`);
            const res = new Uint8Array(bytesLen);
            for (let i = 0, pos = 0; i < u.length; i++) {
                const b = c.encode(u[i]);
                res.set(b, pos);
                b.fill(0); // clean
                pos += b.length;
            }
            return res;
        },
        decode: (a) => {
            abytes$1(a, bytesLen);
            const r = [];
            for (let i = 0; i < a.length; i += c.bytesLen)
                r.push(c.decode(a.subarray(i, i + c.bytesLen)));
            return r;
        },
    };
}
// cleanBytes(Uint8Array.of(), [Uint16Array.of(), Uint32Array.of()])
function cleanBytes(...list) {
    for (const t of list) {
        if (Array.isArray(t))
            for (const b of t)
                b.fill(0);
        else
            t.fill(0);
    }
}
function getMask(bits) {
    return (1 << bits) - 1; // 4 -> 0b1111
}
const EMPTY = Uint8Array.of();
function getMessage(msg, ctx = EMPTY) {
    abytes$1(msg);
    abytes$1(ctx);
    if (ctx.length > 255)
        throw new Error('context should be less than 255 bytes');
    return concatBytes$1(new Uint8Array([0, ctx.length]), ctx, msg);
}
// 06 09 60 86 48 01 65 03 04 02
const oidNistP = /* @__PURE__ */ Uint8Array.from([6, 9, 0x60, 0x86, 0x48, 1, 0x65, 3, 4, 2]);
function checkHash(hash, requiredStrength = 0) {
    if (!hash.oid || !equalBytes(hash.oid.subarray(0, 10), oidNistP))
        throw new Error('hash.oid is invalid: expected NIST hash');
    const collisionResistance = (hash.outputLen * 8) / 2;
    if (requiredStrength > collisionResistance) {
        throw new Error('Pre-hash security strength too low: ' +
            collisionResistance +
            ', required: ' +
            requiredStrength);
    }
}
function getMessagePrehash(hash, msg, ctx = EMPTY) {
    abytes$1(msg);
    abytes$1(ctx);
    if (ctx.length > 255)
        throw new Error('context should be less than 255 bytes');
    const hashed = hash(msg);
    return concatBytes$1(new Uint8Array([1, ctx.length]), ctx, hash.oid, hashed);
}

const utils = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    EMPTY,
    abytes: abytes$1,
    checkHash,
    cleanBytes,
    concatBytes: concatBytes$1,
    copyBytes,
    equalBytes,
    getMask,
    getMessage,
    getMessagePrehash,
    randomBytes,
    splitCoder,
    validateOpts,
    validateSigOpts,
    validateVerOpts,
    vecCoder
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0$2 = /*@__PURE__*/getAugmentedNamespace(utils);

var config = {};

/**
 * Internal methods for lattice-based ML-KEM and ML-DSA.
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
const genCrystals = (opts) => {
    // isKyber: true means Kyber, false means Dilithium
    const { newPoly, N, Q, F, ROOT_OF_UNITY, brvBits} = opts;
    const mod = (a, modulo = Q) => {
        const result = a % modulo | 0;
        return (result >= 0 ? result | 0 : (modulo + result) | 0) | 0;
    };
    // -(Q-1)/2 < a <= (Q-1)/2
    const smod = (a, modulo = Q) => {
        const r = mod(a, modulo) | 0;
        return (r > modulo >> 1 ? (r - modulo) | 0 : r) | 0;
    };
    // Generate zettas (different from roots of unity, negacyclic uses phi, where acyclic uses omega)
    function getZettas() {
        const out = newPoly(N);
        for (let i = 0; i < N; i++) {
            const b = reverseBits(i, brvBits);
            const p = BigInt(ROOT_OF_UNITY) ** BigInt(b) % BigInt(Q);
            out[i] = Number(p) | 0;
        }
        return out;
    }
    const nttZetas = getZettas();
    // Number-Theoretic Transform
    // Explained: https://electricdusk.com/ntt.html
    // Kyber has slightly different params, since there is no 512th primitive root of unity mod q,
    // only 256th primitive root of unity mod. Which also complicates MultiplyNTT.
    const field = {
        add: (a, b) => mod((a | 0) + (b | 0)) | 0,
        sub: (a, b) => mod((a | 0) - (b | 0)) | 0,
        mul: (a, b) => mod((a | 0) * (b | 0)) | 0,
        inv: (_a) => {
            throw new Error('not implemented');
        },
    };
    const nttOpts = {
        N,
        roots: nttZetas,
        invertButterflies: true,
        skipStages: 0,
        brp: false,
    };
    const dif = FFTCore(field, { dit: false, ...nttOpts });
    const dit = FFTCore(field, { dit: true, ...nttOpts });
    const NTT = {
        encode: (r) => {
            return dif(r);
        },
        decode: (r) => {
            dit(r);
            // kyber uses 128 here, because brv && stuff
            for (let i = 0; i < r.length; i++)
                r[i] = mod(F * r[i]);
            return r;
        },
    };
    // Encode polynominal as bits
    const bitsCoder = (d, c) => {
        const mask = getMask(d);
        const bytesLen = d * (N / 8);
        return {
            bytesLen,
            encode: (poly) => {
                const r = new Uint8Array(bytesLen);
                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < poly.length; i++) {
                    buf |= (c.encode(poly[i]) & mask) << bufLen;
                    bufLen += d;
                    for (; bufLen >= 8; bufLen -= 8, buf >>= 8)
                        r[pos++] = buf & getMask(bufLen);
                }
                return r;
            },
            decode: (bytes) => {
                const r = newPoly(N);
                for (let i = 0, buf = 0, bufLen = 0, pos = 0; i < bytes.length; i++) {
                    buf |= bytes[i] << bufLen;
                    bufLen += 8;
                    for (; bufLen >= d; bufLen -= d, buf >>= d)
                        r[pos++] = c.decode(buf & mask);
                }
                return r;
            },
        };
    };
    return { mod, smod, nttZetas, NTT, bitsCoder };
};
const createXofShake = (shake) => (seed, blockLen) => {
    if (!blockLen)
        blockLen = shake.blockLen;
    // Optimizations that won't mater:
    // - cached seed update (two .update(), on start and on the end)
    // - another cache which cloned into working copy
    // Faster than multiple updates, since seed less than blockLen
    const _seed = new Uint8Array(seed.length + 2);
    _seed.set(seed);
    const seedLen = seed.length;
    const buf = new Uint8Array(blockLen); // == shake128.blockLen
    let h = shake.create({});
    let calls = 0;
    let xofs = 0;
    return {
        stats: () => ({ calls, xofs }),
        get: (x, y) => {
            _seed[seedLen + 0] = x;
            _seed[seedLen + 1] = y;
            h.destroy();
            h = shake.create({}).update(_seed);
            calls++;
            return () => {
                xofs++;
                return h.xofInto(buf);
            };
        },
        clean: () => {
            h.destroy();
            cleanBytes(buf, _seed);
        },
    };
};
const XOF128 = /* @__PURE__ */ createXofShake(shake128);
const XOF256 = /* @__PURE__ */ createXofShake(shake256);

/**
 * ML-DSA: Module Lattice-based Digital Signature Algorithm from
 * [FIPS-204](https://csrc.nist.gov/pubs/fips/204/ipd). A.k.a. CRYSTALS-Dilithium.
 *
 * Has similar internals to ML-KEM, but their keys and params are different.
 * Check out [official site](https://www.pq-crystals.org/dilithium/index.shtml),
 * [repo](https://github.com/pq-crystals/dilithium).
 * @module
 */
/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */
function validateInternalOpts(opts) {
    validateOpts(opts);
    if (opts.externalMu !== undefined)
        abool(opts.externalMu, 'opts.externalMu');
}
// Constants
const N = 256;
// 2**23 âˆ’ 2**13 + 1, 23 bits: multiply will be 46. We have enough precision in JS to avoid bigints
const Q = 8380417;
const ROOT_OF_UNITY = 1753;
// f = 256**âˆ’1 mod q, pow(256, -1, q) = 8347681 (python3)
const F = 8347681;
const D = 13;
// Dilithium is kinda parametrized over GAMMA2, but everything will break with any other value.
const GAMMA2_1 = Math.floor((Q - 1) / 88) | 0;
const GAMMA2_2 = Math.floor((Q - 1) / 32) | 0;
/** Internal params for different versions of ML-DSA  */
// prettier-ignore
const PARAMS = {
    2: { K: 4, L: 4, D, GAMMA1: 2 ** 17, GAMMA2: GAMMA2_1, TAU: 39, ETA: 2, OMEGA: 80 },
    3: { K: 6, L: 5, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 49, ETA: 4, OMEGA: 55 },
    5: { K: 8, L: 7, D, GAMMA1: 2 ** 19, GAMMA2: GAMMA2_2, TAU: 60, ETA: 2, OMEGA: 75 },
};
const newPoly = (n) => new Int32Array(n);
const { mod, smod, NTT, bitsCoder } = genCrystals({
    N,
    Q,
    F,
    ROOT_OF_UNITY,
    newPoly,
    brvBits: 8,
});
const id = (n) => n;
const polyCoder = (d, compress = id, verify = id) => bitsCoder(d, {
    encode: (i) => compress(verify(i)),
    decode: (i) => verify(compress(i)),
});
const polyAdd = (a, b) => {
    for (let i = 0; i < a.length; i++)
        a[i] = mod(a[i] + b[i]);
    return a;
};
const polySub = (a, b) => {
    for (let i = 0; i < a.length; i++)
        a[i] = mod(a[i] - b[i]);
    return a;
};
const polyShiftl = (p) => {
    for (let i = 0; i < N; i++)
        p[i] <<= D;
    return p;
};
const polyChknorm = (p, B) => {
    // Not very sure about this, but FIPS204 doesn't provide any function for that :(
    for (let i = 0; i < N; i++)
        if (Math.abs(smod(p[i])) >= B)
            return true;
    return false;
};
const MultiplyNTTs = (a, b) => {
    // NOTE: we don't use montgomery reduction in code, since it requires 64 bit ints,
    // which is not available in JS. mod(a[i] * b[i]) is ok, since Q is 23 bit,
    // which means a[i] * b[i] is 46 bit, which is safe to use in JS. (number is 53 bits).
    // Barrett reduction is slower than mod :(
    const c = newPoly(N);
    for (let i = 0; i < a.length; i++)
        c[i] = mod(a[i] * b[i]);
    return c;
};
// Return poly in NTT representation
function RejNTTPoly(xof) {
    // Samples a polynomial âˆˆ Tq.
    const r = newPoly(N);
    // NOTE: we can represent 3xu24 as 4xu32, but it doesn't improve perf :(
    for (let j = 0; j < N;) {
        const b = xof();
        if (b.length % 3)
            throw new Error('RejNTTPoly: unaligned block');
        for (let i = 0; j < N && i <= b.length - 3; i += 3) {
            const t = (b[i + 0] | (b[i + 1] << 8) | (b[i + 2] << 16)) & 0x7fffff; // 3 bytes
            if (t < Q)
                r[j++] = t;
        }
    }
    return r;
}
function getDilithium(opts) {
    const { K, L, GAMMA1, GAMMA2, TAU, ETA, OMEGA } = opts;
    const { CRH_BYTES, TR_BYTES, C_TILDE_BYTES, XOF128, XOF256, securityLevel } = opts;
    if (![2, 4].includes(ETA))
        throw new Error('Wrong ETA');
    if (![1 << 17, 1 << 19].includes(GAMMA1))
        throw new Error('Wrong GAMMA1');
    if (![GAMMA2_1, GAMMA2_2].includes(GAMMA2))
        throw new Error('Wrong GAMMA2');
    const BETA = TAU * ETA;
    const decompose = (r) => {
        // Decomposes r into (r1, r0) such that r â‰¡ r1(2Î³2) + r0 mod q.
        const rPlus = mod(r);
        const r0 = smod(rPlus, 2 * GAMMA2) | 0;
        if (rPlus - r0 === Q - 1)
            return { r1: 0 | 0, r0: (r0 - 1) | 0 };
        const r1 = Math.floor((rPlus - r0) / (2 * GAMMA2)) | 0;
        return { r1, r0 }; // r1 = HighBits, r0 = LowBits
    };
    const HighBits = (r) => decompose(r).r1;
    const LowBits = (r) => decompose(r).r0;
    const MakeHint = (z, r) => {
        // Compute hint bit indicating whether adding z to r alters the high bits of r.
        // From dilithium code
        const res0 = z <= GAMMA2 || z > Q - GAMMA2 || (z === Q - GAMMA2 && r === 0) ? 0 : 1;
        // from FIPS204:
        // // const r1 = HighBits(r);
        // // const v1 = HighBits(r + z);
        // // const res1 = +(r1 !== v1);
        // But they return different results! However, decompose is same.
        // So, either there is a bug in Dilithium ref implementation or in FIPS204.
        // For now, lets use dilithium one, so test vectors can be passed.
        // See
        // https://github.com/GiacomoPope/dilithium-py?tab=readme-ov-file#optimising-decomposition-and-making-hints
        return res0;
    };
    /*const MakeHint = (z: number, r: number) => {
      const r1 = HighBits(r);
      const v1 = HighBits(r + z);
      return +(r1 !== v1);
    };*/
    const UseHint = (h, r) => {
        // Returns the high bits of r adjusted according to hint h
        const m = Math.floor((Q - 1) / (2 * GAMMA2));
        const { r1, r0 } = decompose(r);
        // 3: if h = 1 and r0 > 0 return (r1 + 1) mod m
        // 4: if h = 1 and r0 â‰¤ 0 return (r1 âˆ’ 1) mod m
        if (h === 1)
            return r0 > 0 ? mod(r1 + 1, m) | 0 : mod(r1 - 1, m) | 0;
        return r1 | 0;
    };
    const Power2Round = (r) => {
        // Decomposes r into (r1, r0) such that r â‰¡ r1*(2**d) + r0 mod q.
        const rPlus = mod(r);
        const r0 = smod(rPlus, 2 ** D) | 0;
        return { r1: Math.floor((rPlus - r0) / 2 ** D) | 0, r0 };
    };
    const hintCoder = {
        bytesLen: OMEGA + K,
        encode: (h) => {
            if (h === false)
                throw new Error('hint.encode: hint is false'); // should never happen
            const res = new Uint8Array(OMEGA + K);
            for (let i = 0, k = 0; i < K; i++) {
                for (let j = 0; j < N; j++)
                    if (h[i][j] !== 0)
                        res[k++] = j;
                res[OMEGA + i] = k;
            }
            return res;
        },
        decode: (buf) => {
            const h = [];
            let k = 0;
            for (let i = 0; i < K; i++) {
                const hi = newPoly(N);
                if (buf[OMEGA + i] < k || buf[OMEGA + i] > OMEGA)
                    return false;
                for (let j = k; j < buf[OMEGA + i]; j++) {
                    if (j > k && buf[j] <= buf[j - 1])
                        return false;
                    hi[buf[j]] = 1;
                }
                k = buf[OMEGA + i];
                h.push(hi);
            }
            for (let j = k; j < OMEGA; j++)
                if (buf[j] !== 0)
                    return false;
            return h;
        },
    };
    const ETACoder = polyCoder(ETA === 2 ? 3 : 4, (i) => ETA - i, (i) => {
        if (!(-ETA <= i && i <= ETA))
            throw new Error(`malformed key s1/s3 ${i} outside of ETA range [${-ETA}, ${ETA}]`);
        return i;
    });
    const T0Coder = polyCoder(13, (i) => (1 << (D - 1)) - i);
    const T1Coder = polyCoder(10);
    // Requires smod. Need to fix!
    const ZCoder = polyCoder(GAMMA1 === 1 << 17 ? 18 : 20, (i) => smod(GAMMA1 - i));
    const W1Coder = polyCoder(GAMMA2 === GAMMA2_1 ? 6 : 4);
    const W1Vec = vecCoder(W1Coder, K);
    // Main structures
    const publicCoder = splitCoder('publicKey', 32, vecCoder(T1Coder, K));
    const secretCoder = splitCoder('secretKey', 32, 32, TR_BYTES, vecCoder(ETACoder, L), vecCoder(ETACoder, K), vecCoder(T0Coder, K));
    const sigCoder = splitCoder('signature', C_TILDE_BYTES, vecCoder(ZCoder, L), hintCoder);
    const CoefFromHalfByte = ETA === 2
        ? (n) => (n < 15 ? 2 - (n % 5) : false)
        : (n) => (n < 9 ? 4 - n : false);
    // Return poly in NTT representation
    function RejBoundedPoly(xof) {
        // Samples an element a âˆˆ Rq with coeffcients in [âˆ’Î·, Î·] computed via rejection sampling from Ï.
        const r = newPoly(N);
        for (let j = 0; j < N;) {
            const b = xof();
            for (let i = 0; j < N && i < b.length; i += 1) {
                // half byte. Should be superfast with vector instructions. But very slow with js :(
                const d1 = CoefFromHalfByte(b[i] & 0x0f);
                const d2 = CoefFromHalfByte((b[i] >> 4) & 0x0f);
                if (d1 !== false)
                    r[j++] = d1;
                if (j < N && d2 !== false)
                    r[j++] = d2;
            }
        }
        return r;
    }
    const SampleInBall = (seed) => {
        // Samples a polynomial c âˆˆ Rq with coeffcients from {âˆ’1, 0, 1} and Hamming weight Ï„
        const pre = newPoly(N);
        const s = shake256.create({}).update(seed);
        const buf = new Uint8Array(shake256.blockLen);
        s.xofInto(buf);
        const masks = buf.slice(0, 8);
        for (let i = N - TAU, pos = 8, maskPos = 0, maskBit = 0; i < N; i++) {
            let b = i + 1;
            for (; b > i;) {
                b = buf[pos++];
                if (pos < shake256.blockLen)
                    continue;
                s.xofInto(buf);
                pos = 0;
            }
            pre[i] = pre[b];
            pre[b] = 1 - (((masks[maskPos] >> maskBit++) & 1) << 1);
            if (maskBit >= 8) {
                maskPos++;
                maskBit = 0;
            }
        }
        return pre;
    };
    const polyPowerRound = (p) => {
        const res0 = newPoly(N);
        const res1 = newPoly(N);
        for (let i = 0; i < p.length; i++) {
            const { r0, r1 } = Power2Round(p[i]);
            res0[i] = r0;
            res1[i] = r1;
        }
        return { r0: res0, r1: res1 };
    };
    const polyUseHint = (u, h) => {
        for (let i = 0; i < N; i++)
            u[i] = UseHint(h[i], u[i]);
        return u;
    };
    const polyMakeHint = (a, b) => {
        const v = newPoly(N);
        let cnt = 0;
        for (let i = 0; i < N; i++) {
            const h = MakeHint(a[i], b[i]);
            v[i] = h;
            cnt += h;
        }
        return { v, cnt };
    };
    const signRandBytes = 32;
    const seedCoder = splitCoder('seed', 32, 64, 32);
    // API & argument positions are exactly as in FIPS204.
    const internal = {
        info: { type: 'internal-ml-dsa' },
        lengths: {
            secretKey: secretCoder.bytesLen,
            publicKey: publicCoder.bytesLen,
            seed: 32,
            signature: sigCoder.bytesLen,
            signRand: signRandBytes,
        },
        keygen: (seed) => {
            // H(ðœ‰||IntegerToBytes(ð‘˜, 1)||IntegerToBytes(â„“, 1), 128) 2: â–· expand seed
            const seedDst = new Uint8Array(32 + 2);
            const randSeed = seed === undefined;
            if (randSeed)
                seed = randomBytes(32);
            abytes$1(seed, 32, 'seed');
            seedDst.set(seed);
            if (randSeed)
                cleanBytes(seed);
            seedDst[32] = K;
            seedDst[33] = L;
            const [rho, rhoPrime, K_] = seedCoder.decode(shake256(seedDst, { dkLen: seedCoder.bytesLen }));
            const xofPrime = XOF256(rhoPrime);
            const s1 = [];
            for (let i = 0; i < L; i++)
                s1.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));
            const s2 = [];
            for (let i = L; i < L + K; i++)
                s2.push(RejBoundedPoly(xofPrime.get(i & 0xff, (i >> 8) & 0xff)));
            const s1Hat = s1.map((i) => NTT.encode(i.slice()));
            const t0 = [];
            const t1 = [];
            const xof = XOF128(rho);
            const t = newPoly(N);
            for (let i = 0; i < K; i++) {
                // t â† NTTâˆ’1(A*NTT(s1)) + s2
                cleanBytes(t); // don't-reallocate
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // super slow!
                    polyAdd(t, MultiplyNTTs(aij, s1Hat[j]));
                }
                NTT.decode(t);
                const { r0, r1 } = polyPowerRound(polyAdd(t, s2[i])); // (t1, t0) â† Power2Round(t, d)
                t0.push(r0);
                t1.push(r1);
            }
            const publicKey = publicCoder.encode([rho, t1]); // pk â† pkEncode(Ï, t1)
            const tr = shake256(publicKey, { dkLen: TR_BYTES }); // tr â† H(BytesToBits(pk), 512)
            const secretKey = secretCoder.encode([rho, K_, tr, s1, s2, t0]); // sk â† skEncode(Ï, K,tr, s1, s2, t0)
            xof.clean();
            xofPrime.clean();
            // STATS
            // Kyber512:  { calls: 4, xofs: 12 }, Kyber768: { calls: 9, xofs: 27 }, Kyber1024: { calls: 16, xofs: 48 }
            // DSA44:    { calls: 24, xofs: 24 }, DSA65:    { calls: 41, xofs: 41 }, DSA87:    { calls: 71, xofs: 71 }
            cleanBytes(rho, rhoPrime, K_, s1, s2, s1Hat, t, t0, t1, tr, seedDst);
            return { publicKey, secretKey };
        },
        getPublicKey: (secretKey) => {
            const [rho, _K, _tr, s1, s2, _t0] = secretCoder.decode(secretKey); // (Ï, K,tr, s1, s2, t0) â† skDecode(sk)
            const xof = XOF128(rho);
            const s1Hat = s1.map((p) => NTT.encode(p.slice()));
            const t1 = [];
            const tmp = newPoly(N);
            for (let i = 0; i < K; i++) {
                tmp.fill(0);
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // A_ij in NTT
                    polyAdd(tmp, MultiplyNTTs(aij, s1Hat[j])); // += A_ij * s1_j
                }
                NTT.decode(tmp); // NTTâ»Â¹
                polyAdd(tmp, s2[i]); // t_i = AÂ·s1 + s2
                const { r1 } = polyPowerRound(tmp); // r1 = t1, r0 â‰ˆ t0
                t1.push(r1);
            }
            xof.clean();
            cleanBytes(tmp, s1Hat, _t0, s1, s2);
            return publicCoder.encode([rho, t1]);
        },
        // NOTE: random is optional.
        sign: (msg, secretKey, opts = {}) => {
            validateSigOpts(opts);
            validateInternalOpts(opts);
            let { extraEntropy: random, externalMu = false } = opts;
            // This part can be pre-cached per secretKey, but there is only minor performance improvement,
            // since we re-use a lot of variables to computation.
            const [rho, _K, tr, s1, s2, t0] = secretCoder.decode(secretKey); // (Ï, K,tr, s1, s2, t0) â† skDecode(sk)
            // Cache matrix to avoid re-compute later
            const A = []; // A â† ExpandA(Ï)
            const xof = XOF128(rho);
            for (let i = 0; i < K; i++) {
                const pv = [];
                for (let j = 0; j < L; j++)
                    pv.push(RejNTTPoly(xof.get(j, i)));
                A.push(pv);
            }
            xof.clean();
            for (let i = 0; i < L; i++)
                NTT.encode(s1[i]); // sË†1 â† NTT(s1)
            for (let i = 0; i < K; i++) {
                NTT.encode(s2[i]); // sË†2 â† NTT(s2)
                NTT.encode(t0[i]); // tË†0 â† NTT(t0)
            }
            // This part is per msg
            const mu = externalMu
                ? msg
                : shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 6: Âµ â† H(tr||M, 512) â–· Compute message representative Âµ
            // Compute private random seed
            const rnd = random === false
                ? new Uint8Array(32)
                : random === undefined
                    ? randomBytes(signRandBytes)
                    : random;
            abytes$1(rnd, 32, 'extraEntropy');
            const rhoprime = shake256
                .create({ dkLen: CRH_BYTES })
                .update(_K)
                .update(rnd)
                .update(mu)
                .digest(); // Ïâ€²â† H(K||rnd||Âµ, 512)
            abytes$1(rhoprime, CRH_BYTES);
            const x256 = XOF256(rhoprime, ZCoder.bytesLen);
            //  Rejection sampling loop
            main_loop: for (let kappa = 0;;) {
                const y = [];
                // y â† ExpandMask(Ï , Îº)
                for (let i = 0; i < L; i++, kappa++)
                    y.push(ZCoder.decode(x256.get(kappa & 0xff, kappa >> 8)()));
                const z = y.map((i) => NTT.encode(i.slice()));
                const w = [];
                for (let i = 0; i < K; i++) {
                    // w â† NTTâˆ’1(A â—¦ NTT(y))
                    const wi = newPoly(N);
                    for (let j = 0; j < L; j++)
                        polyAdd(wi, MultiplyNTTs(A[i][j], z[j]));
                    NTT.decode(wi);
                    w.push(wi);
                }
                const w1 = w.map((j) => j.map(HighBits)); // w1 â† HighBits(w)
                // Commitment hash: cËœ âˆˆ{0, 1 2Î» } â† H(Âµ||w1Encode(w1), 2Î»)
                const cTilde = shake256
                    .create({ dkLen: C_TILDE_BYTES })
                    .update(mu)
                    .update(W1Vec.encode(w1))
                    .digest();
                // Veriferâ€™s challenge
                const cHat = NTT.encode(SampleInBall(cTilde)); // c â† SampleInBall(cËœ1); cË† â† NTT(c)
                // âŸ¨âŸ¨cs1âŸ©âŸ© â† NTTâˆ’1(cË†â—¦ sË†1)
                const cs1 = s1.map((i) => MultiplyNTTs(i, cHat));
                for (let i = 0; i < L; i++) {
                    polyAdd(NTT.decode(cs1[i]), y[i]); // z â† y + âŸ¨âŸ¨cs1âŸ©âŸ©
                    if (polyChknorm(cs1[i], GAMMA1 - BETA))
                        continue main_loop; // ||z||âˆž â‰¥ Î³1 âˆ’ Î²
                }
                // cs1 is now z (â–· Signerâ€™s response)
                let cnt = 0;
                const h = [];
                for (let i = 0; i < K; i++) {
                    const cs2 = NTT.decode(MultiplyNTTs(s2[i], cHat)); // âŸ¨âŸ¨cs2âŸ©âŸ© â† NTTâˆ’1(cË†â—¦ sË†2)
                    const r0 = polySub(w[i], cs2).map(LowBits); // r0 â† LowBits(w âˆ’ âŸ¨âŸ¨cs2âŸ©âŸ©)
                    if (polyChknorm(r0, GAMMA2 - BETA))
                        continue main_loop; // ||r0||âˆž â‰¥ Î³2 âˆ’ Î²
                    const ct0 = NTT.decode(MultiplyNTTs(t0[i], cHat)); // âŸ¨âŸ¨ct0âŸ©âŸ© â† NTTâˆ’1(cË†â—¦ tË†0)
                    if (polyChknorm(ct0, GAMMA2))
                        continue main_loop;
                    polyAdd(r0, ct0);
                    // â–· Signerâ€™s hint
                    const hint = polyMakeHint(r0, w1[i]); // h â† MakeHint(âˆ’âŸ¨âŸ¨ct0âŸ©âŸ©, wâˆ’ âŸ¨âŸ¨cs2âŸ©âŸ© + âŸ¨âŸ¨ct0âŸ©âŸ©)
                    h.push(hint.v);
                    cnt += hint.cnt;
                }
                if (cnt > OMEGA)
                    continue; // the number of 1â€™s in h is greater than Ï‰
                x256.clean();
                const res = sigCoder.encode([cTilde, cs1, h]); // Ïƒ â† sigEncode(cËœ, z modÂ±q, h)
                // rho, _K, tr is subarray of secretKey, cannot clean.
                cleanBytes(cTilde, cs1, h, cHat, w1, w, z, y, rhoprime, mu, s1, s2, t0, ...A);
                return res;
            }
            // @ts-ignore
            throw new Error('Unreachable code path reached, report this error');
        },
        verify: (sig, msg, publicKey, opts = {}) => {
            validateInternalOpts(opts);
            const { externalMu = false } = opts;
            // ML-DSA.Verify(pk, M, Ïƒ): Verifes a signature Ïƒ for a message M.
            const [rho, t1] = publicCoder.decode(publicKey); // (Ï, t1) â† pkDecode(pk)
            const tr = shake256(publicKey, { dkLen: TR_BYTES }); // 6: tr â† H(BytesToBits(pk), 512)
            if (sig.length !== sigCoder.bytesLen)
                return false; // return false instead of exception
            const [cTilde, z, h] = sigCoder.decode(sig); // (cËœ, z, h) â† sigDecode(Ïƒ), â–· Signerâ€™s commitment hash c Ëœ, response z and hint
            if (h === false)
                return false; // if h = âŠ¥ then return false
            for (let i = 0; i < L; i++)
                if (polyChknorm(z[i], GAMMA1 - BETA))
                    return false;
            const mu = externalMu
                ? msg
                : shake256.create({ dkLen: CRH_BYTES }).update(tr).update(msg).digest(); // 7: Âµ â† H(tr||M, 512)
            // Compute veriferâ€™s challenge from cËœ
            const c = NTT.encode(SampleInBall(cTilde)); // c â† SampleInBall(cËœ1)
            const zNtt = z.map((i) => i.slice()); // zNtt = NTT(z)
            for (let i = 0; i < L; i++)
                NTT.encode(zNtt[i]);
            const wTick1 = [];
            const xof = XOF128(rho);
            for (let i = 0; i < K; i++) {
                const ct12d = MultiplyNTTs(NTT.encode(polyShiftl(t1[i])), c); //c * t1 * (2**d)
                const Az = newPoly(N); // // A * z
                for (let j = 0; j < L; j++) {
                    const aij = RejNTTPoly(xof.get(j, i)); // A[i][j] inplace
                    polyAdd(Az, MultiplyNTTs(aij, zNtt[j]));
                }
                // wApprox = A*z - c*t1 * (2**d)
                const wApprox = NTT.decode(polySub(Az, ct12d));
                // Reconstruction of signerâ€™s commitment
                wTick1.push(polyUseHint(wApprox, h[i])); // w â€² â† UseHint(h, w'approx )
            }
            xof.clean();
            // cËœâ€²â† H (Âµ||w1Encode(wâ€²1), 2Î»),  Hash it; this should match cËœ
            const c2 = shake256
                .create({ dkLen: C_TILDE_BYTES })
                .update(mu)
                .update(W1Vec.encode(wTick1))
                .digest();
            // Additional checks in FIPS-204:
            // [[ ||z||âˆž < Î³1 âˆ’ Î² ]] and [[c Ëœ = cËœâ€²]] and [[number of 1â€™s in h is â‰¤ Ï‰]]
            for (const t of h) {
                const sum = t.reduce((acc, i) => acc + i, 0);
                if (!(sum <= OMEGA))
                    return false;
            }
            for (const t of z)
                if (polyChknorm(t, GAMMA1 - BETA))
                    return false;
            return equalBytes(cTilde, c2);
        },
    };
    return {
        info: { type: 'ml-dsa' },
        internal,
        securityLevel: securityLevel,
        keygen: internal.keygen,
        lengths: internal.lengths,
        getPublicKey: internal.getPublicKey,
        sign: (msg, secretKey, opts = {}) => {
            validateSigOpts(opts);
            const M = getMessage(msg, opts.context);
            const res = internal.sign(M, secretKey, opts);
            cleanBytes(M);
            return res;
        },
        verify: (sig, msg, publicKey, opts = {}) => {
            validateVerOpts(opts);
            return internal.verify(sig, getMessage(msg, opts.context), publicKey);
        },
        prehash: (hash) => {
            checkHash(hash, securityLevel);
            return {
                info: { type: 'hashml-dsa' },
                securityLevel: securityLevel,
                lengths: internal.lengths,
                keygen: internal.keygen,
                getPublicKey: internal.getPublicKey,
                sign: (msg, secretKey, opts = {}) => {
                    validateSigOpts(opts);
                    const M = getMessagePrehash(hash, msg, opts.context);
                    const res = internal.sign(M, secretKey, opts);
                    cleanBytes(M);
                    return res;
                },
                verify: (sig, msg, publicKey, opts = {}) => {
                    validateVerOpts(opts);
                    return internal.verify(sig, getMessagePrehash(hash, msg, opts.context), publicKey);
                },
            };
        },
    };
}
/** ML-DSA-44 for 128-bit security level. Not recommended after 2030, as per ASD. */
const ml_dsa44 = /* @__PURE__ */ getDilithium({
    ...PARAMS[2],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 32,
    XOF128,
    XOF256,
    securityLevel: 128,
});
/** ML-DSA-65 for 192-bit security level. Not recommended after 2030, as per ASD. */
const ml_dsa65 = /* @__PURE__ */ getDilithium({
    ...PARAMS[3],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 48,
    XOF128,
    XOF256,
    securityLevel: 192,
});
/** ML-DSA-87 for 256-bit security level. OK after 2030, as per ASD. */
const ml_dsa87 = /* @__PURE__ */ getDilithium({
    ...PARAMS[5],
    CRH_BYTES: 64,
    TR_BYTES: 64,
    C_TILDE_BYTES: 64,
    XOF128,
    XOF256,
    securityLevel: 256,
});

const mlDsa = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    PARAMS,
    ml_dsa44,
    ml_dsa65,
    ml_dsa87
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0$1 = /*@__PURE__*/getAugmentedNamespace(mlDsa);

var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return config;
	hasRequiredConfig = 1;
	Object.defineProperty(config, "__esModule", { value: true });
	config.DEFAULT_SECURITY_LEVEL = config.MLDSASecurityLevel = void 0;
	config.getMLDSAConfig = getMLDSAConfig;
	config.findNetworkByVersion = findNetworkByVersion;
	const ml_dsa_js_1 = require$$0$1;
	const networks_js_1 = requireNetworks();
	/**
	 * ML-DSA security levels
	 *
	 * These correspond to NIST security levels:
	 * - LEVEL2: 128-bit classical security (ML-DSA-44)
	 * - LEVEL3: 192-bit classical security (ML-DSA-65)
	 * - LEVEL5: 256-bit classical security (ML-DSA-87)
	 */
	var MLDSASecurityLevel;
	(function (MLDSASecurityLevel) {
	    /** Level 2 security - 128-bit classical security (smallest keys) */
	    MLDSASecurityLevel[MLDSASecurityLevel["LEVEL2"] = 44] = "LEVEL2";
	    /** Level 3 security - 192-bit classical security (balanced) */
	    MLDSASecurityLevel[MLDSASecurityLevel["LEVEL3"] = 65] = "LEVEL3";
	    /** Level 5 security - 256-bit classical security (highest security) */
	    MLDSASecurityLevel[MLDSASecurityLevel["LEVEL5"] = 87] = "LEVEL5";
	})(MLDSASecurityLevel || (config.MLDSASecurityLevel = MLDSASecurityLevel = {}));
	/**
	 * Base configurations for each security level (network-agnostic)
	 */
	const BASE_CONFIGS = {
	    [MLDSASecurityLevel.LEVEL2]: {
	        level: MLDSASecurityLevel.LEVEL2,
	        privateKeySize: 2560,
	        publicKeySize: 1312,
	        signatureSize: 2420,
	        algorithm: ml_dsa_js_1.ml_dsa44,
	    },
	    [MLDSASecurityLevel.LEVEL3]: {
	        level: MLDSASecurityLevel.LEVEL3,
	        privateKeySize: 4032,
	        publicKeySize: 1952,
	        signatureSize: 3309,
	        algorithm: ml_dsa_js_1.ml_dsa65,
	    },
	    [MLDSASecurityLevel.LEVEL5]: {
	        level: MLDSASecurityLevel.LEVEL5,
	        privateKeySize: 4896,
	        publicKeySize: 2592,
	        signatureSize: 4627,
	        algorithm: ml_dsa_js_1.ml_dsa87,
	    },
	};
	/**
	 * Default security level (Level 2 - 128-bit classical security)
	 */
	config.DEFAULT_SECURITY_LEVEL = MLDSASecurityLevel.LEVEL2;
	/**
	 * Get ML-DSA configuration for a specific security level and network
	 * @param level - Security level (44, 65, or 87)
	 * @param network - Network configuration
	 */
	function getMLDSAConfig(level, network) {
	    const baseConfig = BASE_CONFIGS[level];
	    if (!baseConfig) {
	        throw new TypeError(`Invalid ML-DSA security level: ${level}. Must be MLDSASecurityLevel.LEVEL2 (44), LEVEL3 (65), or LEVEL5 (87)`);
	    }
	    return {
	        ...baseConfig,
	        network,
	    };
	}
	/**
	 * Find matching network and determine if private/public by version bytes
	 * Used when importing from base58
	 */
	function findNetworkByVersion(version) {
	    // Try common networks first
	    const commonNetworks = [networks_js_1.BITCOIN, networks_js_1.TESTNET, networks_js_1.REGTEST];
	    for (const network of commonNetworks) {
	        if (version === network.bip32.private) {
	            return { network, isPrivate: true };
	        }
	        if (version === network.bip32.public) {
	            return { network, isPrivate: false };
	        }
	    }
	    // For unknown networks, we can't determine which network it is
	    // The caller will need to have the network object or fail
	    return null;
	}
	return config;
}

var hasRequiredMldsa;

function requireMldsa () {
	if (hasRequiredMldsa) return mldsa;
	hasRequiredMldsa = 1;
	var __createBinding = (mldsa && mldsa.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (mldsa && mldsa.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (mldsa && mldsa.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(mldsa, "__esModule", { value: true });
	mldsa.QuantumBIP32Factory = void 0;
	const utils_js_1 = require$$0$2;
	const crypto = __importStar(requireCrypto());
	const tools = __importStar(require$$2$1);
	const types_js_1 = requireTypes$1();
	const bs58check = __importStar(require$$4$2);
	const config_js_1 = requireConfig();
	const networks_js_1 = requireNetworks();
	const CHAIN_CODE_SIZE = 32;
	const HIGHEST_BIT = 0x80000000;
	const BITCOIN_SEED = tools.fromUtf8('Bitcoin seed');
	/**
	 * Quantum signer implementation using ML-DSA
	 */
	class QuantumBip32Signer {
	    _privateKey;
	    _publicKey;
	    config;
	    constructor(_privateKey, _publicKey, config) {
	        this._privateKey = _privateKey;
	        this._publicKey = _publicKey;
	        this.config = config;
	    }
	    get publicKey() {
	        if (!this._publicKey) {
	            throw new Error('Public key not available');
	        }
	        return this._publicKey;
	    }
	    get privateKey() {
	        return this._privateKey;
	    }
	    sign(hash) {
	        if (!this._privateKey) {
	            throw new Error('Missing private key');
	        }
	        // ML-DSA signature with extra entropy for enhanced security
	        const signature = this.config.algorithm.sign(hash, this._privateKey, {
	            extraEntropy: (0, utils_js_1.randomBytes)(32),
	        });
	        return signature;
	    }
	    verify(hash, signature) {
	        return this.config.algorithm.verify(signature, hash, this._publicKey);
	    }
	}
	/**
	 * Quantum BIP32 implementation using ML-DSA
	 * Uses BIP32 for hierarchical seed derivation, then ML-DSA for key generation
	 */
	class QuantumBIP32 extends QuantumBip32Signer {
	    chainCode;
	    _depth;
	    _index;
	    _parentFingerprint;
	    constructor(_privateKey, _publicKey, chainCode, config, _depth = 0, _index = 0, _parentFingerprint = 0x00000000) {
	        super(_privateKey, _publicKey, config);
	        this.chainCode = chainCode;
	        this._depth = _depth;
	        this._index = _index;
	        this._parentFingerprint = _parentFingerprint;
	    }
	    get depth() {
	        return this._depth;
	    }
	    get index() {
	        return this._index;
	    }
	    get parentFingerprint() {
	        return this._parentFingerprint;
	    }
	    #ID;
	    get identifier() {
	        if (this.#ID === undefined)
	            this.#ID = crypto.hash160(this.publicKey);
	        return this.#ID;
	    }
	    get fingerprint() {
	        return this.identifier.subarray(0, 4);
	    }
	    get securityLevel() {
	        return this.config.level;
	    }
	    get network() {
	        return this.config.network;
	    }
	    isNeutered() {
	        return this._privateKey === undefined;
	    }
	    neutered() {
	        return new QuantumBIP32(undefined, this.publicKey, this.chainCode, this.config, this.depth, this.index, this.parentFingerprint);
	    }
	    toBase58() {
	        const version = !this.isNeutered()
	            ? this.config.network.bip32.private
	            : this.config.network.bip32.public;
	        const isPrivate = !this.isNeutered();
	        const keySize = isPrivate
	            ? this.config.privateKeySize
	            : this.config.publicKeySize;
	        // Byte layout:
	        // 4 bytes: version
	        // 1 byte: depth
	        // 4 bytes: parent fingerprint
	        // 4 bytes: child index
	        // 32 bytes: chain code
	        // variable bytes: key data (depends on security level)
	        const bufferSize = 4 + 1 + 4 + 4 + 32 + keySize;
	        const buffer = new Uint8Array(bufferSize);
	        let offset = 0;
	        // Version
	        tools.writeUInt32(buffer, offset, version, 'BE');
	        offset += 4;
	        // Depth
	        tools.writeUInt8(buffer, offset, this.depth);
	        offset += 1;
	        // Parent fingerprint
	        tools.writeUInt32(buffer, offset, this.parentFingerprint, 'BE');
	        offset += 4;
	        // Child index
	        tools.writeUInt32(buffer, offset, this.index, 'BE');
	        offset += 4;
	        // Chain code
	        buffer.set(this.chainCode, offset);
	        offset += 32;
	        // Key data
	        if (isPrivate) {
	            buffer.set(this._privateKey, offset);
	        }
	        else {
	            buffer.set(this._publicKey, offset);
	        }
	        return bs58check.encode(buffer);
	    }
	    /**
	     * Derive a child key using BIP32 HMAC chain for seed derivation,
	     * then ML-DSA for key generation
	     */
	    derive(index) {
	        if (index !== (index >>> 0))
	            throw new TypeError('Expected UInt32, got ' + index);
	        // ML-DSA cannot derive child keys without the private key
	        // Unlike EC crypto, you cannot do public key only derivation
	        if (this.isNeutered()) {
	            throw new TypeError('Cannot derive child keys without private key');
	        }
	        const isHardened = index >= HIGHEST_BIT;
	        let data;
	        // Hardened child
	        if (isHardened) {
	            // For ML-DSA, we use a hash of the private key for derivation data
	            // since the private key can be large
	            const privateKeyHash = crypto.hash256(this._privateKey);
	            data = new Uint8Array(1 + 32 + 4);
	            data[0] = 0x00;
	            data.set(privateKeyHash, 1);
	            tools.writeUInt32(data, 33, index, 'BE');
	        }
	        else {
	            // Normal child - still needs private key for ML-DSA
	            // Use hash of private key (not public key like EC)
	            const privateKeyHash = crypto.hash256(this._privateKey);
	            data = new Uint8Array(32 + 4);
	            data.set(privateKeyHash, 0);
	            tools.writeUInt32(data, 32, index, 'BE');
	        }
	        // Derive 512-bit seed using HMAC-SHA512
	        const I = crypto.hmacSHA512(this.chainCode, data);
	        const IL = I.slice(0, 32); // 256 bits for key generation seed
	        const IR = I.slice(32); // 256 bits for new chain code
	        // Use IL as entropy for ML-DSA key generation
	        // Generate ML-DSA key pair from seed
	        const { secretKey: privateKey, publicKey } = this.config.algorithm.keygen(IL);
	        return new QuantumBIP32(privateKey, publicKey, IR, this.config, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, 'BE'));
	    }
	    deriveHardened(index) {
	        if (!Number.isInteger(index) ||
	            index < 0 ||
	            index > 0x7fffffff)
	            throw new TypeError('Expected UInt31, got ' + index);
	        return this.derive(index + HIGHEST_BIT);
	    }
	    derivePath(path) {
	        (0, types_js_1.validateBip32Path)(path);
	        let splitPath = path.split('/');
	        if (splitPath[0] === 'm') {
	            if (this.parentFingerprint) {
	                throw new TypeError('Expected master, got child');
	            }
	            splitPath = splitPath.slice(1);
	        }
	        return splitPath.reduce((prevHd, indexStr) => {
	            let index;
	            if (indexStr.slice(-1) === `'`) {
	                index = parseInt(indexStr.slice(0, -1), 10);
	                return prevHd.deriveHardened(index);
	            }
	            else {
	                index = parseInt(indexStr, 10);
	                return prevHd.derive(index);
	            }
	        }, this);
	    }
	}
	/**
	 * Create a quantum BIP32 master key from a seed
	 * Follows standard BIP32 pattern: fromSeed(seed, network?, securityLevel?)
	 */
	function fromSeed(seed, network, securityLevel) {
	    if (!(seed instanceof Uint8Array))
	        throw new TypeError('Expected Uint8Array');
	    if (seed.length < 16) {
	        throw new TypeError('Seed should be at least 128 bits');
	    }
	    if (seed.length > 64) {
	        throw new TypeError('Seed should be at most 512 bits');
	    }
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
	    // Use BIP32 standard HMAC for initial seed derivation
	    const I = crypto.hmacSHA512(BITCOIN_SEED, seed);
	    const IL = I.slice(0, 32);
	    const IR = I.slice(32);
	    // Generate ML-DSA master key pair
	    const { secretKey: privateKey, publicKey } = config.algorithm.keygen(IL);
	    return new QuantumBIP32(privateKey, publicKey, IR, // Chain code
	    config, 0, // depth
	    0, // index
	    0);
	}
	/**
	 * Import a quantum key from base58
	 * Network is detected from version bytes, security level from key size
	 */
	function fromBase58(inString) {
	    const buffer = bs58check.decode(inString);
	    // Read version to determine network
	    const version = tools.readUInt32(buffer, 0, 'BE');
	    // Find matching network by version
	    const match = (0, config_js_1.findNetworkByVersion)(version);
	    if (!match) {
	        throw new TypeError('Unknown network version');
	    }
	    const { network, isPrivate } = match;
	    // Determine security level from payload size
	    // Byte layout: 4 (version) + 1 (depth) + 4 (parent fp) + 4 (index) + 32 (chain code) + key data
	    const headerSize = 4 + 1 + 4 + 4 + 32;
	    const keyDataSize = buffer.length - headerSize;
	    // Map key sizes to security levels
	    let securityLevel;
	    if (isPrivate) {
	        // Private key sizes: 2560 (44), 4032 (65), 4896 (87)
	        if (keyDataSize === 2560) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL2;
	        }
	        else if (keyDataSize === 4032) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL3;
	        }
	        else if (keyDataSize === 4896) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL5;
	        }
	        else {
	            throw new TypeError(`Invalid private key size: ${keyDataSize}`);
	        }
	    }
	    else {
	        // Public key sizes: 1312 (44), 1952 (65), 2592 (87)
	        if (keyDataSize === 1312) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL2;
	        }
	        else if (keyDataSize === 1952) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL3;
	        }
	        else if (keyDataSize === 2592) {
	            securityLevel = config_js_1.MLDSASecurityLevel.LEVEL5;
	        }
	        else {
	            throw new TypeError(`Invalid public key size: ${keyDataSize}`);
	        }
	    }
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel, network);
	    const expectedSize = isPrivate
	        ? 4 + 1 + 4 + 4 + 32 + config.privateKeySize
	        : 4 + 1 + 4 + 4 + 32 + config.publicKeySize;
	    if (buffer.length !== expectedSize) {
	        throw new TypeError(`Invalid buffer length: expected ${expectedSize}, got ${buffer.length}`);
	    }
	    let offset = 4;
	    // Depth
	    const depth = buffer[offset];
	    offset += 1;
	    // Parent fingerprint
	    const parentFingerprint = tools.readUInt32(buffer, offset, 'BE');
	    if (depth === 0 && parentFingerprint !== 0x00000000) {
	        throw new TypeError('Invalid parent fingerprint');
	    }
	    offset += 4;
	    // Child index
	    const index = tools.readUInt32(buffer, offset, 'BE');
	    if (depth === 0 && index !== 0) {
	        throw new TypeError('Invalid index');
	    }
	    offset += 4;
	    // Chain code
	    const chainCode = buffer.slice(offset, offset + 32);
	    offset += 32;
	    // Key data
	    if (isPrivate) {
	        const privateKey = buffer.slice(offset, offset + config.privateKeySize);
	        const publicKey = config.algorithm.getPublicKey(privateKey);
	        return new QuantumBIP32(privateKey, publicKey, chainCode, config, depth, index, parentFingerprint);
	    }
	    else {
	        const publicKey = buffer.slice(offset, offset + config.publicKeySize);
	        return new QuantumBIP32(undefined, publicKey, chainCode, config, depth, index, parentFingerprint);
	    }
	}
	/**
	 * Create quantum key from public key and chain code
	 * Follows standard BIP32 pattern: fromPublicKey(publicKey, chainCode, network?, securityLevel?)
	 */
	function fromPublicKey(publicKey, chainCode, network, securityLevel) {
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
	    if (publicKey.length !== config.publicKeySize) {
	        throw new TypeError(`Invalid public key length for ML-DSA-${securityLevel}: expected ${config.publicKeySize}, got ${publicKey.length}`);
	    }
	    if (chainCode.length !== CHAIN_CODE_SIZE) {
	        throw new TypeError(`Invalid chain code length: expected ${CHAIN_CODE_SIZE}, got ${chainCode.length}`);
	    }
	    return new QuantumBIP32(undefined, publicKey, chainCode, config, 0, 0, 0);
	}
	/**
	 * Create quantum key from private key and chain code
	 * Follows standard BIP32 pattern: fromPrivateKey(privateKey, chainCode, network?, securityLevel?)
	 */
	function fromPrivateKey(privateKey, chainCode, network, securityLevel) {
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
	    if (privateKey.length !== config.privateKeySize) {
	        throw new TypeError(`Invalid private key length for ML-DSA-${securityLevel}: expected ${config.privateKeySize}, got ${privateKey.length}`);
	    }
	    if (chainCode.length !== CHAIN_CODE_SIZE) {
	        throw new TypeError(`Invalid chain code length: expected ${CHAIN_CODE_SIZE}, got ${chainCode.length}`);
	    }
	    // Derive public key from private key
	    const publicKey = config.algorithm.getPublicKey(privateKey);
	    return new QuantumBIP32(privateKey, publicKey, chainCode, config, 0, 0, 0);
	}
	/**
	 * Create quantum key from private key, public key, and chain code.
	 * This avoids the expensive getPublicKey() derivation when the public key is already known.
	 * Use this for faster imports when both keys are available (e.g., from backup/export).
	 *
	 * IMPORTANT: This function does NOT verify that the public key matches the private key.
	 * The caller is responsible for ensuring the keys are a valid pair.
	 *
	 * @param privateKey - ML-DSA private key
	 * @param publicKey - ML-DSA public key (must correspond to the private key)
	 * @param chainCode - Chain code (32 bytes)
	 * @param network - Network configuration
	 * @param securityLevel - ML-DSA security level
	 */
	function fromKeyPair(privateKey, publicKey, chainCode, network, securityLevel) {
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
	    if (privateKey.length !== config.privateKeySize) {
	        throw new TypeError(`Invalid private key length for ML-DSA-${securityLevel}: expected ${config.privateKeySize}, got ${privateKey.length}`);
	    }
	    if (publicKey.length !== config.publicKeySize) {
	        throw new TypeError(`Invalid public key length for ML-DSA-${securityLevel}: expected ${config.publicKeySize}, got ${publicKey.length}`);
	    }
	    if (chainCode.length !== CHAIN_CODE_SIZE) {
	        throw new TypeError(`Invalid chain code length: expected ${CHAIN_CODE_SIZE}, got ${chainCode.length}`);
	    }
	    return new QuantumBIP32(privateKey, publicKey, chainCode, config, 0, 0, 0);
	}
	/**
	 * Restore a quantum BIP32 node from precomputed values.
	 * Skips all validation and key derivation â€” the caller must ensure values are correct.
	 * Use this when restoring from cache/backup where keys and hierarchy metadata are already known.
	 *
	 * @param privateKey - ML-DSA private key (or undefined for neutered)
	 * @param publicKey - ML-DSA public key
	 * @param chainCode - Chain code (32 bytes)
	 * @param depth - Derivation depth
	 * @param index - Child index
	 * @param parentFingerprint - Parent key fingerprint
	 * @param network - Network configuration
	 * @param securityLevel - ML-DSA security level
	 */
	function fromPrecomputed(privateKey, publicKey, chainCode, depth, index, parentFingerprint, network, securityLevel) {
	    const config = (0, config_js_1.getMLDSAConfig)(securityLevel || config_js_1.MLDSASecurityLevel.LEVEL2, network || networks_js_1.BITCOIN);
	    return new QuantumBIP32(privateKey, publicKey, chainCode, config, depth, index, parentFingerprint);
	}
	/**
	 * Quantum BIP32 Factory
	 * Provides API for creating and managing ML-DSA hierarchical deterministic keys
	 * Supports ML-DSA-44 (default), ML-DSA-65, and ML-DSA-87
	 */
	mldsa.QuantumBIP32Factory = {
	    fromSeed,
	    fromBase58,
	    fromPublicKey,
	    fromPrivateKey,
	    fromKeyPair,
	    fromPrecomputed,
	};
	return mldsa;
}

var hasRequiredQuantum;

function requireQuantum () {
	if (hasRequiredQuantum) return quantum;
	hasRequiredQuantum = 1;
	(function (exports$1) {
		/**
		 * Quantum-resistant BIP32 implementation using ML-DSA
		 *
		 * This module provides hierarchical deterministic key derivation using
		 * ML-DSA (FIPS 204) for post-quantum security.
		 *
		 * Key features:
		 * - Uses BIP32 path derivation (e.g., m/360'/0'/0'/0/0)
		 * - Supports ML-DSA-44 (default), ML-DSA-65, and ML-DSA-87
		 * - ML-DSA-44 provides Level 2 security (128-bit classical security)
		 * - ML-DSA-65 provides Level 3 security (192-bit classical security)
		 * - ML-DSA-87 provides Level 5 security (256-bit classical security)
		 * - Compatible with standard BIP32 mnemonic seeds
		 *
		 * Usage:
		 * ```typescript
		 * import {
		 *   QuantumBIP32Factory,
		 *   MLDSASecurityLevel,
		 *   QuantumDerivationPath
		 * } from '@btc-vision/bip32/quantum';
		 *
		 * const seed = ...; // Your BIP39 seed
		 *
		 * // Default: ML-DSA-44 (Level 2 security)
		 * const master = QuantumBIP32Factory.fromSeed(seed);
		 *
		 * // Or specify security level explicitly using enum
		 * const master87 = QuantumBIP32Factory.fromSeed(seed, MLDSASecurityLevel.LEVEL5);
		 * const master65 = QuantumBIP32Factory.fromSeed(seed, MLDSASecurityLevel.LEVEL3);
		 * const master44 = QuantumBIP32Factory.fromSeed(seed, MLDSASecurityLevel.LEVEL2);
		 *
		 * // Use standard derivation paths
		 * const child = master.derivePath(QuantumDerivationPath.STANDARD);
		 *
		 * const signature = child.sign(messageHash);
		 * const isValid = child.verify(messageHash, signature);
		 * ```
		 */
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.getMLDSAConfig = exports$1.DEFAULT_SECURITY_LEVEL = exports$1.MLDSASecurityLevel = exports$1.QuantumBIP32Factory = void 0;
		// Export the generic ML-DSA implementation (supports 44, 65, 87)
		var mldsa_js_1 = requireMldsa();
		Object.defineProperty(exports$1, "QuantumBIP32Factory", { enumerable: true, get: function () { return mldsa_js_1.QuantumBIP32Factory; } });
		var config_js_1 = requireConfig();
		Object.defineProperty(exports$1, "MLDSASecurityLevel", { enumerable: true, get: function () { return config_js_1.MLDSASecurityLevel; } });
		Object.defineProperty(exports$1, "DEFAULT_SECURITY_LEVEL", { enumerable: true, get: function () { return config_js_1.DEFAULT_SECURITY_LEVEL; } });
		Object.defineProperty(exports$1, "getMLDSAConfig", { enumerable: true, get: function () { return config_js_1.getMLDSAConfig; } }); 
	} (quantum));
	return quantum;
}

var derivationPaths = {};

var hasRequiredDerivationPaths;

function requireDerivationPaths () {
	if (hasRequiredDerivationPaths) return derivationPaths;
	hasRequiredDerivationPaths = 1;
	/**
	 * Standard BIP derivation paths for Bitcoin wallets
	 *
	 * These paths follow Bitcoin Improvement Proposals (BIPs) that define
	 * standardized derivation paths for different address types and use cases.
	 */
	Object.defineProperty(derivationPaths, "__esModule", { value: true });
	derivationPaths.QuantumDerivationPath = derivationPaths.DerivationPath = void 0;
	derivationPaths.getQuantumPath = getQuantumPath;
	derivationPaths.getBitcoinPath = getBitcoinPath;
	/**
	 * Standard derivation paths for Bitcoin addresses
	 */
	var DerivationPath;
	(function (DerivationPath) {
	    /** BIP44 - Legacy P2PKH addresses (1...) */
	    DerivationPath["BIP44"] = "m/44'/0'/0'/0/0";
	    /** BIP49 - SegWit P2SH-P2WPKH addresses (3...) */
	    DerivationPath["BIP49"] = "m/49'/0'/0'/0/0";
	    /** BIP84 - Native SegWit P2WPKH addresses (bc1q...) */
	    DerivationPath["BIP84"] = "m/84'/0'/0'/0/0";
	    /** BIP86 - Taproot P2TR addresses (bc1p...) */
	    DerivationPath["BIP86"] = "m/86'/0'/0'/0/0";
	    /** BIP360 - Post-Quantum (experimental, quantum-resistant keys) */
	    DerivationPath["BIP360"] = "m/360'/0'/0'/0/0";
	})(DerivationPath || (derivationPaths.DerivationPath = DerivationPath = {}));
	/**
	 * Quantum-specific derivation paths (using coin type 360' for quantum)
	 */
	var QuantumDerivationPath;
	(function (QuantumDerivationPath) {
	    /** Standard quantum path - m/360'/0'/0'/0/0 */
	    QuantumDerivationPath["STANDARD"] = "m/360'/0'/0'/0/0";
	    /** Quantum change path - m/360'/0'/0'/1/0 */
	    QuantumDerivationPath["CHANGE"] = "m/360'/0'/0'/1/0";
	    /** Quantum account 0, address 0 */
	    QuantumDerivationPath["ACCOUNT_0_ADDRESS_0"] = "m/360'/0'/0'/0/0";
	    /** Quantum account 0, address 1 */
	    QuantumDerivationPath["ACCOUNT_0_ADDRESS_1"] = "m/360'/0'/0'/0/1";
	    /** Quantum account 1, address 0 */
	    QuantumDerivationPath["ACCOUNT_1_ADDRESS_0"] = "m/360'/1'/0'/0/0";
	})(QuantumDerivationPath || (derivationPaths.QuantumDerivationPath = QuantumDerivationPath = {}));
	/**
	 * Get derivation path by account and address index
	 * @param account - Account index (default: 0)
	 * @param addressIndex - Address index (default: 0)
	 * @param isChange - Whether this is a change address (default: false)
	 * @returns BIP32 derivation path string
	 */
	function getQuantumPath(account = 0, addressIndex = 0, isChange = false) {
	    const changeIndex = isChange ? 1 : 0;
	    return `m/360'/${account}'/${changeIndex}'/${addressIndex}`;
	}
	/**
	 * Get standard Bitcoin derivation path by account and address index
	 * @param bipType - BIP type (44, 49, 84, or 86)
	 * @param account - Account index (default: 0)
	 * @param addressIndex - Address index (default: 0)
	 * @param isChange - Whether this is a change address (default: false)
	 * @returns BIP32 derivation path string
	 */
	function getBitcoinPath(bipType, account = 0, addressIndex = 0, isChange = false) {
	    const changeIndex = isChange ? 1 : 0;
	    return `m/${bipType}'/0'/${account}'/${changeIndex}/${addressIndex}`;
	}
	return derivationPaths;
}

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.getBitcoinPath = exports$1.getQuantumPath = exports$1.QuantumDerivationPath = exports$1.DerivationPath = exports$1.getMLDSAConfig = exports$1.DEFAULT_SECURITY_LEVEL = exports$1.MLDSASecurityLevel = exports$1.QuantumBIP32Factory = exports$1.REGTEST = exports$1.TESTNET = exports$1.BITCOIN = exports$1.BIP32Factory = exports$1.default = void 0;
		var bip32_js_1 = requireBip32();
		Object.defineProperty(exports$1, "default", { enumerable: true, get: function () { return bip32_js_1.BIP32Factory; } });
		Object.defineProperty(exports$1, "BIP32Factory", { enumerable: true, get: function () { return bip32_js_1.BIP32Factory; } });
		// Network configurations
		var networks_js_1 = requireNetworks();
		Object.defineProperty(exports$1, "BITCOIN", { enumerable: true, get: function () { return networks_js_1.BITCOIN; } });
		Object.defineProperty(exports$1, "TESTNET", { enumerable: true, get: function () { return networks_js_1.TESTNET; } });
		Object.defineProperty(exports$1, "REGTEST", { enumerable: true, get: function () { return networks_js_1.REGTEST; } });
		// Quantum-resistant BIP32 using ML-DSA
		var index_js_1 = requireQuantum();
		Object.defineProperty(exports$1, "QuantumBIP32Factory", { enumerable: true, get: function () { return index_js_1.QuantumBIP32Factory; } });
		Object.defineProperty(exports$1, "MLDSASecurityLevel", { enumerable: true, get: function () { return index_js_1.MLDSASecurityLevel; } });
		Object.defineProperty(exports$1, "DEFAULT_SECURITY_LEVEL", { enumerable: true, get: function () { return index_js_1.DEFAULT_SECURITY_LEVEL; } });
		Object.defineProperty(exports$1, "getMLDSAConfig", { enumerable: true, get: function () { return index_js_1.getMLDSAConfig; } });
		// Derivation path enums
		var derivation_paths_js_1 = requireDerivationPaths();
		Object.defineProperty(exports$1, "DerivationPath", { enumerable: true, get: function () { return derivation_paths_js_1.DerivationPath; } });
		Object.defineProperty(exports$1, "QuantumDerivationPath", { enumerable: true, get: function () { return derivation_paths_js_1.QuantumDerivationPath; } });
		Object.defineProperty(exports$1, "getQuantumPath", { enumerable: true, get: function () { return derivation_paths_js_1.getQuantumPath; } });
		Object.defineProperty(exports$1, "getBitcoinPath", { enumerable: true, get: function () { return derivation_paths_js_1.getBitcoinPath; } }); 
	} (cjs));
	return cjs;
}

var cjsExports = requireCjs();
const bip32 = /*@__PURE__*/getDefaultExportFromCjs$1(cjsExports);

const BIP32factory = typeof bip32 === 'function' ? bip32 : cjsExports.BIP32Factory;
if (!BIP32factory) {
    throw new Error('Failed to load BIP32 library');
}
const Point = secp256k1.Point;
const CURVE_N = Point.Fn.ORDER;
const TAP_TAG = new Uint8Array([84, 97, 112, 84, 119, 101, 97, 107]); // 'TapTweak' in UTF-8
const TAP_TAG_HASH = sha256$2(TAP_TAG);
function tapTweakHash(x) {
    return sha256$2(concatBytes$1(TAP_TAG_HASH, TAP_TAG_HASH, x));
}
/**
 * Class for handling EC key pairs
 * @class EcKeyPair
 * @module EcKeyPair
 * @typicalname EcKeyPair
 * @example import { EcKeyPair } from '@btc-vision/transaction';
 */
class EcKeyPair {
    static BIP32 = BIP32factory(backend);
    static ECPairSigner = st;
    // Initialize precomputation for better performance
    static {
        // Precompute tables for the base point for better performance
        Point.BASE.precompute(8);
    }
    /**
     * Generate a keypair from a WIF
     * @param {string} wif - The WIF to use
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated keypair
     */
    static fromWIF(wif, network = bitcoin$1) {
        return st.fromWIF(backend, wif, network);
    }
    /**
     * Generate a keypair from a private key
     * @param {Uint8Array} privateKey - The private key to use
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated keypair
     */
    static fromPrivateKey(privateKey, network = bitcoin$1) {
        return st.fromPrivateKey(backend, privateKey, network);
    }
    /**
     * Generate a keypair from a public key
     * @param {Uint8Array} publicKey - The public key to use
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated keypair
     */
    static fromPublicKey(publicKey, network = bitcoin$1) {
        return st.fromPublicKey(backend, publicKey, network);
    }
    /**
     * Generate a multi-sig address
     * @param {Uint8Array[]} pubKeys - The public keys to use
     * @param {number} minimumSignatureRequired - The minimum number of signatures required
     * @param {Network} network - The network to use
     * @returns {string} - The generated address
     * @throws {Error} - If the address cannot be generated
     */
    static generateMultiSigAddress(pubKeys, minimumSignatureRequired, network = bitcoin$1) {
        const publicKeys = this.verifyPubKeys(pubKeys, network);
        if (publicKeys.length !== pubKeys.length)
            throw new Error(`Contains invalid public keys`);
        const p2ms$1 = p2ms({
            m: minimumSignatureRequired,
            pubkeys: publicKeys,
            network: network,
        });
        const p2wsh$1 = p2wsh({ redeem: p2ms$1, network: network });
        const address = p2wsh$1.address;
        if (!address) {
            throw new Error('Failed to generate address');
        }
        return address;
    }
    /**
     * Verify public keys and return the public keys
     * @param {Uint8Array[]} pubKeys - The public keys to verify
     * @param {Network} network - The network to use
     * @returns {Uint8Array[]} - The verified public keys
     * @throws {Error} - If the key cannot be regenerated
     */
    static verifyPubKeys(pubKeys, network = bitcoin$1) {
        return pubKeys.map((pubKey) => {
            const key = EcKeyPair.fromPublicKey(pubKey, network);
            if (!key) {
                throw new Error('Failed to regenerate key');
            }
            return key.publicKey;
        });
    }
    /**
     * Get a P2WPKH address from a keypair
     * @param {UniversalSigner} keyPair - The keypair to get the address for
     * @param {Network} network - The network to use
     * @returns {string} - The address
     */
    static getP2WPKHAddress(keyPair, network = bitcoin$1) {
        const res = p2wpkh({ pubkey: keyPair.publicKey, network: network });
        if (!res.address) {
            throw new Error('Failed to generate wallet');
        }
        return res.address;
    }
    /**
     * Get the address of a tweaked public key
     * @param {string} tweakedPubKeyHex - The tweaked public key hex string
     * @param {Network} network - The network to use
     * @returns {string} - The address
     * @throws {Error} - If the address cannot be generated
     */
    static tweakedPubKeyToAddress(tweakedPubKeyHex, network) {
        if (tweakedPubKeyHex.startsWith('0x')) {
            tweakedPubKeyHex = tweakedPubKeyHex.slice(2);
        }
        // Convert the tweaked public key hex string to a Uint8Array
        let tweakedPubKeyBuffer = fromHex$1(tweakedPubKeyHex);
        if (tweakedPubKeyBuffer.length !== 32) {
            tweakedPubKeyBuffer = toXOnly(tweakedPubKeyBuffer);
        }
        return EcKeyPair.tweakedPubKeyBufferToAddress(tweakedPubKeyBuffer, network);
    }
    /**
     * Get the address of a tweaked public key
     * @param {Uint8Array} tweakedPubKeyBuffer - The tweaked public key buffer
     * @param {Network} network - The network to use
     * @returns {string} - The address
     * @throws {Error} - If the address cannot be generated
     */
    static tweakedPubKeyBufferToAddress(tweakedPubKeyBuffer, network) {
        // Generate the Taproot address using the p2tr payment method
        const { address } = p2tr({
            pubkey: tweakedPubKeyBuffer,
            network: network,
        });
        if (!address) {
            throw new Error('Failed to generate Taproot address');
        }
        return address;
    }
    /**
     * Generate a P2OP address
     * @param bytes - The bytes to use for the P2OP address
     * @param network - The network to use
     * @param deploymentVersion - The deployment version (default is 0)
     * @returns {string} - The generated P2OP address
     */
    static p2op(bytes, network = bitcoin$1, deploymentVersion = 0) {
        // custom opnet contract addresses
        const witnessProgram = concat$1([
            new Uint8Array([deploymentVersion]),
            bitcoin.crypto.hash160(bytes),
        ]);
        if (witnessProgram.length < 2 || witnessProgram.length > 40) {
            throw new Error('Witness program must be 2-40 bytes.');
        }
        const scriptData = compile([opcodes.OP_16, witnessProgram]);
        return fromOutputScript(scriptData, network);
    }
    /**
     * Get the address of a xOnly tweaked public key
     * @param {string} tweakedPubKeyHex - The xOnly tweaked public key hex string
     * @param {Network} network - The network to use
     * @returns {string} - The address
     * @throws {Error} - If the address cannot be generated
     */
    static xOnlyTweakedPubKeyToAddress(tweakedPubKeyHex, network) {
        if (tweakedPubKeyHex.startsWith('0x')) {
            tweakedPubKeyHex = tweakedPubKeyHex.slice(2);
        }
        // Convert the tweaked public key hex string to a Uint8Array
        const tweakedPubKeyBuffer = fromHex$1(tweakedPubKeyHex);
        if (tweakedPubKeyBuffer.length !== 32) {
            throw new Error('Invalid xOnly public key length');
        }
        // Generate the Taproot address using the p2tr payment method
        const { address } = p2tr({
            pubkey: tweakedPubKeyBuffer,
            network: network,
        });
        if (!address) {
            throw new Error('Failed to generate Taproot address');
        }
        return address;
    }
    /**
     * Tweak a public key
     * @param {Uint8Array | string} pub - The public key to tweak
     * @returns {Uint8Array} - The tweaked public key
     * @throws {Error} - If the public key cannot be tweaked
     */
    static tweakPublicKey(pub) {
        if (typeof pub === 'string' && pub.startsWith('0x'))
            pub = pub.slice(2);
        const hexStr = typeof pub === 'string' ? pub : toHex$1(pub);
        const P = Point.fromHex(hexStr);
        const Peven = (P.y & 1n) === 0n ? P : P.negate();
        const xBytes = Peven.toBytes(true).subarray(1);
        const tBytes = tapTweakHash(xBytes);
        const t = mod$1(bytesToNumberBE(tBytes), CURVE_N);
        const Q = Peven.add(Point.BASE.multiply(t));
        return Q.toBytes(true);
    }
    /**
     * Tweak a batch of public keys
     * @param {readonly Uint8Array[]} pubkeys - The public keys to tweak
     * @param {bigint} tweakScalar - The scalar to use for tweaking
     * @returns {Uint8Array[]} - The tweaked public keys
     */
    static tweakBatchSharedT(pubkeys, tweakScalar) {
        const T = Point.BASE.multiply(tweakScalar);
        return pubkeys.map((bytes) => {
            const P = Point.fromHex(toHex$1(bytes));
            const P_even = P.y % 2n === 0n ? P : P.negate();
            const Q = P_even.add(T);
            return Q.toBytes(true);
        });
    }
    /**
     * Generate a random wallet with both classical and quantum keys
     *
     * @param network - The network to use
     * @param securityLevel - The ML-DSA security level for quantum keys (default: LEVEL2/44)
     * @returns An object containing both classical and quantum key information
     */
    static generateWallet(network = bitcoin$1, securityLevel = cjsExports.MLDSASecurityLevel.LEVEL2) {
        const keyPair = st.makeRandom(backend, network, {
            rng: (size) => {
                return randomBytes$1(size);
            },
        });
        const wallet = this.getP2WPKHAddress(keyPair, network);
        if (!wallet) {
            throw new Error('Failed to generate wallet');
        }
        // Generate random quantum keypair with network
        const quantumKeyPair = this.generateQuantumKeyPair(securityLevel, network);
        return {
            address: wallet,
            privateKey: keyPair.toWIF(),
            publicKey: toHex$1(keyPair.publicKey),
            quantumPrivateKey: toHex$1(quantumKeyPair.privateKey),
            quantumPublicKey: toHex$1(quantumKeyPair.publicKey),
        };
    }
    /**
     * Generate a random quantum ML-DSA keypair
     *
     * This creates a standalone quantum-resistant keypair without using BIP32 derivation.
     * The keys are generated using cryptographically secure random bytes.
     *
     * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
     * @param network - The Bitcoin network (default: bitcoin mainnet)
     * @returns A random ML-DSA keypair
     */
    static generateQuantumKeyPair(securityLevel = cjsExports.MLDSASecurityLevel.LEVEL2, network = bitcoin$1) {
        // Generate random seed for quantum key generation
        const randomSeed = randomBytes$1(64);
        // Create a quantum root from the random seed with network parameter
        const quantumRoot = cjsExports.QuantumBIP32Factory.fromSeed(randomSeed, network, securityLevel);
        if (!quantumRoot.privateKey || !quantumRoot.publicKey) {
            throw new Error('Failed to generate quantum keypair');
        }
        return {
            privateKey: new Uint8Array(quantumRoot.privateKey),
            publicKey: new Uint8Array(quantumRoot.publicKey),
        };
    }
    /**
     * Verify that a contract address is a valid p2tr address
     * @param {string} contractAddress - The contract address to verify
     * @param {Network} network - The network to use
     * @returns {boolean} - Whether the address is valid
     */
    static verifyContractAddress(contractAddress, network = bitcoin$1) {
        return !!toOutputScript(contractAddress, network);
    }
    /**
     * Get the legacy segwit address from a keypair
     * @param {UniversalSigner} keyPair - The keypair to get the address for
     * @param {Network} network - The network to use
     * @returns {string} - The legacy address
     */
    static getLegacySegwitAddress(keyPair, network = bitcoin$1) {
        const wallet = p2sh({
            redeem: p2wpkh({ pubkey: keyPair.publicKey, network: network }),
            network: network,
        });
        if (!wallet.address) {
            throw new Error('Failed to generate wallet');
        }
        return wallet.address;
    }
    /**
     * Get the legacy address from a keypair
     * @param {UniversalSigner} keyPair - The keypair to get the address for
     * @param {Network} network - The network to use
     * @returns {string} - The legacy address
     */
    static getLegacyAddress(keyPair, network = bitcoin$1) {
        const wallet = p2pkh({ pubkey: keyPair.publicKey, network: network });
        if (!wallet.address) {
            throw new Error('Failed to generate wallet');
        }
        return wallet.address;
    }
    /**
     * Get the legacy address from a public key
     * @param publicKey
     * @param {Network} network - The network to use
     * @returns {string} - The legacy address
     */
    static getP2PKH(publicKey, network = bitcoin$1) {
        const wallet = p2pkh({ pubkey: publicKey, network: network });
        if (!wallet.address) {
            throw new Error('Failed to generate wallet');
        }
        return wallet.address;
    }
    /**
     * Get the P2PK output from a keypair
     * @param {UniversalSigner} keyPair - The keypair to get the address for
     * @param {Network} network - The network to use
     * @returns {string} - The legacy address
     */
    static getP2PKAddress(keyPair, network = bitcoin$1) {
        const wallet = p2pk({ pubkey: keyPair.publicKey, network: network });
        if (!wallet.output) {
            throw new Error('Failed to generate wallet');
        }
        return '0x' + toHex$1(wallet.output);
    }
    /**
     * Generate a random keypair
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated keypair
     */
    static generateRandomKeyPair(network = bitcoin$1) {
        return st.makeRandom(backend, network, {
            rng: (size) => {
                return randomBytes$1(size);
            },
        });
    }
    /**
     * Generate a BIP32 keypair from a seed
     * @param {Uint8Array} seed - The seed to generate the keypair from
     * @param {Network} network - The network to use
     * @returns {BIP32Interface} - The generated keypair
     */
    static fromSeed(seed, network = bitcoin$1) {
        return this.BIP32.fromSeed(seed, network);
    }
    /**
     * Get taproot address from keypair
     * @param {UniversalSigner | Signer} keyPair - The keypair to get the taproot address for
     * @param {Network} network - The network to use
     * @returns {string} - The taproot address
     */
    static getTaprootAddress(keyPair, network = bitcoin$1) {
        const { address } = p2tr({
            internalPubkey: toXOnly(keyPair.publicKey),
            network: network,
        });
        if (!address) {
            throw new Error(`Failed to generate sender address for transaction`);
        }
        return address;
    }
    /**
     * Get taproot address from address
     * @param {string} inAddr - The address to convert to taproot
     * @param {Network} network - The network to use
     * @returns {string} - The taproot address
     */
    static getTaprootAddressFromAddress(inAddr, network = bitcoin$1) {
        const { address } = p2tr({
            address: inAddr,
            network: network,
        });
        if (!address) {
            throw new Error(`Failed to generate sender address for transaction`);
        }
        return address;
    }
    /**
     * Get a keypair from a given seed.
     * @param {Uint8Array} seed - The seed to generate the key pair from
     * @param {Network} network - The network to use
     * @returns {UniversalSigner} - The generated key pair
     */
    static fromSeedKeyPair(seed, network = bitcoin$1) {
        const fromSeed = this.BIP32.fromSeed(seed, network);
        const privKey = fromSeed.privateKey;
        if (!privKey)
            throw new Error('Failed to generate key pair');
        return st.fromPrivateKey(backend, privKey, network);
    }
}

var Features;
(function (Features) {
    Features[Features["ACCESS_LIST"] = 1] = "ACCESS_LIST";
    Features[Features["EPOCH_SUBMISSION"] = 2] = "EPOCH_SUBMISSION";
    Features[Features["MLDSA_LINK_PUBKEY"] = 4] = "MLDSA_LINK_PUBKEY";
})(Features || (Features = {}));
var FeaturePriority;
(function (FeaturePriority) {
    FeaturePriority[FeaturePriority["ACCESS_LIST"] = 1] = "ACCESS_LIST";
    FeaturePriority[FeaturePriority["EPOCH_SUBMISSION"] = 2] = "EPOCH_SUBMISSION";
    FeaturePriority[FeaturePriority["MLDSA_LINK_PUBKEY"] = 3] = "MLDSA_LINK_PUBKEY";
})(FeaturePriority || (FeaturePriority = {}));

const ADDRESS_BYTE_LENGTH = 32;
const EXTENDED_ADDRESS_BYTE_LENGTH = 64;
const SCHNORR_SIGNATURE_BYTE_LENGTH = 64;
const U256_BYTE_LENGTH = 32;
const U128_BYTE_LENGTH = 16;
const U64_BYTE_LENGTH = 8;
const U32_BYTE_LENGTH = 4;
const U16_BYTE_LENGTH = 2;
const U8_BYTE_LENGTH = 1;
const I128_BYTE_LENGTH = 16;
const I64_BYTE_LENGTH = 8;
const I32_BYTE_LENGTH = 4;
const I16_BYTE_LENGTH = 2;
const I8_BYTE_LENGTH = 1;

function assertArgument(check, message, name, value) {
  {
    throw new Error(`${message} (${name}: ${value})`);
  }
}
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal = getGlobal();
anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha1":
      return sha1$2.create();
    case "sha256":
      return sha256$2.create();
    case "sha512":
      return sha512$1.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}

const hexPattern = /^[0-9a-fA-F]+$/;
class BitcoinUtils {
  /**
   * Converts satoshi to BTC
   * @param {number} btc - The amount in BTC
   * @returns {bigint} The amount in satoshi
   */
  static btcToSatoshi(btc) {
    return BigInt(btc * 1e8);
  }
  /**
   * Generates random bytes.
   * @public
   * @returns {Uint8Array} The random bytes
   */
  static rndBytes() {
    return BitcoinUtils.getSafeRandomValues(64);
  }
  static getSafeRandomValues(length) {
    if (typeof globalThis.window !== "undefined" && globalThis.window.crypto && typeof globalThis.window.crypto.getRandomValues === "function") {
      const array = new Uint8Array(length);
      window.crypto.getRandomValues(array);
      return array;
    } else if (globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
      const array = new Uint8Array(length);
      globalThis.crypto.getRandomValues(array);
      return array;
    } else {
      console.log(`No secure random number generator available. Please upgrade your environment.`, globalThis.window.crypto, globalThis.crypto);
      throw new Error("No secure random number generator available. Please upgrade your environment.");
    }
  }
  static isValidHex(hex) {
    return hexPattern.test(hex);
  }
  /**
   * Hashes the given data
   * @param {Uint8Array} data - The data to hash
   * @returns {string} The hashed data
   */
  static opnetHash(data) {
    const hashed = createHash("sha512");
    hashed.update(data);
    const hash = hashed.digest();
    return `0x${toHex$1(new Uint8Array(hash))}`;
  }
}

/**
 * P2WDA Detection and Validation Utilities
 */
class P2WDADetector {
    /**
     * Check if a UTXO is a P2WDA output by examining its script structure
     */
    static isP2WDAUTXO(utxo) {
        if (!utxo.witnessScript) {
            return false;
        }
        const witnessScript = utxo.witnessScript instanceof Uint8Array
            ? utxo.witnessScript
            : fromHex$1(utxo.witnessScript);
        return this.isP2WDAWitnessScript(witnessScript);
    }
    /**
     * Check if a witness script follows the P2WDA pattern
     */
    static isP2WDAWitnessScript(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled || decompiled.length !== 7) {
                return false;
            }
            // Check for 5 OP_2DROP operations
            for (let i = 0; i < 5; i++) {
                if (decompiled[i] !== opcodes.OP_2DROP) {
                    return false;
                }
            }
            // Check for pubkey and OP_CHECKSIG
            return (decompiled[5] instanceof Uint8Array &&
                decompiled[5].length === 33 && // Compressed public key
                decompiled[6] === opcodes.OP_CHECKSIG);
        }
        catch {
            return false;
        }
    }
    /**
     * Generate a P2WDA address from a public key
     */
    static generateP2WDAAddress(publicKey, network) {
        if (publicKey.length !== 33) {
            throw new Error('Public key must be 33 bytes (compressed)');
        }
        // Create the P2WDA witness script with 5x OP_2DROP
        const witnessScript = compile([
            opcodes.OP_2DROP,
            opcodes.OP_2DROP,
            opcodes.OP_2DROP,
            opcodes.OP_2DROP,
            opcodes.OP_2DROP,
            publicKey,
            opcodes.OP_CHECKSIG,
        ]);
        // Wrap in P2WSH
        const p2wsh$1 = p2wsh({
            redeem: { output: witnessScript },
            network,
        });
        if (!p2wsh$1.address || !p2wsh$1.output) {
            throw new Error('Failed to generate P2WDA address');
        }
        return {
            address: p2wsh$1.address,
            witnessScript,
            scriptPubKey: p2wsh$1.output,
        };
    }
    /**
     * Extract the public key from a P2WDA witness script
     */
    static extractPublicKeyFromP2WDA(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled || decompiled.length !== 7) {
                return null;
            }
            // Check for 5x OP_2DROP pattern
            for (let i = 0; i < 5; i++) {
                if (decompiled[i] !== opcodes.OP_2DROP) {
                    return null;
                }
            }
            if (decompiled[5] instanceof Uint8Array &&
                decompiled[5].length === 33 &&
                decompiled[6] === opcodes.OP_CHECKSIG) {
                return decompiled[5];
            }
            return null;
        }
        catch {
            return null;
        }
    }
    /**
     * Create witness data for a simple P2WDA spend (no operation data)
     */
    static createSimpleP2WDAWitness(transactionSignature, witnessScript) {
        const witnessStack = [transactionSignature];
        // Add 10 empty buffers for the 5x OP_2DROP operations
        for (let i = 0; i < 10; i++) {
            witnessStack.push(new Uint8Array(0));
        }
        witnessStack.push(witnessScript);
        return witnessStack;
    }
    /**
     * Validate P2WDA operation data signature
     */
    static validateP2WDASignature(_publicKey, dataSignature, _operationData) {
        return dataSignature.length === 64; // Schnorr signatures are always 64 bytes
    }
    /**
     * Calculate the witness size for P2WDA transaction estimation
     */
    static estimateP2WDAWitnessSize(dataSize = 0) {
        return 72 + dataSize + 39 + 12;
    }
    /**
     * Check if a scriptPubKey is a P2WSH that could be P2WDA
     */
    static couldBeP2WDA(scriptPubKey) {
        return scriptPubKey.length === 34 && scriptPubKey[0] === 0x00 && scriptPubKey[1] === 0x20;
    }
}

var AddressTypes;
(function (AddressTypes) {
    AddressTypes["P2PKH"] = "P2PKH";
    AddressTypes["P2OP"] = "P2OP";
    AddressTypes["P2SH_OR_P2SH_P2WPKH"] = "P2SH_OR_P2SH-P2WPKH";
    AddressTypes["P2PK"] = "P2PK";
    AddressTypes["P2TR"] = "P2TR";
    AddressTypes["P2MR"] = "P2MR";
    AddressTypes["P2WPKH"] = "P2WPKH";
    AddressTypes["P2WSH"] = "P2WSH";
    AddressTypes["P2WDA"] = "P2WDA";
})(AddressTypes || (AddressTypes = {}));
class AddressVerificator {
    static isValidP2TRAddress(inAddress, network) {
        if (!inAddress || inAddress.length < 50)
            return false;
        let isValidTapRootAddress = false;
        try {
            toOutputScript(inAddress, network);
            const decodedAddress = fromBech32(inAddress);
            isValidTapRootAddress = decodedAddress.version === 1;
        }
        catch { }
        return isValidTapRootAddress;
    }
    /**
     * Validates that the given address is a valid P2MR (BIP 360) address.
     * Checks for witness version 2 with a 32-byte Merkle root program.
     */
    static isValidP2MRAddress(inAddress, network) {
        if (!inAddress || inAddress.length < 50)
            return false;
        let isValidP2MR = false;
        try {
            toOutputScript(inAddress, network);
            const decodedAddress = fromBech32(inAddress);
            isValidP2MR = decodedAddress.version === 2 && decodedAddress.data.length === 32;
        }
        catch { }
        return isValidP2MR;
    }
    static isP2WPKHAddress(inAddress, network) {
        if (!inAddress || inAddress.length < 20 || inAddress.length > 50)
            return false;
        let isValidSegWitAddress = false;
        try {
            const decodedAddress = fromBech32(inAddress);
            toOutputScript(inAddress, network);
            isValidSegWitAddress =
                decodedAddress.version === 0 && decodedAddress.data.length === 20;
        }
        catch { }
        return isValidSegWitAddress;
    }
    static isP2WDAWitnessScript(witnessScript) {
        return P2WDADetector.isP2WDAWitnessScript(witnessScript);
    }
    static isP2PKHOrP2SH(addy, network) {
        try {
            const decodedBase58 = fromBase58Check(addy);
            if (decodedBase58.version === network.pubKeyHash) {
                return true;
            }
            return decodedBase58.version === network.scriptHash;
        }
        catch (error) {
            return false;
        }
    }
    static isValidPublicKey(input, network) {
        try {
            if (input.startsWith('0x')) {
                input = input.slice(2);
            }
            if (!BitcoinUtils.isValidHex(input)) {
                return false;
            }
            if (input.length === 64) {
                return true;
            }
            const pubKeyBuffer = fromHex$1(input);
            if ((input.length === 130 && pubKeyBuffer[0] === 0x06) || pubKeyBuffer[0] === 0x07) {
                return true;
            }
            if (input.length === 66 || input.length === 130) {
                EcKeyPair.fromPublicKey(pubKeyBuffer, network);
                return true;
            }
        }
        catch (e) {
            return false;
        }
        return false;
    }
    static isValidMLDSAPublicKey(input) {
        try {
            let byteLength;
            if (typeof input !== 'string' && input instanceof Uint8Array) {
                byteLength = input.length;
            }
            else {
                if (input.startsWith('0x')) {
                    input = input.slice(2);
                }
                if (!BitcoinUtils.isValidHex(input)) {
                    return null;
                }
                byteLength = input.length / 2;
            }
            switch (byteLength) {
                case 1312:
                    return cjsExports.MLDSASecurityLevel.LEVEL2;
                case 1952:
                    return cjsExports.MLDSASecurityLevel.LEVEL3;
                case 2592:
                    return cjsExports.MLDSASecurityLevel.LEVEL5;
                default:
                    return null;
            }
        }
        catch (e) {
            return null;
        }
    }
    static isValidP2OPAddress(inAddress, network) {
        if (!inAddress || inAddress.length < 20)
            return false;
        try {
            const decodedAddress = fromBech32(inAddress);
            const validPrefix = decodedAddress.prefix === network.bech32 ||
                decodedAddress.prefix === network.bech32Opnet;
            if (!validPrefix) {
                return false;
            }
            return decodedAddress.version === 16 && decodedAddress.data.length === 21;
        }
        catch {
            return false;
        }
    }
    static requireRedeemScript(addy, network) {
        try {
            const decodedBase58 = fromBase58Check(addy);
            if (decodedBase58.version === network.pubKeyHash) {
                return false;
            }
            return decodedBase58.version === network.scriptHash;
        }
        catch {
            return false;
        }
    }
    static detectAddressType(addy, network) {
        if (AddressVerificator.isValidPublicKey(addy, network)) {
            return AddressTypes.P2PK;
        }
        try {
            const decodedBase58 = fromBase58Check(addy);
            if (decodedBase58.version === network.pubKeyHash) {
                return AddressTypes.P2PKH;
            }
            if (decodedBase58.version === network.scriptHash) {
                return AddressTypes.P2SH_OR_P2SH_P2WPKH;
            }
        }
        catch { }
        try {
            const decodedBech32 = fromBech32(addy);
            if ((decodedBech32.prefix === network.bech32Opnet ||
                decodedBech32.prefix === network.bech32) &&
                decodedBech32.version === 16 &&
                decodedBech32.data.length === 21) {
                return AddressTypes.P2OP;
            }
            if (decodedBech32.prefix === network.bech32) {
                if (decodedBech32.version === 0 && decodedBech32.data.length === 20) {
                    return AddressTypes.P2WPKH;
                }
                if (decodedBech32.version === 0 && decodedBech32.data.length === 32) {
                    return AddressTypes.P2WSH;
                }
                if (decodedBech32.version === 1 && decodedBech32.data.length === 32) {
                    return AddressTypes.P2TR;
                }
                if (decodedBech32.version === 2 && decodedBech32.data.length === 32) {
                    return AddressTypes.P2MR;
                }
            }
        }
        catch { }
        return null;
    }
    static detectAddressTypeWithWitnessScript(addy, network, witnessScript) {
        const baseType = AddressVerificator.detectAddressType(addy, network);
        if (baseType === AddressTypes.P2WSH && witnessScript) {
            if (AddressVerificator.isP2WDAWitnessScript(witnessScript)) {
                return AddressTypes.P2WDA;
            }
        }
        return baseType;
    }
    static validateP2WDAAddress(address, network, witnessScript) {
        try {
            const addressType = AddressVerificator.detectAddressType(address, network);
            if (addressType !== AddressTypes.P2WSH) {
                return {
                    isValid: false,
                    isPotentiallyP2WDA: false,
                    isDefinitelyP2WDA: false,
                    error: 'Not a P2WSH address',
                };
            }
            if (!witnessScript) {
                return {
                    isValid: true,
                    isPotentiallyP2WDA: true,
                    isDefinitelyP2WDA: false,
                };
            }
            if (!AddressVerificator.isP2WDAWitnessScript(witnessScript)) {
                return {
                    isValid: true,
                    isPotentiallyP2WDA: true,
                    isDefinitelyP2WDA: false,
                    error: 'Witness script does not match P2WDA pattern',
                };
            }
            const p2wsh$1 = p2wsh({
                redeem: { output: witnessScript },
                network,
            });
            if (p2wsh$1.address !== address) {
                return {
                    isValid: false,
                    isPotentiallyP2WDA: false,
                    isDefinitelyP2WDA: false,
                    error: 'Witness script does not match address',
                };
            }
            const publicKey = P2WDADetector.extractPublicKeyFromP2WDA(witnessScript);
            if (!publicKey) {
                return {
                    isValid: false,
                    isPotentiallyP2WDA: false,
                    isDefinitelyP2WDA: false,
                    error: 'Failed to extract public key from witness script',
                };
            }
            return {
                isValid: true,
                isPotentiallyP2WDA: true,
                isDefinitelyP2WDA: true,
                publicKey,
            };
        }
        catch (error) {
            return {
                isValid: false,
                isPotentiallyP2WDA: false,
                isDefinitelyP2WDA: false,
                error: error.message,
            };
        }
    }
}

const P = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
class Secp256k1PointDeriver {
    /**
     * The maximum increments to try before giving up on deriving a valid x.
     */
    maxTries;
    constructor(maxTries = 10000) {
        this.maxTries = maxTries;
    }
    /**
     * Main entry point.
     * Given a 32-byte input, ensures we obtain a "real" x on secp256k1.
     * - If the given x is valid, we use it.
     * - Otherwise, we increment x (mod p) until we find one whose (x^3 + 7) is a quadratic residue.
     * Then we return { x, y1, y2 } for that valid point.
     *
     * @param xBytes A 32-byte Uint8Array for the candidate x
     * @param failOnInvalidX (optional) whether to throw if the given x is not a valid curve point, defaults to true
     * @param maxTries (optional) number of increments to attempt, defaults to this.maxTries
     * @returns An object { x: bigint; y1: bigint; y2: bigint } describing a valid curve point
     * @throws If no valid x found within maxTries
     */
    findOrDeriveValidPoint(xBytes, failOnInvalidX = true, maxTries = this.maxTries) {
        if (xBytes.length !== 32) {
            throw new Error('xBytes must be exactly 32 bytes.');
        }
        // Convert input to a BigInt in [0, p-1]
        let xCandidate = this.bytesToBigInt(xBytes) % P;
        // 2. Loop up to maxTries to find a valid x
        let sqrtVal = this.isValidX(xCandidate);
        if (failOnInvalidX && sqrtVal === null) {
            throw new Error(`The given x is not a valid curve point.`);
        }
        let tries = 0;
        while (sqrtVal === null) {
            xCandidate = (xCandidate + 1n) % P;
            sqrtVal = this.isValidX(xCandidate);
            tries++;
            if (tries > maxTries) {
                throw new Error(`Could not find a valid X point within ${maxTries} increments.`);
            }
        }
        // Now, sqrtVal is a valid 'r' for alpha = x^3 + 7
        // The two roots for y are: r and p-r
        const y1 = sqrtVal;
        const y2 = (P - y1) % P;
        return { x: xCandidate, y1, y2 };
    }
    /**
     * Given two candidate y values, returns the one with the smaller y-coordinate.
     * @param {bigint} y
     * @param {bigint} y2
     */
    getCanonicalY(y, y2) {
        return y < y2 ? y : y2;
    }
    /**
     * Creates a 65-byte "hybrid public key" from the specified x and y.
     * - First byte:
     *   - 0x06 if y is even
     *   - 0x07 if y is odd
     * - Next 32 bytes: x
     * - Last 32 bytes: y
     *
     * @param x X-coordinate as a bigint
     * @param y Y-coordinate as a bigint
     * @returns A Uint8Array of length 65
     */
    getHybridPublicKey(x, y) {
        // Determine prefix based on parity of y
        const prefix = y % 2n === 0n ? 0x06 : 0x07;
        // Convert x and y to 32-byte big-endian arrays
        const xBytes = this.bigIntTo32Bytes(x);
        const yBytes = this.bigIntTo32Bytes(y);
        // Allocate 65 bytes: 1 for prefix + 32 for x + 32 for y
        const hybrid = new Uint8Array(65);
        hybrid[0] = prefix;
        hybrid.set(xBytes, 1);
        hybrid.set(yBytes, 33);
        return hybrid;
    }
    /**
     * Checks if (x^3 + 7) is a quadratic residue mod p.
     * Returns the square root if it is, or null if not.
     */
    isValidX(x) {
        // alpha = (x^3 + 7) mod p
        const alpha = (this.modPow(x, 3n, P) + 7n) % P;
        return this.sqrtModP(alpha, P);
    }
    /**
     * Computes base^exp (mod m) using exponentiation by squaring.
     */
    modPow(base, exp, m) {
        let result = 1n;
        let cur = base % m;
        let e = exp;
        while (e > 0) {
            if ((e & 1n) === 1n) {
                result = (result * cur) % m;
            }
            cur = (cur * cur) % m;
            e >>= 1n;
        }
        return result;
    }
    /**
     * sqrtModP(a, p):
     *   Attempts to compute the square root of `a` modulo prime `p`.
     *   Returns the root if it exists, or null if `a` is not a quadratic residue.
     *
     * Since p â‰¡ 3 (mod 4), we can do:
     *   sqrt(a) = a^((p+1)/4) mod p
     */
    sqrtModP(a, prime) {
        // Candidate root
        const root = this.modPow(a, (prime + 1n) >> 2n, prime);
        // Check if it's truly a root
        if ((root * root) % prime !== a % prime) {
            return null;
        }
        return root;
    }
    /**
     * Convert a 32-byte Uint8Array (big-endian) to a BigInt.
     */
    bytesToBigInt(bytes) {
        let b = 0n;
        for (const byte of bytes) {
            b = (b << 8n) | BigInt(byte);
        }
        return b;
    }
    /**
     * Convert a BigInt to a 32-byte array (big-endian).
     */
    bigIntTo32Bytes(value) {
        const bytes = new Uint8Array(32);
        for (let i = 31; i >= 0; i--) {
            bytes[i] = Number(value & 0xffn);
            value >>= 8n;
        }
        return bytes;
    }
}

class ContractAddressBase {
    deriver = new Secp256k1PointDeriver();
    generateHybridKeyFromHash(input) {
        const p = this.deriver.findOrDeriveValidPoint(new Uint8Array(input), false);
        const y = this.deriver.getCanonicalY(p.y1, p.y2);
        return new Uint8Array(this.deriver.getHybridPublicKey(p.x, y));
    }
}
const ContractAddress = new ContractAddressBase();

class TimeLockGenerator {
    static UNSPENDABLE_INTERNAL_KEY = fromHex$1('50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0');
    static CSV_BLOCKS = 75;
    /**
     * Generate a P2WSH address with CSV timelock
     * Note: This uses ECDSA, not Schnorr (Schnorr only available in Taproot)
     */
    static generateTimeLockAddress(publicKey, network = bitcoin$1, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const p2wsh = bitcoin.payments.p2wsh({
            redeem: { output: witnessScript },
            network,
        });
        if (!p2wsh.address) {
            throw new Error('Failed to generate P2WSH address');
        }
        return {
            address: p2wsh.address,
            witnessScript: witnessScript,
        };
    }
    /**
     * Generate a P2TR address with CSV time lock
     * Note: This uses Schnorr signatures
     */
    static generateTimeLockAddressP2TR(publicKey, network = bitcoin$1, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        if (publicKey.length !== 32) {
            throw new Error('Public key must be 32 bytes for Taproot');
        }
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const taproot = bitcoin.payments.p2tr({
            redeem: { output: witnessScript },
            network,
            internalPubkey: TimeLockGenerator.UNSPENDABLE_INTERNAL_KEY,
        });
        if (!taproot.address) {
            throw new Error('Failed to generate P2TR address');
        }
        return taproot.address;
    }
    /**
     * Generate a P2MR address with CSV time lock
     * Note: This uses Schnorr signatures within a P2MR (BIP 360) script tree
     */
    static generateTimeLockAddressP2MR(publicKey, network = bitcoin$1, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        if (publicKey.length !== 32) {
            throw new Error('Public key must be 32 bytes for P2MR');
        }
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const scriptTree = { output: witnessScript, version: 192 };
        const p2mr$1 = p2mr({ scriptTree, network });
        if (!p2mr$1.address) {
            throw new Error('Failed to generate P2MR address');
        }
        return p2mr$1.address;
    }
    static generateTimeLockScript(publicKey, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        return compile([
            number.encode(csvBlocks),
            opcodes.OP_CHECKSEQUENCEVERIFY,
            opcodes.OP_DROP,
            publicKey,
            opcodes.OP_CHECKSIG,
        ]);
    }
}

// ML-DSA-44 (Level 2): 1312 bytes public key
// ML-DSA-65 (Level 3): 1952 bytes public key
// ML-DSA-87 (Level 5): 2592 bytes public key
const validMLDSALengths = [1312, 1952, 2592];
/**
 * Objects of type "Address" represent hashed ML-DSA (quantum) public keys (using SHA256 of quantum keys) and maintain classical public keys separately.
 * This class supports a hybrid quantum-classical architecture, allowing conversion to different address formats and management of both key types.
 *
 * The Address internally stores the SHA256 hash of the ML-DSA public key as its primary content, while maintaining
 * the classical public key in a separate field. This enables quantum-resistant addressing while preserving
 * compatibility with traditional Bitcoin cryptography.
 *
 * @category KeyPair
 */
class Address extends Uint8Array {
    #p2tr;
    #p2op;
    #network;
    #originalPublicKey;
    #keyPair;
    #uncompressed;
    #tweakedUncompressed;
    #p2wda;
    #mldsaPublicKey;
    #cachedBigInt;
    #cachedBigIntTweaked;
    #cachedUint64Array;
    #originalMDLSAPublicKey;
    #mldsaLevel;
    // Lazy loading state - defers expensive EC operations until actually needed
    #pendingLegacyKey;
    #legacyProcessed = false;
    // After processing, this is 32-byte tweaked x-only (same as original behavior)
    #tweakedPublicKey;
    constructor(mldsaPublicKey, publicKeyOrTweak) {
        super(ADDRESS_BYTE_LENGTH);
        if (!mldsaPublicKey) {
            return;
        }
        if (publicKeyOrTweak) {
            // Validate length immediately (cheap check), defer EC operations
            const validLengths = [ADDRESS_BYTE_LENGTH, 33, 65];
            if (!validLengths.includes(publicKeyOrTweak.length)) {
                throw new Error(`Invalid public key length ${publicKeyOrTweak.length}`);
            }
            // Store but don't process yet - defer EC operations
            this.#pendingLegacyKey = new Uint8Array(publicKeyOrTweak.length);
            this.#pendingLegacyKey.set(publicKeyOrTweak);
        }
        this.setMldsaKey(mldsaPublicKey);
    }
    /**
     * Prevent TypedArray methods (subarray, slice, etc.) from creating Address
     * instances. Without this, @noble/hashes and other libraries that call
     * subarray() on an Address would invoke the Address constructor that recomputes
     * everything leading to bad performance.
     */
    static get [Symbol.species]() {
        return Uint8Array;
    }
    get mldsaLevel() {
        return this.#mldsaLevel;
    }
    set mldsaLevel(level) {
        this.#mldsaLevel = level;
    }
    get originalMDLSAPublicKey() {
        return this.#originalMDLSAPublicKey;
    }
    set originalMDLSAPublicKey(key) {
        this.#originalMDLSAPublicKey = key ? new Uint8Array(key) : undefined;
    }
    /**
     * If available, this will return the original public key associated with the address.
     * @returns {Uint8Array} The original public key used to create the address.
     */
    get originalPublicKey() {
        this.ensureLegacyProcessed();
        return this.#originalPublicKey;
    }
    get mldsaPublicKey() {
        return this.#mldsaPublicKey;
    }
    /**
     * Get the legacy public key (32-byte tweaked x-only after processing).
     * Triggers lazy processing if not yet done.
     */
    get legacyPublicKey() {
        this.ensureLegacyProcessed();
        return this.#tweakedPublicKey;
    }
    /**
     * Get the key pair for the address
     * @description This is only for internal use. Please use address.tweakedBytes instead.
     */
    get keyPair() {
        this.ensureLegacyProcessed();
        if (!this.#keyPair) {
            throw new Error('Legacy public key not set for address');
        }
        return this.#keyPair;
    }
    static dead() {
        return Address.fromString('0x0000000000000000000000000000000000000000000000000000000000000000', // DEAD ADDRESS
        '0x04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f');
    }
    /**
     * Create an address from a hex string
     * @param {string} mldsaPublicKey The ml-dsa public key in hex format
     * @param {string} legacyPublicKey The classical public key in hex format
     * @returns {Address} The address
     */
    static fromString(mldsaPublicKey, legacyPublicKey) {
        if (!mldsaPublicKey) {
            throw new Error('Invalid public key');
        }
        if (mldsaPublicKey.startsWith('0x')) {
            mldsaPublicKey = mldsaPublicKey.slice(2);
        }
        if (!BitcoinUtils.isValidHex(mldsaPublicKey)) {
            throw new Error('You must only pass public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.');
        }
        let classicBuffer;
        if (legacyPublicKey) {
            if (legacyPublicKey.startsWith('0x')) {
                legacyPublicKey = legacyPublicKey.slice(2);
            }
            if (!BitcoinUtils.isValidHex(legacyPublicKey)) {
                throw new Error('You must only pass classical public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.');
            }
            classicBuffer = fromHex$1(legacyPublicKey);
        }
        return new Address(fromHex$1(mldsaPublicKey), classicBuffer);
    }
    /**
     * Create an address from a public key
     * @returns {Address} The address
     * @param {ArrayLike<number>} bytes The public key
     */
    static wrap(bytes) {
        return new Address(bytes);
    }
    static uncompressedToCompressed(publicKey) {
        const buffer = Uint8Array.from(publicKey);
        const x = buffer.slice(1, 33);
        const y = buffer.slice(33);
        const compressed = new Uint8Array(33);
        compressed[0] = 0x02 + (y[y.length - 1] & 0x01);
        compressed.set(x, 1);
        return compressed;
    }
    /**
     * Creates an Address instance from a BigInt value.
     *
     * Converts a 256-bit unsigned integer into a 32-byte address by splitting it
     * into four 64-bit chunks and writing them in big-endian format using DataView.
     * This is the inverse operation of toBigInt().
     *
     * @param {bigint} value - The 256-bit unsigned integer to convert (0 to 2^256-1)
     * @param {bigint} [tweakedValue] - Optional tweaked public key as a 256-bit unsigned integer
     * @returns {Address} A new Address instance containing the converted value
     *
     * @throws {RangeError} If the value is negative or exceeds 2^256-1
     *
     * @example
     * ```typescript
     * const bigIntValue = 12345678901234567890n;
     * const address = Address.fromBigInt(bigIntValue);
     * console.log(address.toHex()); // 0x0000000000000000000000000000000000000000000000000000abc123...
     * ```
     */
    static fromBigInt(value, tweakedValue) {
        const address = Address.bigintToUint8Array(value);
        const legacyAddress = tweakedValue !== undefined ? Address.bigintToUint8Array(tweakedValue) : undefined;
        return new Address(address, legacyAddress);
    }
    /**
     * Creates an Address instance from four 64-bit unsigned integers.
     *
     * Constructs a 32-byte address by combining four 64-bit big-endian unsigned integers.
     * This is the inverse operation of toUint64Array() and provides an efficient way
     * to create addresses from word-aligned data.
     *
     * @param {bigint} w0 - Most significant 64 bits (bytes 0-7)
     * @param {bigint} w1 - Second 64 bits (bytes 8-15)
     * @param {bigint} w2 - Third 64 bits (bytes 16-23)
     * @param {bigint} w3 - Least significant 64 bits (bytes 24-31)
     * @returns {Address} A new Address instance containing the combined value
     *
     * @throws {RangeError} If any value exceeds 64 bits (2^64-1)
     *
     * @example
     * ```typescript
     * const address = Address.fromUint64Array(
     *     0x0123456789abcdefn,
     *     0xfedcba9876543210n,
     *     0x1111222233334444n,
     *     0x5555666677778888n
     * );
     * console.log(address.toHex());
     * ```
     */
    static fromUint64Array(w0, w1, w2, w3) {
        const buffer = new Uint8Array(32);
        const view = new DataView(buffer.buffer);
        view.setBigUint64(0, w0, false);
        view.setBigUint64(8, w1, false);
        view.setBigUint64(16, w2, false);
        view.setBigUint64(24, w3, false);
        return new Address(buffer);
    }
    static bigintToUint8Array(value) {
        const buffer = new Uint8Array(32);
        const view = new DataView(buffer.buffer);
        view.setBigUint64(0, (value >> 192n) & 0xffffffffffffffffn, false);
        view.setBigUint64(8, (value >> 128n) & 0xffffffffffffffffn, false);
        view.setBigUint64(16, (value >> 64n) & 0xffffffffffffffffn, false);
        view.setBigUint64(24, value & 0xffffffffffffffffn, false);
        return buffer;
    }
    [Symbol.dispose]() {
        // Zero the base Uint8Array (hashed ML-DSA public key)
        this.fill(0);
        // Clear all cached / derived state
        this.#p2tr = undefined;
        this.#p2op = undefined;
        this.#network = undefined;
        this.#originalPublicKey = undefined;
        this.#keyPair = undefined;
        this.#uncompressed = undefined;
        this.#tweakedUncompressed = undefined;
        this.#p2wda = undefined;
        this.#mldsaPublicKey?.fill(0);
        this.#mldsaPublicKey = undefined;
        this.#cachedBigInt = undefined;
        this.#cachedBigIntTweaked = undefined;
        this.#cachedUint64Array = undefined;
        this.#originalMDLSAPublicKey?.fill(0);
        this.#originalMDLSAPublicKey = undefined;
        this.#mldsaLevel = undefined;
        this.#legacyProcessed = false;
        this.#tweakedPublicKey = undefined;
    }
    /**
     * Converts the address to four 64-bit unsigned integers.
     *
     * Splits the 32-byte (256-bit) address into four 64-bit big-endian unsigned integers.
     * This representation is useful for efficient storage, comparison operations, or
     * interfacing with systems that work with 64-bit word sizes.
     *
     * @returns {[bigint, bigint, bigint, bigint]} An array of four 64-bit unsigned integers
     *          representing the address from most significant to least significant bits
     *
     * @example
     * ```typescript
     * const address = Address.fromString('0x0123456789abcdef...');
     * const [w0, w1, w2, w3] = address.toUint64Array();
     * console.log(w0); // Most significant 64 bits
     * console.log(w3); // Least significant 64 bits
     * ```
     */
    toUint64Array() {
        if (this.#cachedUint64Array !== undefined) {
            return this.#cachedUint64Array;
        }
        const view = new DataView(this.buffer, this.byteOffset, 32);
        this.#cachedUint64Array = [
            view.getBigUint64(0, false),
            view.getBigUint64(8, false),
            view.getBigUint64(16, false),
            view.getBigUint64(24, false),
        ];
        return this.#cachedUint64Array;
    }
    /**
     * Check if the address is the dead address
     * @returns {boolean}
     */
    isDead() {
        for (let i = 0; i < ADDRESS_BYTE_LENGTH; i++) {
            if (this[i] !== 0) {
                return false;
            }
        }
        return true;
    }
    /**
     * Converts the address to a hex string
     * @returns {string} The hex string
     */
    toHex() {
        return '0x' + toHex$1(this);
    }
    /**
     * Converts the classical public key to a hex string
     * @returns {string} The hex string
     */
    tweakedToHex() {
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + toHex$1(key);
    }
    /**
     * Converts the address content (SHA256 hash of ML-DSA public key) to a Uint8Array
     * @returns {Uint8Array} The Uint8Array containing the hashed ML-DSA public key
     */
    toBuffer() {
        return new Uint8Array(this);
    }
    /**
     * Converts the classical public key to a Uint8Array
     * @returns {Uint8Array} The Uint8Array
     */
    tweakedPublicKeyToBuffer() {
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error('Legacy public key not set');
        }
        return new Uint8Array(key);
    }
    toUncompressedHex() {
        this.ensureLegacyProcessed();
        if (!this.#uncompressed) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + toHex$1(this.#uncompressed.uncompressed);
    }
    toUncompressedBuffer() {
        this.ensureLegacyProcessed();
        if (!this.#uncompressed) {
            throw new Error('Legacy public key not set');
        }
        return this.#uncompressed.uncompressed;
    }
    toHybridPublicKeyHex() {
        this.ensureLegacyProcessed();
        if (!this.#uncompressed) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + toHex$1(this.#uncompressed.hybrid);
    }
    toHybridPublicKeyBuffer() {
        this.ensureLegacyProcessed();
        if (!this.#uncompressed) {
            throw new Error('Legacy public key not set');
        }
        return this.#uncompressed.hybrid;
    }
    originalPublicKeyBuffer() {
        this.ensureLegacyProcessed();
        if (!this.#originalPublicKey) {
            throw new Error('Legacy public key not set');
        }
        return new Uint8Array(this.#originalPublicKey);
    }
    /**
     * Converts the address to a BigInt representation.
     *
     * This method uses an optimized DataView approach to read the 32-byte address
     * as four 64-bit big-endian unsigned integers, then combines them using bitwise
     * operations. This is approximately 10-20x faster than string-based conversion.
     *
     * @returns {bigint} The address as a 256-bit unsigned integer
     *
     * @example
     * ```typescript
     * const address = Address.fromString('0x0123456789abcdef...');
     * const bigIntValue = address.toBigInt();
     * console.log(bigIntValue); // 123456789...n
     * ```
     */
    toBigInt() {
        if (this.#cachedBigInt !== undefined) {
            return this.#cachedBigInt;
        }
        const view = new DataView(this.buffer, this.byteOffset, 32);
        this.#cachedBigInt =
            (view.getBigUint64(0, false) << 192n) |
                (view.getBigUint64(8, false) << 128n) |
                (view.getBigUint64(16, false) << 64n) |
                view.getBigUint64(24, false);
        return this.#cachedBigInt;
    }
    /**
     * Converts the tweaked public key to a BigInt representation.
     *
     * This method uses an optimized DataView approach to read the 32-byte address
     * as four 64-bit big-endian unsigned integers, then combines them using bitwise
     * operations. This is approximately 10-20x faster than string-based conversion.
     *
     * @returns {bigint} The address as a 256-bit unsigned integer
     *
     * @example
     * ```typescript
     * const address = Address.fromString('0x0123456789abcdef...', '0xtweaked...');
     * const bigIntValue = address.tweakedToBigInt();
     * console.log(bigIntValue); // 123456789...n
     * ```
     */
    tweakedToBigInt() {
        if (!this.legacyPublicKey) {
            throw new Error('Legacy public key not set');
        }
        if (this.#cachedBigIntTweaked !== undefined) {
            return this.#cachedBigIntTweaked;
        }
        const view = new DataView(this.legacyPublicKey.buffer, this.byteOffset, 32);
        this.#cachedBigIntTweaked =
            (view.getBigUint64(0, false) << 192n) |
                (view.getBigUint64(8, false) << 128n) |
                (view.getBigUint64(16, false) << 64n) |
                view.getBigUint64(24, false);
        return this.#cachedBigIntTweaked;
    }
    equals(a) {
        const b = this;
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < b.length; i++) {
            if (b[i] !== a[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Check if the address is bigger than another address
     * @returns {boolean} If bigger
     */
    lessThan(a) {
        const b = this;
        for (let i = 0; i < ADDRESS_BYTE_LENGTH; i++) {
            const thisByte = b[i];
            const aByte = a[i];
            if (thisByte < aByte) {
                return true; // this is less than a
            }
            else if (thisByte > aByte) {
                return false; // this is greater than or equal to a
            }
        }
        return false;
    }
    /**
     * Check if the address is smaller than another address
     * @returns {boolean} If smaller
     */
    greaterThan(a) {
        // Compare the two addresses byte-by-byte, treating them as big-endian uint256
        const b = this;
        for (let i = 0; i < ADDRESS_BYTE_LENGTH; i++) {
            const thisByte = b[i];
            const aByte = a[i];
            if (thisByte > aByte) {
                return true; // this is greater than a
            }
            else if (thisByte < aByte) {
                return false; // this is less than or equal to a
            }
        }
        return false;
    }
    /**
     * Set the public key
     * @param {ArrayLike<number>} mldsaPublicKey ML-DSA public key
     * @returns {void}
     */
    set(mldsaPublicKey) {
        // Legacy key processing is now deferred via ensureLegacyProcessed()
        this.setMldsaKey(mldsaPublicKey);
    }
    /**
     * Check if the public key is valid
     * @param {Network} network The network
     * @returns {boolean} If the public key is valid
     */
    isValidLegacyPublicKey(network) {
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error(`Legacy key not set.`);
        }
        return AddressVerificator.isValidPublicKey(toHex$1(key), network);
    }
    /**
     * Get the public key as address
     */
    p2pk() {
        return this.toHex();
    }
    /**
     * Get the address in p2wpkh format
     * @param {Network} network The network
     */
    p2wpkh(network) {
        return EcKeyPair.getP2WPKHAddress(this.keyPair, network);
    }
    /**
     * Get the address in p2pkh format
     * @param {Network} network The network
     */
    p2pkh(network) {
        return EcKeyPair.getLegacyAddress(this.keyPair, network);
    }
    /**
     * Get the address in p2sh-p2wpkh format
     * @param {Network} network The network
     */
    p2shp2wpkh(network) {
        return EcKeyPair.getLegacySegwitAddress(this.keyPair, network);
    }
    /**
     * Convert the address to a string
     */
    toString() {
        return this.toHex();
    }
    /**
     * Convert the address to a JSON string
     */
    toJSON() {
        return this.toHex();
    }
    /**
     * Get the address in p2tr format
     * @param {Network} network The network
     */
    p2tr(network) {
        if (this.#p2tr && this.#network === network) {
            return this.#p2tr;
        }
        const key = this.legacyPublicKey;
        if (!key) {
            throw new Error('Legacy public key not set');
        }
        const p2trAddy = EcKeyPair.tweakedPubKeyBufferToAddress(key, network);
        if (p2trAddy) {
            this.#network = network;
            this.#p2tr = p2trAddy;
            return p2trAddy;
        }
        throw new Error('Legacy public key not set');
    }
    /**
     * Generate a P2WDA (Pay-to-Witness-Data-Authentication) address
     *
     * P2WDA addresses are a special type of P2WSH address that allows embedding
     * authenticated data directly in the witness field, achieving 75% cost reduction
     * through Bitcoin's witness discount.
     *
     * The witness script pattern is: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
     * This allows up to 10 witness data fields (5 * 2 = 10), where each field
     * can hold up to 80 bytes of data due to relay rules.
     *
     * @param {Network} network - The Bitcoin network to use
     * @returns {IP2WSHAddress} The P2WDA address
     * @throws {Error} If the public key is not set or address generation fails
     *
     * @example
     * ```typescript
     * const address = Address.fromString('0x02...');
     * const p2wdaAddress = address.p2wda(networks.bitcoin);
     * console.log(p2wdaAddress); // bc1q...
     * ```
     */
    p2wda(network) {
        if (this.#p2wda && this.#network === network) {
            return this.#p2wda;
        }
        this.ensureLegacyProcessed();
        if (!this.#originalPublicKey) {
            throw new Error('Cannot create P2WDA address: public key not set');
        }
        const publicKeyBuffer = new Uint8Array(this.#originalPublicKey);
        if (publicKeyBuffer.length !== 33) {
            throw new Error('P2WDA requires a compressed public key (33 bytes)');
        }
        try {
            const p2wdaInfo = P2WDADetector.generateP2WDAAddress(publicKeyBuffer, network);
            this.#network = network;
            this.#p2wda = p2wdaInfo;
            return {
                address: p2wdaInfo.address,
                witnessScript: p2wdaInfo.witnessScript,
            };
        }
        catch (error) {
            throw new Error(`Failed to generate P2WDA address: ${error.message}`, {
                cause: error,
            });
        }
    }
    /**
     * Generate a P2WSH address with CSV (CheckSequenceVerify) time lock
     * The resulting address can only be spent after the specified number of blocks
     * have passed since the UTXO was created.
     *
     * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
     * @param {Network} network - The Bitcoin network to use
     * @returns {IP2WSHAddress} The timelocked address and its witness script
     * @throws {Error} If the block number is out of range or public key is not available
     */
    toCSV(duration, network) {
        const n = Number(duration);
        // First, let's validate the block number to ensure it's within the valid range
        // CSV uses sequence numbers, which have special encoding for block-based locks
        if (n < 1 || n > 65535) {
            throw new Error('CSV block number must be between 1 and 65535');
        }
        // We need the original public key in compressed format for the script
        // Your class stores this in #originalPublicKey when a key is set
        this.ensureLegacyProcessed();
        if (!this.#originalPublicKey) {
            throw new Error('Cannot create CSV address: public key not set');
        }
        // Convert the public key to Uint8Array format that TimeLockGenerator expects
        const publicKeyBuffer = new Uint8Array(this.#originalPublicKey);
        // Now we can use your TimeLockGenerator to create the timelocked address
        // Converting bigint to number is safe here because we've already validated the range
        return TimeLockGenerator.generateTimeLockAddress(publicKeyBuffer, network, n);
    }
    /**
     * Generate a P2TR address with CSV (CheckSequenceVerify) time lock
     * The resulting address can only be spent after the specified number of blocks
     * have passed since the UTXO was created.
     *
     * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
     * @param {Network} network - The Bitcoin network to use
     * @returns {IP2WSHAddress} The timelocked address and its witness script
     * @throws {Error} If the block number is out of range or public key is not available
     */
    toCSVTweaked(duration, network) {
        const n = Number(duration);
        // First, let's validate the block number to ensure it's within the valid range
        // CSV uses sequence numbers, which have special encoding for block-based locks
        if (n < 1 || n > 65535) {
            throw new Error('CSV block number must be between 1 and 65535');
        }
        // We need the original public key in compressed format for the script
        // Your class stores this in #originalPublicKey when a key is set
        this.ensureLegacyProcessed();
        if (!this.#originalPublicKey) {
            throw new Error('Cannot create CSV address: public key not set');
        }
        // Now we can use your TimeLockGenerator to create the timelocked address
        // Converting bigint to number is safe here because we've already validated the range
        return TimeLockGenerator.generateTimeLockAddressP2TR(this.tweakedPublicKeyToBuffer(), network, n);
    }
    /**
     * Generate a P2MR address with CSV (CheckSequenceVerify) time lock
     * The resulting address can only be spent after the specified number of blocks
     * have passed since the UTXO was created. Uses P2MR (BIP 360) instead of P2TR.
     *
     * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
     * @param {Network} network - The Bitcoin network to use
     * @returns {string} The timelocked P2MR address
     * @throws {Error} If the block number is out of range or public key is not available
     */
    toCSVP2MR(duration, network) {
        const n = Number(duration);
        if (n < 1 || n > 65535) {
            throw new Error('CSV block number must be between 1 and 65535');
        }
        this.ensureLegacyProcessed();
        if (!this.#tweakedPublicKey) {
            throw new Error('Cannot create CSV P2MR address: public key not set');
        }
        return TimeLockGenerator.generateTimeLockAddressP2MR(this.tweakedPublicKeyToBuffer(), network, n);
    }
    /**
     * Returns the OPNet address encoded in bech32m format, derived from the SHA256 hash of the ML-DSA public key
     * (which is what the Address internally stores).
     *
     * This method generates a P2OP (Pay-to-OPNet) address using witness version 16, suitable for
     * quantum-resistant transactions on the OPNet protocol.
     *
     * @param network - The Bitcoin network to use (mainnet, testnet, regtest)
     * @returns The P2OP address in bech32m format
     */
    p2op(network) {
        if (this.#p2op && this.#network === network) {
            return this.#p2op;
        }
        // p2op only uses the MLDSA hash (this Uint8Array), no legacy key processing needed.
        // This is the HOT PATH for parsing - stays fast without triggering EC operations.
        const p2opAddy = EcKeyPair.p2op(this, network);
        if (p2opAddy) {
            this.#network = network;
            this.#p2op = p2opAddy;
            return p2opAddy;
        }
        throw new Error('ML-DSA public key not set');
    }
    toTweakedHybridPublicKeyHex() {
        this.ensureLegacyProcessed();
        this.ensureTweakedUncompressed();
        if (!this.#tweakedUncompressed) {
            throw new Error('Legacy public key not set');
        }
        return '0x' + toHex$1(this.#tweakedUncompressed);
    }
    toTweakedHybridPublicKeyBuffer() {
        this.ensureLegacyProcessed();
        this.ensureTweakedUncompressed();
        if (!this.#tweakedUncompressed) {
            throw new Error('Legacy public key not set');
        }
        return this.#tweakedUncompressed;
    }
    /**
     * Lazily generates the tweaked uncompressed/hybrid key from the legacy public key.
     * Only called when toTweakedHybridPublicKey* methods are accessed.
     */
    ensureTweakedUncompressed() {
        if (this.#tweakedUncompressed)
            return;
        const key = this.#tweakedPublicKey;
        if (!key)
            return;
        // Only attempt hybrid key generation for 32-byte keys that weren't processed through autoFormat
        if (key.length === ADDRESS_BYTE_LENGTH && !this.#originalPublicKey) {
            try {
                this.#tweakedUncompressed = ContractAddress.generateHybridKeyFromHash(key);
            }
            catch {
                // Hybrid key generation may fail for keys that aren't valid EC points
                // (e.g., zero addresses). Leave #tweakedUncompressed undefined.
            }
        }
    }
    /**
     * Sets the MLDSA key portion of the address.
     * @param {ArrayLike<number>} mldsaPublicKey - The MLDSA public key or its hash
     */
    setMldsaKey(mldsaPublicKey) {
        // THIS is the SHA256(ORIGINAL_ML_DSA_PUBLIC_KEY)
        if (mldsaPublicKey.length === ADDRESS_BYTE_LENGTH) {
            const buf = new Uint8Array(ADDRESS_BYTE_LENGTH);
            buf.set(mldsaPublicKey);
            super.set(buf);
        }
        else {
            // Validate ML-DSA public key lengths according to BIP360 and FIPS 204
            if (!validMLDSALengths.includes(mldsaPublicKey.length)) {
                throw new Error(`Invalid ML-DSA public key length: ${mldsaPublicKey.length}. ` +
                    `Expected 1312 (ML-DSA-44/LEVEL2), 1952 (ML-DSA-65/LEVEL3), or 2592 (ML-DSA-87/LEVEL5) bytes.`);
            }
            // Store the original ML-DSA public key
            this.#mldsaPublicKey = new Uint8Array(mldsaPublicKey.length);
            this.#mldsaPublicKey.set(mldsaPublicKey);
            // Hash the ML-DSA public key to get the 32-byte address
            const hashedPublicKey = sha256$2(new Uint8Array(mldsaPublicKey));
            const buf = new Uint8Array(ADDRESS_BYTE_LENGTH);
            buf.set(hashedPublicKey);
            super.set(buf);
        }
    }
    /**
     * Lazy processing of legacy key - defers expensive EC operations until actually needed.
     * Does the EXACT same logic as the original set() method did for legacy keys.
     */
    ensureLegacyProcessed() {
        if (this.#legacyProcessed)
            return;
        this.#legacyProcessed = true;
        const pending = this.#pendingLegacyKey;
        if (!pending)
            return;
        // Length validation already done in constructor
        if (pending.length === ADDRESS_BYTE_LENGTH) {
            this.#tweakedPublicKey = pending;
        }
        else {
            // 33 or 65 bytes: full autoFormat processing with EC operations
            this.autoFormat(pending);
        }
    }
    /**
     * Processes a 33 or 65 byte public key, performing EC operations.
     * Sets #tweakedPublicKey to 32-byte tweaked x-only (same as original behavior).
     */
    autoFormat(publicKey) {
        const firstByte = publicKey[0];
        if (firstByte === 0x03 || firstByte === 0x02) ;
        else if (firstByte === 0x04 || firstByte === 0x06 || firstByte === 0x07) {
            // uncompressed
            publicKey = Address.uncompressedToCompressed(publicKey);
        }
        this.#originalPublicKey = Uint8Array.from(publicKey);
        this.#keyPair = EcKeyPair.fromPublicKey(this.#originalPublicKey);
        this.#uncompressed = decompressPublicKey(this.#originalPublicKey);
        const tweakedBytes = toXOnly(EcKeyPair.tweakPublicKey(this.#originalPublicKey));
        this.#tweakedUncompressed = ContractAddress.generateHybridKeyFromHash(tweakedBytes);
        this.#tweakedPublicKey = new Uint8Array(ADDRESS_BYTE_LENGTH);
        this.#tweakedPublicKey.set(tweakedBytes);
    }
}

class FastMap {
    _keys = [];
    _values = {};
    constructor(iterable) {
        if (iterable instanceof FastMap) {
            this.setAll(iterable);
        }
        else {
            if (iterable) {
                for (const [key, value] of iterable) {
                    this.set(key, value);
                }
            }
        }
    }
    get size() {
        return this._keys.length;
    }
    setAll(map) {
        this._keys = [...map._keys];
        this._values = { ...map._values };
    }
    addAll(map) {
        for (const [key, value] of map.entries()) {
            this.set(key, value);
        }
    }
    *keys() {
        yield* this._keys;
    }
    *values() {
        for (const key of this._keys) {
            yield this._values[key];
        }
    }
    *entries() {
        for (const key of this._keys) {
            yield [key, this._values[key]];
        }
    }
    set(key, value) {
        if (!this.has(key)) {
            this._keys.push(key);
        }
        this._values[key] = value;
        return this;
    }
    indexOf(key) {
        if (!this.has(key)) {
            return -1;
        }
        for (let i = 0; i < this._keys.length; i++) {
            if (this._keys[i] === key) {
                return i;
            }
        }
        throw new Error('Key not found, this should not happen.');
    }
    get(key) {
        return this._values[key];
    }
    has(key) {
        return Object.prototype.hasOwnProperty.call(this._values, key);
    }
    delete(key) {
        if (!this.has(key)) {
            return false;
        }
        const index = this.indexOf(key);
        this._keys.splice(index, 1);
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete this._values[key];
        return true;
    }
    clear() {
        this._keys = [];
        this._values = {};
    }
    [Symbol.dispose]() {
        this.clear();
    }
    forEach(callback, thisArg) {
        for (const key of this._keys) {
            callback.call(thisArg, this._values[key], key, this);
        }
    }
    *[Symbol.iterator]() {
        for (const key of this._keys) {
            yield [key, this._values[key]];
        }
    }
}

class AddressMap {
    items;
    constructor(iterable) {
        this.items = new FastMap();
        if (iterable) {
            for (const [key, value] of iterable) {
                this.set(key, value);
            }
        }
    }
    get size() {
        return this.items.size;
    }
    set(key, value) {
        const keyBigInt = key.toBigInt();
        this.items.set(keyBigInt, value);
        return this;
    }
    get(key) {
        return this.items.get(key.toBigInt());
    }
    has(key) {
        return this.items.has(key.toBigInt());
    }
    delete(key) {
        const keyBigInt = key.toBigInt();
        return this.items.delete(keyBigInt);
    }
    clear() {
        this.items.clear();
    }
    [Symbol.dispose]() {
        this.clear();
    }
    indexOf(address) {
        return this.items.indexOf(address.toBigInt());
    }
    /**
     * WARNING, THIS RETURN NEW COPY OF THE KEYS
     */
    *entries() {
        for (const [keyBigInt, value] of this.items.entries()) {
            yield [Address.fromBigInt(keyBigInt), value];
        }
    }
    *keys() {
        for (const keyBigInt of this.items.keys()) {
            yield Address.fromBigInt(keyBigInt);
        }
    }
    *values() {
        for (const value of this.items.values()) {
            yield value;
        }
    }
    forEach(callback, thisArg) {
        for (const [keyBigInt, value] of this.items.entries()) {
            const key = Address.fromBigInt(keyBigInt);
            callback.call(thisArg, value, key, this);
        }
    }
    *[Symbol.iterator]() {
        yield* this.entries();
    }
}

/**
 * A map implementation using Address with both MLDSA and tweaked keys.
 * Uses the tweaked public key for lookup/indexing, but stores the full Address.
 */
class ExtendedAddressMap {
    // Store tweaked bigint -> index mapping for fast lookup
    indexMap;
    // Store actual addresses and values
    _keys = [];
    _values = [];
    constructor(iterable) {
        this.indexMap = new FastMap();
        if (iterable) {
            for (const [key, value] of iterable) {
                this.set(key, value);
            }
        }
    }
    get size() {
        return this._keys.length;
    }
    set(key, value) {
        const keyBigInt = key.tweakedToBigInt();
        const existingIndex = this.indexMap.get(keyBigInt);
        if (existingIndex !== undefined) {
            // Update existing entry
            this._values[existingIndex] = value;
        }
        else {
            // Add new entry
            const newIndex = this._keys.length;
            this._keys.push(key);
            this._values.push(value);
            this.indexMap.set(keyBigInt, newIndex);
        }
        return this;
    }
    get(key) {
        const keyBigInt = key.tweakedToBigInt();
        const index = this.indexMap.get(keyBigInt);
        if (index === undefined) {
            return undefined;
        }
        return this._values[index];
    }
    has(key) {
        return this.indexMap.has(key.tweakedToBigInt());
    }
    delete(key) {
        const keyBigInt = key.tweakedToBigInt();
        const index = this.indexMap.get(keyBigInt);
        if (index === undefined) {
            return false;
        }
        // Remove from arrays
        this._keys.splice(index, 1);
        this._values.splice(index, 1);
        // Rebuild index map (indices shifted after splice)
        this.indexMap.clear();
        for (let i = 0; i < this._keys.length; i++) {
            this.indexMap.set(this._keys[i].tweakedToBigInt(), i);
        }
        return true;
    }
    clear() {
        this.indexMap.clear();
        this._keys = [];
        this._values = [];
    }
    [Symbol.dispose]() {
        this.clear();
    }
    indexOf(address) {
        const index = this.indexMap.get(address.tweakedToBigInt());
        return index !== undefined ? index : -1;
    }
    *entries() {
        for (let i = 0; i < this._keys.length; i++) {
            yield [this._keys[i], this._values[i]];
        }
    }
    *keys() {
        for (const key of this._keys) {
            yield key;
        }
    }
    *values() {
        for (const value of this._values) {
            yield value;
        }
    }
    forEach(callback, thisArg) {
        for (let i = 0; i < this._keys.length; i++) {
            callback.call(thisArg, this._values[i], this._keys[i], this);
        }
    }
    *[Symbol.iterator]() {
        yield* this.entries();
    }
}

class BufferHelper {
    static EXPECTED_BUFFER_LENGTH = 32;
    static bufferToUint8Array(buffer) {
        const result = new Uint8Array(buffer.byteLength);
        result.set(buffer);
        return result;
    }
    static uint8ArrayToHex(input) {
        return toHex$1(input);
    }
    static hexToUint8Array(input) {
        let hex = input;
        if (hex.length >= 2 && hex[0] === '0' && (hex[1] === 'x' || hex[1] === 'X')) {
            hex = hex.slice(2);
        }
        // Pad with a leading zero if the length is odd
        if (hex.length % 2 !== 0) {
            hex = '0' + hex;
        }
        return fromHex$1(hex);
    }
    static pointerToUint8Array(pointer) {
        if (pointer < 0n) {
            throw new RangeError('Pointer cannot be negative');
        }
        const hex = pointer.toString(16).padStart(64, '0');
        if (hex.length > 64) {
            throw new RangeError('Pointer exceeds 256-bit range');
        }
        return fromHex$1(hex);
    }
    static uint8ArrayToPointer(input) {
        if (input.length === 0) {
            return 0n;
        }
        return BigInt('0x' + toHex$1(input));
    }
    static valueToUint8Array(value, length = U256_BYTE_LENGTH) {
        if (value < 0n) {
            throw new RangeError('Value cannot be negative');
        }
        const hex = value.toString(16).padStart(length * 2, '0');
        if (hex.length > length * 2) {
            throw new RangeError(`Value exceeds ${length}-byte range`);
        }
        return fromHex$1(hex);
    }
    static uint8ArrayToValue(input) {
        if (input.length === 0) {
            return 0n;
        }
        return BigInt('0x' + toHex$1(input));
    }
}

class BinaryReader {
    buffer;
    currentOffset = 0;
    constructor(bytes) {
        this.buffer = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    }
    get byteLength() {
        return this.buffer.byteLength;
    }
    // Helpers for comparisons; unchanged
    static stringCompare(a, b) {
        return a.localeCompare(b);
    }
    static bigintCompare(a, b) {
        if (a < b)
            return -1;
        if (a > b)
            return 1;
        return 0;
    }
    static numberCompare(a, b) {
        if (a < b)
            return -1;
        if (a > b)
            return 1;
        return 0;
    }
    setBuffer(bytes) {
        this.buffer = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        this.currentOffset = 0;
    }
    length() {
        return this.buffer.byteLength;
    }
    bytesLeft() {
        return this.buffer.byteLength - this.currentOffset;
    }
    // ------------------- Signed Integer Readers ------------------- //
    /**
     * Reads a single signed byte (i8).
     */
    readI8() {
        this.verifyEnd(this.currentOffset + I8_BYTE_LENGTH);
        const value = this.buffer.getInt8(this.currentOffset);
        this.currentOffset += I8_BYTE_LENGTH;
        return value;
    }
    /**
     * Reads a signed 16-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readI16(be = true) {
        this.verifyEnd(this.currentOffset + I16_BYTE_LENGTH);
        const value = this.buffer.getInt16(this.currentOffset, !be);
        this.currentOffset += I16_BYTE_LENGTH;
        return value;
    }
    /**
     * Reads a signed 32-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readI32(be = true) {
        this.verifyEnd(this.currentOffset + I32_BYTE_LENGTH);
        const value = this.buffer.getInt32(this.currentOffset, !be);
        this.currentOffset += I32_BYTE_LENGTH;
        return value;
    }
    /**
     * Reads a signed 64-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readI64(be = true) {
        this.verifyEnd(this.currentOffset + I64_BYTE_LENGTH);
        const value = this.buffer.getBigInt64(this.currentOffset, !be);
        this.currentOffset += I64_BYTE_LENGTH;
        return value;
    }
    // ------------------- Unsigned Integer Readers ------------------- //
    /**
     * Reads a single unsigned byte (u8).
     */
    readU8() {
        this.verifyEnd(this.currentOffset + U8_BYTE_LENGTH);
        const value = this.buffer.getUint8(this.currentOffset);
        this.currentOffset += U8_BYTE_LENGTH;
        return value;
    }
    /**
     * Reads an unsigned 16-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readU16(be = true) {
        this.verifyEnd(this.currentOffset + U16_BYTE_LENGTH);
        const value = this.buffer.getUint16(this.currentOffset, !be);
        this.currentOffset += U16_BYTE_LENGTH;
        return value;
    }
    /**
     * Reads an unsigned 32-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readU32(be = true) {
        this.verifyEnd(this.currentOffset + U32_BYTE_LENGTH);
        const value = this.buffer.getUint32(this.currentOffset, !be);
        this.currentOffset += U32_BYTE_LENGTH;
        return value;
    }
    /**
     * Reads an unsigned 64-bit integer. By default, big-endian.
     * @param be - Endianness; true means big-endian (the default).
     */
    readU64(be = true) {
        this.verifyEnd(this.currentOffset + U64_BYTE_LENGTH);
        const value = this.buffer.getBigUint64(this.currentOffset, !be);
        this.currentOffset += U64_BYTE_LENGTH;
        return value;
    }
    /**
     * Reads a 128-bit unsigned integer. By default, read big-endian.
     * @param be - Endianness; true => big-endian (default).
     */
    readU128(be = true) {
        const raw = this.readBytes(U128_BYTE_LENGTH);
        let bytes = raw;
        // If data was written in little-endian, we reverse before interpreting
        if (!be) {
            bytes = this.reverseBytes(raw);
        }
        return BigInt('0x' + this.toHexString(bytes));
    }
    /**
     * Reads a 256-bit unsigned integer. Same approach as readU128.
     * @param be - Endianness; true => big-endian (default).
     */
    readU256(be = true) {
        const raw = this.readBytes(U256_BYTE_LENGTH);
        let bytes = raw;
        if (!be) {
            bytes = this.reverseBytes(raw);
        }
        return BigInt('0x' + this.toHexString(bytes));
    }
    /**
     * Reads a 128-bit signed integer. Interpret the sign bit if big-endian.
     * @param be - Endianness; true => big-endian (default).
     */
    readI128(be = true) {
        const raw = this.readBytes(I128_BYTE_LENGTH);
        let bytes = raw;
        if (!be) {
            bytes = this.reverseBytes(raw);
        }
        // Construct as a 128-bit two's complement
        let value = BigInt('0x' + this.toHexString(bytes));
        // If the top bit is set (sign bit in big-endian), interpret negative
        const signBitMask = 0x80;
        if (bytes[0] & signBitMask) {
            // (1 << 128)
            const twoTo128 = BigInt(1) << BigInt(128);
            // 2's complement
            value = value - twoTo128;
        }
        return value;
    }
    /**
     * Read a boolean (u8 != 0).
     */
    readBoolean() {
        return this.readU8() !== 0;
    }
    /**
     * Reads 32 bits
     */
    readSelector() {
        return this.readU32(true);
    }
    /**
     * Reads a raw sequence of bytes (length must be known).
     * If zeroStop = true, stops if we encounter 0x00 early.
     */
    readBytes(length, zeroStop = false) {
        this.verifyEnd(this.currentOffset + length);
        let bytes = new Uint8Array(length);
        for (let i = 0; i < length; i++) {
            const b = this.buffer.getUint8(this.currentOffset++);
            if (zeroStop && b === 0) {
                bytes = new Uint8Array(bytes.subarray(0, i));
                break;
            }
            bytes[i] = b;
        }
        return bytes;
    }
    /**
     * Reads a string of the given length in raw bytes. By default, do NOT zero-stop
     * (matching how we wrote the raw bytes).
     */
    readString(length) {
        const textDecoder = new TextDecoder();
        const bytes = this.readBytes(length, false);
        return textDecoder.decode(bytes);
    }
    /**
     * Reads a string that was written as [u16 length][raw bytes].
     */
    readStringWithLength(be = true) {
        const length = this.readU32(be);
        return this.readString(length);
    }
    /**
     * Reads an address (32 bytes MLDSA key hash only).
     */
    readAddress() {
        const bytes = Array.from(this.readBytes(ADDRESS_BYTE_LENGTH));
        return new Address(bytes);
    }
    /**
     * Reads the tweaked public key portion (32 bytes) and returns it as a raw Uint8Array.
     * Use this when you only need the tweaked key without the full Address object.
     */
    readTweakedPublicKey() {
        this.verifyEnd(this.currentOffset + ADDRESS_BYTE_LENGTH);
        return this.readBytes(ADDRESS_BYTE_LENGTH);
    }
    /**
     * Reads a full address with both MLDSA key hash and tweaked public key (64 bytes total).
     * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
     *
     * This is the equivalent of btc-runtime's readExtendedAddress().
     *
     * @returns An Address instance with both keys set
     */
    readExtendedAddress() {
        this.verifyEnd(this.currentOffset + EXTENDED_ADDRESS_BYTE_LENGTH);
        // Read tweaked public key first (32 bytes)
        const tweakedPublicKey = Array.from(this.readBytes(ADDRESS_BYTE_LENGTH));
        // Read MLDSA key hash (32 bytes)
        const mldsaKeyHash = Array.from(this.readBytes(ADDRESS_BYTE_LENGTH));
        return new Address(mldsaKeyHash, tweakedPublicKey);
    }
    /**
     * Reads a Schnorr signature with its associated full Address.
     * Format: [64 bytes full Address][64 bytes signature]
     *
     * Used for deserializing signed data where both the signer's address
     * and their Schnorr signature are stored together.
     *
     * @returns A SchnorrSignature containing the address and signature
     */
    readSchnorrSignature() {
        this.verifyEnd(this.currentOffset + EXTENDED_ADDRESS_BYTE_LENGTH + SCHNORR_SIGNATURE_BYTE_LENGTH);
        const address = this.readExtendedAddress();
        const signature = this.readBytes(SCHNORR_SIGNATURE_BYTE_LENGTH);
        return { address, signature };
    }
    /**
     * Reads bytes written as [u32 length][bytes].
     * @param maxLength if > 0, enforces an upper bound
     * @param be
     */
    readBytesWithLength(maxLength = 0, be = true) {
        const length = this.readU32(be);
        if (maxLength > 0 && length > maxLength) {
            throw new Error('Data length exceeds maximum length.');
        }
        return this.readBytes(length);
    }
    // ------------------ Array readers ------------------ //
    readArrayOfBuffer(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readBytesWithLength();
        }
        return result;
    }
    readAddressArray(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readAddress();
        }
        return result;
    }
    readU256Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU256(be);
        }
        return result;
    }
    readU128Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU128(be);
        }
        return result;
    }
    readU64Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU64(be);
        }
        return result;
    }
    readU32Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU32(be);
        }
        return result;
    }
    readU16Array(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU16(be);
        }
        return result;
    }
    readU8Array() {
        const length = this.readU16(true); // by default big-endian
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readU8();
        }
        return result;
    }
    readStringArray(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readStringWithLength(be);
        }
        return result;
    }
    readBytesArray(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readBytesWithLength(0, be);
        }
        return result;
    }
    /**
     * Reads [u16 length][ (address, u256) pairs ].
     */
    readAddressValueTuple(be = true) {
        const length = this.readU16(be);
        const result = new AddressMap();
        for (let i = 0; i < length; i++) {
            const address = this.readAddress();
            const value = this.readU256(be);
            if (result.has(address)) {
                throw new Error('Duplicate address found in map');
            }
            result.set(address, value);
        }
        return result;
    }
    /**
     * Reads an array of full addresses (64 bytes each).
     * Format: [u16 length][FullAddress 0][FullAddress 1]...
     */
    readExtendedAddressArray(be = true) {
        const length = this.readU16(be);
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.readExtendedAddress();
        }
        return result;
    }
    /**
     * Reads a map of full Address -> u256 using the tweaked key for map lookup.
     * Format: [u16 length][FullAddress key][u256 value]...
     *
     * This is the equivalent of btc-runtime's readExtendedAddressMapU256().
     */
    readExtendedAddressMapU256(be = true) {
        const length = this.readU16(be);
        const result = new ExtendedAddressMap();
        for (let i = 0; i < length; i++) {
            const address = this.readExtendedAddress();
            const value = this.readU256(be);
            if (result.has(address)) {
                throw new Error('Duplicate tweaked address found in map');
            }
            result.set(address, value);
        }
        return result;
    }
    // --------------------------------------------------- //
    getOffset() {
        return this.currentOffset;
    }
    setOffset(offset) {
        this.currentOffset = offset;
    }
    /**
     * Verifies we have enough bytes in the buffer to read up to `size`.
     */
    verifyEnd(size) {
        if (size > this.buffer.byteLength) {
            throw new Error(`Attempt to read beyond buffer length: requested up to byte offset ${size}, but buffer is only ${this.buffer.byteLength} bytes.`);
        }
    }
    /**
     * Utility: reverses a byte array in-place or returns a reversed copy.
     */
    reverseBytes(bytes) {
        const out = new Uint8Array(bytes.length);
        for (let i = 0; i < bytes.length; i++) {
            out[i] = bytes[bytes.length - 1 - i];
        }
        return out;
    }
    /**
     * Utility: turn bytes into a hex string without `0x` prefix.
     */
    toHexString(bytes) {
        return Array.from(bytes, (b) => b.toString(16).padStart(2, '0')).join('');
    }
}

class BinaryWriter {
    currentOffset = 0;
    buffer;
    constructor(length = 0) {
        this.buffer = this.getDefaultBuffer(length);
    }
    static estimateArrayOfBufferLength(values) {
        if (values.length > 65535)
            throw new Error('Array size is too large');
        let totalLength = U16_BYTE_LENGTH;
        for (let i = 0; i < values.length; i++) {
            totalLength += U32_BYTE_LENGTH + values[i].length; // each entry has a u32 length prefix
        }
        return totalLength;
    }
    writeU8(value) {
        if (value > 255)
            throw new Error('u8 value is too large.');
        this.allocSafe(U8_BYTE_LENGTH);
        this.buffer.setUint8(this.currentOffset++, value);
    }
    writeU16(value, be = true) {
        if (value > 65535)
            throw new Error('u16 value is too large.');
        this.allocSafe(U16_BYTE_LENGTH);
        this.buffer.setUint16(this.currentOffset, value, !be);
        this.currentOffset += 2;
    }
    writeU32(value, be = true) {
        if (value > 4294967295)
            throw new Error('u32 value is too large.');
        this.allocSafe(U32_BYTE_LENGTH);
        this.buffer.setUint32(this.currentOffset, value, !be);
        this.currentOffset += 4;
    }
    writeU64(value, be = true) {
        if (value > 18446744073709551615n)
            throw new Error('u64 value is too large.');
        this.allocSafe(U64_BYTE_LENGTH);
        this.buffer.setBigUint64(this.currentOffset, value, !be);
        this.currentOffset += 8;
    }
    // ------------------- Signed Integer Writers ------------------- //
    /**
     * Writes a signed 8-bit integer.
     */
    writeI8(value) {
        if (value < -128 || value > 127)
            throw new Error('i8 value is out of range.');
        this.allocSafe(I8_BYTE_LENGTH);
        this.buffer.setInt8(this.currentOffset, value);
        this.currentOffset += I8_BYTE_LENGTH;
    }
    /**
     * Writes a signed 16-bit integer. By default big-endian (be = true).
     */
    writeI16(value, be = true) {
        if (value < -32768 || value > 32767)
            throw new Error('i16 value is out of range.');
        this.allocSafe(I16_BYTE_LENGTH);
        this.buffer.setInt16(this.currentOffset, value, !be);
        this.currentOffset += I16_BYTE_LENGTH;
    }
    /**
     * Writes a signed 32-bit integer. By default big-endian (be = true).
     */
    writeI32(value, be = true) {
        if (value < -2147483648 || value > 2147483647)
            throw new Error('i32 value is out of range.');
        this.allocSafe(I32_BYTE_LENGTH);
        this.buffer.setInt32(this.currentOffset, value, !be);
        this.currentOffset += I32_BYTE_LENGTH;
    }
    /**
     * Writes a signed 64-bit integer. By default big-endian (be = true).
     */
    writeI64(value, be = true) {
        if (value < -9223372036854775808n || value > 9223372036854775807n) {
            throw new Error('i64 value is out of range.');
        }
        this.allocSafe(I64_BYTE_LENGTH);
        this.buffer.setBigInt64(this.currentOffset, value, !be);
        this.currentOffset += I64_BYTE_LENGTH;
    }
    // ---------------------------------------------------------------- //
    writeSelector(value) {
        this.writeU32(value, true);
    }
    writeBoolean(value) {
        this.writeU8(value ? 1 : 0);
    }
    writeI128(bigIntValue, be = true) {
        if (bigIntValue > 170141183460469231731687303715884105727n ||
            bigIntValue < -170141183460469231731687303715884105728n) {
            throw new Error('i128 value is too large.');
        }
        this.allocSafe(I128_BYTE_LENGTH);
        const bytesToHex = BufferHelper.valueToUint8Array(bigIntValue, I128_BYTE_LENGTH);
        if (bytesToHex.byteLength !== I128_BYTE_LENGTH) {
            throw new Error(`Invalid i128 value: ${bigIntValue}`);
        }
        if (be) {
            for (let i = 0; i < bytesToHex.byteLength; i++) {
                this.writeU8(bytesToHex[i]);
            }
        }
        else {
            for (let i = bytesToHex.byteLength - 1; i >= 0; i--) {
                this.writeU8(bytesToHex[i]);
            }
        }
    }
    writeU256(bigIntValue, be = true) {
        if (bigIntValue >
            115792089237316195423570985008687907853269984665640564039457584007913129639935n &&
            bigIntValue < 0n) {
            throw new Error('u256 value is too large or negative.');
        }
        this.allocSafe(U256_BYTE_LENGTH);
        const bytesToHex = BufferHelper.valueToUint8Array(bigIntValue);
        if (bytesToHex.byteLength !== U256_BYTE_LENGTH) {
            throw new Error(`Invalid u256 value: ${bigIntValue}`);
        }
        if (be) {
            for (let i = 0; i < bytesToHex.byteLength; i++) {
                this.writeU8(bytesToHex[i]);
            }
        }
        else {
            for (let i = bytesToHex.byteLength - 1; i >= 0; i--) {
                this.writeU8(bytesToHex[i]);
            }
        }
    }
    writeU128(bigIntValue, be = true) {
        if (bigIntValue > 340282366920938463463374607431768211455n && bigIntValue < 0n) {
            throw new Error('u128 value is too large or negative.');
        }
        this.allocSafe(U128_BYTE_LENGTH);
        const bytesToHex = BufferHelper.valueToUint8Array(bigIntValue, U128_BYTE_LENGTH);
        if (bytesToHex.byteLength !== U128_BYTE_LENGTH) {
            throw new Error(`Invalid u128 value: ${bigIntValue}`);
        }
        if (be) {
            for (let i = 0; i < bytesToHex.byteLength; i++) {
                this.writeU8(bytesToHex[i]);
            }
        }
        else {
            for (let i = bytesToHex.byteLength - 1; i >= 0; i--) {
                this.writeU8(bytesToHex[i]);
            }
        }
    }
    writeBytes(value) {
        this.allocSafe(value.byteLength);
        for (let i = 0; i < value.byteLength; i++) {
            this.writeU8(value[i]);
        }
    }
    writeString(value) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(value);
        this.allocSafe(bytes.length);
        this.writeBytes(bytes);
    }
    writeStringWithLength(value) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(value);
        this.allocSafe(U32_BYTE_LENGTH + bytes.length);
        this.writeU32(bytes.length);
        this.writeBytes(bytes);
    }
    /**
     * Writes an address (32 bytes MLDSA key hash only).
     */
    writeAddress(value) {
        this.verifyAddress(value);
        this.writeBytes(value);
    }
    /**
     * Writes the tweaked public key from an Address (32 bytes).
     * @param value - The Address containing the tweaked public key
     */
    writeTweakedPublicKey(value) {
        const tweakedKey = value.tweakedPublicKeyToBuffer();
        this.allocSafe(ADDRESS_BYTE_LENGTH);
        this.writeBytes(tweakedKey);
    }
    /**
     * Writes a full address with both tweaked public key and MLDSA key hash (64 bytes total).
     * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
     *
     * This is the equivalent of btc-runtime's writeExtendedAddress().
     *
     * @param value - The Address containing both keys
     */
    writeExtendedAddress(value) {
        this.allocSafe(EXTENDED_ADDRESS_BYTE_LENGTH);
        // Write tweaked public key first (32 bytes)
        this.writeTweakedPublicKey(value);
        // Write MLDSA key hash (32 bytes)
        this.writeBytes(value);
    }
    /**
     * Writes a Schnorr signature with its associated full Address.
     * Format: [64 bytes full Address][64 bytes signature]
     *
     * Used for serializing signed data where both the signer's address
     * and their Schnorr signature need to be stored together.
     *
     * @param address - The signer's Address (with both MLDSA and tweaked keys)
     * @param signature - The 64-byte Schnorr signature
     * @throws {Error} If signature is not exactly 64 bytes
     */
    writeSchnorrSignature(address, signature) {
        if (signature.length !== SCHNORR_SIGNATURE_BYTE_LENGTH) {
            throw new Error(`Invalid Schnorr signature length: expected ${SCHNORR_SIGNATURE_BYTE_LENGTH}, got ${signature.length}`);
        }
        this.allocSafe(EXTENDED_ADDRESS_BYTE_LENGTH + SCHNORR_SIGNATURE_BYTE_LENGTH);
        this.writeExtendedAddress(address);
        this.writeBytes(signature);
    }
    getBuffer(clear = true) {
        const buf = new Uint8Array(this.buffer.byteLength);
        for (let i = 0; i < this.buffer.byteLength; i++) {
            buf[i] = this.buffer.getUint8(i);
        }
        if (clear)
            this.clear();
        return buf;
    }
    reset() {
        this.currentOffset = 0;
        this.buffer = this.getDefaultBuffer(4);
    }
    toBytesReader() {
        return new BinaryReader(this.getBuffer());
    }
    getOffset() {
        return this.currentOffset;
    }
    setOffset(offset) {
        this.currentOffset = offset;
    }
    clear() {
        this.currentOffset = 0;
        this.buffer = this.getDefaultBuffer();
    }
    [Symbol.dispose]() {
        this.clear();
    }
    allocSafe(size) {
        if (this.currentOffset + size > this.buffer.byteLength) {
            this.resize(size);
        }
    }
    writeAddressValueTuple(map, be = true) {
        if (map.size > 65535)
            throw new Error('Map size is too large');
        this.writeU16(map.size, be);
        const keys = Array.from(map.keys());
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const value = map.get(key);
            if (value === null || value === undefined)
                throw new Error('Value not found');
            this.writeAddress(key);
            this.writeU256(value, be);
        }
    }
    /**
     * Writes a map of full Address -> u256 using the tweaked key for map lookup.
     * Format: [u16 length][FullAddress key][u256 value]...
     *
     * This is the equivalent of btc-runtime's writeExtendedAddressMapU256().
     */
    writeExtendedAddressMapU256(map, be = true) {
        if (map.size > 65535)
            throw new Error('Map size is too large');
        this.writeU16(map.size, be);
        for (const [key, value] of map.entries()) {
            this.writeExtendedAddress(key);
            this.writeU256(value, be);
        }
    }
    writeBytesWithLength(value) {
        this.writeU32(value.length);
        this.writeBytes(value);
    }
    writeArrayOfBuffer(values, be = true) {
        const totalLength = BinaryWriter.estimateArrayOfBufferLength(values);
        this.allocSafe(totalLength);
        this.writeU16(values.length, be);
        for (let i = 0; i < values.length; i++) {
            this.writeU32(values[i].length, be);
            this.writeBytes(values[i]);
        }
    }
    writeAddressArray(value) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeAddress(value[i]);
        }
    }
    /**
     * Writes an array of full addresses (64 bytes each).
     * Format: [u16 length][FullAddress 0][FullAddress 1]...
     */
    writeExtendedAddressArray(value) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.allocSafe(U16_BYTE_LENGTH + value.length * EXTENDED_ADDRESS_BYTE_LENGTH);
        this.writeU16(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeExtendedAddress(value[i]);
        }
    }
    writeU32Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU32(value[i], be);
        }
    }
    writeU256Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU256(value[i], be);
        }
    }
    writeU128Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU128(value[i], be);
        }
    }
    writeStringArray(value) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeStringWithLength(value[i]);
        }
    }
    writeU16Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU16(value[i], be);
        }
    }
    writeU8Array(value) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeU8(value[i]);
        }
    }
    writeU64Array(value, be = true) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length, be);
        for (let i = 0; i < value.length; i++) {
            this.writeU64(value[i], be);
        }
    }
    writeBytesArray(value) {
        if (value.length > 65535)
            throw new Error('Array size is too large');
        this.writeU16(value.length);
        for (let i = 0; i < value.length; i++) {
            this.writeBytesWithLength(value[i]);
        }
    }
    verifyAddress(pubKey) {
        if (pubKey.byteLength > ADDRESS_BYTE_LENGTH) {
            throw new Error(`Address is too long ${pubKey.byteLength} > ${ADDRESS_BYTE_LENGTH} bytes`);
        }
    }
    resize(size) {
        const buf = new Uint8Array(this.buffer.byteLength + size);
        for (let i = 0; i < this.buffer.byteLength; i++) {
            buf[i] = this.buffer.getUint8(i);
        }
        this.buffer = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    getDefaultBuffer(length = 0) {
        return new DataView(new ArrayBuffer(length));
    }
}

/** Bitcoin Script Generator */
class Generator {
    /**
     * The maximum size of a data chunk
     */
    static DATA_CHUNK_SIZE = 512;
    /**
     * The magic number of OPNet
     */
    static MAGIC = fromUtf8$1('op');
    /**
     * The public key of the sender
     * @protected
     */
    senderPubKey;
    /**
     * The public key of the sender
     * @protected
     */
    xSenderPubKey;
    /**
     * The public key of the contract salt
     * @protected
     */
    contractSaltPubKey;
    /**
     * The network to use
     * @protected
     */
    network = bitcoin$1;
    constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
        this.senderPubKey = senderPubKey;
        this.contractSaltPubKey = contractSaltPubKey;
        this.network = network;
        this.xSenderPubKey = toXOnly(senderPubKey);
    }
    buildHeader(features) {
        let flags = 0;
        for (const feature of features) {
            flags |= feature;
        }
        const bytesU24 = alloc(3);
        bytesU24[0] = (flags >> 16) & 0xff;
        bytesU24[1] = (flags >> 8) & 0xff;
        bytesU24[2] = flags & 0xff;
        return Uint8Array.from([this.senderPubKey[0], ...bytesU24]);
    }
    getHeader(maxPriority, features = []) {
        const writer = new BinaryWriter(12);
        writer.writeBytes(this.buildHeader(features));
        writer.writeU64(maxPriority);
        return new Uint8Array(writer.getBuffer());
    }
    /**
     * Split a buffer into chunks
     * @param {Uint8Array} buffer - The buffer to split
     * @param {number} chunkSize - The size of each chunk
     * @protected
     * @returns {Array<Uint8Array[]>} - The chunks
     */
    splitBufferIntoChunks(buffer, chunkSize = Generator.DATA_CHUNK_SIZE) {
        const chunks = [];
        for (let i = 0; i < buffer.length; i += chunkSize) {
            const dataLength = Math.min(chunkSize, buffer.length - i);
            const buf2 = alloc(dataLength);
            for (let j = 0; j < dataLength; j++) {
                buf2[j] = buffer[i + j];
            }
            chunks.push([buf2]);
        }
        return chunks;
    }
    encodeFeature(feature, finalBuffer) {
        switch (feature.opcode) {
            case Features.ACCESS_LIST: {
                return this.encodeAccessListFeature(feature, finalBuffer);
            }
            case Features.EPOCH_SUBMISSION: {
                return this.encodeChallengeSubmission(feature, finalBuffer);
            }
            case Features.MLDSA_LINK_PUBKEY: {
                return this.encodeLinkRequest(feature, finalBuffer);
            }
            default:
                throw new Error(`Unknown feature type: ${feature.opcode}`);
        }
    }
    encodeAccessListFeature(feature, finalBuffer) {
        const writer = new BinaryWriter();
        writer.writeU16(Object.keys(feature.data).length);
        for (const contract in feature.data) {
            const parsedContract = Address.fromString(contract);
            const data = feature.data[contract];
            writer.writeAddress(parsedContract);
            writer.writeU32(data.length);
            for (const pointer of data) {
                const pointerBuffer = Uint8Array.from(atob(pointer), (c) => c.charCodeAt(0));
                if (pointerBuffer.length !== 32) {
                    throw new Error(`Invalid pointer length: ${pointerBuffer.length}`);
                }
                writer.writeBytes(pointerBuffer);
            }
        }
        finalBuffer.writeBytesWithLength(Compressor.compress(new Uint8Array(writer.getBuffer())));
    }
    encodeChallengeSubmission(feature, finalBuffer) {
        if ('verifySignature' in feature.data && !feature.data.verifySignature()) {
            throw new Error('Invalid signature in challenge submission feature');
        }
        const writer = new BinaryWriter();
        writer.writeBytes(feature.data.publicKey.toBuffer());
        writer.writeBytes(feature.data.solution);
        if (feature.data.graffiti) {
            writer.writeBytesWithLength(feature.data.graffiti);
        }
        finalBuffer.writeBytesWithLength(writer.getBuffer());
    }
    encodeLinkRequest(feature, finalBuffer) {
        const data = feature.data;
        const writer = new BinaryWriter();
        writer.writeU8(data.level);
        writer.writeBytes(data.hashedPublicKey);
        writer.writeBoolean(data.verifyRequest);
        if (data.verifyRequest) {
            if (!data.publicKey || !data.mldsaSignature) {
                throw new Error('MLDSA public key and signature required when verifyRequest is true');
            }
            writer.writeBytes(data.publicKey);
            writer.writeBytes(data.mldsaSignature);
        }
        if (!data.legacySignature || data.legacySignature.length !== 64) {
            throw new Error('Legacy signature must be exactly 64 bytes');
        }
        writer.writeBytes(data.legacySignature);
        finalBuffer.writeBytesWithLength(writer.getBuffer());
    }
}

/**
 * Class to generate bitcoin script for interaction transactions
 */
class CalldataGenerator extends Generator {
    constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
        super(senderPubKey, contractSaltPubKey, network);
    }
    /**
     * Get the public key as a buffer
     * @param {Uint8Array[]} witnessKeys - The public keys
     * @param {Network} network - The network to use
     * @private
     * @returns {Uint8Array} - The public key as a buffer
     */
    static getPubKeyAsBuffer(witnessKeys, network) {
        let finalBuffer = new Uint8Array(0);
        for (const pubKey of witnessKeys) {
            const key = EcKeyPair.fromPublicKey(pubKey, network);
            if (!key.compressed) {
                throw new Error('Public key must be compressed');
            }
            if (pubKey.byteLength !== 33) {
                throw new Error(`Public key must be 33 bytes, got ${pubKey.byteLength} bytes.`);
            }
            finalBuffer = concat$1([finalBuffer, pubKey]);
        }
        // compress the public keys
        const compressed = Compressor.compress(finalBuffer);
        if (compressed.byteLength >= finalBuffer.byteLength) {
            // we ensure that the user pays the smallest amount of fees. [micro-optimization]
            return finalBuffer;
        }
        // if compressed is smaller, return compressed.
        return compressed;
    }
    /**
     * Compile an interaction bitcoin script
     * @param {Uint8Array} calldata - The calldata to use
     * @param {Uint8Array} contractSecret - The contract secret
     * @param {IChallengeSolution} challenge
     * @param maxPriority - Amount of satoshis to spend max on priority fee
     * @param {Feature<Features>[]} featuresRaw - The features to use
     * @returns {Uint8Array} - The compiled script
     * @throws {Error} - If something goes wrong
     */
    compile(calldata, contractSecret, challenge, maxPriority, featuresRaw = []) {
        if (!this.contractSaltPubKey)
            throw new Error('Contract salt public key not set');
        const dataChunks = this.splitBufferIntoChunks(calldata);
        if (!dataChunks.length)
            throw new Error('No data chunks found');
        const featuresList = [];
        const featureData = [];
        if (featuresRaw && featuresRaw.length) {
            const features = featuresRaw.sort((a, b) => a.priority - b.priority);
            const finalBuffer = new BinaryWriter();
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                featuresList.push(feature.opcode);
                this.encodeFeature(feature, finalBuffer);
            }
            featureData.push(...this.splitBufferIntoChunks(new Uint8Array(finalBuffer.getBuffer())));
        }
        let compiledData = [
            this.getHeader(maxPriority, featuresList),
            opcodes.OP_TOALTSTACK,
            // CHALLENGE PREIMAGE FOR REWARD,
            challenge.publicKey.toBuffer(),
            opcodes.OP_TOALTSTACK,
            challenge.solution,
            opcodes.OP_TOALTSTACK,
            this.xSenderPubKey,
            opcodes.OP_DUP,
            opcodes.OP_HASH256,
            hash256(this.xSenderPubKey),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_CHECKSIGVERIFY,
            this.contractSaltPubKey,
            opcodes.OP_CHECKSIGVERIFY,
            opcodes.OP_HASH160,
            hash160(contractSecret),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_DEPTH,
            opcodes.OP_1,
            opcodes.OP_NUMEQUAL,
            opcodes.OP_IF,
            Generator.MAGIC,
        ];
        // Write calldata
        compiledData = compiledData.concat(...featureData, ...[opcodes.OP_1NEGATE, ...dataChunks, opcodes.OP_ELSE, opcodes.OP_1, opcodes.OP_ENDIF]);
        const asm = compiledData.flat();
        const compiled = compile(asm);
        /** Verify the validity of the script */
        const decompiled = decompile(compiled);
        if (!decompiled) {
            throw new Error('Failed to decompile script??');
        }
        return compiled;
    }
}

/**
 * Class to generate bitcoin script for interaction transactions
 */
class CustomGenerator extends Generator {
    constructor(senderPubKey, network = bitcoin$1) {
        super(senderPubKey, undefined, network);
    }
    /**
     * Compile an interaction bitcoin script
     * @param compiledData - The compiled data
     * @returns {Uint8Array} - The compiled script
     * @throws {Error} - If something goes wrong
     */
    compile(compiledData) {
        const asm = compiledData.flat();
        const compiled = compile(asm);
        /** Verify the validity of the script */
        const decompiled = decompile(compiled);
        if (!decompiled) {
            throw new Error('Failed to decompile script??');
        }
        return compiled;
    }
}

const OPNET_DEPLOYMENT_VERSION = 0x00;
const versionBuffer = Uint8Array.from([OPNET_DEPLOYMENT_VERSION]);
class DeploymentGenerator extends Generator {
    constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
        super(senderPubKey, contractSaltPubKey, network);
    }
    /**
     * Compile a bitcoin script representing a contract deployment
     * @param {Uint8Array} contractBytecode - The contract bytecode
     * @param {Uint8Array} contractSalt - The contract salt
     * @param {ChallengeSolution} challenge - The challenge for reward
     * @param {bigint} maxPriority - The maximum priority for the contract
     * @param {Uint8Array} [calldata] - The calldata to be passed to the contract
     * @param {Feature<Features>[]} [features] - Optional features to include in the script
     * @returns {Uint8Array} - The compiled script
     */
    compile(contractBytecode, contractSalt, challenge, maxPriority, calldata, features) {
        const asm = this.getAsm(contractBytecode, contractSalt, challenge, maxPriority, calldata, features);
        const compiled = compile(asm);
        /**
         * Verify that the script can be decompiled
         */
        const decompiled = decompile(compiled);
        if (!decompiled) {
            throw new Error('Failed to decompile script??');
        }
        return compiled;
    }
    getAsm(contractBytecode, contractSalt, challenge, maxPriority, calldata, featuresRaw) {
        if (!this.contractSaltPubKey)
            throw new Error('Contract salt public key not set');
        const dataChunks = this.splitBufferIntoChunks(contractBytecode);
        const calldataChunks = calldata ? this.splitBufferIntoChunks(calldata) : [];
        const featuresList = [];
        const featureData = [];
        if (featuresRaw && featuresRaw.length) {
            const features = featuresRaw.sort((a, b) => a.priority - b.priority);
            const finalBuffer = new BinaryWriter();
            for (let i = 0; i < features.length; i++) {
                const feature = features[i];
                featuresList.push(feature.opcode);
                this.encodeFeature(feature, finalBuffer);
            }
            featureData.push(...this.splitBufferIntoChunks(new Uint8Array(finalBuffer.getBuffer())));
        }
        const compiledData = [
            this.getHeader(maxPriority, featuresList),
            opcodes.OP_TOALTSTACK,
            // CHALLENGE PREIMAGE FOR REWARD,
            challenge.publicKey.toBuffer(),
            opcodes.OP_TOALTSTACK,
            challenge.solution,
            opcodes.OP_TOALTSTACK,
            this.xSenderPubKey,
            opcodes.OP_DUP,
            opcodes.OP_HASH256,
            hash256(this.xSenderPubKey),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_CHECKSIGVERIFY,
            this.contractSaltPubKey,
            opcodes.OP_CHECKSIGVERIFY,
            opcodes.OP_HASH256,
            hash256(contractSalt),
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_DEPTH,
            opcodes.OP_1,
            opcodes.OP_NUMEQUAL,
            opcodes.OP_IF,
            Generator.MAGIC,
            ...featureData,
            opcodes.OP_0,
            ...calldataChunks,
            opcodes.OP_1NEGATE,
            ...dataChunks,
            opcodes.OP_ELSE,
            opcodes.OP_1,
            opcodes.OP_ENDIF,
        ];
        return compiledData.flat();
    }
}

function lightenColor(color, percent) {
    color = color.replace('#', '');
    const num = parseInt(color, 16), amt = Math.round(2.55 * percent), R = (num >> 16) + amt, B = ((num >> 8) & 0x00ff) + amt, G = (num & 0x0000ff) + amt;
    return (0x1000000 +
        (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
        (B < 255 ? (B < 1 ? 0 : B) : 255) * 0x100 +
        (G < 255 ? (G < 1 ? 0 : G) : 255))
        .toString(16)
        .slice(1);
}

const ANSI_BACKGROUND_OFFSET = 10;

const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;

const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

const styles$1 = {
	modifier: {
		reset: [0, 0],
		// 21 isn't widely supported and 22 does the same thing
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],

		// Bright color
		blackBright: [90, 39],
		gray: [90, 39], // Alias of `blackBright`
		grey: [90, 39], // Alias of `blackBright`
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],

		// Bright color
		bgBlackBright: [100, 49],
		bgGray: [100, 49], // Alias of `bgBlackBright`
		bgGrey: [100, 49], // Alias of `bgBlackBright`
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};

Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
[...foregroundColorNames, ...backgroundColorNames];

function assembleStyles() {
	const codes = new Map();

	for (const [groupName, group] of Object.entries(styles$1)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$1[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};

			group[styleName] = styles$1[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles$1, groupName, {
			value: group,
			enumerable: false,
		});
	}

	Object.defineProperty(styles$1, 'codes', {
		value: codes,
		enumerable: false,
	});

	styles$1.color.close = '\u001B[39m';
	styles$1.bgColor.close = '\u001B[49m';

	styles$1.color.ansi = wrapAnsi16();
	styles$1.color.ansi256 = wrapAnsi256();
	styles$1.color.ansi16m = wrapAnsi16m();
	styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	Object.defineProperties(styles$1, {
		rgbToAnsi256: {
			value(red, green, blue) {
				// We use the extended greyscale palette here, with the exception of
				// black and white. normal palette only has 4 greyscale shades.
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}

					if (red > 248) {
						return 231;
					}

					return Math.round(((red - 8) / 247) * 24) + 232;
				}

				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}

				let [colorString] = matches;

				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}

				const integer = Number.parseInt(colorString, 16);

				return [
					/* eslint-disable no-bitwise */
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
					/* eslint-enable no-bitwise */
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) {
					return 30 + code;
				}

				if (code < 16) {
					return 90 + (code - 8);
				}

				let red;
				let green;
				let blue;

				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;

					const remainder = code % 36;

					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}

				const value = Math.max(red, green, blue) * 2;

				if (value === 0) {
					return 30;
				}

				// eslint-disable-next-line no-bitwise
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));

				if (value === 2) {
					result += 60;
				}

				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
			enumerable: false,
		},
	});

	return styles$1;
}

const ansiStyles = assembleStyles();

const level = (() => {
  if (!("navigator" in globalThis)) {
    return 0;
  }
  if (globalThis.navigator.userAgentData) {
    const brand = navigator.userAgentData.brands.find(({ brand: brand2 }) => brand2 === "Chromium");
    if (brand && brand.version > 93) {
      return 3;
    }
  }
  if (/\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent)) {
    return 1;
  }
  return 0;
})();
const colorSupport = level !== 0 && {
  level};
const supportsColor = {
  stdout: colorSupport,
  stderr: colorSupport
};

// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.slice(endIndex, (gotCR ? index - 1 : index)) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

const {stdout: stdoutColor, stderr: stderrColor} = supportsColor;

const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');

// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m',
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class Chalk {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = (...strings) => strings.join(' ');
	applyOptions(chalk, options);

	Object.setPrototypeOf(chalk, createChalk.prototype);

	return chalk;
};

function createChalk(options) {
	return chalkFactory(options);
}

Object.setPrototypeOf(createChalk.prototype, Function.prototype);

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		},
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this[STYLER], true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	},
};

const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === 'rgb') {
		if (level === 'ansi16m') {
			return ansiStyles[type].ansi16m(...arguments_);
		}

		if (level === 'ansi256') {
			return ansiStyles[type].ansi256(ansiStyles.rgbToAnsi256(...arguments_));
		}

		return ansiStyles[type].ansi(ansiStyles.rgbToAnsi(...arguments_));
	}

	if (model === 'hex') {
		return getModelAnsi('rgb', level, type, ...ansiStyles.hexToRgb(...arguments_));
	}

	return ansiStyles[type][model](...arguments_);
};

const usedModels = ['rgb', 'hex', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), ansiStyles.color.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), ansiStyles.bgColor.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		},
	},
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent,
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	// Single argument is hot path, implicit coercion is faster than anything
	// eslint-disable-next-line no-implicit-coercion
	const builder = (...arguments_) => applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self[IS_EMPTY] ? '' : string;
	}

	let styler = self[STYLER];

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.includes('\u001B')) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

Object.defineProperties(createChalk.prototype, styles);

createChalk();
createChalk({level: stderrColor ? stderrColor.level : 0});

var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SharedLogger_pink, _SharedLogger_lightPink, _SharedLogger_purple, _SharedLogger_lightPurple, _SharedLogger_lighterPurple, _SharedLogger_green, _SharedLogger_lightGreen, _SharedLogger_moca, _SharedLogger_lightMoca, _SharedLogger_orange, _SharedLogger_lightOrange, _SharedLogger_red, _SharedLogger_lightRed, _SharedLogger_white, _SharedLogger_lightWhite, _SharedLogger_darkred, _SharedLogger_lightdarkred;
class SharedLogger {
    constructor(chalk = new Chalk()) {
        this.chalk = chalk;
        this.moduleName = '';
        this.logColor = '#00bfff';
        this.enableLogs = true;
        this.hideLogs = false;
        _SharedLogger_pink.set(this, '#ff00ff');
        _SharedLogger_lightPink.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_pink, "f"), 75));
        _SharedLogger_purple.set(this, '#9400d3');
        _SharedLogger_lightPurple.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_purple, "f"), 15));
        _SharedLogger_lighterPurple.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_lightPurple, "f"), 15));
        _SharedLogger_green.set(this, '#7cfc00');
        _SharedLogger_lightGreen.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_green, "f"), 15));
        _SharedLogger_moca.set(this, '#ffdead');
        _SharedLogger_lightMoca.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_moca, "f"), 15));
        _SharedLogger_orange.set(this, '#ff8c00');
        _SharedLogger_lightOrange.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_orange, "f"), 15));
        _SharedLogger_red.set(this, '#ff4500');
        _SharedLogger_lightRed.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_red, "f"), 15));
        _SharedLogger_white.set(this, '#ffffff');
        _SharedLogger_lightWhite.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_white, "f"), 15));
        _SharedLogger_darkred.set(this, '#8b0000');
        _SharedLogger_lightdarkred.set(this, lightenColor(__classPrivateFieldGet(this, _SharedLogger_darkred, "f"), 15));
        this.prefix = '';
        this.moduleName = this.constructor.name;
    }
    setLogPrefix(prefix) {
        this.prefix = prefix;
    }
    getStartPrefix() {
        return this.prefix;
    }
    disable() {
        this.enableLogs = false;
    }
    enable() {
        this.enableLogs = true;
    }
    fancyLog(msg1, highlight1, msg2, highlight2, msg3) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_pink, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(msg1) +
            ' ' +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightOrange, "f"))(highlight1) +
            ' ' +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(msg2) +
            ' ' +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lighterPurple, "f"))(highlight2) +
            ' ' +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(msg3));
    }
    log(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            const light = lightenColor(this.logColor, 15);
            console.log(this.chalk.hex(this.logColor)(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(light)(...args));
        }
    }
    lightOrangeLog(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightOrange, "f"))(`${this.getStartPrefix()}[${this.moduleName} LOG]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(...args));
        }
    }
    error(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_red, "f"))(`${this.getStartPrefix()}[${this.moduleName} ERROR]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightRed, "f"))(...args));
    }
    warn(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_orange, "f"))(`${this.getStartPrefix()}[${this.moduleName} WARN]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightOrange, "f"))(...args));
    }
    debug(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_moca, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) +
                this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightMoca, "f"))(...args));
        }
    }
    success(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_green, "f"))(`${this.getStartPrefix()}[${this.moduleName} SUCCESS]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightGreen, "f"))(...args));
        }
    }
    fail(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_red, "f"))(`${this.getStartPrefix()}[${this.moduleName} FAIL]: `) +
                this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightRed, "f"))(...args));
        }
    }
    debugBright(...args) {
        if (!this.enableLogs)
            return;
        if (!this.hideLogs) {
            console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_purple, "f"))(`${this.getStartPrefix()}[${this.moduleName} DEBUG]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightPurple, "f"))(...args));
        }
    }
    important(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_pink, "f"))(`${this.getStartPrefix()}[${this.moduleName} IMPORTANT]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightPink, "f"))(...args));
    }
    panic(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_darkred, "f"))(`${this.getStartPrefix()}[${this.moduleName} HELP PANIC]: `) + this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightdarkred, "f"))(...args));
    }
    info(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_pink, "f"))(`${this.getStartPrefix()}[${this.moduleName} INFO]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_white, "f"))(...args));
    }
    securityNotice(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex('#22d8e6')(`${this.getStartPrefix()}[${this.moduleName} SECURITY NOTICE]: `) + this.chalk.hex('#22e3e6')(...args));
    }
    traceLog(...args) {
        if (!this.enableLogs)
            return;
        console.log(this.chalk.hex('#ffffff')(`${this.getStartPrefix()}[${this.moduleName} TRACE LOG]: `) +
            this.chalk.hex(__classPrivateFieldGet(this, _SharedLogger_lightWhite, "f"))(...args));
    }
}
_SharedLogger_pink = new WeakMap(), _SharedLogger_lightPink = new WeakMap(), _SharedLogger_purple = new WeakMap(), _SharedLogger_lightPurple = new WeakMap(), _SharedLogger_lighterPurple = new WeakMap(), _SharedLogger_green = new WeakMap(), _SharedLogger_lightGreen = new WeakMap(), _SharedLogger_moca = new WeakMap(), _SharedLogger_lightMoca = new WeakMap(), _SharedLogger_orange = new WeakMap(), _SharedLogger_lightOrange = new WeakMap(), _SharedLogger_red = new WeakMap(), _SharedLogger_lightRed = new WeakMap(), _SharedLogger_white = new WeakMap(), _SharedLogger_lightWhite = new WeakMap(), _SharedLogger_darkred = new WeakMap(), _SharedLogger_lightdarkred = new WeakMap();

class Logger extends SharedLogger {
    constructor() {
        super();
    }
}

var DebugLevel;
(function (DebugLevel) {
    DebugLevel[DebugLevel["NONE"] = 0] = "NONE";
    DebugLevel[DebugLevel["ERROR"] = 1] = "ERROR";
    DebugLevel[DebugLevel["WARN"] = 2] = "WARN";
    DebugLevel[DebugLevel["INFO"] = 3] = "INFO";
    DebugLevel[DebugLevel["DEBUG"] = 4] = "DEBUG";
    DebugLevel[DebugLevel["TRACE"] = 5] = "TRACE";
    DebugLevel[DebugLevel["ALL"] = 6] = "ALL";
})(DebugLevel || (DebugLevel = {}));

/**
 * Generates hash-committed P2WSH addresses for the Consolidated Hash-Committed Transaction (CHCT) system.
 *
 * These P2WSH scripts enforce that specific data must be provided in the witness to spend the output.
 * If data is stripped or modified, the transaction fails at Bitcoin consensus level.
 *
 * Witness Script Structure (58 bytes):
 * OP_HASH160 <20-byte-hash> OP_EQUALVERIFY <33-byte-pubkey> OP_CHECKSIG
 *
 * Witness Stack (when spending):
 * [signature, data_chunk, witnessScript]
 */
class HashCommitmentGenerator extends Logger {
    /**
     * Maximum chunk size per Bitcoin P2WSH stack item limit.
     * See policy.h: MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80
     */
    static MAX_CHUNK_SIZE = 80;
    /**
     * Maximum stack items per P2WSH input.
     * See policy.h: MAX_STANDARD_P2WSH_STACK_ITEMS = 100
     */
    static MAX_STACK_ITEMS = 100;
    /**
     * Maximum total witness size (serialized).
     * See policy.cpp: GetSerializeSize(tx.vin[i].scriptWitness.stack) > g_script_size_policy_limit
     * Default: 1650 bytes
     */
    static MAX_WITNESS_SIZE = 1650;
    /** Maximum weight per standard transaction */
    static MAX_STANDARD_WEIGHT = 400000;
    /** Minimum satoshis per output (dust limit) */
    static MIN_OUTPUT_VALUE = 330n;
    /**
     * Bytes per hash commitment in witness script.
     * OP_HASH160 (1) + push (1) + hash (20) + OP_EQUALVERIFY (1) = 23 bytes
     */
    static BYTES_PER_COMMITMENT = 23;
    /**
     * Fixed overhead in witness serialization:
     * - Stack item count: 1 byte
     * - Signature: 73 bytes (72 + 1 length prefix)
     * - Script length prefix: 3 bytes (varInt for sizes 253-65535)
     * - Script base (pubkey + checksig): 35 bytes
     */
    static WITNESS_FIXED_OVERHEAD = 1 + 73 + 3 + 35;
    /**
     * Per-chunk overhead in witness:
     * - Data: 81 bytes (80 + 1 length prefix)
     * - Script commitment: 23 bytes
     * Total: 104 bytes per chunk
     */
    static WITNESS_PER_CHUNK_OVERHEAD = HashCommitmentGenerator.MAX_CHUNK_SIZE + 1 + HashCommitmentGenerator.BYTES_PER_COMMITMENT;
    /**
     * Maximum data chunks per P2WSH output.
     * Limited by total witness size: (1650 - 112) / 104 = 14 chunks
     */
    static MAX_CHUNKS_PER_OUTPUT = Math.floor((HashCommitmentGenerator.MAX_WITNESS_SIZE -
        HashCommitmentGenerator.WITNESS_FIXED_OVERHEAD) /
        HashCommitmentGenerator.WITNESS_PER_CHUNK_OVERHEAD);
    /** Base weight per input (non-witness): 41 bytes * 4 = 164 */
    static INPUT_BASE_WEIGHT = 164;
    /**
     * Witness weight per input with max chunks:
     * Total witness size is ~1566 bytes (under 1650 limit)
     * Witness bytes count as 1 weight unit each.
     */
    static INPUT_WITNESS_WEIGHT_MAX = HashCommitmentGenerator.MAX_WITNESS_SIZE; // Use max as upper bound
    /** Total weight per input (with max chunks) */
    static WEIGHT_PER_INPUT = HashCommitmentGenerator.INPUT_BASE_WEIGHT +
        HashCommitmentGenerator.INPUT_WITNESS_WEIGHT_MAX;
    logColor = '#4a90d9';
    publicKey;
    network;
    constructor(publicKey, network = bitcoin$1) {
        super();
        if (publicKey.length !== 33) {
            throw new Error('Public key must be 33 bytes (compressed)');
        }
        this.publicKey = publicKey;
        this.network = network;
    }
    /**
     * Calculate the maximum number of inputs per standard reveal transaction.
     *
     * Standard tx weight limit: 400,000
     * With max chunks per input (~10,385 weight), only ~38 inputs fit
     *
     * @returns Maximum inputs per reveal tx (~38 with max chunks)
     */
    static calculateMaxInputsPerTx() {
        const txOverhead = 40; // version, locktime, input/output counts
        const outputOverhead = 200; // typical outputs (contract, change)
        const availableWeight = HashCommitmentGenerator.MAX_STANDARD_WEIGHT - txOverhead - outputOverhead;
        return Math.floor(availableWeight / HashCommitmentGenerator.WEIGHT_PER_INPUT);
    }
    /**
     * Calculate maximum data per standard reveal transaction.
     *
     * @returns Maximum data in bytes (~300KB with batched chunks at 70 chunks/output)
     */
    static calculateMaxDataPerTx() {
        return (HashCommitmentGenerator.calculateMaxInputsPerTx() *
            HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT *
            HashCommitmentGenerator.MAX_CHUNK_SIZE);
    }
    /**
     * Estimate the number of P2WSH outputs needed for a given data size.
     *
     * @param dataSize Data size in bytes
     * @returns Number of P2WSH outputs needed
     */
    static estimateOutputCount(dataSize) {
        return Math.ceil(dataSize /
            (HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT *
                HashCommitmentGenerator.MAX_CHUNK_SIZE));
    }
    /**
     * Estimate the number of 80-byte chunks for a given data size.
     *
     * @param dataSize Data size in bytes
     * @returns Number of 80-byte chunks needed
     */
    static estimateChunkCount(dataSize) {
        return Math.ceil(dataSize / HashCommitmentGenerator.MAX_CHUNK_SIZE);
    }
    /**
     * Validate that a witness script is a valid multi-hash committed script.
     *
     * Script structure: (OP_HASH160 <hash> OP_EQUALVERIFY)+ <pubkey> OP_CHECKSIG
     *
     * @param witnessScript The witness script to validate
     * @returns true if valid hash-committed script
     */
    static validateHashCommittedScript(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled || decompiled.length < 5) {
                return false;
            }
            // Last two elements must be pubkey and OP_CHECKSIG
            const lastIdx = decompiled.length - 1;
            if (decompiled[lastIdx] !== opcodes.OP_CHECKSIG) {
                return false;
            }
            const pubkey = decompiled[lastIdx - 1];
            if (!(pubkey instanceof Uint8Array) || pubkey.length !== 33) {
                return false;
            }
            // Everything before must be (OP_HASH160 <hash> OP_EQUALVERIFY) triplets
            const hashParts = decompiled.slice(0, -2);
            if (hashParts.length % 3 !== 0 || hashParts.length === 0) {
                return false;
            }
            for (let i = 0; i < hashParts.length; i += 3) {
                const hash = hashParts[i + 1];
                if (hashParts[i] !== opcodes.OP_HASH160 ||
                    !(hash instanceof Uint8Array) ||
                    hash.length !== 20 ||
                    hashParts[i + 2] !== opcodes.OP_EQUALVERIFY) {
                    return false;
                }
            }
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Extract all data hashes from a hash-committed witness script.
     *
     * @param witnessScript The witness script
     * @returns Array of 20-byte data hashes (in data order), or null if invalid
     */
    static extractDataHashes(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled ||
                !HashCommitmentGenerator.validateHashCommittedScript(witnessScript)) {
                return null;
            }
            // Extract hashes from triplets (they're in reverse order in script)
            const hashParts = decompiled.slice(0, -2);
            const hashes = [];
            for (let i = 0; i < hashParts.length; i += 3) {
                hashes.push(hashParts[i + 1]);
            }
            // Reverse to get data order (script has them reversed)
            return hashes.reverse();
        }
        catch {
            return null;
        }
    }
    /**
     * Extract the public key from a hash-committed witness script.
     *
     * @param witnessScript The witness script
     * @returns The 33-byte public key, or null if invalid script
     */
    static extractPublicKey(witnessScript) {
        try {
            const decompiled = decompile(witnessScript);
            if (!decompiled ||
                !HashCommitmentGenerator.validateHashCommittedScript(witnessScript)) {
                return null;
            }
            return decompiled[decompiled.length - 2];
        }
        catch {
            return null;
        }
    }
    /**
     * Verify that data chunks match their committed hashes.
     *
     * @param dataChunks Array of data chunks (in order)
     * @param witnessScript The witness script containing the hash commitments
     * @returns true if all chunks match their commitments
     */
    static verifyChunkCommitments(dataChunks, witnessScript) {
        const committedHashes = HashCommitmentGenerator.extractDataHashes(witnessScript);
        if (!committedHashes || committedHashes.length !== dataChunks.length) {
            return false;
        }
        for (let i = 0; i < dataChunks.length; i++) {
            const actualHash = hash160(dataChunks[i]);
            if (!equals(committedHashes[i], actualHash)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Estimate fees for a complete CHCT flow (setup + reveal).
     *
     * @param dataSize Data size in bytes (before compression)
     * @param feeRate Fee rate in sat/vB
     * @param compressionRatio Expected compression ratio (default: 0.7)
     * @returns Fee estimates
     */
    static estimateFees(dataSize, feeRate, compressionRatio = 0.7) {
        const compressedSize = Math.ceil(dataSize * compressionRatio);
        const outputCount = HashCommitmentGenerator.estimateOutputCount(compressedSize);
        const chunkCount = HashCommitmentGenerator.estimateChunkCount(compressedSize);
        // Setup tx: inputs (funding) + outputs (P2WSH commitments + change)
        // Estimate: 2 P2TR inputs + N P2WSH outputs + 1 change output
        const setupInputVBytes = 2 * 58; // P2TR inputs ~58 vB each
        const setupOutputVBytes = outputCount * 43 + 43; // P2WSH outputs ~43 vB, change ~43 vB
        const setupOverhead = 11; // version, locktime, counts
        const setupVBytes = setupOverhead + setupInputVBytes + setupOutputVBytes;
        // Reveal tx: N P2WSH inputs (each with up to 98 data chunks) + contract output + change
        const revealWeight = 40 + outputCount * HashCommitmentGenerator.WEIGHT_PER_INPUT + 200;
        const revealVBytes = Math.ceil(revealWeight / 4);
        const setupFee = BigInt(Math.ceil(setupVBytes * feeRate));
        const revealFee = BigInt(Math.ceil(revealVBytes * feeRate));
        const totalFee = setupFee + revealFee;
        const outputsValue = BigInt(outputCount) * HashCommitmentGenerator.MIN_OUTPUT_VALUE;
        const totalCost = totalFee + outputsValue;
        return {
            compressedSize,
            outputCount,
            chunkCount,
            setupVBytes,
            revealVBytes,
            setupFee,
            revealFee,
            totalFee,
            outputsValue,
            totalCost,
        };
    }
    /**
     * Calculate the HASH160 of a data chunk.
     * HASH160 = RIPEMD160(SHA256(data))
     */
    hashChunk(data) {
        return hash160(data);
    }
    /**
     * Generate a hash-committed witness script for multiple data chunks.
     *
     * Script structure (for N chunks):
     * OP_HASH160 <hash_N> OP_EQUALVERIFY
     * OP_HASH160 <hash_N-1> OP_EQUALVERIFY
     * ...
     * OP_HASH160 <hash_1> OP_EQUALVERIFY
     * <pubkey> OP_CHECKSIG
     *
     * Hashes are in reverse order because witness stack is LIFO.
     * Witness stack: [sig, data_1, data_2, ..., data_N, witnessScript]
     * Stack before execution: [sig, data_1, data_2, ..., data_N] (data_N on top)
     *
     * @param dataHashes Array of HASH160 values (in data order, will be reversed in script)
     * @returns The compiled witness script
     */
    generateWitnessScript(dataHashes) {
        if (dataHashes.length === 0) {
            throw new Error('At least one data hash is required');
        }
        if (dataHashes.length > HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT) {
            throw new Error(`Too many chunks: ${dataHashes.length} exceeds limit of ${HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT}`);
        }
        for (const hash of dataHashes) {
            if (hash.length !== 20) {
                throw new Error(`HASH160 requires 20-byte hash, got ${hash.length}`);
            }
        }
        // Build script parts - hashes in reverse order (last data chunk verified first)
        const scriptParts = [];
        // Add hash commitments in reverse order
        for (let i = dataHashes.length - 1; i >= 0; i--) {
            scriptParts.push(opcodes.OP_HASH160);
            scriptParts.push(dataHashes[i]);
            scriptParts.push(opcodes.OP_EQUALVERIFY);
        }
        // Add signature check
        scriptParts.push(this.publicKey);
        scriptParts.push(opcodes.OP_CHECKSIG);
        return compile(scriptParts);
    }
    /**
     * Generate a P2WSH address from a witness script.
     *
     * @param witnessScript The witness script
     * @returns P2WSH address info
     */
    generateP2WSHAddress(witnessScript) {
        const p2wsh$1 = p2wsh({
            redeem: { output: witnessScript },
            network: this.network,
        });
        if (!p2wsh$1.address || !p2wsh$1.output) {
            throw new Error('Failed to generate P2WSH address');
        }
        return {
            address: p2wsh$1.address,
            witnessScript,
            scriptPubKey: p2wsh$1.output,
        };
    }
    /**
     * Split data into chunks and generate hash-committed P2WSH outputs.
     *
     * Each output commits to up to 98 data chunks (80 bytes each = 7,840 bytes).
     * This is MUCH more efficient than one output per chunk.
     *
     * @param data The data to chunk and commit
     * @param maxChunkSize Maximum bytes per stack item (default: 80, P2WSH stack item limit)
     * @returns Array of hash-committed P2WSH outputs
     */
    prepareChunks(data, maxChunkSize = HashCommitmentGenerator.MAX_CHUNK_SIZE) {
        if (maxChunkSize > HashCommitmentGenerator.MAX_CHUNK_SIZE) {
            throw new Error(`Chunk size ${maxChunkSize} exceeds P2WSH stack item limit of ${HashCommitmentGenerator.MAX_CHUNK_SIZE}`);
        }
        if (data.length === 0) {
            throw new Error('Data cannot be empty');
        }
        // First, split data into 80-byte chunks
        const allChunks = [];
        let offset = 0;
        while (offset < data.length) {
            const chunkSize = Math.min(maxChunkSize, data.length - offset);
            allChunks.push(new Uint8Array(data.subarray(offset, offset + chunkSize)));
            offset += chunkSize;
        }
        // Now batch chunks into outputs (up to 98 chunks per output)
        const outputs = [];
        let chunkIndex = 0;
        while (chunkIndex < allChunks.length) {
            const chunksForThisOutput = allChunks.slice(chunkIndex, chunkIndex + HashCommitmentGenerator.MAX_CHUNKS_PER_OUTPUT);
            const dataChunks = chunksForThisOutput;
            const dataHashes = dataChunks.map((chunk) => this.hashChunk(chunk));
            const witnessScript = this.generateWitnessScript(dataHashes);
            const p2wsh = this.generateP2WSHAddress(witnessScript);
            outputs.push({
                address: p2wsh.address,
                witnessScript: p2wsh.witnessScript,
                scriptPubKey: p2wsh.scriptPubKey,
                dataHashes,
                dataChunks,
                chunkStartIndex: chunkIndex,
            });
            chunkIndex += chunksForThisOutput.length;
        }
        const totalChunks = allChunks.length;
        this.log(`Prepared ${outputs.length} P2WSH outputs with ${totalChunks} chunks ` +
            `(${data.length} bytes, ~${Math.ceil(data.length / outputs.length)} bytes/output)`);
        return outputs;
    }
}

/**
 * Generate a bitcoin script for a multisign interaction
 */
class MultiSignGenerator {
    static MAXIMUM_SUPPORTED_SIGNATURE = 255;
    static compile(vaultPublicKeys, minimumSignatures = 0, internal) {
        if (minimumSignatures < 2) {
            throw new Error('Minimum signatures must be greater than 1');
        }
        if (vaultPublicKeys.length < minimumSignatures) {
            throw new Error('The amount of public keys is lower than the minimum required');
        }
        if (minimumSignatures > MultiSignGenerator.MAXIMUM_SUPPORTED_SIGNATURE) {
            throw new Error(`The maximum amount of signatures is ${MultiSignGenerator.MAXIMUM_SUPPORTED_SIGNATURE}`);
        }
        const minimumRequired = alloc(1);
        minimumRequired[0] = minimumSignatures;
        /** Remove duplicates **/
        vaultPublicKeys = vaultPublicKeys.filter((buf, index, self) => index === self.findIndex((otherBuf) => equals(buf, otherBuf)));
        /** We must order the pub keys. */
        vaultPublicKeys = vaultPublicKeys.sort((a, b) => compare$2(a, b));
        let included = false;
        const data = vaultPublicKeys.map((key) => {
            const newKey = toXOnly(key);
            if (internal && !included)
                included = equals(internal, newKey);
            return newKey;
        });
        if (internal && !included)
            data.push(internal);
        const compiledData = [
            // Push the initial 0 (for OP_CHECKSIGADD)
            opcodes.OP_0,
            // For each public key, add CHECKSIGADD operation
            ...data.flatMap((key) => [
                key, // Push the public key
                opcodes.OP_CHECKSIGADD, // Add the public key to the signature set
            ]),
            // Finally, compare the sum with the minimum required signatures
            minimumRequired,
            opcodes.OP_NUMEQUAL, // Use NUMEQUALVERIFY to ensure the correct number of signatures
        ];
        const asm = compiledData.flat();
        const compiled = compile(asm);
        /** Verify the validity of the script */
        const decompiled = decompile(compiled);
        if (!decompiled) {
            throw new Error('Failed to decompile script.');
        }
        return compiled;
    }
}

/**
 * @category Generators
 * @remarks Not fully implemented yet
 */
class P2WDAGenerator extends Generator {
    static P2WDA_VERSION = 0x01;
    constructor(senderPubKey, contractSaltPubKey, network = bitcoin$1) {
        super(senderPubKey, contractSaltPubKey, network);
    }
    /**
     * Validate that operation data will fit in P2WDA witness fields
     *
     * @param dataSize Size of the operation data
     * @param maxWitnessFields Maximum number of witness fields (default 10)
     * @param maxBytesPerWitness Maximum bytes per witness field (default 80)
     * @returns true if data will fit, false otherwise
     */
    static validateWitnessSize(dataSize, maxWitnessFields = 10, maxBytesPerWitness = 80) {
        const signatureSize = 64;
        const compressionRatio = 0.7;
        const totalSize = dataSize + signatureSize;
        const compressedSize = Math.ceil(totalSize * compressionRatio);
        const requiredFields = Math.ceil(compressedSize / maxBytesPerWitness);
        return requiredFields <= maxWitnessFields;
    }
    /**
     * Compile operation data for P2WDA witness embedding
     *
     * This creates a binary structure containing all operation information
     * without Bitcoin script opcodes. The structure is:
     *
     * [version(1)] [header(12)] [contract(32)] [challenge_pubkey(33)] [challenge_solution(32)]
     * [calldata_length(4)] [calldata] [features_length(2)] [features_data]
     *
     * @param calldata The compressed calldata for the contract interaction
     * @param contractSecret The 32-byte contract secret
     * @param challenge The challenge solution for epoch rewards
     * @param maxPriority Maximum priority fee in satoshis
     * @param featuresRaw Optional features like access lists
     * @returns Raw operation data ready for signing and compression
     */
    compile(calldata, contractSecret, challenge, maxPriority, featuresRaw = []) {
        if (!this.contractSaltPubKey) {
            throw new Error('Contract salt public key not set');
        }
        if (contractSecret.length !== 32) {
            throw new Error('Contract secret must be exactly 32 bytes');
        }
        const writer = new BinaryWriter();
        writer.writeU8(P2WDAGenerator.P2WDA_VERSION);
        const features = featuresRaw.sort((a, b) => a.priority - b.priority);
        writer.writeBytes(this.getHeader(maxPriority, features.map((f) => f.opcode)));
        writer.writeBytes(contractSecret);
        writer.writeBytes(challenge.publicKey.toBuffer());
        writer.writeBytes(challenge.solution);
        writer.writeU32(calldata.length);
        writer.writeBytes(calldata);
        this.writeFeatures(writer, features);
        return new Uint8Array(writer.getBuffer());
    }
    getHeader(maxPriority, features = []) {
        return super.getHeader(maxPriority, features);
    }
    /**
     * Write features section to the operation data
     *
     * Features are encoded as:
     * [feature_count(2)] [feature1_opcode(1)] [feature1_length(4)] [feature1_data] ...
     *
     * @param writer Binary writer to write to
     * @param features Array of features to encode
     */
    writeFeatures(writer, features) {
        writer.writeU16(features.length);
        for (const feature of features) {
            writer.writeU8(feature.opcode);
            this.encodeFeature(feature, writer);
        }
    }
}

class AddressGenerator {
    // Generate a valid SegWit address from random bytes
    static generatePKSH(sha256Hash, network) {
        if (sha256Hash.length !== 32)
            throw new Error('Invalid hash length');
        const pkh = ripemd160(sha256Hash);
        return this.toSegwitAddress(pkh, network);
    }
    // Generate a valid Taproot address from a public key
    static generateTaprootAddress(pubKey, network) {
        if (pubKey.length !== 32)
            throw new Error('Invalid public key length');
        // Convert the public key to words
        const words = distExports.bech32m.toWords(pubKey);
        // Prepend the witness version (0x01 for Taproot)
        words.unshift(0x01);
        // Encode using Bech32m
        return distExports.bech32m.encode(network.bech32, words);
    }
    // Convert a hash to a SegWit address
    static toSegwitAddress(pkh, network) {
        const words = distExports.bech32.toWords(pkh);
        words.unshift(0x00); // Add the witness version byte (0x00 for P2WPKH)
        return distExports.bech32.encode(network.bech32, words);
    }
}

/**
 * Type guard to check if a Signer is a UniversalSigner (has privateKey).
 */
function isUniversalSigner(signer) {
    return 'privateKey' in signer && signer.privateKey != null;
}
/**
 * Class for tweaking signers
 * @class TweakedSigner
 */
class TweakedSigner {
    /**
     * Tweak a signer
     * @param {UniversalSigner} signer - The signer to tweak (must have privateKey)
     * @param {TweakSettings} opts - The tweak settings
     * @returns {UniversalSigner} - The tweaked signer
     */
    static tweakSigner(signer, opts = {}) {
        let privateKey = signer.privateKey;
        if (!privateKey) {
            throw new Error('Private key is required for tweaking signer!');
        }
        if (signer.publicKey[0] === 3) {
            privateKey = backend.privateNegate(privateKey);
        }
        const tweakedPrivateKey = backend.privateAdd(privateKey, tapTweakHash$1(toXOnly(signer.publicKey), opts.tweakHash));
        if (!tweakedPrivateKey) {
            throw new Error('Invalid tweaked private key!');
        }
        return EcKeyPair.fromPrivateKey(tweakedPrivateKey, opts.network);
    }
}

/**
 * Type guard to check if a wallet supports OPWallet features
 */
function isOPWallet(wallet) {
    return (typeof wallet === 'object' &&
        wallet !== null &&
        'web3' in wallet &&
        typeof wallet.web3 === 'object' &&
        'getMLDSAPublicKey' in wallet.web3 &&
        'signMLDSAMessage' in wallet.web3);
}

var WalletNetworks;
(function (WalletNetworks) {
    WalletNetworks["Mainnet"] = "mainnet";
    WalletNetworks["Testnet"] = "testnet";
    WalletNetworks["OpnetTestnet"] = "opnetTestnet";
    WalletNetworks["Regtest"] = "regtest";
})(WalletNetworks || (WalletNetworks = {}));
var UnisatChainType;
(function (UnisatChainType) {
    UnisatChainType["BITCOIN_MAINNET"] = "BITCOIN_MAINNET";
    UnisatChainType["BITCOIN_TESTNET"] = "BITCOIN_TESTNET";
    UnisatChainType["BITCOIN_TESTNET4"] = "BITCOIN_TESTNET4";
    UnisatChainType["BITCOIN_REGTEST"] = "BITCOIN_REGTEST";
    UnisatChainType["BITCOIN_SIGNET"] = "BITCOIN_SIGNET";
    UnisatChainType["OPNET_TESTNET"] = "OPNET_TESTNET";
    UnisatChainType["FRACTAL_BITCOIN_MAINNET"] = "FRACTAL_BITCOIN_MAINNET";
    UnisatChainType["FRACTAL_BITCOIN_TESTNET"] = "FRACTAL_BITCOIN_TESTNET";
    UnisatChainType["DOGECOIN_MAINNET"] = "DOGECOIN_MAINNET";
    UnisatChainType["DOGECOIN_TESTNET"] = "DOGECOIN_TESTNET";
    UnisatChainType["DOGECOIN_REGTEST"] = "DOGECOIN_REGTEST";
    UnisatChainType["LITECOIN_MAINNET"] = "LITECOIN_MAINNET";
    UnisatChainType["LITECOIN_TESTNET"] = "LITECOIN_TESTNET";
    UnisatChainType["LITECOIN_REGTEST"] = "LITECOIN_REGTEST";
    UnisatChainType["BITCOINCASH_MAINNET"] = "BITCOINCASH_MAINNET";
    UnisatChainType["BITCOINCASH_TESTNET"] = "BITCOINCASH_TESTNET";
    UnisatChainType["BITCOINCASH_REGTEST"] = "BITCOINCASH_REGTEST";
    UnisatChainType["DASH_MAINNET"] = "DASH_MAINNET";
    UnisatChainType["DASH_TESTNET"] = "DASH_TESTNET";
    UnisatChainType["DASH_REGTEST"] = "DASH_REGTEST";
})(UnisatChainType || (UnisatChainType = {}));

var MessageType;
(function (MessageType) {
    MessageType["ecdsa"] = "ecdsa";
    MessageType["bip322"] = "bip322-simple";
})(MessageType || (MessageType = {}));
var SignatureType;
(function (SignatureType) {
    SignatureType["ecdsa"] = "ecdsa";
    SignatureType["schnorr"] = "schnorr";
})(SignatureType || (SignatureType = {}));

class MessageSignerBase {
    sha256(message) {
        return sha256$1(message);
    }
    async trySignSchnorrWithOPWallet(message) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? new TextEncoder().encode(message) : message;
        const hashedMessage = this.sha256(messageBuffer);
        const messageHex = toHex$1(hashedMessage);
        const signatureHex = await wallet.signData(messageHex, SignatureType.schnorr, typeof message === 'string' ? message : undefined);
        return {
            signature: fromHex$1(signatureHex),
            message: hashedMessage,
        };
    }
    async trySignECDSAWithOPWallet(message) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? new TextEncoder().encode(message) : message;
        const hashedMessage = this.sha256(messageBuffer);
        const messageHex = toHex$1(hashedMessage);
        const signatureHex = await wallet.signData(messageHex, SignatureType.ecdsa, typeof message === 'string' ? message : undefined);
        return {
            signature: fromHex$1(signatureHex),
            message: hashedMessage,
        };
    }
    async trySignMLDSAWithOPWallet(message) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? new TextEncoder().encode(message) : message;
        const hashedMessage = this.sha256(messageBuffer);
        const messageHex = toHex$1(hashedMessage);
        const result = await wallet.web3.signMLDSAMessage(messageHex, typeof message === 'string' ? message : undefined);
        return {
            signature: fromHex$1(result.signature),
            message: hashedMessage,
            publicKey: fromHex$1(result.publicKey),
            securityLevel: result.securityLevel,
        };
    }
    async signMessageAuto(message, keypair) {
        if (!keypair) {
            const walletResult = await this.trySignSchnorrWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No keypair provided and OP_WALLET is not available.');
        }
        return this.signMessage(keypair, message);
    }
    async signMessageECDSAAuto(message, keypair) {
        if (!keypair) {
            const walletResult = await this.trySignECDSAWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No keypair provided and OP_WALLET is not available.');
        }
        return this.signECDSA(keypair, message);
    }
    async tweakAndSignMessageAuto(message, keypair, network) {
        if (!keypair) {
            const walletResult = await this.trySignSchnorrWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No keypair provided and OP_WALLET is not available.');
        }
        if (!network) {
            throw new Error('Network is required when signing with a local keypair.');
        }
        return this.tweakAndSignMessage(keypair, message, network);
    }
    async signMLDSAMessageAuto(message, mldsaKeypair) {
        if (!mldsaKeypair) {
            const walletResult = await this.trySignMLDSAWithOPWallet(message);
            if (walletResult) {
                return walletResult;
            }
            throw new Error('No ML-DSA keypair provided and OP_WALLET is not available.');
        }
        return this.signMLDSAMessage(mldsaKeypair, message);
    }
    async verifyMLDSAWithOPWallet(message, signature) {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const messageBuffer = typeof message === 'string' ? new TextEncoder().encode(message) : message;
        const hashedMessage = this.sha256(messageBuffer);
        const mldsaSignature = {
            signature: toHex$1(signature.signature),
            publicKey: toHex$1(signature.publicKey),
            securityLevel: signature.securityLevel,
            messageHash: toHex$1(hashedMessage),
        };
        return wallet.web3.verifyMLDSASignature(toHex$1(hashedMessage), mldsaSignature);
    }
    async getMLDSAPublicKeyFromOPWallet() {
        const wallet = this.getOPWallet();
        if (!wallet) {
            return null;
        }
        const publicKeyHex = await wallet.web3.getMLDSAPublicKey();
        return fromHex$1(publicKeyHex);
    }
    tweakAndSignMessage(keypair, message, network) {
        const tweaked = TweakedSigner.tweakSigner(keypair, { network });
        return this.signMessage(tweaked, message);
    }
    signMessage(keypair, message) {
        if (typeof message === 'string') {
            message = new TextEncoder().encode(message);
        }
        if (!keypair.privateKey) {
            throw new Error('Private key not found in keypair.');
        }
        const hashedMessage = this.sha256(message);
        if (!backend.signSchnorr) {
            throw new Error('backend.signSchnorr is not available.');
        }
        return {
            signature: backend.signSchnorr(hashedMessage, keypair.privateKey),
            message: hashedMessage,
        };
    }
    signECDSA(keypair, message) {
        if (typeof message === 'string') {
            message = new TextEncoder().encode(message);
        }
        if (!keypair.privateKey) {
            throw new Error('Private key not found in keypair.');
        }
        const hashedMessage = this.sha256(message);
        if (!backend.sign) {
            throw new Error('backend.signSchnorr is not available.');
        }
        return {
            signature: backend.sign(hashedMessage, keypair.privateKey),
            message: hashedMessage,
        };
    }
    verifyECDSASignature(publicKey, message, signature) {
        if (typeof message === 'string') {
            message = new TextEncoder().encode(message);
        }
        if (signature.length !== 64) {
            throw new Error('Invalid signature length.');
        }
        const hashedMessage = this.sha256(message);
        if (!backend.verify) {
            throw new Error('backend.verifySchnorr is not available.');
        }
        return backend.verify(hashedMessage, publicKey, signature);
    }
    verifySignature(publicKey, message, signature) {
        if (typeof message === 'string') {
            message = new TextEncoder().encode(message);
        }
        if (signature.length !== 64) {
            throw new Error('Invalid signature length.');
        }
        const hashedMessage = this.sha256(message);
        if (!backend.verifySchnorr) {
            throw new Error('backend.verifySchnorr is not available.');
        }
        return backend.verifySchnorr(hashedMessage, toXOnly(publicKey), signature);
    }
    tweakAndVerifySignature(publicKey, message, signature) {
        const tweakedPublicKey = EcKeyPair.tweakPublicKey(publicKey);
        return this.verifySignature(tweakedPublicKey, message, signature);
    }
    signMLDSAMessage(mldsaKeypair, message) {
        if (typeof message === 'string') {
            message = new TextEncoder().encode(message);
        }
        if (!mldsaKeypair.privateKey) {
            throw new Error('ML-DSA private key not found in keypair.');
        }
        const hashedMessage = this.sha256(message);
        const signature = mldsaKeypair.sign(hashedMessage);
        return {
            signature: new Uint8Array(signature),
            message: hashedMessage,
            publicKey: new Uint8Array(mldsaKeypair.publicKey),
            securityLevel: mldsaKeypair.securityLevel,
        };
    }
    verifyMLDSASignature(mldsaKeypair, message, signature) {
        if (typeof message === 'string') {
            message = new TextEncoder().encode(message);
        }
        const hashedMessage = this.sha256(message);
        return mldsaKeypair.verify(hashedMessage, signature);
    }
    isOPWalletAvailable() {
        return this.getOPWallet() !== null;
    }
    getOPWallet() {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window.opnet || !isOPWallet(_window.opnet)) {
            return null;
        }
        return _window.opnet;
    }
}
const MessageSigner = new MessageSignerBase();

var src = {};

var _wordlists = {};

const require$$0 = /* #__PURE__ */ JSON.parse("[\"abdikace\",\"abeceda\",\"adresa\",\"agrese\",\"akce\",\"aktovka\",\"alej\",\"alkohol\",\"amputace\",\"ananas\",\"andulka\",\"anekdota\",\"anketa\",\"antika\",\"anulovat\",\"archa\",\"arogance\",\"asfalt\",\"asistent\",\"aspirace\",\"astma\",\"astronom\",\"atlas\",\"atletika\",\"atol\",\"autobus\",\"azyl\",\"babka\",\"bachor\",\"bacil\",\"baculka\",\"badatel\",\"bageta\",\"bagr\",\"bahno\",\"bakterie\",\"balada\",\"baletka\",\"balkon\",\"balonek\",\"balvan\",\"balza\",\"bambus\",\"bankomat\",\"barbar\",\"baret\",\"barman\",\"baroko\",\"barva\",\"baterka\",\"batoh\",\"bavlna\",\"bazalka\",\"bazilika\",\"bazuka\",\"bedna\",\"beran\",\"beseda\",\"bestie\",\"beton\",\"bezinka\",\"bezmoc\",\"beztak\",\"bicykl\",\"bidlo\",\"biftek\",\"bikiny\",\"bilance\",\"biograf\",\"biolog\",\"bitva\",\"bizon\",\"blahobyt\",\"blatouch\",\"blecha\",\"bledule\",\"blesk\",\"blikat\",\"blizna\",\"blokovat\",\"bloudit\",\"blud\",\"bobek\",\"bobr\",\"bodlina\",\"bodnout\",\"bohatost\",\"bojkot\",\"bojovat\",\"bokorys\",\"bolest\",\"borec\",\"borovice\",\"bota\",\"boubel\",\"bouchat\",\"bouda\",\"boule\",\"bourat\",\"boxer\",\"bradavka\",\"brambora\",\"branka\",\"bratr\",\"brepta\",\"briketa\",\"brko\",\"brloh\",\"bronz\",\"broskev\",\"brunetka\",\"brusinka\",\"brzda\",\"brzy\",\"bublina\",\"bubnovat\",\"buchta\",\"buditel\",\"budka\",\"budova\",\"bufet\",\"bujarost\",\"bukvice\",\"buldok\",\"bulva\",\"bunda\",\"bunkr\",\"burza\",\"butik\",\"buvol\",\"buzola\",\"bydlet\",\"bylina\",\"bytovka\",\"bzukot\",\"capart\",\"carevna\",\"cedr\",\"cedule\",\"cejch\",\"cejn\",\"cela\",\"celer\",\"celkem\",\"celnice\",\"cenina\",\"cennost\",\"cenovka\",\"centrum\",\"cenzor\",\"cestopis\",\"cetka\",\"chalupa\",\"chapadlo\",\"charita\",\"chata\",\"chechtat\",\"chemie\",\"chichot\",\"chirurg\",\"chlad\",\"chleba\",\"chlubit\",\"chmel\",\"chmura\",\"chobot\",\"chochol\",\"chodba\",\"cholera\",\"chomout\",\"chopit\",\"choroba\",\"chov\",\"chrapot\",\"chrlit\",\"chrt\",\"chrup\",\"chtivost\",\"chudina\",\"chutnat\",\"chvat\",\"chvilka\",\"chvost\",\"chyba\",\"chystat\",\"chytit\",\"cibule\",\"cigareta\",\"cihelna\",\"cihla\",\"cinkot\",\"cirkus\",\"cisterna\",\"citace\",\"citrus\",\"cizinec\",\"cizost\",\"clona\",\"cokoliv\",\"couvat\",\"ctitel\",\"ctnost\",\"cudnost\",\"cuketa\",\"cukr\",\"cupot\",\"cvaknout\",\"cval\",\"cvik\",\"cvrkot\",\"cyklista\",\"daleko\",\"dareba\",\"datel\",\"datum\",\"dcera\",\"debata\",\"dechovka\",\"decibel\",\"deficit\",\"deflace\",\"dekl\",\"dekret\",\"demokrat\",\"deprese\",\"derby\",\"deska\",\"detektiv\",\"dikobraz\",\"diktovat\",\"dioda\",\"diplom\",\"disk\",\"displej\",\"divadlo\",\"divoch\",\"dlaha\",\"dlouho\",\"dluhopis\",\"dnes\",\"dobro\",\"dobytek\",\"docent\",\"dochutit\",\"dodnes\",\"dohled\",\"dohoda\",\"dohra\",\"dojem\",\"dojnice\",\"doklad\",\"dokola\",\"doktor\",\"dokument\",\"dolar\",\"doleva\",\"dolina\",\"doma\",\"dominant\",\"domluvit\",\"domov\",\"donutit\",\"dopad\",\"dopis\",\"doplnit\",\"doposud\",\"doprovod\",\"dopustit\",\"dorazit\",\"dorost\",\"dort\",\"dosah\",\"doslov\",\"dostatek\",\"dosud\",\"dosyta\",\"dotaz\",\"dotek\",\"dotknout\",\"doufat\",\"doutnat\",\"dovozce\",\"dozadu\",\"doznat\",\"dozorce\",\"drahota\",\"drak\",\"dramatik\",\"dravec\",\"draze\",\"drdol\",\"drobnost\",\"drogerie\",\"drozd\",\"drsnost\",\"drtit\",\"drzost\",\"duben\",\"duchovno\",\"dudek\",\"duha\",\"duhovka\",\"dusit\",\"dusno\",\"dutost\",\"dvojice\",\"dvorec\",\"dynamit\",\"ekolog\",\"ekonomie\",\"elektron\",\"elipsa\",\"email\",\"emise\",\"emoce\",\"empatie\",\"epizoda\",\"epocha\",\"epopej\",\"epos\",\"esej\",\"esence\",\"eskorta\",\"eskymo\",\"etiketa\",\"euforie\",\"evoluce\",\"exekuce\",\"exkurze\",\"expedice\",\"exploze\",\"export\",\"extrakt\",\"facka\",\"fajfka\",\"fakulta\",\"fanatik\",\"fantazie\",\"farmacie\",\"favorit\",\"fazole\",\"federace\",\"fejeton\",\"fenka\",\"fialka\",\"figurant\",\"filozof\",\"filtr\",\"finance\",\"finta\",\"fixace\",\"fjord\",\"flanel\",\"flirt\",\"flotila\",\"fond\",\"fosfor\",\"fotbal\",\"fotka\",\"foton\",\"frakce\",\"freska\",\"fronta\",\"fukar\",\"funkce\",\"fyzika\",\"galeje\",\"garant\",\"genetika\",\"geolog\",\"gilotina\",\"glazura\",\"glejt\",\"golem\",\"golfista\",\"gotika\",\"graf\",\"gramofon\",\"granule\",\"grep\",\"gril\",\"grog\",\"groteska\",\"guma\",\"hadice\",\"hadr\",\"hala\",\"halenka\",\"hanba\",\"hanopis\",\"harfa\",\"harpuna\",\"havran\",\"hebkost\",\"hejkal\",\"hejno\",\"hejtman\",\"hektar\",\"helma\",\"hematom\",\"herec\",\"herna\",\"heslo\",\"hezky\",\"historik\",\"hladovka\",\"hlasivky\",\"hlava\",\"hledat\",\"hlen\",\"hlodavec\",\"hloh\",\"hloupost\",\"hltat\",\"hlubina\",\"hluchota\",\"hmat\",\"hmota\",\"hmyz\",\"hnis\",\"hnojivo\",\"hnout\",\"hoblina\",\"hoboj\",\"hoch\",\"hodiny\",\"hodlat\",\"hodnota\",\"hodovat\",\"hojnost\",\"hokej\",\"holinka\",\"holka\",\"holub\",\"homole\",\"honitba\",\"honorace\",\"horal\",\"horda\",\"horizont\",\"horko\",\"horlivec\",\"hormon\",\"hornina\",\"horoskop\",\"horstvo\",\"hospoda\",\"hostina\",\"hotovost\",\"houba\",\"houf\",\"houpat\",\"houska\",\"hovor\",\"hradba\",\"hranice\",\"hravost\",\"hrazda\",\"hrbolek\",\"hrdina\",\"hrdlo\",\"hrdost\",\"hrnek\",\"hrobka\",\"hromada\",\"hrot\",\"hrouda\",\"hrozen\",\"hrstka\",\"hrubost\",\"hryzat\",\"hubenost\",\"hubnout\",\"hudba\",\"hukot\",\"humr\",\"husita\",\"hustota\",\"hvozd\",\"hybnost\",\"hydrant\",\"hygiena\",\"hymna\",\"hysterik\",\"idylka\",\"ihned\",\"ikona\",\"iluze\",\"imunita\",\"infekce\",\"inflace\",\"inkaso\",\"inovace\",\"inspekce\",\"internet\",\"invalida\",\"investor\",\"inzerce\",\"ironie\",\"jablko\",\"jachta\",\"jahoda\",\"jakmile\",\"jakost\",\"jalovec\",\"jantar\",\"jarmark\",\"jaro\",\"jasan\",\"jasno\",\"jatka\",\"javor\",\"jazyk\",\"jedinec\",\"jedle\",\"jednatel\",\"jehlan\",\"jekot\",\"jelen\",\"jelito\",\"jemnost\",\"jenom\",\"jepice\",\"jeseter\",\"jevit\",\"jezdec\",\"jezero\",\"jinak\",\"jindy\",\"jinoch\",\"jiskra\",\"jistota\",\"jitrnice\",\"jizva\",\"jmenovat\",\"jogurt\",\"jurta\",\"kabaret\",\"kabel\",\"kabinet\",\"kachna\",\"kadet\",\"kadidlo\",\"kahan\",\"kajak\",\"kajuta\",\"kakao\",\"kaktus\",\"kalamita\",\"kalhoty\",\"kalibr\",\"kalnost\",\"kamera\",\"kamkoliv\",\"kamna\",\"kanibal\",\"kanoe\",\"kantor\",\"kapalina\",\"kapela\",\"kapitola\",\"kapka\",\"kaple\",\"kapota\",\"kapr\",\"kapusta\",\"kapybara\",\"karamel\",\"karotka\",\"karton\",\"kasa\",\"katalog\",\"katedra\",\"kauce\",\"kauza\",\"kavalec\",\"kazajka\",\"kazeta\",\"kazivost\",\"kdekoliv\",\"kdesi\",\"kedluben\",\"kemp\",\"keramika\",\"kino\",\"klacek\",\"kladivo\",\"klam\",\"klapot\",\"klasika\",\"klaun\",\"klec\",\"klenba\",\"klepat\",\"klesnout\",\"klid\",\"klima\",\"klisna\",\"klobouk\",\"klokan\",\"klopa\",\"kloub\",\"klubovna\",\"klusat\",\"kluzkost\",\"kmen\",\"kmitat\",\"kmotr\",\"kniha\",\"knot\",\"koalice\",\"koberec\",\"kobka\",\"kobliha\",\"kobyla\",\"kocour\",\"kohout\",\"kojenec\",\"kokos\",\"koktejl\",\"kolaps\",\"koleda\",\"kolize\",\"kolo\",\"komando\",\"kometa\",\"komik\",\"komnata\",\"komora\",\"kompas\",\"komunita\",\"konat\",\"koncept\",\"kondice\",\"konec\",\"konfese\",\"kongres\",\"konina\",\"konkurs\",\"kontakt\",\"konzerva\",\"kopanec\",\"kopie\",\"kopnout\",\"koprovka\",\"korbel\",\"korektor\",\"kormidlo\",\"koroptev\",\"korpus\",\"koruna\",\"koryto\",\"korzet\",\"kosatec\",\"kostka\",\"kotel\",\"kotleta\",\"kotoul\",\"koukat\",\"koupelna\",\"kousek\",\"kouzlo\",\"kovboj\",\"koza\",\"kozoroh\",\"krabice\",\"krach\",\"krajina\",\"kralovat\",\"krasopis\",\"kravata\",\"kredit\",\"krejcar\",\"kresba\",\"kreveta\",\"kriket\",\"kritik\",\"krize\",\"krkavec\",\"krmelec\",\"krmivo\",\"krocan\",\"krok\",\"kronika\",\"kropit\",\"kroupa\",\"krovka\",\"krtek\",\"kruhadlo\",\"krupice\",\"krutost\",\"krvinka\",\"krychle\",\"krypta\",\"krystal\",\"kryt\",\"kudlanka\",\"kufr\",\"kujnost\",\"kukla\",\"kulajda\",\"kulich\",\"kulka\",\"kulomet\",\"kultura\",\"kuna\",\"kupodivu\",\"kurt\",\"kurzor\",\"kutil\",\"kvalita\",\"kvasinka\",\"kvestor\",\"kynolog\",\"kyselina\",\"kytara\",\"kytice\",\"kytka\",\"kytovec\",\"kyvadlo\",\"labrador\",\"lachtan\",\"ladnost\",\"laik\",\"lakomec\",\"lamela\",\"lampa\",\"lanovka\",\"lasice\",\"laso\",\"lastura\",\"latinka\",\"lavina\",\"lebka\",\"leckdy\",\"leden\",\"lednice\",\"ledovka\",\"ledvina\",\"legenda\",\"legie\",\"legrace\",\"lehce\",\"lehkost\",\"lehnout\",\"lektvar\",\"lenochod\",\"lentilka\",\"lepenka\",\"lepidlo\",\"letadlo\",\"letec\",\"letmo\",\"letokruh\",\"levhart\",\"levitace\",\"levobok\",\"libra\",\"lichotka\",\"lidojed\",\"lidskost\",\"lihovina\",\"lijavec\",\"lilek\",\"limetka\",\"linie\",\"linka\",\"linoleum\",\"listopad\",\"litina\",\"litovat\",\"lobista\",\"lodivod\",\"logika\",\"logoped\",\"lokalita\",\"loket\",\"lomcovat\",\"lopata\",\"lopuch\",\"lord\",\"losos\",\"lotr\",\"loudal\",\"louh\",\"louka\",\"louskat\",\"lovec\",\"lstivost\",\"lucerna\",\"lucifer\",\"lump\",\"lusk\",\"lustrace\",\"lvice\",\"lyra\",\"lyrika\",\"lysina\",\"madam\",\"madlo\",\"magistr\",\"mahagon\",\"majetek\",\"majitel\",\"majorita\",\"makak\",\"makovice\",\"makrela\",\"malba\",\"malina\",\"malovat\",\"malvice\",\"maminka\",\"mandle\",\"manko\",\"marnost\",\"masakr\",\"maskot\",\"masopust\",\"matice\",\"matrika\",\"maturita\",\"mazanec\",\"mazivo\",\"mazlit\",\"mazurka\",\"mdloba\",\"mechanik\",\"meditace\",\"medovina\",\"melasa\",\"meloun\",\"mentolka\",\"metla\",\"metoda\",\"metr\",\"mezera\",\"migrace\",\"mihnout\",\"mihule\",\"mikina\",\"mikrofon\",\"milenec\",\"milimetr\",\"milost\",\"mimika\",\"mincovna\",\"minibar\",\"minomet\",\"minulost\",\"miska\",\"mistr\",\"mixovat\",\"mladost\",\"mlha\",\"mlhovina\",\"mlok\",\"mlsat\",\"mluvit\",\"mnich\",\"mnohem\",\"mobil\",\"mocnost\",\"modelka\",\"modlitba\",\"mohyla\",\"mokro\",\"molekula\",\"momentka\",\"monarcha\",\"monokl\",\"monstrum\",\"montovat\",\"monzun\",\"mosaz\",\"moskyt\",\"most\",\"motivace\",\"motorka\",\"motyka\",\"moucha\",\"moudrost\",\"mozaika\",\"mozek\",\"mozol\",\"mramor\",\"mravenec\",\"mrkev\",\"mrtvola\",\"mrzet\",\"mrzutost\",\"mstitel\",\"mudrc\",\"muflon\",\"mulat\",\"mumie\",\"munice\",\"muset\",\"mutace\",\"muzeum\",\"muzikant\",\"myslivec\",\"mzda\",\"nabourat\",\"nachytat\",\"nadace\",\"nadbytek\",\"nadhoz\",\"nadobro\",\"nadpis\",\"nahlas\",\"nahnat\",\"nahodile\",\"nahradit\",\"naivita\",\"najednou\",\"najisto\",\"najmout\",\"naklonit\",\"nakonec\",\"nakrmit\",\"nalevo\",\"namazat\",\"namluvit\",\"nanometr\",\"naoko\",\"naopak\",\"naostro\",\"napadat\",\"napevno\",\"naplnit\",\"napnout\",\"naposled\",\"naprosto\",\"narodit\",\"naruby\",\"narychlo\",\"nasadit\",\"nasekat\",\"naslepo\",\"nastat\",\"natolik\",\"navenek\",\"navrch\",\"navzdory\",\"nazvat\",\"nebe\",\"nechat\",\"necky\",\"nedaleko\",\"nedbat\",\"neduh\",\"negace\",\"nehet\",\"nehoda\",\"nejen\",\"nejprve\",\"neklid\",\"nelibost\",\"nemilost\",\"nemoc\",\"neochota\",\"neonka\",\"nepokoj\",\"nerost\",\"nerv\",\"nesmysl\",\"nesoulad\",\"netvor\",\"neuron\",\"nevina\",\"nezvykle\",\"nicota\",\"nijak\",\"nikam\",\"nikdy\",\"nikl\",\"nikterak\",\"nitro\",\"nocleh\",\"nohavice\",\"nominace\",\"nora\",\"norek\",\"nositel\",\"nosnost\",\"nouze\",\"noviny\",\"novota\",\"nozdra\",\"nuda\",\"nudle\",\"nuget\",\"nutit\",\"nutnost\",\"nutrie\",\"nymfa\",\"obal\",\"obarvit\",\"obava\",\"obdiv\",\"obec\",\"obehnat\",\"obejmout\",\"obezita\",\"obhajoba\",\"obilnice\",\"objasnit\",\"objekt\",\"obklopit\",\"oblast\",\"oblek\",\"obliba\",\"obloha\",\"obluda\",\"obnos\",\"obohatit\",\"obojek\",\"obout\",\"obrazec\",\"obrna\",\"obruba\",\"obrys\",\"obsah\",\"obsluha\",\"obstarat\",\"obuv\",\"obvaz\",\"obvinit\",\"obvod\",\"obvykle\",\"obyvatel\",\"obzor\",\"ocas\",\"ocel\",\"ocenit\",\"ochladit\",\"ochota\",\"ochrana\",\"ocitnout\",\"odboj\",\"odbyt\",\"odchod\",\"odcizit\",\"odebrat\",\"odeslat\",\"odevzdat\",\"odezva\",\"odhadce\",\"odhodit\",\"odjet\",\"odjinud\",\"odkaz\",\"odkoupit\",\"odliv\",\"odluka\",\"odmlka\",\"odolnost\",\"odpad\",\"odpis\",\"odplout\",\"odpor\",\"odpustit\",\"odpykat\",\"odrazka\",\"odsoudit\",\"odstup\",\"odsun\",\"odtok\",\"odtud\",\"odvaha\",\"odveta\",\"odvolat\",\"odvracet\",\"odznak\",\"ofina\",\"ofsajd\",\"ohlas\",\"ohnisko\",\"ohrada\",\"ohrozit\",\"ohryzek\",\"okap\",\"okenice\",\"oklika\",\"okno\",\"okouzlit\",\"okovy\",\"okrasa\",\"okres\",\"okrsek\",\"okruh\",\"okupant\",\"okurka\",\"okusit\",\"olejnina\",\"olizovat\",\"omak\",\"omeleta\",\"omezit\",\"omladina\",\"omlouvat\",\"omluva\",\"omyl\",\"onehdy\",\"opakovat\",\"opasek\",\"operace\",\"opice\",\"opilost\",\"opisovat\",\"opora\",\"opozice\",\"opravdu\",\"oproti\",\"orbital\",\"orchestr\",\"orgie\",\"orlice\",\"orloj\",\"ortel\",\"osada\",\"oschnout\",\"osika\",\"osivo\",\"oslava\",\"oslepit\",\"oslnit\",\"oslovit\",\"osnova\",\"osoba\",\"osolit\",\"ospalec\",\"osten\",\"ostraha\",\"ostuda\",\"ostych\",\"osvojit\",\"oteplit\",\"otisk\",\"otop\",\"otrhat\",\"otrlost\",\"otrok\",\"otruby\",\"otvor\",\"ovanout\",\"ovar\",\"oves\",\"ovlivnit\",\"ovoce\",\"oxid\",\"ozdoba\",\"pachatel\",\"pacient\",\"padouch\",\"pahorek\",\"pakt\",\"palanda\",\"palec\",\"palivo\",\"paluba\",\"pamflet\",\"pamlsek\",\"panenka\",\"panika\",\"panna\",\"panovat\",\"panstvo\",\"pantofle\",\"paprika\",\"parketa\",\"parodie\",\"parta\",\"paruka\",\"paryba\",\"paseka\",\"pasivita\",\"pastelka\",\"patent\",\"patrona\",\"pavouk\",\"pazneht\",\"pazourek\",\"pecka\",\"pedagog\",\"pejsek\",\"peklo\",\"peloton\",\"penalta\",\"pendrek\",\"penze\",\"periskop\",\"pero\",\"pestrost\",\"petarda\",\"petice\",\"petrolej\",\"pevnina\",\"pexeso\",\"pianista\",\"piha\",\"pijavice\",\"pikle\",\"piknik\",\"pilina\",\"pilnost\",\"pilulka\",\"pinzeta\",\"pipeta\",\"pisatel\",\"pistole\",\"pitevna\",\"pivnice\",\"pivovar\",\"placenta\",\"plakat\",\"plamen\",\"planeta\",\"plastika\",\"platit\",\"plavidlo\",\"plaz\",\"plech\",\"plemeno\",\"plenta\",\"ples\",\"pletivo\",\"plevel\",\"plivat\",\"plnit\",\"plno\",\"plocha\",\"plodina\",\"plomba\",\"plout\",\"pluk\",\"plyn\",\"pobavit\",\"pobyt\",\"pochod\",\"pocit\",\"poctivec\",\"podat\",\"podcenit\",\"podepsat\",\"podhled\",\"podivit\",\"podklad\",\"podmanit\",\"podnik\",\"podoba\",\"podpora\",\"podraz\",\"podstata\",\"podvod\",\"podzim\",\"poezie\",\"pohanka\",\"pohnutka\",\"pohovor\",\"pohroma\",\"pohyb\",\"pointa\",\"pojistka\",\"pojmout\",\"pokazit\",\"pokles\",\"pokoj\",\"pokrok\",\"pokuta\",\"pokyn\",\"poledne\",\"polibek\",\"polknout\",\"poloha\",\"polynom\",\"pomalu\",\"pominout\",\"pomlka\",\"pomoc\",\"pomsta\",\"pomyslet\",\"ponechat\",\"ponorka\",\"ponurost\",\"popadat\",\"popel\",\"popisek\",\"poplach\",\"poprosit\",\"popsat\",\"popud\",\"poradce\",\"porce\",\"porod\",\"porucha\",\"poryv\",\"posadit\",\"posed\",\"posila\",\"poskok\",\"poslanec\",\"posoudit\",\"pospolu\",\"postava\",\"posudek\",\"posyp\",\"potah\",\"potkan\",\"potlesk\",\"potomek\",\"potrava\",\"potupa\",\"potvora\",\"poukaz\",\"pouto\",\"pouzdro\",\"povaha\",\"povidla\",\"povlak\",\"povoz\",\"povrch\",\"povstat\",\"povyk\",\"povzdech\",\"pozdrav\",\"pozemek\",\"poznatek\",\"pozor\",\"pozvat\",\"pracovat\",\"prahory\",\"praktika\",\"prales\",\"praotec\",\"praporek\",\"prase\",\"pravda\",\"princip\",\"prkno\",\"probudit\",\"procento\",\"prodej\",\"profese\",\"prohra\",\"projekt\",\"prolomit\",\"promile\",\"pronikat\",\"propad\",\"prorok\",\"prosba\",\"proton\",\"proutek\",\"provaz\",\"prskavka\",\"prsten\",\"prudkost\",\"prut\",\"prvek\",\"prvohory\",\"psanec\",\"psovod\",\"pstruh\",\"ptactvo\",\"puberta\",\"puch\",\"pudl\",\"pukavec\",\"puklina\",\"pukrle\",\"pult\",\"pumpa\",\"punc\",\"pupen\",\"pusa\",\"pusinka\",\"pustina\",\"putovat\",\"putyka\",\"pyramida\",\"pysk\",\"pytel\",\"racek\",\"rachot\",\"radiace\",\"radnice\",\"radon\",\"raft\",\"ragby\",\"raketa\",\"rakovina\",\"rameno\",\"rampouch\",\"rande\",\"rarach\",\"rarita\",\"rasovna\",\"rastr\",\"ratolest\",\"razance\",\"razidlo\",\"reagovat\",\"reakce\",\"recept\",\"redaktor\",\"referent\",\"reflex\",\"rejnok\",\"reklama\",\"rekord\",\"rekrut\",\"rektor\",\"reputace\",\"revize\",\"revma\",\"revolver\",\"rezerva\",\"riskovat\",\"riziko\",\"robotika\",\"rodokmen\",\"rohovka\",\"rokle\",\"rokoko\",\"romaneto\",\"ropovod\",\"ropucha\",\"rorejs\",\"rosol\",\"rostlina\",\"rotmistr\",\"rotoped\",\"rotunda\",\"roubenka\",\"roucho\",\"roup\",\"roura\",\"rovina\",\"rovnice\",\"rozbor\",\"rozchod\",\"rozdat\",\"rozeznat\",\"rozhodce\",\"rozinka\",\"rozjezd\",\"rozkaz\",\"rozloha\",\"rozmar\",\"rozpad\",\"rozruch\",\"rozsah\",\"roztok\",\"rozum\",\"rozvod\",\"rubrika\",\"ruchadlo\",\"rukavice\",\"rukopis\",\"ryba\",\"rybolov\",\"rychlost\",\"rydlo\",\"rypadlo\",\"rytina\",\"ryzost\",\"sadista\",\"sahat\",\"sako\",\"samec\",\"samizdat\",\"samota\",\"sanitka\",\"sardinka\",\"sasanka\",\"satelit\",\"sazba\",\"sazenice\",\"sbor\",\"schovat\",\"sebranka\",\"secese\",\"sedadlo\",\"sediment\",\"sedlo\",\"sehnat\",\"sejmout\",\"sekera\",\"sekta\",\"sekunda\",\"sekvoje\",\"semeno\",\"seno\",\"servis\",\"sesadit\",\"seshora\",\"seskok\",\"seslat\",\"sestra\",\"sesuv\",\"sesypat\",\"setba\",\"setina\",\"setkat\",\"setnout\",\"setrvat\",\"sever\",\"seznam\",\"shoda\",\"shrnout\",\"sifon\",\"silnice\",\"sirka\",\"sirotek\",\"sirup\",\"situace\",\"skafandr\",\"skalisko\",\"skanzen\",\"skaut\",\"skeptik\",\"skica\",\"skladba\",\"sklenice\",\"sklo\",\"skluz\",\"skoba\",\"skokan\",\"skoro\",\"skripta\",\"skrz\",\"skupina\",\"skvost\",\"skvrna\",\"slabika\",\"sladidlo\",\"slanina\",\"slast\",\"slavnost\",\"sledovat\",\"slepec\",\"sleva\",\"slezina\",\"slib\",\"slina\",\"sliznice\",\"slon\",\"sloupek\",\"slovo\",\"sluch\",\"sluha\",\"slunce\",\"slupka\",\"slza\",\"smaragd\",\"smetana\",\"smilstvo\",\"smlouva\",\"smog\",\"smrad\",\"smrk\",\"smrtka\",\"smutek\",\"smysl\",\"snad\",\"snaha\",\"snob\",\"sobota\",\"socha\",\"sodovka\",\"sokol\",\"sopka\",\"sotva\",\"souboj\",\"soucit\",\"soudce\",\"souhlas\",\"soulad\",\"soumrak\",\"souprava\",\"soused\",\"soutok\",\"souviset\",\"spalovna\",\"spasitel\",\"spis\",\"splav\",\"spodek\",\"spojenec\",\"spolu\",\"sponzor\",\"spornost\",\"spousta\",\"sprcha\",\"spustit\",\"sranda\",\"sraz\",\"srdce\",\"srna\",\"srnec\",\"srovnat\",\"srpen\",\"srst\",\"srub\",\"stanice\",\"starosta\",\"statika\",\"stavba\",\"stehno\",\"stezka\",\"stodola\",\"stolek\",\"stopa\",\"storno\",\"stoupat\",\"strach\",\"stres\",\"strhnout\",\"strom\",\"struna\",\"studna\",\"stupnice\",\"stvol\",\"styk\",\"subjekt\",\"subtropy\",\"suchar\",\"sudost\",\"sukno\",\"sundat\",\"sunout\",\"surikata\",\"surovina\",\"svah\",\"svalstvo\",\"svetr\",\"svatba\",\"svazek\",\"svisle\",\"svitek\",\"svoboda\",\"svodidlo\",\"svorka\",\"svrab\",\"sykavka\",\"sykot\",\"synek\",\"synovec\",\"sypat\",\"sypkost\",\"syrovost\",\"sysel\",\"sytost\",\"tabletka\",\"tabule\",\"tahoun\",\"tajemno\",\"tajfun\",\"tajga\",\"tajit\",\"tajnost\",\"taktika\",\"tamhle\",\"tampon\",\"tancovat\",\"tanec\",\"tanker\",\"tapeta\",\"tavenina\",\"tazatel\",\"technika\",\"tehdy\",\"tekutina\",\"telefon\",\"temnota\",\"tendence\",\"tenista\",\"tenor\",\"teplota\",\"tepna\",\"teprve\",\"terapie\",\"termoska\",\"textil\",\"ticho\",\"tiskopis\",\"titulek\",\"tkadlec\",\"tkanina\",\"tlapka\",\"tleskat\",\"tlukot\",\"tlupa\",\"tmel\",\"toaleta\",\"topinka\",\"topol\",\"torzo\",\"touha\",\"toulec\",\"tradice\",\"traktor\",\"tramp\",\"trasa\",\"traverza\",\"trefit\",\"trest\",\"trezor\",\"trhavina\",\"trhlina\",\"trochu\",\"trojice\",\"troska\",\"trouba\",\"trpce\",\"trpitel\",\"trpkost\",\"trubec\",\"truchlit\",\"truhlice\",\"trus\",\"trvat\",\"tudy\",\"tuhnout\",\"tuhost\",\"tundra\",\"turista\",\"turnaj\",\"tuzemsko\",\"tvaroh\",\"tvorba\",\"tvrdost\",\"tvrz\",\"tygr\",\"tykev\",\"ubohost\",\"uboze\",\"ubrat\",\"ubrousek\",\"ubrus\",\"ubytovna\",\"ucho\",\"uctivost\",\"udivit\",\"uhradit\",\"ujednat\",\"ujistit\",\"ujmout\",\"ukazatel\",\"uklidnit\",\"uklonit\",\"ukotvit\",\"ukrojit\",\"ulice\",\"ulita\",\"ulovit\",\"umyvadlo\",\"unavit\",\"uniforma\",\"uniknout\",\"upadnout\",\"uplatnit\",\"uplynout\",\"upoutat\",\"upravit\",\"uran\",\"urazit\",\"usednout\",\"usilovat\",\"usmrtit\",\"usnadnit\",\"usnout\",\"usoudit\",\"ustlat\",\"ustrnout\",\"utahovat\",\"utkat\",\"utlumit\",\"utonout\",\"utopenec\",\"utrousit\",\"uvalit\",\"uvolnit\",\"uvozovka\",\"uzdravit\",\"uzel\",\"uzenina\",\"uzlina\",\"uznat\",\"vagon\",\"valcha\",\"valoun\",\"vana\",\"vandal\",\"vanilka\",\"varan\",\"varhany\",\"varovat\",\"vcelku\",\"vchod\",\"vdova\",\"vedro\",\"vegetace\",\"vejce\",\"velbloud\",\"veletrh\",\"velitel\",\"velmoc\",\"velryba\",\"venkov\",\"veranda\",\"verze\",\"veselka\",\"veskrze\",\"vesnice\",\"vespodu\",\"vesta\",\"veterina\",\"veverka\",\"vibrace\",\"vichr\",\"videohra\",\"vidina\",\"vidle\",\"vila\",\"vinice\",\"viset\",\"vitalita\",\"vize\",\"vizitka\",\"vjezd\",\"vklad\",\"vkus\",\"vlajka\",\"vlak\",\"vlasec\",\"vlevo\",\"vlhkost\",\"vliv\",\"vlnovka\",\"vloupat\",\"vnucovat\",\"vnuk\",\"voda\",\"vodivost\",\"vodoznak\",\"vodstvo\",\"vojensky\",\"vojna\",\"vojsko\",\"volant\",\"volba\",\"volit\",\"volno\",\"voskovka\",\"vozidlo\",\"vozovna\",\"vpravo\",\"vrabec\",\"vracet\",\"vrah\",\"vrata\",\"vrba\",\"vrcholek\",\"vrhat\",\"vrstva\",\"vrtule\",\"vsadit\",\"vstoupit\",\"vstup\",\"vtip\",\"vybavit\",\"vybrat\",\"vychovat\",\"vydat\",\"vydra\",\"vyfotit\",\"vyhledat\",\"vyhnout\",\"vyhodit\",\"vyhradit\",\"vyhubit\",\"vyjasnit\",\"vyjet\",\"vyjmout\",\"vyklopit\",\"vykonat\",\"vylekat\",\"vymazat\",\"vymezit\",\"vymizet\",\"vymyslet\",\"vynechat\",\"vynikat\",\"vynutit\",\"vypadat\",\"vyplatit\",\"vypravit\",\"vypustit\",\"vyrazit\",\"vyrovnat\",\"vyrvat\",\"vyslovit\",\"vysoko\",\"vystavit\",\"vysunout\",\"vysypat\",\"vytasit\",\"vytesat\",\"vytratit\",\"vyvinout\",\"vyvolat\",\"vyvrhel\",\"vyzdobit\",\"vyznat\",\"vzadu\",\"vzbudit\",\"vzchopit\",\"vzdor\",\"vzduch\",\"vzdychat\",\"vzestup\",\"vzhledem\",\"vzkaz\",\"vzlykat\",\"vznik\",\"vzorek\",\"vzpoura\",\"vztah\",\"vztek\",\"xylofon\",\"zabrat\",\"zabydlet\",\"zachovat\",\"zadarmo\",\"zadusit\",\"zafoukat\",\"zahltit\",\"zahodit\",\"zahrada\",\"zahynout\",\"zajatec\",\"zajet\",\"zajistit\",\"zaklepat\",\"zakoupit\",\"zalepit\",\"zamezit\",\"zamotat\",\"zamyslet\",\"zanechat\",\"zanikat\",\"zaplatit\",\"zapojit\",\"zapsat\",\"zarazit\",\"zastavit\",\"zasunout\",\"zatajit\",\"zatemnit\",\"zatknout\",\"zaujmout\",\"zavalit\",\"zavelet\",\"zavinit\",\"zavolat\",\"zavrtat\",\"zazvonit\",\"zbavit\",\"zbrusu\",\"zbudovat\",\"zbytek\",\"zdaleka\",\"zdarma\",\"zdatnost\",\"zdivo\",\"zdobit\",\"zdroj\",\"zdvih\",\"zdymadlo\",\"zelenina\",\"zeman\",\"zemina\",\"zeptat\",\"zezadu\",\"zezdola\",\"zhatit\",\"zhltnout\",\"zhluboka\",\"zhotovit\",\"zhruba\",\"zima\",\"zimnice\",\"zjemnit\",\"zklamat\",\"zkoumat\",\"zkratka\",\"zkumavka\",\"zlato\",\"zlehka\",\"zloba\",\"zlom\",\"zlost\",\"zlozvyk\",\"zmapovat\",\"zmar\",\"zmatek\",\"zmije\",\"zmizet\",\"zmocnit\",\"zmodrat\",\"zmrzlina\",\"zmutovat\",\"znak\",\"znalost\",\"znamenat\",\"znovu\",\"zobrazit\",\"zotavit\",\"zoubek\",\"zoufale\",\"zplodit\",\"zpomalit\",\"zprava\",\"zprostit\",\"zprudka\",\"zprvu\",\"zrada\",\"zranit\",\"zrcadlo\",\"zrnitost\",\"zrno\",\"zrovna\",\"zrychlit\",\"zrzavost\",\"zticha\",\"ztratit\",\"zubovina\",\"zubr\",\"zvednout\",\"zvenku\",\"zvesela\",\"zvon\",\"zvrat\",\"zvukovod\",\"zvyk\"]");

const require$$1 = /* #__PURE__ */ JSON.parse("[\"çš„\",\"ä¸€\",\"æ˜¯\",\"åœ¨\",\"ä¸\",\"äº†\",\"æœ‰\",\"å’Œ\",\"äºº\",\"è¿™\",\"ä¸­\",\"å¤§\",\"ä¸º\",\"ä¸Š\",\"ä¸ª\",\"å›½\",\"æˆ‘\",\"ä»¥\",\"è¦\",\"ä»–\",\"æ—¶\",\"æ¥\",\"ç”¨\",\"ä»¬\",\"ç”Ÿ\",\"åˆ°\",\"ä½œ\",\"åœ°\",\"äºŽ\",\"å‡º\",\"å°±\",\"åˆ†\",\"å¯¹\",\"æˆ\",\"ä¼š\",\"å¯\",\"ä¸»\",\"å‘\",\"å¹´\",\"åŠ¨\",\"åŒ\",\"å·¥\",\"ä¹Ÿ\",\"èƒ½\",\"ä¸‹\",\"è¿‡\",\"å­\",\"è¯´\",\"äº§\",\"ç§\",\"é¢\",\"è€Œ\",\"æ–¹\",\"åŽ\",\"å¤š\",\"å®š\",\"è¡Œ\",\"å­¦\",\"æ³•\",\"æ‰€\",\"æ°‘\",\"å¾—\",\"ç»\",\"å\",\"ä¸‰\",\"ä¹‹\",\"è¿›\",\"ç€\",\"ç­‰\",\"éƒ¨\",\"åº¦\",\"å®¶\",\"ç”µ\",\"åŠ›\",\"é‡Œ\",\"å¦‚\",\"æ°´\",\"åŒ–\",\"é«˜\",\"è‡ª\",\"äºŒ\",\"ç†\",\"èµ·\",\"å°\",\"ç‰©\",\"çŽ°\",\"å®ž\",\"åŠ \",\"é‡\",\"éƒ½\",\"ä¸¤\",\"ä½“\",\"åˆ¶\",\"æœº\",\"å½“\",\"ä½¿\",\"ç‚¹\",\"ä»Ž\",\"ä¸š\",\"æœ¬\",\"åŽ»\",\"æŠŠ\",\"æ€§\",\"å¥½\",\"åº”\",\"å¼€\",\"å®ƒ\",\"åˆ\",\"è¿˜\",\"å› \",\"ç”±\",\"å…¶\",\"äº›\",\"ç„¶\",\"å‰\",\"å¤–\",\"å¤©\",\"æ”¿\",\"å››\",\"æ—¥\",\"é‚£\",\"ç¤¾\",\"ä¹‰\",\"äº‹\",\"å¹³\",\"å½¢\",\"ç›¸\",\"å…¨\",\"è¡¨\",\"é—´\",\"æ ·\",\"ä¸Ž\",\"å…³\",\"å„\",\"é‡\",\"æ–°\",\"çº¿\",\"å†…\",\"æ•°\",\"æ­£\",\"å¿ƒ\",\"å\",\"ä½ \",\"æ˜Ž\",\"çœ‹\",\"åŽŸ\",\"åˆ\",\"ä¹ˆ\",\"åˆ©\",\"æ¯”\",\"æˆ–\",\"ä½†\",\"è´¨\",\"æ°”\",\"ç¬¬\",\"å‘\",\"é“\",\"å‘½\",\"æ­¤\",\"å˜\",\"æ¡\",\"åª\",\"æ²¡\",\"ç»“\",\"è§£\",\"é—®\",\"æ„\",\"å»º\",\"æœˆ\",\"å…¬\",\"æ— \",\"ç³»\",\"å†›\",\"å¾ˆ\",\"æƒ…\",\"è€…\",\"æœ€\",\"ç«‹\",\"ä»£\",\"æƒ³\",\"å·²\",\"é€š\",\"å¹¶\",\"æ\",\"ç›´\",\"é¢˜\",\"å…š\",\"ç¨‹\",\"å±•\",\"äº”\",\"æžœ\",\"æ–™\",\"è±¡\",\"å‘˜\",\"é©\",\"ä½\",\"å…¥\",\"å¸¸\",\"æ–‡\",\"æ€»\",\"æ¬¡\",\"å“\",\"å¼\",\"æ´»\",\"è®¾\",\"åŠ\",\"ç®¡\",\"ç‰¹\",\"ä»¶\",\"é•¿\",\"æ±‚\",\"è€\",\"å¤´\",\"åŸº\",\"èµ„\",\"è¾¹\",\"æµ\",\"è·¯\",\"çº§\",\"å°‘\",\"å›¾\",\"å±±\",\"ç»Ÿ\",\"æŽ¥\",\"çŸ¥\",\"è¾ƒ\",\"å°†\",\"ç»„\",\"è§\",\"è®¡\",\"åˆ«\",\"å¥¹\",\"æ‰‹\",\"è§’\",\"æœŸ\",\"æ ¹\",\"è®º\",\"è¿\",\"å†œ\",\"æŒ‡\",\"å‡ \",\"ä¹\",\"åŒº\",\"å¼º\",\"æ”¾\",\"å†³\",\"è¥¿\",\"è¢«\",\"å¹²\",\"åš\",\"å¿…\",\"æˆ˜\",\"å…ˆ\",\"å›ž\",\"åˆ™\",\"ä»»\",\"å–\",\"æ®\",\"å¤„\",\"é˜Ÿ\",\"å—\",\"ç»™\",\"è‰²\",\"å…‰\",\"é—¨\",\"å³\",\"ä¿\",\"æ²»\",\"åŒ—\",\"é€ \",\"ç™¾\",\"è§„\",\"çƒ­\",\"é¢†\",\"ä¸ƒ\",\"æµ·\",\"å£\",\"ä¸œ\",\"å¯¼\",\"å™¨\",\"åŽ‹\",\"å¿—\",\"ä¸–\",\"é‡‘\",\"å¢ž\",\"äº‰\",\"æµŽ\",\"é˜¶\",\"æ²¹\",\"æ€\",\"æœ¯\",\"æž\",\"äº¤\",\"å—\",\"è”\",\"ä»€\",\"è®¤\",\"å…­\",\"å…±\",\"æƒ\",\"æ”¶\",\"è¯\",\"æ”¹\",\"æ¸…\",\"ç¾Ž\",\"å†\",\"é‡‡\",\"è½¬\",\"æ›´\",\"å•\",\"é£Ž\",\"åˆ‡\",\"æ‰“\",\"ç™½\",\"æ•™\",\"é€Ÿ\",\"èŠ±\",\"å¸¦\",\"å®‰\",\"åœº\",\"èº«\",\"è½¦\",\"ä¾‹\",\"çœŸ\",\"åŠ¡\",\"å…·\",\"ä¸‡\",\"æ¯\",\"ç›®\",\"è‡³\",\"è¾¾\",\"èµ°\",\"ç§¯\",\"ç¤º\",\"è®®\",\"å£°\",\"æŠ¥\",\"æ–—\",\"å®Œ\",\"ç±»\",\"å…«\",\"ç¦»\",\"åŽ\",\"å\",\"ç¡®\",\"æ‰\",\"ç§‘\",\"å¼ \",\"ä¿¡\",\"é©¬\",\"èŠ‚\",\"è¯\",\"ç±³\",\"æ•´\",\"ç©º\",\"å…ƒ\",\"å†µ\",\"ä»Š\",\"é›†\",\"æ¸©\",\"ä¼ \",\"åœŸ\",\"è®¸\",\"æ­¥\",\"ç¾¤\",\"å¹¿\",\"çŸ³\",\"è®°\",\"éœ€\",\"æ®µ\",\"ç ”\",\"ç•Œ\",\"æ‹‰\",\"æž—\",\"å¾‹\",\"å«\",\"ä¸”\",\"ç©¶\",\"è§‚\",\"è¶Š\",\"ç»‡\",\"è£…\",\"å½±\",\"ç®—\",\"ä½Ž\",\"æŒ\",\"éŸ³\",\"ä¼—\",\"ä¹¦\",\"å¸ƒ\",\"å¤\",\"å®¹\",\"å„¿\",\"é¡»\",\"é™…\",\"å•†\",\"éž\",\"éªŒ\",\"è¿ž\",\"æ–­\",\"æ·±\",\"éš¾\",\"è¿‘\",\"çŸ¿\",\"åƒ\",\"å‘¨\",\"å§”\",\"ç´ \",\"æŠ€\",\"å¤‡\",\"åŠ\",\"åŠž\",\"é’\",\"çœ\",\"åˆ—\",\"ä¹ \",\"å“\",\"çº¦\",\"æ”¯\",\"èˆ¬\",\"å²\",\"æ„Ÿ\",\"åŠ³\",\"ä¾¿\",\"å›¢\",\"å¾€\",\"é…¸\",\"åŽ†\",\"å¸‚\",\"å…‹\",\"ä½•\",\"é™¤\",\"æ¶ˆ\",\"æž„\",\"åºœ\",\"ç§°\",\"å¤ª\",\"å‡†\",\"ç²¾\",\"å€¼\",\"å·\",\"çŽ‡\",\"æ—\",\"ç»´\",\"åˆ’\",\"é€‰\",\"æ ‡\",\"å†™\",\"å­˜\",\"å€™\",\"æ¯›\",\"äº²\",\"å¿«\",\"æ•ˆ\",\"æ–¯\",\"é™¢\",\"æŸ¥\",\"æ±Ÿ\",\"åž‹\",\"çœ¼\",\"çŽ‹\",\"æŒ‰\",\"æ ¼\",\"å…»\",\"æ˜“\",\"ç½®\",\"æ´¾\",\"å±‚\",\"ç‰‡\",\"å§‹\",\"å´\",\"ä¸“\",\"çŠ¶\",\"è‚²\",\"åŽ‚\",\"äº¬\",\"è¯†\",\"é€‚\",\"å±ž\",\"åœ†\",\"åŒ…\",\"ç«\",\"ä½\",\"è°ƒ\",\"æ»¡\",\"åŽ¿\",\"å±€\",\"ç…§\",\"å‚\",\"çº¢\",\"ç»†\",\"å¼•\",\"å¬\",\"è¯¥\",\"é“\",\"ä»·\",\"ä¸¥\",\"é¦–\",\"åº•\",\"æ¶²\",\"å®˜\",\"å¾·\",\"éš\",\"ç—…\",\"è‹\",\"å¤±\",\"å°”\",\"æ­»\",\"è®²\",\"é…\",\"å¥³\",\"é»„\",\"æŽ¨\",\"æ˜¾\",\"è°ˆ\",\"ç½ª\",\"ç¥ž\",\"è‰º\",\"å‘¢\",\"å¸­\",\"å«\",\"ä¼\",\"æœ›\",\"å¯†\",\"æ‰¹\",\"è¥\",\"é¡¹\",\"é˜²\",\"ä¸¾\",\"çƒ\",\"è‹±\",\"æ°§\",\"åŠ¿\",\"å‘Š\",\"æŽ\",\"å°\",\"è½\",\"æœ¨\",\"å¸®\",\"è½®\",\"ç ´\",\"äºš\",\"å¸ˆ\",\"å›´\",\"æ³¨\",\"è¿œ\",\"å­—\",\"æ\",\"æŽ’\",\"ä¾›\",\"æ²³\",\"æ€\",\"å°\",\"å¦\",\"æ–½\",\"å‡\",\"æ ‘\",\"æº¶\",\"æ€Ž\",\"æ­¢\",\"æ¡ˆ\",\"è¨€\",\"å£«\",\"å‡\",\"æ­¦\",\"å›º\",\"å¶\",\"é±¼\",\"æ³¢\",\"è§†\",\"ä»…\",\"è´¹\",\"ç´§\",\"çˆ±\",\"å·¦\",\"ç« \",\"æ—©\",\"æœ\",\"å®³\",\"ç»­\",\"è½»\",\"æœ\",\"è¯•\",\"é£Ÿ\",\"å……\",\"å…µ\",\"æº\",\"åˆ¤\",\"æŠ¤\",\"å¸\",\"è¶³\",\"æŸ\",\"ç»ƒ\",\"å·®\",\"è‡´\",\"æ¿\",\"ç”°\",\"é™\",\"é»‘\",\"çŠ¯\",\"è´Ÿ\",\"å‡»\",\"èŒƒ\",\"ç»§\",\"å…´\",\"ä¼¼\",\"ä½™\",\"åš\",\"æ›²\",\"è¾“\",\"ä¿®\",\"æ•…\",\"åŸŽ\",\"å¤«\",\"å¤Ÿ\",\"é€\",\"ç¬”\",\"èˆ¹\",\"å \",\"å³\",\"è´¢\",\"åƒ\",\"å¯Œ\",\"æ˜¥\",\"èŒ\",\"è§‰\",\"æ±‰\",\"ç”»\",\"åŠŸ\",\"å·´\",\"è·Ÿ\",\"è™½\",\"æ‚\",\"é£ž\",\"æ£€\",\"å¸\",\"åŠ©\",\"å‡\",\"é˜³\",\"äº’\",\"åˆ\",\"åˆ›\",\"æŠ—\",\"è€ƒ\",\"æŠ•\",\"å\",\"ç­–\",\"å¤\",\"å¾„\",\"æ¢\",\"æœª\",\"è·‘\",\"ç•™\",\"é’¢\",\"æ›¾\",\"ç«¯\",\"è´£\",\"ç«™\",\"ç®€\",\"è¿°\",\"é’±\",\"å‰¯\",\"å°½\",\"å¸\",\"å°„\",\"è‰\",\"å†²\",\"æ‰¿\",\"ç‹¬\",\"ä»¤\",\"é™\",\"é˜¿\",\"å®£\",\"çŽ¯\",\"åŒ\",\"è¯·\",\"è¶…\",\"å¾®\",\"è®©\",\"æŽ§\",\"å·ž\",\"è‰¯\",\"è½´\",\"æ‰¾\",\"å¦\",\"çºª\",\"ç›Š\",\"ä¾\",\"ä¼˜\",\"é¡¶\",\"ç¡€\",\"è½½\",\"å€’\",\"æˆ¿\",\"çª\",\"å\",\"ç²‰\",\"æ•Œ\",\"ç•¥\",\"å®¢\",\"è¢\",\"å†·\",\"èƒœ\",\"ç»\",\"æž\",\"å—\",\"å‰‚\",\"æµ‹\",\"ä¸\",\"å\",\"è¯‰\",\"å¿µ\",\"é™ˆ\",\"ä»\",\"ç½—\",\"ç›\",\"å‹\",\"æ´‹\",\"é”™\",\"è‹¦\",\"å¤œ\",\"åˆ‘\",\"ç§»\",\"é¢‘\",\"é€\",\"é \",\"æ··\",\"æ¯\",\"çŸ­\",\"çš®\",\"ç»ˆ\",\"èš\",\"æ±½\",\"æ‘\",\"äº‘\",\"å“ª\",\"æ—¢\",\"è·\",\"å«\",\"åœ\",\"çƒˆ\",\"å¤®\",\"å¯Ÿ\",\"çƒ§\",\"è¿…\",\"å¢ƒ\",\"è‹¥\",\"å°\",\"æ´²\",\"åˆ»\",\"æ‹¬\",\"æ¿€\",\"å­”\",\"æž\",\"ç”š\",\"å®¤\",\"å¾…\",\"æ ¸\",\"æ ¡\",\"æ•£\",\"ä¾µ\",\"å§\",\"ç”²\",\"æ¸¸\",\"ä¹…\",\"èœ\",\"å‘³\",\"æ—§\",\"æ¨¡\",\"æ¹–\",\"è´§\",\"æŸ\",\"é¢„\",\"é˜»\",\"æ¯«\",\"æ™®\",\"ç¨³\",\"ä¹™\",\"å¦ˆ\",\"æ¤\",\"æ¯\",\"æ‰©\",\"é“¶\",\"è¯­\",\"æŒ¥\",\"é…’\",\"å®ˆ\",\"æ‹¿\",\"åº\",\"çº¸\",\"åŒ»\",\"ç¼º\",\"é›¨\",\"å—\",\"é’ˆ\",\"åˆ˜\",\"å•Š\",\"æ€¥\",\"å”±\",\"è¯¯\",\"è®­\",\"æ„¿\",\"å®¡\",\"é™„\",\"èŽ·\",\"èŒ¶\",\"é²œ\",\"ç²®\",\"æ–¤\",\"å­©\",\"è„±\",\"ç¡«\",\"è‚¥\",\"å–„\",\"é¾™\",\"æ¼”\",\"çˆ¶\",\"æ¸\",\"è¡€\",\"æ¬¢\",\"æ¢°\",\"æŽŒ\",\"æ­Œ\",\"æ²™\",\"åˆš\",\"æ”»\",\"è°“\",\"ç›¾\",\"è®¨\",\"æ™š\",\"ç²’\",\"ä¹±\",\"ç‡ƒ\",\"çŸ›\",\"ä¹Ž\",\"æ€\",\"è¯\",\"å®\",\"é²\",\"è´µ\",\"é’Ÿ\",\"ç…¤\",\"è¯»\",\"ç­\",\"ä¼¯\",\"é¦™\",\"ä»‹\",\"è¿«\",\"å¥\",\"ä¸°\",\"åŸ¹\",\"æ¡\",\"å…°\",\"æ‹…\",\"å¼¦\",\"è›‹\",\"æ²‰\",\"å‡\",\"ç©¿\",\"æ‰§\",\"ç­”\",\"ä¹\",\"è°\",\"é¡º\",\"çƒŸ\",\"ç¼©\",\"å¾\",\"è„¸\",\"å–œ\",\"æ¾\",\"è„š\",\"å›°\",\"å¼‚\",\"å…\",\"èƒŒ\",\"æ˜Ÿ\",\"ç¦\",\"ä¹°\",\"æŸ“\",\"äº•\",\"æ¦‚\",\"æ…¢\",\"æ€•\",\"ç£\",\"å€\",\"ç¥–\",\"çš‡\",\"ä¿ƒ\",\"é™\",\"è¡¥\",\"è¯„\",\"ç¿»\",\"è‚‰\",\"è·µ\",\"å°¼\",\"è¡£\",\"å®½\",\"æ‰¬\",\"æ£‰\",\"å¸Œ\",\"ä¼¤\",\"æ“\",\"åž‚\",\"ç§‹\",\"å®œ\",\"æ°¢\",\"å¥—\",\"ç£\",\"æŒ¯\",\"æž¶\",\"äº®\",\"æœ«\",\"å®ª\",\"åº†\",\"ç¼–\",\"ç‰›\",\"è§¦\",\"æ˜ \",\"é›·\",\"é”€\",\"è¯—\",\"åº§\",\"å±…\",\"æŠ“\",\"è£‚\",\"èƒž\",\"å‘¼\",\"å¨˜\",\"æ™¯\",\"å¨\",\"ç»¿\",\"æ™¶\",\"åŽš\",\"ç›Ÿ\",\"è¡¡\",\"é¸¡\",\"å­™\",\"å»¶\",\"å±\",\"èƒ¶\",\"å±‹\",\"ä¹¡\",\"ä¸´\",\"é™†\",\"é¡¾\",\"æŽ‰\",\"å‘€\",\"ç¯\",\"å²\",\"æŽª\",\"æŸ\",\"è€\",\"å‰§\",\"çŽ‰\",\"èµµ\",\"è·³\",\"å“¥\",\"å­£\",\"è¯¾\",\"å‡¯\",\"èƒ¡\",\"é¢\",\"æ¬¾\",\"ç»\",\"å·\",\"é½\",\"ä¼Ÿ\",\"è’¸\",\"æ®–\",\"æ°¸\",\"å®—\",\"è‹—\",\"å·\",\"ç‚‰\",\"å²©\",\"å¼±\",\"é›¶\",\"æ¨\",\"å¥\",\"æ²¿\",\"éœ²\",\"æ†\",\"æŽ¢\",\"æ»‘\",\"é•‡\",\"é¥­\",\"æµ“\",\"èˆª\",\"æ€€\",\"èµ¶\",\"åº“\",\"å¤º\",\"ä¼Š\",\"çµ\",\"ç¨Ž\",\"é€”\",\"ç­\",\"èµ›\",\"å½’\",\"å¬\",\"é¼“\",\"æ’­\",\"ç›˜\",\"è£\",\"é™©\",\"åº·\",\"å”¯\",\"å½•\",\"èŒ\",\"çº¯\",\"å€Ÿ\",\"ç³–\",\"ç›–\",\"æ¨ª\",\"ç¬¦\",\"ç§\",\"åŠª\",\"å ‚\",\"åŸŸ\",\"æžª\",\"æ¶¦\",\"å¹…\",\"å“ˆ\",\"ç«Ÿ\",\"ç†Ÿ\",\"è™«\",\"æ³½\",\"è„‘\",\"å£¤\",\"ç¢³\",\"æ¬§\",\"é\",\"ä¾§\",\"å¯¨\",\"æ•¢\",\"å½»\",\"è™‘\",\"æ–œ\",\"è–„\",\"åº­\",\"çº³\",\"å¼¹\",\"é¥²\",\"ä¼¸\",\"æŠ˜\",\"éº¦\",\"æ¹¿\",\"æš—\",\"è·\",\"ç“¦\",\"å¡ž\",\"åºŠ\",\"ç­‘\",\"æ¶\",\"æˆ·\",\"è®¿\",\"å¡”\",\"å¥‡\",\"é€\",\"æ¢\",\"åˆ€\",\"æ—‹\",\"è¿¹\",\"å¡\",\"æ°¯\",\"é‡\",\"ä»½\",\"æ¯’\",\"æ³¥\",\"é€€\",\"æ´—\",\"æ‘†\",\"ç°\",\"å½©\",\"å–\",\"è€—\",\"å¤\",\"æ‹©\",\"å¿™\",\"é“œ\",\"çŒ®\",\"ç¡¬\",\"äºˆ\",\"ç¹\",\"åœˆ\",\"é›ª\",\"å‡½\",\"äº¦\",\"æŠ½\",\"ç¯‡\",\"é˜µ\",\"é˜´\",\"ä¸\",\"å°º\",\"è¿½\",\"å †\",\"é›„\",\"è¿Ž\",\"æ³›\",\"çˆ¸\",\"æ¥¼\",\"é¿\",\"è°‹\",\"å¨\",\"é‡Ž\",\"çŒª\",\"æ——\",\"ç´¯\",\"å\",\"å…¸\",\"é¦†\",\"ç´¢\",\"ç§¦\",\"è„‚\",\"æ½®\",\"çˆ·\",\"è±†\",\"å¿½\",\"æ‰˜\",\"æƒŠ\",\"å¡‘\",\"é—\",\"æ„ˆ\",\"æœ±\",\"æ›¿\",\"çº¤\",\"ç²—\",\"å€¾\",\"å°š\",\"ç—›\",\"æ¥š\",\"è°¢\",\"å¥‹\",\"è´­\",\"ç£¨\",\"å›\",\"æ± \",\"æ—\",\"ç¢Ž\",\"éª¨\",\"ç›‘\",\"æ•\",\"å¼Ÿ\",\"æš´\",\"å‰²\",\"è´¯\",\"æ®Š\",\"é‡Š\",\"è¯\",\"äº¡\",\"å£\",\"é¡¿\",\"å®\",\"åˆ\",\"å°˜\",\"é—»\",\"æ­\",\"ç‚®\",\"æ®‹\",\"å†¬\",\"æ¡¥\",\"å¦‡\",\"è­¦\",\"ç»¼\",\"æ‹›\",\"å´\",\"ä»˜\",\"æµ®\",\"é­\",\"å¾\",\"æ‚¨\",\"æ‘‡\",\"è°·\",\"èµž\",\"ç®±\",\"éš”\",\"è®¢\",\"ç”·\",\"å¹\",\"å›­\",\"çº·\",\"å”\",\"è´¥\",\"å®‹\",\"çŽ»\",\"å·¨\",\"è€•\",\"å¦\",\"è£\",\"é—­\",\"æ¹¾\",\"é”®\",\"å‡¡\",\"é©»\",\"é”…\",\"æ•‘\",\"æ©\",\"å‰¥\",\"å‡\",\"ç¢±\",\"é½¿\",\"æˆª\",\"ç‚¼\",\"éº»\",\"çºº\",\"ç¦\",\"åºŸ\",\"ç››\",\"ç‰ˆ\",\"ç¼“\",\"å‡€\",\"ç›\",\"æ˜Œ\",\"å©š\",\"æ¶‰\",\"ç­’\",\"å˜´\",\"æ’\",\"å²¸\",\"æœ—\",\"åº„\",\"è¡—\",\"è—\",\"å§‘\",\"è´¸\",\"è…\",\"å¥´\",\"å•¦\",\"æƒ¯\",\"ä¹˜\",\"ä¼™\",\"æ¢\",\"åŒ€\",\"çº±\",\"æ‰Ž\",\"è¾©\",\"è€³\",\"å½ª\",\"è‡£\",\"äº¿\",\"ç’ƒ\",\"æŠµ\",\"è„‰\",\"ç§€\",\"è¨\",\"ä¿„\",\"ç½‘\",\"èˆž\",\"åº—\",\"å–·\",\"çºµ\",\"å¯¸\",\"æ±—\",\"æŒ‚\",\"æ´ª\",\"è´º\",\"é—ª\",\"æŸ¬\",\"çˆ†\",\"çƒ¯\",\"æ´¥\",\"ç¨»\",\"å¢™\",\"è½¯\",\"å‹‡\",\"åƒ\",\"æ»š\",\"åŽ˜\",\"è’™\",\"èŠ³\",\"è‚¯\",\"å¡\",\"æŸ±\",\"è¡\",\"è…¿\",\"ä»ª\",\"æ—…\",\"å°¾\",\"è½§\",\"å†°\",\"è´¡\",\"ç™»\",\"é»Ž\",\"å‰Š\",\"é’»\",\"å‹’\",\"é€ƒ\",\"éšœ\",\"æ°¨\",\"éƒ­\",\"å³°\",\"å¸\",\"æ¸¯\",\"ä¼\",\"è½¨\",\"äº©\",\"æ¯•\",\"æ“¦\",\"èŽ«\",\"åˆº\",\"æµª\",\"ç§˜\",\"æ´\",\"æ ª\",\"å¥\",\"å”®\",\"è‚¡\",\"å²›\",\"ç”˜\",\"æ³¡\",\"ç¡\",\"ç«¥\",\"é“¸\",\"æ±¤\",\"é˜€\",\"ä¼‘\",\"æ±‡\",\"èˆ\",\"ç‰§\",\"ç»•\",\"ç‚¸\",\"å“²\",\"ç£·\",\"ç»©\",\"æœ‹\",\"æ·¡\",\"å°–\",\"å¯\",\"é™·\",\"æŸ´\",\"å‘ˆ\",\"å¾’\",\"é¢œ\",\"æ³ª\",\"ç¨\",\"å¿˜\",\"æ³µ\",\"è“\",\"æ‹–\",\"æ´ž\",\"æŽˆ\",\"é•œ\",\"è¾›\",\"å£®\",\"é”‹\",\"è´«\",\"è™š\",\"å¼¯\",\"æ‘©\",\"æ³°\",\"å¹¼\",\"å»·\",\"å°Š\",\"çª—\",\"çº²\",\"å¼„\",\"éš¶\",\"ç–‘\",\"æ°\",\"å®«\",\"å§\",\"éœ‡\",\"ç‘ž\",\"æ€ª\",\"å°¤\",\"ç´\",\"å¾ª\",\"æ\",\"è†œ\",\"è¿\",\"å¤¹\",\"è…°\",\"ç¼˜\",\"ç \",\"ç©·\",\"æ£®\",\"æž\",\"ç«¹\",\"æ²Ÿ\",\"å‚¬\",\"ç»³\",\"å¿†\",\"é‚¦\",\"å‰©\",\"å¹¸\",\"æµ†\",\"æ \",\"æ‹¥\",\"ç‰™\",\"è´®\",\"ç¤¼\",\"æ»¤\",\"é’ \",\"çº¹\",\"ç½¢\",\"æ‹\",\"å’±\",\"å–Š\",\"è¢–\",\"åŸƒ\",\"å‹¤\",\"ç½š\",\"ç„¦\",\"æ½œ\",\"ä¼\",\"å¢¨\",\"æ¬²\",\"ç¼\",\"å§“\",\"åˆŠ\",\"é¥±\",\"ä»¿\",\"å¥–\",\"é“\",\"é¬¼\",\"ä¸½\",\"è·¨\",\"é»˜\",\"æŒ–\",\"é“¾\",\"æ‰«\",\"å–\",\"è¢‹\",\"ç‚­\",\"æ±¡\",\"å¹•\",\"è¯¸\",\"å¼§\",\"åŠ±\",\"æ¢…\",\"å¥¶\",\"æ´\",\"ç¾\",\"èˆŸ\",\"é‰´\",\"è‹¯\",\"è®¼\",\"æŠ±\",\"æ¯\",\"æ‡‚\",\"å¯’\",\"æ™º\",\"åŸ”\",\"å¯„\",\"å±Š\",\"è·ƒ\",\"æ¸¡\",\"æŒ‘\",\"ä¸¹\",\"è‰°\",\"è´\",\"ç¢°\",\"æ‹”\",\"çˆ¹\",\"æˆ´\",\"ç \",\"æ¢¦\",\"èŠ½\",\"ç†”\",\"èµ¤\",\"æ¸”\",\"å“­\",\"æ•¬\",\"é¢—\",\"å¥”\",\"é“…\",\"ä»²\",\"è™Ž\",\"ç¨€\",\"å¦¹\",\"ä¹\",\"ç\",\"ç”³\",\"æ¡Œ\",\"éµ\",\"å…\",\"éš†\",\"èžº\",\"ä»“\",\"é­\",\"é”\",\"æ™“\",\"æ°®\",\"å…¼\",\"éš\",\"ç¢\",\"èµ«\",\"æ‹¨\",\"å¿ \",\"è‚ƒ\",\"ç¼¸\",\"ç‰µ\",\"æŠ¢\",\"åš\",\"å·§\",\"å£³\",\"å…„\",\"æœ\",\"è®¯\",\"è¯š\",\"ç¢§\",\"ç¥¥\",\"æŸ¯\",\"é¡µ\",\"å·¡\",\"çŸ©\",\"æ‚²\",\"çŒ\",\"é¾„\",\"ä¼¦\",\"ç¥¨\",\"å¯»\",\"æ¡‚\",\"é“º\",\"åœ£\",\"æ\",\"æ°\",\"éƒ‘\",\"è¶£\",\"æŠ¬\",\"è’\",\"è…¾\",\"è´´\",\"æŸ”\",\"æ»´\",\"çŒ›\",\"é˜”\",\"è¾†\",\"å¦»\",\"å¡«\",\"æ’¤\",\"å‚¨\",\"ç­¾\",\"é—¹\",\"æ‰°\",\"ç´«\",\"ç ‚\",\"é€’\",\"æˆ\",\"åŠ\",\"é™¶\",\"ä¼\",\"å–‚\",\"ç–—\",\"ç“¶\",\"å©†\",\"æŠš\",\"è‡‚\",\"æ‘¸\",\"å¿\",\"è™¾\",\"èœ¡\",\"é‚»\",\"èƒ¸\",\"å·©\",\"æŒ¤\",\"å¶\",\"å¼ƒ\",\"æ§½\",\"åŠ²\",\"ä¹³\",\"é‚“\",\"å‰\",\"ä»\",\"çƒ‚\",\"ç –\",\"ç§Ÿ\",\"ä¹Œ\",\"èˆ°\",\"ä¼´\",\"ç“œ\",\"æµ…\",\"ä¸™\",\"æš‚\",\"ç‡¥\",\"æ©¡\",\"æŸ³\",\"è¿·\",\"æš–\",\"ç‰Œ\",\"ç§§\",\"èƒ†\",\"è¯¦\",\"ç°§\",\"è¸\",\"ç“·\",\"è°±\",\"å‘†\",\"å®¾\",\"ç³Š\",\"æ´›\",\"è¾‰\",\"æ„¤\",\"ç«ž\",\"éš™\",\"æ€’\",\"ç²˜\",\"ä¹ƒ\",\"ç»ª\",\"è‚©\",\"ç±\",\"æ•\",\"æ¶‚\",\"ç†™\",\"çš†\",\"ä¾¦\",\"æ‚¬\",\"æŽ˜\",\"äº«\",\"çº \",\"é†’\",\"ç‹‚\",\"é”\",\"æ·€\",\"æ¨\",\"ç‰²\",\"éœ¸\",\"çˆ¬\",\"èµ\",\"é€†\",\"çŽ©\",\"é™µ\",\"ç¥\",\"ç§’\",\"æµ™\",\"è²Œ\",\"å½¹\",\"å½¼\",\"æ‚‰\",\"é¸­\",\"è¶‹\",\"å‡¤\",\"æ™¨\",\"ç•œ\",\"è¾ˆ\",\"ç§©\",\"åµ\",\"ç½²\",\"æ¢¯\",\"ç‚Ž\",\"æ»©\",\"æ£‹\",\"é©±\",\"ç­›\",\"å³¡\",\"å†’\",\"å•¥\",\"å¯¿\",\"è¯‘\",\"æµ¸\",\"æ³‰\",\"å¸½\",\"è¿Ÿ\",\"ç¡…\",\"ç–†\",\"è´·\",\"æ¼\",\"ç¨¿\",\"å† \",\"å«©\",\"èƒ\",\"èŠ¯\",\"ç‰¢\",\"å›\",\"èš€\",\"å¥¥\",\"é¸£\",\"å²­\",\"ç¾Š\",\"å‡­\",\"ä¸²\",\"å¡˜\",\"ç»˜\",\"é…µ\",\"èž\",\"ç›†\",\"é”¡\",\"åº™\",\"ç­¹\",\"å†»\",\"è¾…\",\"æ‘„\",\"è¢­\",\"ç­‹\",\"æ‹’\",\"åƒš\",\"æ—±\",\"é’¾\",\"é¸Ÿ\",\"æ¼†\",\"æ²ˆ\",\"çœ‰\",\"ç–\",\"æ·»\",\"æ£’\",\"ç©—\",\"ç¡\",\"éŸ©\",\"é€¼\",\"æ‰­\",\"ä¾¨\",\"å‡‰\",\"æŒº\",\"ç¢—\",\"æ ½\",\"ç‚’\",\"æ¯\",\"æ‚£\",\"é¦\",\"åŠ\",\"è±ª\",\"è¾½\",\"å‹ƒ\",\"é¸¿\",\"æ—¦\",\"å\",\"æ‹œ\",\"ç‹—\",\"åŸ‹\",\"è¾Š\",\"æŽ©\",\"é¥®\",\"æ¬\",\"éª‚\",\"è¾ž\",\"å‹¾\",\"æ‰£\",\"ä¼°\",\"è’‹\",\"ç»’\",\"é›¾\",\"ä¸ˆ\",\"æœµ\",\"å§†\",\"æ‹Ÿ\",\"å®‡\",\"è¾‘\",\"é™•\",\"é›•\",\"å¿\",\"è“„\",\"å´‡\",\"å‰ª\",\"å€¡\",\"åŽ…\",\"å’¬\",\"é©¶\",\"è–¯\",\"åˆ·\",\"æ–¥\",\"ç•ª\",\"èµ‹\",\"å¥‰\",\"ä½›\",\"æµ‡\",\"æ¼«\",\"æ›¼\",\"æ‰‡\",\"é’™\",\"æ¡ƒ\",\"æ‰¶\",\"ä»”\",\"è¿”\",\"ä¿—\",\"äº\",\"è…”\",\"éž‹\",\"æ£±\",\"è¦†\",\"æ¡†\",\"æ‚„\",\"å”\",\"æ’ž\",\"éª—\",\"å‹˜\",\"æ—º\",\"æ²¸\",\"å­¤\",\"å\",\"å­Ÿ\",\"æ¸ \",\"å±ˆ\",\"ç–¾\",\"å¦™\",\"æƒœ\",\"ä»°\",\"ç‹ \",\"èƒ€\",\"è°\",\"æŠ›\",\"éœ‰\",\"æ¡‘\",\"å²—\",\"å˜›\",\"è¡°\",\"ç›—\",\"æ¸—\",\"è„\",\"èµ–\",\"æ¶Œ\",\"ç”œ\",\"æ›¹\",\"é˜…\",\"è‚Œ\",\"å“©\",\"åŽ‰\",\"çƒƒ\",\"çº¬\",\"æ¯…\",\"æ˜¨\",\"ä¼ª\",\"ç—‡\",\"ç…®\",\"å¹\",\"é’‰\",\"æ­\",\"èŒŽ\",\"ç¬¼\",\"é…·\",\"å·\",\"å¼“\",\"é”¥\",\"æ’\",\"æ°\",\"å‘\",\"é¼»\",\"ç¿¼\",\"çº¶\",\"å™\",\"ç‹±\",\"é€®\",\"ç½\",\"ç»œ\",\"æ£š\",\"æŠ‘\",\"è†¨\",\"è”¬\",\"å¯º\",\"éª¤\",\"ç©†\",\"å†¶\",\"æž¯\",\"å†Œ\",\"å°¸\",\"å‡¸\",\"ç»…\",\"å¯\",\"ç‰º\",\"ç„°\",\"è½°\",\"æ¬£\",\"æ™‹\",\"ç˜¦\",\"å¾¡\",\"é”­\",\"é”¦\",\"ä¸§\",\"æ—¬\",\"é”»\",\"åž„\",\"æœ\",\"æ‰‘\",\"é‚€\",\"äº­\",\"é…¯\",\"è¿ˆ\",\"èˆ’\",\"è„†\",\"é…¶\",\"é—²\",\"å¿§\",\"é…š\",\"é¡½\",\"ç¾½\",\"æ¶¨\",\"å¸\",\"ä»—\",\"é™ª\",\"è¾Ÿ\",\"æƒ©\",\"æ­\",\"å§š\",\"è‚š\",\"æ‰\",\"é£˜\",\"æ¼‚\",\"æ˜†\",\"æ¬º\",\"å¾\",\"éƒŽ\",\"çƒ·\",\"æ±\",\"å‘µ\",\"é¥°\",\"è§\",\"é›…\",\"é‚®\",\"è¿\",\"ç‡•\",\"æ’’\",\"å§»\",\"èµ´\",\"å®´\",\"çƒ¦\",\"å€º\",\"å¸\",\"æ–‘\",\"é“ƒ\",\"æ—¨\",\"é†‡\",\"è‘£\",\"é¥¼\",\"é›\",\"å§¿\",\"æ‹Œ\",\"å‚…\",\"è…¹\",\"å¦¥\",\"æ‰\",\"è´¤\",\"æ‹†\",\"æ­ª\",\"è‘¡\",\"èƒº\",\"ä¸¢\",\"æµ©\",\"å¾½\",\"æ˜‚\",\"åž«\",\"æŒ¡\",\"è§ˆ\",\"è´ª\",\"æ…°\",\"ç¼´\",\"æ±ª\",\"æ…Œ\",\"å†¯\",\"è¯º\",\"å§œ\",\"è°Š\",\"å‡¶\",\"åŠ£\",\"è¯¬\",\"è€€\",\"æ˜\",\"èºº\",\"ç›ˆ\",\"éª‘\",\"ä¹”\",\"æºª\",\"ä¸›\",\"å¢\",\"æŠ¹\",\"é—·\",\"å’¨\",\"åˆ®\",\"é©¾\",\"ç¼†\",\"æ‚Ÿ\",\"æ‘˜\",\"é“’\",\"æŽ·\",\"é¢‡\",\"å¹»\",\"æŸ„\",\"æƒ \",\"æƒ¨\",\"ä½³\",\"ä»‡\",\"è…Š\",\"çª\",\"æ¶¤\",\"å‰‘\",\"çž§\",\"å ¡\",\"æ³¼\",\"è‘±\",\"ç½©\",\"éœ\",\"æž\",\"èƒŽ\",\"è‹\",\"æ»¨\",\"ä¿©\",\"æ…\",\"æ¹˜\",\"ç \",\"éœž\",\"é‚µ\",\"è„\",\"ç–¯\",\"æ·®\",\"é‚\",\"ç†Š\",\"ç²ª\",\"çƒ˜\",\"å®¿\",\"æ¡£\",\"æˆˆ\",\"é©³\",\"å«‚\",\"è£•\",\"å¾™\",\"ç®­\",\"æ\",\"è‚ \",\"æ’‘\",\"æ™’\",\"è¾¨\",\"æ®¿\",\"èŽ²\",\"æ‘Š\",\"æ…\",\"é…±\",\"å±\",\"ç–«\",\"å“€\",\"è”¡\",\"å µ\",\"æ²«\",\"çš±\",\"ç•…\",\"å \",\"é˜\",\"èŽ±\",\"æ•²\",\"è¾–\",\"é’©\",\"ç—•\",\"å\",\"å··\",\"é¥¿\",\"ç¥¸\",\"ä¸˜\",\"çŽ„\",\"æºœ\",\"æ›°\",\"é€»\",\"å½­\",\"å°\",\"å¿\",\"å¦¨\",\"è‰‡\",\"åž\",\"éŸ¦\",\"æ€¨\",\"çŸ®\",\"æ­‡\"]");

const require$$2 = /* #__PURE__ */ JSON.parse("[\"çš„\",\"ä¸€\",\"æ˜¯\",\"åœ¨\",\"ä¸\",\"äº†\",\"æœ‰\",\"å’Œ\",\"äºº\",\"é€™\",\"ä¸­\",\"å¤§\",\"ç‚º\",\"ä¸Š\",\"å€‹\",\"åœ‹\",\"æˆ‘\",\"ä»¥\",\"è¦\",\"ä»–\",\"æ™‚\",\"ä¾†\",\"ç”¨\",\"å€‘\",\"ç”Ÿ\",\"åˆ°\",\"ä½œ\",\"åœ°\",\"æ–¼\",\"å‡º\",\"å°±\",\"åˆ†\",\"å°\",\"æˆ\",\"æœƒ\",\"å¯\",\"ä¸»\",\"ç™¼\",\"å¹´\",\"å‹•\",\"åŒ\",\"å·¥\",\"ä¹Ÿ\",\"èƒ½\",\"ä¸‹\",\"éŽ\",\"å­\",\"èªª\",\"ç”¢\",\"ç¨®\",\"é¢\",\"è€Œ\",\"æ–¹\",\"å¾Œ\",\"å¤š\",\"å®š\",\"è¡Œ\",\"å­¸\",\"æ³•\",\"æ‰€\",\"æ°‘\",\"å¾—\",\"ç¶“\",\"å\",\"ä¸‰\",\"ä¹‹\",\"é€²\",\"è‘—\",\"ç­‰\",\"éƒ¨\",\"åº¦\",\"å®¶\",\"é›»\",\"åŠ›\",\"è£¡\",\"å¦‚\",\"æ°´\",\"åŒ–\",\"é«˜\",\"è‡ª\",\"äºŒ\",\"ç†\",\"èµ·\",\"å°\",\"ç‰©\",\"ç¾\",\"å¯¦\",\"åŠ \",\"é‡\",\"éƒ½\",\"å…©\",\"é«”\",\"åˆ¶\",\"æ©Ÿ\",\"ç•¶\",\"ä½¿\",\"é»ž\",\"å¾ž\",\"æ¥­\",\"æœ¬\",\"åŽ»\",\"æŠŠ\",\"æ€§\",\"å¥½\",\"æ‡‰\",\"é–‹\",\"å®ƒ\",\"åˆ\",\"é‚„\",\"å› \",\"ç”±\",\"å…¶\",\"äº›\",\"ç„¶\",\"å‰\",\"å¤–\",\"å¤©\",\"æ”¿\",\"å››\",\"æ—¥\",\"é‚£\",\"ç¤¾\",\"ç¾©\",\"äº‹\",\"å¹³\",\"å½¢\",\"ç›¸\",\"å…¨\",\"è¡¨\",\"é–“\",\"æ¨£\",\"èˆ‡\",\"é—œ\",\"å„\",\"é‡\",\"æ–°\",\"ç·š\",\"å…§\",\"æ•¸\",\"æ­£\",\"å¿ƒ\",\"å\",\"ä½ \",\"æ˜Ž\",\"çœ‹\",\"åŽŸ\",\"åˆ\",\"éº¼\",\"åˆ©\",\"æ¯”\",\"æˆ–\",\"ä½†\",\"è³ª\",\"æ°£\",\"ç¬¬\",\"å‘\",\"é“\",\"å‘½\",\"æ­¤\",\"è®Š\",\"æ¢\",\"åª\",\"æ²’\",\"çµ\",\"è§£\",\"å•\",\"æ„\",\"å»º\",\"æœˆ\",\"å…¬\",\"ç„¡\",\"ç³»\",\"è»\",\"å¾ˆ\",\"æƒ…\",\"è€…\",\"æœ€\",\"ç«‹\",\"ä»£\",\"æƒ³\",\"å·²\",\"é€š\",\"ä¸¦\",\"æ\",\"ç›´\",\"é¡Œ\",\"é»¨\",\"ç¨‹\",\"å±•\",\"äº”\",\"æžœ\",\"æ–™\",\"è±¡\",\"å“¡\",\"é©\",\"ä½\",\"å…¥\",\"å¸¸\",\"æ–‡\",\"ç¸½\",\"æ¬¡\",\"å“\",\"å¼\",\"æ´»\",\"è¨­\",\"åŠ\",\"ç®¡\",\"ç‰¹\",\"ä»¶\",\"é•·\",\"æ±‚\",\"è€\",\"é ­\",\"åŸº\",\"è³‡\",\"é‚Š\",\"æµ\",\"è·¯\",\"ç´š\",\"å°‘\",\"åœ–\",\"å±±\",\"çµ±\",\"æŽ¥\",\"çŸ¥\",\"è¼ƒ\",\"å°‡\",\"çµ„\",\"è¦‹\",\"è¨ˆ\",\"åˆ¥\",\"å¥¹\",\"æ‰‹\",\"è§’\",\"æœŸ\",\"æ ¹\",\"è«–\",\"é‹\",\"è¾²\",\"æŒ‡\",\"å¹¾\",\"ä¹\",\"å€\",\"å¼·\",\"æ”¾\",\"æ±º\",\"è¥¿\",\"è¢«\",\"å¹¹\",\"åš\",\"å¿…\",\"æˆ°\",\"å…ˆ\",\"å›ž\",\"å‰‡\",\"ä»»\",\"å–\",\"æ“š\",\"è™•\",\"éšŠ\",\"å—\",\"çµ¦\",\"è‰²\",\"å…‰\",\"é–€\",\"å³\",\"ä¿\",\"æ²»\",\"åŒ—\",\"é€ \",\"ç™¾\",\"è¦\",\"ç†±\",\"é ˜\",\"ä¸ƒ\",\"æµ·\",\"å£\",\"æ±\",\"å°Ž\",\"å™¨\",\"å£“\",\"å¿—\",\"ä¸–\",\"é‡‘\",\"å¢ž\",\"çˆ­\",\"æ¿Ÿ\",\"éšŽ\",\"æ²¹\",\"æ€\",\"è¡“\",\"æ¥µ\",\"äº¤\",\"å—\",\"è¯\",\"ä»€\",\"èª\",\"å…­\",\"å…±\",\"æ¬Š\",\"æ”¶\",\"è­‰\",\"æ”¹\",\"æ¸…\",\"ç¾Ž\",\"å†\",\"æŽ¡\",\"è½‰\",\"æ›´\",\"å–®\",\"é¢¨\",\"åˆ‡\",\"æ‰“\",\"ç™½\",\"æ•™\",\"é€Ÿ\",\"èŠ±\",\"å¸¶\",\"å®‰\",\"å ´\",\"èº«\",\"è»Š\",\"ä¾‹\",\"çœŸ\",\"å‹™\",\"å…·\",\"è¬\",\"æ¯\",\"ç›®\",\"è‡³\",\"é”\",\"èµ°\",\"ç©\",\"ç¤º\",\"è­°\",\"è²\",\"å ±\",\"é¬¥\",\"å®Œ\",\"é¡ž\",\"å…«\",\"é›¢\",\"è¯\",\"å\",\"ç¢º\",\"æ‰\",\"ç§‘\",\"å¼µ\",\"ä¿¡\",\"é¦¬\",\"ç¯€\",\"è©±\",\"ç±³\",\"æ•´\",\"ç©º\",\"å…ƒ\",\"æ³\",\"ä»Š\",\"é›†\",\"æº«\",\"å‚³\",\"åœŸ\",\"è¨±\",\"æ­¥\",\"ç¾¤\",\"å»£\",\"çŸ³\",\"è¨˜\",\"éœ€\",\"æ®µ\",\"ç ”\",\"ç•Œ\",\"æ‹‰\",\"æž—\",\"å¾‹\",\"å«\",\"ä¸”\",\"ç©¶\",\"è§€\",\"è¶Š\",\"ç¹”\",\"è£\",\"å½±\",\"ç®—\",\"ä½Ž\",\"æŒ\",\"éŸ³\",\"çœ¾\",\"æ›¸\",\"å¸ƒ\",\"å¤\",\"å®¹\",\"å…’\",\"é ˆ\",\"éš›\",\"å•†\",\"éž\",\"é©—\",\"é€£\",\"æ–·\",\"æ·±\",\"é›£\",\"è¿‘\",\"ç¤¦\",\"åƒ\",\"é€±\",\"å§”\",\"ç´ \",\"æŠ€\",\"å‚™\",\"åŠ\",\"è¾¦\",\"é’\",\"çœ\",\"åˆ—\",\"ç¿’\",\"éŸ¿\",\"ç´„\",\"æ”¯\",\"èˆ¬\",\"å²\",\"æ„Ÿ\",\"å‹ž\",\"ä¾¿\",\"åœ˜\",\"å¾€\",\"é…¸\",\"æ­·\",\"å¸‚\",\"å…‹\",\"ä½•\",\"é™¤\",\"æ¶ˆ\",\"æ§‹\",\"åºœ\",\"ç¨±\",\"å¤ª\",\"æº–\",\"ç²¾\",\"å€¼\",\"è™Ÿ\",\"çŽ‡\",\"æ—\",\"ç¶­\",\"åŠƒ\",\"é¸\",\"æ¨™\",\"å¯«\",\"å­˜\",\"å€™\",\"æ¯›\",\"è¦ª\",\"å¿«\",\"æ•ˆ\",\"æ–¯\",\"é™¢\",\"æŸ¥\",\"æ±Ÿ\",\"åž‹\",\"çœ¼\",\"çŽ‹\",\"æŒ‰\",\"æ ¼\",\"é¤Š\",\"æ˜“\",\"ç½®\",\"æ´¾\",\"å±¤\",\"ç‰‡\",\"å§‹\",\"å»\",\"å°ˆ\",\"ç‹€\",\"è‚²\",\"å» \",\"äº¬\",\"è­˜\",\"é©\",\"å±¬\",\"åœ“\",\"åŒ…\",\"ç«\",\"ä½\",\"èª¿\",\"æ»¿\",\"ç¸£\",\"å±€\",\"ç…§\",\"åƒ\",\"ç´…\",\"ç´°\",\"å¼•\",\"è½\",\"è©²\",\"éµ\",\"åƒ¹\",\"åš´\",\"é¦–\",\"åº•\",\"æ¶²\",\"å®˜\",\"å¾·\",\"éš¨\",\"ç—…\",\"è˜‡\",\"å¤±\",\"çˆ¾\",\"æ­»\",\"è¬›\",\"é…\",\"å¥³\",\"é»ƒ\",\"æŽ¨\",\"é¡¯\",\"è«‡\",\"ç½ª\",\"ç¥ž\",\"è—\",\"å‘¢\",\"å¸­\",\"å«\",\"ä¼\",\"æœ›\",\"å¯†\",\"æ‰¹\",\"ç‡Ÿ\",\"é …\",\"é˜²\",\"èˆ‰\",\"çƒ\",\"è‹±\",\"æ°§\",\"å‹¢\",\"å‘Š\",\"æŽ\",\"å°\",\"è½\",\"æœ¨\",\"å¹«\",\"è¼ª\",\"ç ´\",\"äºž\",\"å¸«\",\"åœ\",\"æ³¨\",\"é \",\"å­—\",\"æ\",\"æŽ’\",\"ä¾›\",\"æ²³\",\"æ…‹\",\"å°\",\"å¦\",\"æ–½\",\"æ¸›\",\"æ¨¹\",\"æº¶\",\"æ€Ž\",\"æ­¢\",\"æ¡ˆ\",\"è¨€\",\"å£«\",\"å‡\",\"æ­¦\",\"å›º\",\"è‘‰\",\"é­š\",\"æ³¢\",\"è¦–\",\"åƒ…\",\"è²»\",\"ç·Š\",\"æ„›\",\"å·¦\",\"ç« \",\"æ—©\",\"æœ\",\"å®³\",\"çºŒ\",\"è¼•\",\"æœ\",\"è©¦\",\"é£Ÿ\",\"å……\",\"å…µ\",\"æº\",\"åˆ¤\",\"è­·\",\"å¸\",\"è¶³\",\"æŸ\",\"ç·´\",\"å·®\",\"è‡´\",\"æ¿\",\"ç”°\",\"é™\",\"é»‘\",\"çŠ¯\",\"è² \",\"æ“Š\",\"èŒƒ\",\"ç¹¼\",\"èˆˆ\",\"ä¼¼\",\"é¤˜\",\"å …\",\"æ›²\",\"è¼¸\",\"ä¿®\",\"æ•…\",\"åŸŽ\",\"å¤«\",\"å¤ \",\"é€\",\"ç­†\",\"èˆ¹\",\"ä½”\",\"å³\",\"è²¡\",\"åƒ\",\"å¯Œ\",\"æ˜¥\",\"è·\",\"è¦º\",\"æ¼¢\",\"ç•«\",\"åŠŸ\",\"å·´\",\"è·Ÿ\",\"é›–\",\"é›œ\",\"é£›\",\"æª¢\",\"å¸\",\"åŠ©\",\"æ˜‡\",\"é™½\",\"äº’\",\"åˆ\",\"å‰µ\",\"æŠ—\",\"è€ƒ\",\"æŠ•\",\"å£ž\",\"ç­–\",\"å¤\",\"å¾‘\",\"æ›\",\"æœª\",\"è·‘\",\"ç•™\",\"é‹¼\",\"æ›¾\",\"ç«¯\",\"è²¬\",\"ç«™\",\"ç°¡\",\"è¿°\",\"éŒ¢\",\"å‰¯\",\"ç›¡\",\"å¸\",\"å°„\",\"è‰\",\"è¡\",\"æ‰¿\",\"ç¨\",\"ä»¤\",\"é™\",\"é˜¿\",\"å®£\",\"ç’°\",\"é›™\",\"è«‹\",\"è¶…\",\"å¾®\",\"è®“\",\"æŽ§\",\"å·ž\",\"è‰¯\",\"è»¸\",\"æ‰¾\",\"å¦\",\"ç´€\",\"ç›Š\",\"ä¾\",\"å„ª\",\"é ‚\",\"ç¤Ž\",\"è¼‰\",\"å€’\",\"æˆ¿\",\"çª\",\"å\",\"ç²‰\",\"æ•µ\",\"ç•¥\",\"å®¢\",\"è¢\",\"å†·\",\"å‹\",\"çµ•\",\"æž\",\"å¡Š\",\"åŠ‘\",\"æ¸¬\",\"çµ²\",\"å”\",\"è¨´\",\"å¿µ\",\"é™³\",\"ä»\",\"ç¾…\",\"é¹½\",\"å‹\",\"æ´‹\",\"éŒ¯\",\"è‹¦\",\"å¤œ\",\"åˆ‘\",\"ç§»\",\"é »\",\"é€\",\"é \",\"æ··\",\"æ¯\",\"çŸ­\",\"çš®\",\"çµ‚\",\"èš\",\"æ±½\",\"æ‘\",\"é›²\",\"å“ª\",\"æ—¢\",\"è·\",\"è¡›\",\"åœ\",\"çƒˆ\",\"å¤®\",\"å¯Ÿ\",\"ç‡’\",\"è¿…\",\"å¢ƒ\",\"è‹¥\",\"å°\",\"æ´²\",\"åˆ»\",\"æ‹¬\",\"æ¿€\",\"å­”\",\"æž\",\"ç”š\",\"å®¤\",\"å¾…\",\"æ ¸\",\"æ ¡\",\"æ•£\",\"ä¾µ\",\"å§\",\"ç”²\",\"éŠ\",\"ä¹…\",\"èœ\",\"å‘³\",\"èˆŠ\",\"æ¨¡\",\"æ¹–\",\"è²¨\",\"æ\",\"é \",\"é˜»\",\"æ¯«\",\"æ™®\",\"ç©©\",\"ä¹™\",\"åª½\",\"æ¤\",\"æ¯\",\"æ“´\",\"éŠ€\",\"èªž\",\"æ®\",\"é…’\",\"å®ˆ\",\"æ‹¿\",\"åº\",\"ç´™\",\"é†«\",\"ç¼º\",\"é›¨\",\"å—Ž\",\"é‡\",\"åŠ‰\",\"å•Š\",\"æ€¥\",\"å”±\",\"èª¤\",\"è¨“\",\"é¡˜\",\"å¯©\",\"é™„\",\"ç²\",\"èŒ¶\",\"é®®\",\"ç³§\",\"æ–¤\",\"å­©\",\"è„«\",\"ç¡«\",\"è‚¥\",\"å–„\",\"é¾\",\"æ¼”\",\"çˆ¶\",\"æ¼¸\",\"è¡€\",\"æ­¡\",\"æ¢°\",\"æŽŒ\",\"æ­Œ\",\"æ²™\",\"å‰›\",\"æ”»\",\"è¬‚\",\"ç›¾\",\"è¨Ž\",\"æ™š\",\"ç²’\",\"äº‚\",\"ç‡ƒ\",\"çŸ›\",\"ä¹Ž\",\"æ®º\",\"è—¥\",\"å¯§\",\"é­¯\",\"è²´\",\"é˜\",\"ç…¤\",\"è®€\",\"ç­\",\"ä¼¯\",\"é¦™\",\"ä»‹\",\"è¿«\",\"å¥\",\"è±\",\"åŸ¹\",\"æ¡\",\"è˜­\",\"æ“”\",\"å¼¦\",\"è›‹\",\"æ²‰\",\"å‡\",\"ç©¿\",\"åŸ·\",\"ç­”\",\"æ¨‚\",\"èª°\",\"é †\",\"ç…™\",\"ç¸®\",\"å¾µ\",\"è‡‰\",\"å–œ\",\"æ¾\",\"è…³\",\"å›°\",\"ç•°\",\"å…\",\"èƒŒ\",\"æ˜Ÿ\",\"ç¦\",\"è²·\",\"æŸ“\",\"äº•\",\"æ¦‚\",\"æ…¢\",\"æ€•\",\"ç£\",\"å€\",\"ç¥–\",\"çš‡\",\"ä¿ƒ\",\"éœ\",\"è£œ\",\"è©•\",\"ç¿»\",\"è‚‰\",\"è¸\",\"å°¼\",\"è¡£\",\"å¯¬\",\"æš\",\"æ£‰\",\"å¸Œ\",\"å‚·\",\"æ“\",\"åž‚\",\"ç§‹\",\"å®œ\",\"æ°«\",\"å¥—\",\"ç£\",\"æŒ¯\",\"æž¶\",\"äº®\",\"æœ«\",\"æ†²\",\"æ…¶\",\"ç·¨\",\"ç‰›\",\"è§¸\",\"æ˜ \",\"é›·\",\"éŠ·\",\"è©©\",\"åº§\",\"å±…\",\"æŠ“\",\"è£‚\",\"èƒž\",\"å‘¼\",\"å¨˜\",\"æ™¯\",\"å¨\",\"ç¶ \",\"æ™¶\",\"åŽš\",\"ç›Ÿ\",\"è¡¡\",\"é›ž\",\"å­«\",\"å»¶\",\"å±\",\"è† \",\"å±‹\",\"é„‰\",\"è‡¨\",\"é™¸\",\"é¡§\",\"æŽ‰\",\"å‘€\",\"ç‡ˆ\",\"æ­²\",\"æŽª\",\"æŸ\",\"è€\",\"åŠ‡\",\"çŽ‰\",\"è¶™\",\"è·³\",\"å“¥\",\"å­£\",\"èª²\",\"å‡±\",\"èƒ¡\",\"é¡\",\"æ¬¾\",\"ç´¹\",\"å·\",\"é½Š\",\"å‰\",\"è’¸\",\"æ®–\",\"æ°¸\",\"å®—\",\"è‹—\",\"å·\",\"çˆ\",\"å²©\",\"å¼±\",\"é›¶\",\"æ¥Š\",\"å¥\",\"æ²¿\",\"éœ²\",\"æ¡¿\",\"æŽ¢\",\"æ»‘\",\"éŽ®\",\"é£¯\",\"æ¿ƒ\",\"èˆª\",\"æ‡·\",\"è¶•\",\"åº«\",\"å¥ª\",\"ä¼Š\",\"éˆ\",\"ç¨…\",\"é€”\",\"æ»…\",\"è³½\",\"æ­¸\",\"å¬\",\"é¼“\",\"æ’­\",\"ç›¤\",\"è£\",\"éšª\",\"åº·\",\"å”¯\",\"éŒ„\",\"èŒ\",\"ç´”\",\"å€Ÿ\",\"ç³–\",\"è“‹\",\"æ©«\",\"ç¬¦\",\"ç§\",\"åŠª\",\"å ‚\",\"åŸŸ\",\"æ§\",\"æ½¤\",\"å¹…\",\"å“ˆ\",\"ç«Ÿ\",\"ç†Ÿ\",\"èŸ²\",\"æ¾¤\",\"è…¦\",\"å£¤\",\"ç¢³\",\"æ­\",\"é\",\"å´\",\"å¯¨\",\"æ•¢\",\"å¾¹\",\"æ…®\",\"æ–œ\",\"è–„\",\"åº­\",\"ç´\",\"å½ˆ\",\"é£¼\",\"ä¼¸\",\"æŠ˜\",\"éº¥\",\"æ¿•\",\"æš—\",\"è·\",\"ç“¦\",\"å¡ž\",\"åºŠ\",\"ç¯‰\",\"æƒ¡\",\"æˆ¶\",\"è¨ª\",\"å¡”\",\"å¥‡\",\"é€\",\"æ¢\",\"åˆ€\",\"æ—‹\",\"è·¡\",\"å¡\",\"æ°¯\",\"é‡\",\"ä»½\",\"æ¯’\",\"æ³¥\",\"é€€\",\"æ´—\",\"æ“º\",\"ç°\",\"å½©\",\"è³£\",\"è€—\",\"å¤\",\"æ“‡\",\"å¿™\",\"éŠ…\",\"ç»\",\"ç¡¬\",\"äºˆ\",\"ç¹\",\"åœˆ\",\"é›ª\",\"å‡½\",\"äº¦\",\"æŠ½\",\"ç¯‡\",\"é™£\",\"é™°\",\"ä¸\",\"å°º\",\"è¿½\",\"å †\",\"é›„\",\"è¿Ž\",\"æ³›\",\"çˆ¸\",\"æ¨“\",\"é¿\",\"è¬€\",\"å™¸\",\"é‡Ž\",\"è±¬\",\"æ——\",\"ç´¯\",\"å\",\"å…¸\",\"é¤¨\",\"ç´¢\",\"ç§¦\",\"è„‚\",\"æ½®\",\"çˆº\",\"è±†\",\"å¿½\",\"æ‰˜\",\"é©š\",\"å¡‘\",\"éº\",\"æ„ˆ\",\"æœ±\",\"æ›¿\",\"çº–\",\"ç²—\",\"å‚¾\",\"å°š\",\"ç—›\",\"æ¥š\",\"è¬\",\"å¥®\",\"è³¼\",\"ç£¨\",\"å›\",\"æ± \",\"æ—\",\"ç¢Ž\",\"éª¨\",\"ç›£\",\"æ•\",\"å¼Ÿ\",\"æš´\",\"å‰²\",\"è²«\",\"æ®Š\",\"é‡‹\",\"è©ž\",\"äº¡\",\"å£\",\"é “\",\"å¯¶\",\"åˆ\",\"å¡µ\",\"èž\",\"æ­\",\"ç‚®\",\"æ®˜\",\"å†¬\",\"æ©‹\",\"å©¦\",\"è­¦\",\"ç¶œ\",\"æ‹›\",\"å³\",\"ä»˜\",\"æµ®\",\"é­\",\"å¾\",\"æ‚¨\",\"æ–\",\"è°·\",\"è´Š\",\"ç®±\",\"éš”\",\"è¨‚\",\"ç”·\",\"å¹\",\"åœ’\",\"ç´›\",\"å”\",\"æ•—\",\"å®‹\",\"çŽ»\",\"å·¨\",\"è€•\",\"å¦\",\"æ¦®\",\"é–‰\",\"ç£\",\"éµ\",\"å‡¡\",\"é§\",\"é‹\",\"æ•‘\",\"æ©\",\"å‰\",\"å‡\",\"é¹¼\",\"é½’\",\"æˆª\",\"ç…‰\",\"éº»\",\"ç´¡\",\"ç¦\",\"å»¢\",\"ç››\",\"ç‰ˆ\",\"ç·©\",\"æ·¨\",\"ç›\",\"æ˜Œ\",\"å©š\",\"æ¶‰\",\"ç­’\",\"å˜´\",\"æ’\",\"å²¸\",\"æœ—\",\"èŽŠ\",\"è¡—\",\"è—\",\"å§‘\",\"è²¿\",\"è…\",\"å¥´\",\"å•¦\",\"æ…£\",\"ä¹˜\",\"å¤¥\",\"æ¢\",\"å‹»\",\"ç´—\",\"æ‰Ž\",\"è¾¯\",\"è€³\",\"å½ª\",\"è‡£\",\"å„„\",\"ç’ƒ\",\"æŠµ\",\"è„ˆ\",\"ç§€\",\"è–©\",\"ä¿„\",\"ç¶²\",\"èˆž\",\"åº—\",\"å™´\",\"ç¸±\",\"å¯¸\",\"æ±—\",\"æŽ›\",\"æ´ª\",\"è³€\",\"é–ƒ\",\"æŸ¬\",\"çˆ†\",\"çƒ¯\",\"æ´¥\",\"ç¨»\",\"ç‰†\",\"è»Ÿ\",\"å‹‡\",\"åƒ\",\"æ»¾\",\"åŽ˜\",\"è’™\",\"èŠ³\",\"è‚¯\",\"å¡\",\"æŸ±\",\"ç›ª\",\"è…¿\",\"å„€\",\"æ—…\",\"å°¾\",\"è»‹\",\"å†°\",\"è²¢\",\"ç™»\",\"é»Ž\",\"å‰Š\",\"é‘½\",\"å‹’\",\"é€ƒ\",\"éšœ\",\"æ°¨\",\"éƒ­\",\"å³°\",\"å¹£\",\"æ¸¯\",\"ä¼\",\"è»Œ\",\"ç•\",\"ç•¢\",\"æ“¦\",\"èŽ«\",\"åˆº\",\"æµª\",\"ç§˜\",\"æ´\",\"æ ª\",\"å¥\",\"å”®\",\"è‚¡\",\"å³¶\",\"ç”˜\",\"æ³¡\",\"ç¡\",\"ç«¥\",\"é‘„\",\"æ¹¯\",\"é–¥\",\"ä¼‘\",\"åŒ¯\",\"èˆ\",\"ç‰§\",\"ç¹ž\",\"ç‚¸\",\"å“²\",\"ç£·\",\"ç¸¾\",\"æœ‹\",\"æ·¡\",\"å°–\",\"å•Ÿ\",\"é™·\",\"æŸ´\",\"å‘ˆ\",\"å¾’\",\"é¡\",\"æ·š\",\"ç¨\",\"å¿˜\",\"æ³µ\",\"è—\",\"æ‹–\",\"æ´ž\",\"æŽˆ\",\"é¡\",\"è¾›\",\"å£¯\",\"é‹’\",\"è²§\",\"è™›\",\"å½Ž\",\"æ‘©\",\"æ³°\",\"å¹¼\",\"å»·\",\"å°Š\",\"çª—\",\"ç¶±\",\"å¼„\",\"éš¸\",\"ç–‘\",\"æ°\",\"å®®\",\"å§\",\"éœ‡\",\"ç‘ž\",\"æ€ª\",\"å°¤\",\"ç´\",\"å¾ª\",\"æ\",\"è†œ\",\"é•\",\"å¤¾\",\"è…°\",\"ç·£\",\"ç \",\"çª®\",\"æ£®\",\"æž\",\"ç«¹\",\"æº\",\"å‚¬\",\"ç¹©\",\"æ†¶\",\"é‚¦\",\"å‰©\",\"å¹¸\",\"æ¼¿\",\"æ¬„\",\"æ“\",\"ç‰™\",\"è²¯\",\"ç¦®\",\"æ¿¾\",\"éˆ‰\",\"ç´‹\",\"ç½·\",\"æ‹\",\"å’±\",\"å–Š\",\"è¢–\",\"åŸƒ\",\"å‹¤\",\"ç½°\",\"ç„¦\",\"æ½›\",\"ä¼\",\"å¢¨\",\"æ¬²\",\"ç¸«\",\"å§“\",\"åˆŠ\",\"é£½\",\"ä»¿\",\"çŽ\",\"é‹\",\"é¬¼\",\"éº—\",\"è·¨\",\"é»˜\",\"æŒ–\",\"éˆ\",\"æŽƒ\",\"å–\",\"è¢‹\",\"ç‚­\",\"æ±¡\",\"å¹•\",\"è«¸\",\"å¼§\",\"å‹µ\",\"æ¢…\",\"å¥¶\",\"æ½”\",\"ç½\",\"èˆŸ\",\"é‘‘\",\"è‹¯\",\"è¨Ÿ\",\"æŠ±\",\"æ¯€\",\"æ‡‚\",\"å¯’\",\"æ™º\",\"åŸ”\",\"å¯„\",\"å±†\",\"èº\",\"æ¸¡\",\"æŒ‘\",\"ä¸¹\",\"è‰±\",\"è²\",\"ç¢°\",\"æ‹”\",\"çˆ¹\",\"æˆ´\",\"ç¢¼\",\"å¤¢\",\"èŠ½\",\"ç†”\",\"èµ¤\",\"æ¼\",\"å“­\",\"æ•¬\",\"é¡†\",\"å¥”\",\"é‰›\",\"ä»²\",\"è™Ž\",\"ç¨€\",\"å¦¹\",\"ä¹\",\"ç\",\"ç”³\",\"æ¡Œ\",\"éµ\",\"å…\",\"éš†\",\"èžº\",\"å€‰\",\"é­\",\"éŠ³\",\"æ›‰\",\"æ°®\",\"å…¼\",\"éš±\",\"ç¤™\",\"èµ«\",\"æ’¥\",\"å¿ \",\"è‚…\",\"ç¼¸\",\"ç‰½\",\"æ¶\",\"åš\",\"å·§\",\"æ®¼\",\"å…„\",\"æœ\",\"è¨Š\",\"èª \",\"ç¢§\",\"ç¥¥\",\"æŸ¯\",\"é \",\"å·¡\",\"çŸ©\",\"æ‚²\",\"çŒ\",\"é½¡\",\"å€«\",\"ç¥¨\",\"å°‹\",\"æ¡‚\",\"é‹ª\",\"è–\",\"æ\",\"æ°\",\"é„­\",\"è¶£\",\"æŠ¬\",\"è’\",\"é¨°\",\"è²¼\",\"æŸ”\",\"æ»´\",\"çŒ›\",\"é—Š\",\"è¼›\",\"å¦»\",\"å¡«\",\"æ’¤\",\"å„²\",\"ç°½\",\"é¬§\",\"æ“¾\",\"ç´«\",\"ç ‚\",\"éž\",\"æˆ²\",\"åŠ\",\"é™¶\",\"ä¼\",\"é¤µ\",\"ç™‚\",\"ç“¶\",\"å©†\",\"æ’«\",\"è‡‚\",\"æ‘¸\",\"å¿\",\"è¦\",\"è Ÿ\",\"é„°\",\"èƒ¸\",\"éž\",\"æ“ \",\"å¶\",\"æ£„\",\"æ§½\",\"å‹\",\"ä¹³\",\"é„§\",\"å‰\",\"ä»\",\"çˆ›\",\"ç£š\",\"ç§Ÿ\",\"çƒ\",\"è‰¦\",\"ä¼´\",\"ç“œ\",\"æ·º\",\"ä¸™\",\"æš«\",\"ç‡¥\",\"æ©¡\",\"æŸ³\",\"è¿·\",\"æš–\",\"ç‰Œ\",\"ç§§\",\"è†½\",\"è©³\",\"ç°§\",\"è¸\",\"ç“·\",\"è­œ\",\"å‘†\",\"è³“\",\"ç³Š\",\"æ´›\",\"è¼\",\"æ†¤\",\"ç«¶\",\"éš™\",\"æ€’\",\"ç²˜\",\"ä¹ƒ\",\"ç·’\",\"è‚©\",\"ç±\",\"æ•\",\"å¡—\",\"ç†™\",\"çš†\",\"åµ\",\"æ‡¸\",\"æŽ˜\",\"äº«\",\"ç³¾\",\"é†’\",\"ç‹‚\",\"éŽ–\",\"æ·€\",\"æ¨\",\"ç‰²\",\"éœ¸\",\"çˆ¬\",\"è³ž\",\"é€†\",\"çŽ©\",\"é™µ\",\"ç¥\",\"ç§’\",\"æµ™\",\"è²Œ\",\"å½¹\",\"å½¼\",\"æ‚‰\",\"é´¨\",\"è¶¨\",\"é³³\",\"æ™¨\",\"ç•œ\",\"è¼©\",\"ç§©\",\"åµ\",\"ç½²\",\"æ¢¯\",\"ç‚Ž\",\"ç˜\",\"æ£‹\",\"é©…\",\"ç¯©\",\"å³½\",\"å†’\",\"å•¥\",\"å£½\",\"è­¯\",\"æµ¸\",\"æ³‰\",\"å¸½\",\"é²\",\"çŸ½\",\"ç–†\",\"è²¸\",\"æ¼\",\"ç¨¿\",\"å† \",\"å«©\",\"è„…\",\"èŠ¯\",\"ç‰¢\",\"å›\",\"è•\",\"å¥§\",\"é³´\",\"å¶º\",\"ç¾Š\",\"æ†‘\",\"ä¸²\",\"å¡˜\",\"ç¹ª\",\"é…µ\",\"èž\",\"ç›†\",\"éŒ«\",\"å»Ÿ\",\"ç±Œ\",\"å‡\",\"è¼”\",\"æ”\",\"è¥²\",\"ç­‹\",\"æ‹’\",\"åƒš\",\"æ—±\",\"é‰€\",\"é³¥\",\"æ¼†\",\"æ²ˆ\",\"çœ‰\",\"ç–\",\"æ·»\",\"æ£’\",\"ç©—\",\"ç¡\",\"éŸ“\",\"é€¼\",\"æ‰­\",\"åƒ‘\",\"æ¶¼\",\"æŒº\",\"ç¢—\",\"æ ½\",\"ç‚’\",\"æ¯\",\"æ‚£\",\"é¤¾\",\"å‹¸\",\"è±ª\",\"é¼\",\"å‹ƒ\",\"é´»\",\"æ—¦\",\"å\",\"æ‹œ\",\"ç‹—\",\"åŸ‹\",\"è¼¥\",\"æŽ©\",\"é£²\",\"æ¬\",\"ç½µ\",\"è¾­\",\"å‹¾\",\"æ‰£\",\"ä¼°\",\"è”£\",\"çµ¨\",\"éœ§\",\"ä¸ˆ\",\"æœµ\",\"å§†\",\"æ“¬\",\"å®‡\",\"è¼¯\",\"é™\",\"é›•\",\"å„Ÿ\",\"è“„\",\"å´‡\",\"å‰ª\",\"å€¡\",\"å»³\",\"å’¬\",\"é§›\",\"è–¯\",\"åˆ·\",\"æ–¥\",\"ç•ª\",\"è³¦\",\"å¥‰\",\"ä½›\",\"æ¾†\",\"æ¼«\",\"æ›¼\",\"æ‰‡\",\"éˆ£\",\"æ¡ƒ\",\"æ‰¶\",\"ä»”\",\"è¿”\",\"ä¿—\",\"è™§\",\"è…”\",\"éž‹\",\"æ£±\",\"è¦†\",\"æ¡†\",\"æ‚„\",\"å”\",\"æ’ž\",\"é¨™\",\"å‹˜\",\"æ—º\",\"æ²¸\",\"å­¤\",\"å\",\"å­Ÿ\",\"æ¸ \",\"å±ˆ\",\"ç–¾\",\"å¦™\",\"æƒœ\",\"ä»°\",\"ç‹ \",\"è„¹\",\"è«§\",\"æ‹‹\",\"é»´\",\"æ¡‘\",\"å´—\",\"å˜›\",\"è¡°\",\"ç›œ\",\"æ»²\",\"è‡Ÿ\",\"è³´\",\"æ¹§\",\"ç”œ\",\"æ›¹\",\"é–±\",\"è‚Œ\",\"å“©\",\"åŽ²\",\"çƒ´\",\"ç·¯\",\"æ¯…\",\"æ˜¨\",\"å½\",\"ç—‡\",\"ç…®\",\"å˜†\",\"é‡˜\",\"æ­\",\"èŽ–\",\"ç± \",\"é…·\",\"å·\",\"å¼“\",\"éŒ\",\"æ†\",\"å‚‘\",\"å‘\",\"é¼»\",\"ç¿¼\",\"ç¶¸\",\"æ•˜\",\"ç„\",\"é€®\",\"ç½\",\"çµ¡\",\"æ£š\",\"æŠ‘\",\"è†¨\",\"è”¬\",\"å¯º\",\"é©Ÿ\",\"ç©†\",\"å†¶\",\"æž¯\",\"å†Š\",\"å±\",\"å‡¸\",\"ç´³\",\"å¯\",\"çŠ§\",\"ç„°\",\"è½Ÿ\",\"æ¬£\",\"æ™‰\",\"ç˜¦\",\"ç¦¦\",\"éŒ \",\"éŒ¦\",\"å–ª\",\"æ—¬\",\"é›\",\"å£Ÿ\",\"æœ\",\"æ’²\",\"é‚€\",\"äº­\",\"é…¯\",\"é‚\",\"èˆ’\",\"è„†\",\"é…¶\",\"é–’\",\"æ†‚\",\"é…š\",\"é ‘\",\"ç¾½\",\"æ¼²\",\"å¸\",\"ä»—\",\"é™ª\",\"é—¢\",\"æ‡²\",\"æ­\",\"å§š\",\"è‚š\",\"æ‰\",\"é£„\",\"æ¼‚\",\"æ˜†\",\"æ¬º\",\"å¾\",\"éƒŽ\",\"çƒ·\",\"æ±\",\"å‘µ\",\"é£¾\",\"è•­\",\"é›…\",\"éƒµ\",\"é·\",\"ç‡•\",\"æ’’\",\"å§»\",\"èµ´\",\"å®´\",\"ç…©\",\"å‚µ\",\"å¸³\",\"æ–‘\",\"éˆ´\",\"æ—¨\",\"é†‡\",\"è‘£\",\"é¤…\",\"é››\",\"å§¿\",\"æ‹Œ\",\"å‚…\",\"è…¹\",\"å¦¥\",\"æ‰\",\"è³¢\",\"æ‹†\",\"æ­ª\",\"è‘¡\",\"èƒº\",\"ä¸Ÿ\",\"æµ©\",\"å¾½\",\"æ˜‚\",\"å¢Š\",\"æ“‹\",\"è¦½\",\"è²ª\",\"æ…°\",\"ç¹³\",\"æ±ª\",\"æ…Œ\",\"é¦®\",\"è«¾\",\"å§œ\",\"èª¼\",\"å…‡\",\"åŠ£\",\"èª£\",\"è€€\",\"æ˜\",\"èºº\",\"ç›ˆ\",\"é¨Ž\",\"å–¬\",\"æºª\",\"å¢\",\"ç›§\",\"æŠ¹\",\"æ‚¶\",\"è«®\",\"åˆ®\",\"é§•\",\"çºœ\",\"æ‚Ÿ\",\"æ‘˜\",\"é‰º\",\"æ“²\",\"é —\",\"å¹»\",\"æŸ„\",\"æƒ \",\"æ…˜\",\"ä½³\",\"ä»‡\",\"è‡˜\",\"çª©\",\"æ»Œ\",\"åŠ\",\"çž§\",\"å ¡\",\"æ½‘\",\"è”¥\",\"ç½©\",\"éœ\",\"æ’ˆ\",\"èƒŽ\",\"è’¼\",\"æ¿±\",\"å€†\",\"æ…\",\"æ¹˜\",\"ç \",\"éœž\",\"é‚µ\",\"è„\",\"ç˜‹\",\"æ·®\",\"é‚\",\"ç†Š\",\"ç³ž\",\"çƒ˜\",\"å®¿\",\"æª”\",\"æˆˆ\",\"é§\",\"å«‚\",\"è£•\",\"å¾™\",\"ç®­\",\"æ\",\"è…¸\",\"æ’\",\"æ›¬\",\"è¾¨\",\"æ®¿\",\"è“®\",\"æ”¤\",\"æ”ª\",\"é†¬\",\"å±\",\"ç–«\",\"å“€\",\"è”¡\",\"å µ\",\"æ²«\",\"çšº\",\"æš¢\",\"ç–Š\",\"é–£\",\"èŠ\",\"æ•²\",\"è½„\",\"é‰¤\",\"ç—•\",\"å£©\",\"å··\",\"é¤“\",\"ç¦\",\"ä¸˜\",\"çŽ„\",\"æºœ\",\"æ›°\",\"é‚\",\"å½­\",\"å˜—\",\"å¿\",\"å¦¨\",\"è‰‡\",\"åž\",\"éŸ‹\",\"æ€¨\",\"çŸ®\",\"æ­‡\"]");

const require$$3 = /* #__PURE__ */ JSON.parse("[\"á„€á…¡á„€á…§á†¨\",\"á„€á…¡á„á…³á†·\",\"á„€á…¡á„‚á…¡á†«\",\"á„€á…¡á„‚á…³á†¼\",\"á„€á…¡á„ƒá…³á†¨\",\"á„€á…¡á„…á…³á„Žá…µá†·\",\"á„€á…¡á„†á…®á†·\",\"á„€á…¡á„‡á…¡á†¼\",\"á„€á…¡á„‰á…¡á†¼\",\"á„€á…¡á„‰á…³á†·\",\"á„€á…¡á„‹á…®á†«á„ƒá…¦\",\"á„€á…¡á„‹á…³á†¯\",\"á„€á…¡á„‹á…µá„ƒá…³\",\"á„€á…¡á„‹á…µá†¸\",\"á„€á…¡á„Œá…¡á†¼\",\"á„€á…¡á„Œá…¥á†¼\",\"á„€á…¡á„Œá…©á†¨\",\"á„€á…¡á„Œá…®á†¨\",\"á„€á…¡á†¨á„‹á…©\",\"á„€á…¡á†¨á„Œá…¡\",\"á„€á…¡á†«á„€á…§á†¨\",\"á„€á…¡á†«á„‡á…®\",\"á„€á…¡á†«á„‰á…¥á†¸\",\"á„€á…¡á†«á„Œá…¡á†¼\",\"á„€á…¡á†«á„Œá…¥á†¸\",\"á„€á…¡á†«á„‘á…¡á†«\",\"á„€á…¡á†¯á„ƒá…³á†¼\",\"á„€á…¡á†¯á„‡á…µ\",\"á„€á…¡á†¯á„‰á…¢á†¨\",\"á„€á…¡á†¯á„Œá…³á†¼\",\"á„€á…¡á†·á„€á…¡á†¨\",\"á„€á…¡á†·á„€á…µ\",\"á„€á…¡á†·á„‰á…©\",\"á„€á…¡á†·á„‰á…®á„‰á…¥á†¼\",\"á„€á…¡á†·á„Œá…¡\",\"á„€á…¡á†·á„Œá…¥á†¼\",\"á„€á…¡á†¸á„Œá…¡á„€á…µ\",\"á„€á…¡á†¼á„‚á…¡á†·\",\"á„€á…¡á†¼á„ƒá…¡á†¼\",\"á„€á…¡á†¼á„ƒá…©\",\"á„€á…¡á†¼á„…á…§á†¨á„’á…µ\",\"á„€á…¡á†¼á„‡á…§á†«\",\"á„€á…¡á†¼á„‡á…®á†¨\",\"á„€á…¡á†¼á„‰á…¡\",\"á„€á…¡á†¼á„‰á…®á„…á…£á†¼\",\"á„€á…¡á†¼á„‹á…¡á„Œá…µ\",\"á„€á…¡á†¼á„‹á…¯á†«á„ƒá…©\",\"á„€á…¡á†¼á„‹á…´\",\"á„€á…¡á†¼á„Œá…¦\",\"á„€á…¡á†¼á„Œá…©\",\"á„€á…¡á‡€á„‹á…µ\",\"á„€á…¢á„€á…®á„…á…µ\",\"á„€á…¢á„‚á…¡á„…á…µ\",\"á„€á…¢á„‡á…¡á†¼\",\"á„€á…¢á„‡á…§á†¯\",\"á„€á…¢á„‰á…¥á†«\",\"á„€á…¢á„‰á…¥á†¼\",\"á„€á…¢á„‹á…µá†«\",\"á„€á…¢á†¨á„€á…ªá†«á„Œá…¥á†¨\",\"á„€á…¥á„‰á…µá†¯\",\"á„€á…¥á„‹á…¢á†¨\",\"á„€á…¥á„‹á…®á†¯\",\"á„€á…¥á„Œá…µá†º\",\"á„€á…¥á„‘á…®á†·\",\"á„€á…¥á†¨á„Œá…¥á†¼\",\"á„€á…¥á†«á„€á…¡á†¼\",\"á„€á…¥á†«á„†á…®á†¯\",\"á„€á…¥á†«á„‰á…¥á†¯\",\"á„€á…¥á†«á„Œá…©\",\"á„€á…¥á†«á„Žá…®á†¨\",\"á„€á…¥á†¯á„‹á…³á†·\",\"á„€á…¥á†·á„‰á…¡\",\"á„€á…¥á†·á„á…©\",\"á„€á…¦á„‰á…µá„‘á…¡á†«\",\"á„€á…¦á„‹á…µá†·\",\"á„€á…§á„‹á…®á†¯\",\"á„€á…§á†«á„’á…¢\",\"á„€á…§á†¯á„€á…ª\",\"á„€á…§á†¯á„€á…®á†¨\",\"á„€á…§á†¯á„…á…©á†«\",\"á„€á…§á†¯á„‰á…¥á†¨\",\"á„€á…§á†¯á„‰á…³á†¼\",\"á„€á…§á†¯á„‰á…µá†·\",\"á„€á…§á†¯á„Œá…¥á†¼\",\"á„€á…§á†¯á„’á…©á†«\",\"á„€á…§á†¼á„€á…¨\",\"á„€á…§á†¼á„€á…©\",\"á„€á…§á†¼á„€á…µ\",\"á„€á…§á†¼á„…á…§á†¨\",\"á„€á…§á†¼á„‡á…©á†¨á„€á…®á†¼\",\"á„€á…§á†¼á„‡á…µ\",\"á„€á…§á†¼á„‰á…¡á†¼á„ƒá…©\",\"á„€á…§á†¼á„‹á…§á†¼\",\"á„€á…§á†¼á„‹á…®\",\"á„€á…§á†¼á„Œá…¢á†¼\",\"á„€á…§á†¼á„Œá…¦\",\"á„€á…§á†¼á„Œá…®\",\"á„€á…§á†¼á„Žá…¡á†¯\",\"á„€á…§á†¼á„Žá…µ\",\"á„€á…§á†¼á„’á…£á†¼\",\"á„€á…§á†¼á„’á…¥á†·\",\"á„€á…¨á„€á…©á†¨\",\"á„€á…¨á„ƒá…¡á†«\",\"á„€á…¨á„…á…¡á†«\",\"á„€á…¨á„‰á…¡á†«\",\"á„€á…¨á„‰á…©á†¨\",\"á„€á…¨á„‹á…£á†¨\",\"á„€á…¨á„Œá…¥á†¯\",\"á„€á…¨á„Žá…³á†¼\",\"á„€á…¨á„’á…¬á†¨\",\"á„€á…©á„€á…¢á†¨\",\"á„€á…©á„€á…®á„…á…§\",\"á„€á…©á„€á…®á†¼\",\"á„€á…©á„€á…³á†¸\",\"á„€á…©á„ƒá…³á†¼á„’á…¡á†¨á„‰á…¢á†¼\",\"á„€á…©á„†á…®á„‰á…µá†«\",\"á„€á…©á„†á…µá†«\",\"á„€á…©á„‹á…£á†¼á„‹á…µ\",\"á„€á…©á„Œá…¡á†¼\",\"á„€á…©á„Œá…¥á†«\",\"á„€á…©á„Œá…µá†¸\",\"á„€á…©á„Žá…®á†ºá„€á…¡á„…á…®\",\"á„€á…©á„á…©á†¼\",\"á„€á…©á„’á…£á†¼\",\"á„€á…©á†¨á„‰á…µá†¨\",\"á„€á…©á†¯á„†á…©á†¨\",\"á„€á…©á†¯á„á…¡á„€á…µ\",\"á„€á…©á†¯á„‘á…³\",\"á„€á…©á†¼á„€á…¡á†«\",\"á„€á…©á†¼á„€á…¢\",\"á„€á…©á†¼á„€á…§á†¨\",\"á„€á…©á†¼á„€á…®á†«\",\"á„€á…©á†¼á„€á…³á†¸\",\"á„€á…©á†¼á„€á…µ\",\"á„€á…©á†¼á„ƒá…©á†¼\",\"á„€á…©á†¼á„†á…®á„‹á…¯á†«\",\"á„€á…©á†¼á„‡á…®\",\"á„€á…©á†¼á„‰á…¡\",\"á„€á…©á†¼á„‰á…µá†¨\",\"á„€á…©á†¼á„‹á…¥á†¸\",\"á„€á…©á†¼á„‹á…§á†«\",\"á„€á…©á†¼á„‹á…¯á†«\",\"á„€á…©á†¼á„Œá…¡á†¼\",\"á„€á…©á†¼á„á…¡\",\"á„€á…©á†¼á„Žá…¢á†¨\",\"á„€á…©á†¼á„á…©á†¼\",\"á„€á…©á†¼á„‘á…©\",\"á„€á…©á†¼á„’á…¡á†¼\",\"á„€á…©á†¼á„’á…²á„‹á…µá†¯\",\"á„€á…ªá„†á…©á†¨\",\"á„€á…ªá„‹á…µá†¯\",\"á„€á…ªá„Œá…¡á†¼\",\"á„€á…ªá„Œá…¥á†¼\",\"á„€á…ªá„’á…¡á†¨\",\"á„€á…ªá†«á„€á…¢á†¨\",\"á„€á…ªá†«á„€á…¨\",\"á„€á…ªá†«á„€á…ªá†¼\",\"á„€á…ªá†«á„‚á…§á†·\",\"á„€á…ªá†«á„…á…¡á†·\",\"á„€á…ªá†«á„…á…§á†«\",\"á„€á…ªá†«á„…á…µ\",\"á„€á…ªá†«á„‰á…³á†¸\",\"á„€á…ªá†«á„‰á…µá†·\",\"á„€á…ªá†«á„Œá…¥á†·\",\"á„€á…ªá†«á„Žá…¡á†¯\",\"á„€á…ªá†¼á„€á…§á†¼\",\"á„€á…ªá†¼á„€á…©\",\"á„€á…ªá†¼á„Œá…¡á†¼\",\"á„€á…ªá†¼á„Œá…®\",\"á„€á…¬á„…á…©á„‹á…®á†·\",\"á„€á…¬á†¼á„Œá…¡á†¼á„’á…µ\",\"á„€á…­á„€á…ªá„‰á…¥\",\"á„€á…­á„†á…®á†«\",\"á„€á…­á„‡á…©á†¨\",\"á„€á…­á„‰á…µá†¯\",\"á„€á…­á„‹á…£á†¼\",\"á„€á…­á„‹á…²á†¨\",\"á„€á…­á„Œá…¡á†¼\",\"á„€á…­á„Œá…µá†¨\",\"á„€á…­á„á…©á†¼\",\"á„€á…­á„’á…ªá†«\",\"á„€á…­á„’á…®á†«\",\"á„€á…®á„€á…§á†¼\",\"á„€á…®á„…á…³á†·\",\"á„€á…®á„†á…¥á†¼\",\"á„€á…®á„‡á…§á†¯\",\"á„€á…®á„‡á…®á†«\",\"á„€á…®á„‰á…¥á†¨\",\"á„€á…®á„‰á…¥á†¼\",\"á„€á…®á„‰á…©á†¨\",\"á„€á…®á„‹á…§á†¨\",\"á„€á…®á„‹á…µá†¸\",\"á„€á…®á„Žá…¥á†¼\",\"á„€á…®á„Žá…¦á„Œá…¥á†¨\",\"á„€á…®á†¨á„€á…¡\",\"á„€á…®á†¨á„€á…µ\",\"á„€á…®á†¨á„‚á…¢\",\"á„€á…®á†¨á„…á…µá†¸\",\"á„€á…®á†¨á„†á…®á†¯\",\"á„€á…®á†¨á„†á…µá†«\",\"á„€á…®á†¨á„‰á…®\",\"á„€á…®á†¨á„‹á…¥\",\"á„€á…®á†¨á„‹á…ªá†¼\",\"á„€á…®á†¨á„Œá…¥á†¨\",\"á„€á…®á†¨á„Œá…¦\",\"á„€á…®á†¨á„’á…¬\",\"á„€á…®á†«á„ƒá…¢\",\"á„€á…®á†«á„‰á…¡\",\"á„€á…®á†«á„‹á…µá†«\",\"á„€á…®á†¼á„€á…³á†¨á„Œá…¥á†¨\",\"á„€á…¯á†«á„…á…µ\",\"á„€á…¯á†«á„‹á…±\",\"á„€á…¯á†«á„á…®\",\"á„€á…±á„€á…®á†¨\",\"á„€á…±á„‰á…µá†«\",\"á„€á…²á„Œá…¥á†¼\",\"á„€á…²á„Žá…µá†¨\",\"á„€á…²á†«á„’á…§á†¼\",\"á„€á…³á„‚á…¡á†¯\",\"á„€á…³á„‚á…£á†¼\",\"á„€á…³á„‚á…³á†¯\",\"á„€á…³á„…á…¥á„‚á…¡\",\"á„€á…³á„…á…®á†¸\",\"á„€á…³á„…á…³á†º\",\"á„€á…³á„…á…µá†·\",\"á„€á…³á„Œá…¦á„‰á…¥á„‹á…£\",\"á„€á…³á„á…©á„…á…©á†¨\",\"á„€á…³á†¨á„‡á…©á†¨\",\"á„€á…³á†¨á„’á…µ\",\"á„€á…³á†«á„€á…¥\",\"á„€á…³á†«á„€á…­\",\"á„€á…³á†«á„…á…¢\",\"á„€á…³á†«á„…á…©\",\"á„€á…³á†«á„†á…®\",\"á„€á…³á†«á„‡á…©á†«\",\"á„€á…³á†«á„‹á…¯á†«\",\"á„€á…³á†«á„‹á…²á†¨\",\"á„€á…³á†«á„Žá…¥\",\"á„€á…³á†¯á„Šá…µ\",\"á„€á…³á†¯á„Œá…¡\",\"á„€á…³á†·á„€á…¡á†¼á„‰á…¡á†«\",\"á„€á…³á†·á„€á…©\",\"á„€á…³á†·á„‚á…§á†«\",\"á„€á…³á†·á„†á…¦á„ƒá…¡á†¯\",\"á„€á…³á†·á„‹á…¢á†¨\",\"á„€á…³á†·á„‹á…§á†«\",\"á„€á…³á†·á„‹á…­á„‹á…µá†¯\",\"á„€á…³á†·á„Œá…µ\",\"á„€á…³á†¼á„Œá…¥á†¼á„Œá…¥á†¨\",\"á„€á…µá„€á…¡á†«\",\"á„€á…µá„€á…ªá†«\",\"á„€á…µá„‚á…§á†·\",\"á„€á…µá„‚á…³á†¼\",\"á„€á…µá„ƒá…©á†¨á„€á…­\",\"á„€á…µá„ƒá…®á†¼\",\"á„€á…µá„…á…©á†¨\",\"á„€á…µá„…á…³á†·\",\"á„€á…µá„‡á…¥á†¸\",\"á„€á…µá„‡á…©á†«\",\"á„€á…µá„‡á…®á†«\",\"á„€á…µá„ˆá…³á†·\",\"á„€á…µá„‰á…®á†¨á„‰á…¡\",\"á„€á…µá„‰á…®á†¯\",\"á„€á…µá„‹á…¥á†¨\",\"á„€á…µá„‹á…¥á†¸\",\"á„€á…µá„‹á…©á†«\",\"á„€á…µá„‹á…®á†«\",\"á„€á…µá„‹á…¯á†«\",\"á„€á…µá„Œá…¥á†¨\",\"á„€á…µá„Œá…®á†«\",\"á„€á…µá„Žá…µá†·\",\"á„€á…µá„’á…©á†«\",\"á„€á…µá„’á…¬á†¨\",\"á„€á…µá†«á„€á…³á†¸\",\"á„€á…µá†«á„Œá…¡á†¼\",\"á„€á…µá†¯á„‹á…µ\",\"á„€á…µá†·á„‡á…¡á†¸\",\"á„€á…µá†·á„Žá…µ\",\"á„€á…µá†·á„‘á…©á„€á…©á†¼á„’á…¡á†¼\",\"á„á…¡á†¨á„ƒá…®á„€á…µ\",\"á„á…¡á†·á„ˆá…¡á†¨\",\"á„á…¢á„ƒá…¡á†¯á„‹á…³á†·\",\"á„á…¢á„‰á…©á„€á…³á†·\",\"á„á…¥á†¸á„Œá…µá†¯\",\"á„á…©á†¨á„ƒá…¢á„€á…µ\",\"á„á…©á†¾á„‹á…µá‡\",\"á„‚á…¡á„ƒá…³á†¯á„‹á…µ\",\"á„‚á…¡á„…á…¡á†«á„’á…µ\",\"á„‚á…¡á„†á…¥á„Œá…µ\",\"á„‚á…¡á„†á…®á†¯\",\"á„‚á…¡á„Žá…µá†·á„‡á…¡á†«\",\"á„‚á…¡á„’á…³á†¯\",\"á„‚á…¡á†¨á„‹á…§á†¸\",\"á„‚á…¡á†«á„‡á…¡á†¼\",\"á„‚á…¡á†¯á„€á…¢\",\"á„‚á…¡á†¯á„Šá…µ\",\"á„‚á…¡á†¯á„á…¡\",\"á„‚á…¡á†·á„‚á…§\",\"á„‚á…¡á†·á„ƒá…¢á„†á…®á†«\",\"á„‚á…¡á†·á„†á…¢\",\"á„‚á…¡á†·á„‰á…¡á†«\",\"á„‚á…¡á†·á„Œá…¡\",\"á„‚á…¡á†·á„‘á…§á†«\",\"á„‚á…¡á†·á„’á…¡á†¨á„‰á…¢á†¼\",\"á„‚á…¡á†¼á„‡á…µ\",\"á„‚á…¡á‡€á„†á…¡á†¯\",\"á„‚á…¢á„‚á…§á†«\",\"á„‚á…¢á„‹á…­á†¼\",\"á„‚á…¢á„‹á…µá†¯\",\"á„‚á…¢á†·á„‡á…µ\",\"á„‚á…¢á†·á„‰á…¢\",\"á„‚á…¢á†ºá„†á…®á†¯\",\"á„‚á…¢á†¼á„ƒá…©á†¼\",\"á„‚á…¢á†¼á„†á…§á†«\",\"á„‚á…¢á†¼á„‡á…¡á†¼\",\"á„‚á…¢á†¼á„Œá…¡á†¼á„€á…©\",\"á„‚á…¦á†¨á„á…¡á„‹á…µ\",\"á„‚á…¦á†ºá„á…¢\",\"á„‚á…©á„ƒá…©á†¼\",\"á„‚á…©á„…á…¡á†«á„‰á…¢á†¨\",\"á„‚á…©á„…á…§á†¨\",\"á„‚á…©á„‹á…µá†«\",\"á„‚á…©á†¨á„‹á…³á†·\",\"á„‚á…©á†¨á„Žá…¡\",\"á„‚á…©á†¨á„’á…ª\",\"á„‚á…©á†«á„…á…µ\",\"á„‚á…©á†«á„†á…®á†«\",\"á„‚á…©á†«á„Œá…¢á†¼\",\"á„‚á…©á†¯á„‹á…µ\",\"á„‚á…©á†¼á„€á…®\",\"á„‚á…©á†¼á„ƒá…¡á†·\",\"á„‚á…©á†¼á„†á…µá†«\",\"á„‚á…©á†¼á„‡á…®\",\"á„‚á…©á†¼á„‹á…¥á†¸\",\"á„‚á…©á†¼á„Œá…¡á†¼\",\"á„‚á…©á†¼á„Žá…©á†«\",\"á„‚á…©á‡á„‹á…µ\",\"á„‚á…®á†«á„ƒá…©á†¼á„Œá…¡\",\"á„‚á…®á†«á„†á…®á†¯\",\"á„‚á…®á†«á„Šá…¥á†¸\",\"á„‚á…²á„‹á…­á†¨\",\"á„‚á…³á„á…µá†·\",\"á„‚á…³á†¨á„ƒá…¢\",\"á„‚á…³á†¼á„ƒá…©á†¼á„Œá…¥á†¨\",\"á„‚á…³á†¼á„…á…§á†¨\",\"á„ƒá…¡á„‡á…¡á†¼\",\"á„ƒá…¡á„‹á…£á†¼á„‰á…¥á†¼\",\"á„ƒá…¡á„‹á…³á†·\",\"á„ƒá…¡á„‹á…µá„‹á…¥á„á…³\",\"á„ƒá…¡á„’á…¢á†¼\",\"á„ƒá…¡á†«á„€á…¨\",\"á„ƒá…¡á†«á„€á…©á†¯\",\"á„ƒá…¡á†«á„ƒá…©á†¨\",\"á„ƒá…¡á†«á„†á…¡á†º\",\"á„ƒá…¡á†«á„‰á…®á†«\",\"á„ƒá…¡á†«á„‹á…¥\",\"á„ƒá…¡á†«á„‹á…±\",\"á„ƒá…¡á†«á„Œá…¥á†·\",\"á„ƒá…¡á†«á„Žá…¦\",\"á„ƒá…¡á†«á„Žá…®\",\"á„ƒá…¡á†«á„‘á…§á†«\",\"á„ƒá…¡á†«á„‘á…®á†¼\",\"á„ƒá…¡á†¯á„€á…£á†¯\",\"á„ƒá…¡á†¯á„…á…¥\",\"á„ƒá…¡á†¯á„…á…§á†¨\",\"á„ƒá…¡á†¯á„…á…µ\",\"á„ƒá…¡á†°á„€á…©á„€á…µ\",\"á„ƒá…¡á†·á„ƒá…¡á†¼\",\"á„ƒá…¡á†·á„‡á…¢\",\"á„ƒá…¡á†·á„‹á…­\",\"á„ƒá…¡á†·á„‹á…µá†·\",\"á„ƒá…¡á†¸á„‡á…§á†«\",\"á„ƒá…¡á†¸á„Œá…¡á†¼\",\"á„ƒá…¡á†¼á„€á…³á†«\",\"á„ƒá…¡á†¼á„‡á…®á†«á„€á…¡á†«\",\"á„ƒá…¡á†¼á„‹á…§á†«á„’á…µ\",\"á„ƒá…¡á†¼á„Œá…¡á†¼\",\"á„ƒá…¢á„€á…²á„†á…©\",\"á„ƒá…¢á„‚á…¡á†½\",\"á„ƒá…¢á„ƒá…¡á†«á„’á…µ\",\"á„ƒá…¢á„ƒá…¡á†¸\",\"á„ƒá…¢á„ƒá…©á„‰á…µ\",\"á„ƒá…¢á„…á…£á†¨\",\"á„ƒá…¢á„…á…£á†¼\",\"á„ƒá…¢á„…á…²á†¨\",\"á„ƒá…¢á„†á…®á†«\",\"á„ƒá…¢á„‡á…®á„‡á…®á†«\",\"á„ƒá…¢á„‰á…µá†«\",\"á„ƒá…¢á„‹á…³á†¼\",\"á„ƒá…¢á„Œá…¡á†¼\",\"á„ƒá…¢á„Œá…¥á†«\",\"á„ƒá…¢á„Œá…¥á†¸\",\"á„ƒá…¢á„Œá…®á†¼\",\"á„ƒá…¢á„Žá…¢á†¨\",\"á„ƒá…¢á„Žá…®á†¯\",\"á„ƒá…¢á„Žá…®á†¼\",\"á„ƒá…¢á„á…©á†¼á„…á…§á†¼\",\"á„ƒá…¢á„’á…¡á†¨\",\"á„ƒá…¢á„’á…¡á†«á„†á…µá†«á„€á…®á†¨\",\"á„ƒá…¢á„’á…¡á†¸á„‰á…µá†¯\",\"á„ƒá…¢á„’á…§á†¼\",\"á„ƒá…¥á†¼á„‹á…¥á„…á…µ\",\"á„ƒá…¦á„‹á…µá„á…³\",\"á„ƒá…©á„ƒá…¢á„Žá…¦\",\"á„ƒá…©á„ƒá…¥á†¨\",\"á„ƒá…©á„ƒá…®á†¨\",\"á„ƒá…©á„†á…¡á†¼\",\"á„ƒá…©á„‰á…¥á„€á…ªá†«\",\"á„ƒá…©á„‰á…µá†·\",\"á„ƒá…©á„‹á…®á†·\",\"á„ƒá…©á„‹á…µá†¸\",\"á„ƒá…©á„Œá…¡á„€á…µ\",\"á„ƒá…©á„Œá…¥á„’á…µ\",\"á„ƒá…©á„Œá…¥á†«\",\"á„ƒá…©á„Œá…®á†¼\",\"á„ƒá…©á„Žá…¡á†¨\",\"á„ƒá…©á†¨á„€á…¡á†·\",\"á„ƒá…©á†¨á„…á…µá†¸\",\"á„ƒá…©á†¨á„‰á…¥\",\"á„ƒá…©á†¨á„‹á…µá†¯\",\"á„ƒá…©á†¨á„Žá…¡á†¼á„Œá…¥á†¨\",\"á„ƒá…©á†¼á„’á…ªá„Žá…¢á†¨\",\"á„ƒá…±á†ºá„†á…©á„‰á…³á†¸\",\"á„ƒá…±á†ºá„‰á…¡á†«\",\"á„„á…¡á†¯á„‹á…¡á„‹á…µ\",\"á„†á…¡á„‚á…®á„…á…¡\",\"á„†á…¡á„‚á…³á†¯\",\"á„†á…¡á„ƒá…¡á†¼\",\"á„†á…¡á„…á…¡á„á…©á†«\",\"á„†á…¡á„…á…§á†«\",\"á„†á…¡á„†á…®á„…á…µ\",\"á„†á…¡á„‰á…¡á„Œá…µ\",\"á„†á…¡á„‹á…£á†¨\",\"á„†á…¡á„‹á…­á„‚á…¦á„Œá…³\",\"á„†á…¡á„‹á…³á†¯\",\"á„†á…¡á„‹á…³á†·\",\"á„†á…¡á„‹á…µá„á…³\",\"á„†á…¡á„Œá…®á†¼\",\"á„†á…¡á„Œá…µá„†á…¡á†¨\",\"á„†á…¡á„Žá…¡á†«á„€á…¡á„Œá…µ\",\"á„†á…¡á„Žá…¡á†¯\",\"á„†á…¡á„’á…³á†«\",\"á„†á…¡á†¨á„€á…¥á†¯á„…á…µ\",\"á„†á…¡á†¨á„‚á…¢\",\"á„†á…¡á†¨á„‰á…¡á†¼\",\"á„†á…¡á†«á„‚á…¡á†·\",\"á„†á…¡á†«á„ƒá…®\",\"á„†á…¡á†«á„‰á…¦\",\"á„†á…¡á†«á„‹á…£á†¨\",\"á„†á…¡á†«á„‹á…µá†¯\",\"á„†á…¡á†«á„Œá…¥á†·\",\"á„†á…¡á†«á„Œá…©á†¨\",\"á„†á…¡á†«á„’á…ª\",\"á„†á…¡á†­á„‹á…µ\",\"á„†á…¡á†¯á„€á…µ\",\"á„†á…¡á†¯á„Šá…³á†·\",\"á„†á…¡á†¯á„á…®\",\"á„†á…¡á†·á„ƒá…¢á„…á…©\",\"á„†á…¡á†¼á„‹á…¯á†«á„€á…§á†¼\",\"á„†á…¢á„‚á…§á†«\",\"á„†á…¢á„ƒá…¡á†¯\",\"á„†á…¢á„…á…§á†¨\",\"á„†á…¢á„‡á…¥á†«\",\"á„†á…¢á„‰á…³á„á…¥á†·\",\"á„†á…¢á„‹á…µá†¯\",\"á„†á…¢á„Œá…¡á†¼\",\"á„†á…¢á†¨á„Œá…®\",\"á„†á…¥á†¨á„‹á…µ\",\"á„†á…¥á†«á„Œá…¥\",\"á„†á…¥á†«á„Œá…µ\",\"á„†á…¥á†¯á„…á…µ\",\"á„†á…¦á„‹á…µá†¯\",\"á„†á…§á„‚á…³á„…á…µ\",\"á„†á…§á„Žá…µá†¯\",\"á„†á…§á†«á„ƒá…¡á†·\",\"á„†á…§á†¯á„Žá…µ\",\"á„†á…§á†¼á„ƒá…¡á†«\",\"á„†á…§á†¼á„…á…§á†¼\",\"á„†á…§á†¼á„‹á…¨\",\"á„†á…§á†¼á„‹á…´\",\"á„†á…§á†¼á„Œá…¥á†¯\",\"á„†á…§á†¼á„Žá…µá†¼\",\"á„†á…§á†¼á„’á…¡á†·\",\"á„†á…©á„€á…³á†·\",\"á„†á…©á„‚á…µá„á…¥\",\"á„†á…©á„ƒá…¦á†¯\",\"á„†á…©á„ƒá…³á†«\",\"á„†á…©á„‡á…¥á†·\",\"á„†á…©á„‰á…³á†¸\",\"á„†á…©á„‹á…£á†¼\",\"á„†á…©á„‹á…µá†·\",\"á„†á…©á„Œá…©á„…á…µ\",\"á„†á…©á„Œá…µá†¸\",\"á„†á…©á„á…®á†¼á„‹á…µ\",\"á„†á…©á†¨á„€á…¥á†¯á„‹á…µ\",\"á„†á…©á†¨á„…á…©á†¨\",\"á„†á…©á†¨á„‰á…¡\",\"á„†á…©á†¨á„‰á…©á„…á…µ\",\"á„†á…©á†¨á„‰á…®á†·\",\"á„†á…©á†¨á„Œá…¥á†¨\",\"á„†á…©á†¨á„‘á…­\",\"á„†á…©á†¯á„…á…¢\",\"á„†á…©á†·á„†á…¢\",\"á„†á…©á†·á„†á…®á„€á…¦\",\"á„†á…©á†·á„‰á…¡á†¯\",\"á„†á…©á†·á„‰á…©á†¨\",\"á„†á…©á†·á„Œá…µá†º\",\"á„†á…©á†·á„á…©á†¼\",\"á„†á…©á†¸á„‰á…µ\",\"á„†á…®á„€á…ªá†«á„‰á…µá†·\",\"á„†á…®á„€á…®á†¼á„’á…ª\",\"á„†á…®á„ƒá…¥á„‹á…±\",\"á„†á…®á„ƒá…¥á†·\",\"á„†á…®á„…á…³á‡\",\"á„†á…®á„‰á…³á†«\",\"á„†á…®á„‹á…¥á†º\",\"á„†á…®á„‹á…§á†¨\",\"á„†á…®á„‹á…­á†¼\",\"á„†á…®á„Œá…©á„€á…¥á†«\",\"á„†á…®á„Œá…µá„€á…¢\",\"á„†á…®á„Žá…¥á†¨\",\"á„†á…®á†«á„€á…®\",\"á„†á…®á†«á„ƒá…³á†¨\",\"á„†á…®á†«á„‡á…¥á†¸\",\"á„†á…®á†«á„‰á…¥\",\"á„†á…®á†«á„Œá…¦\",\"á„†á…®á†«á„’á…¡á†¨\",\"á„†á…®á†«á„’á…ª\",\"á„†á…®á†¯á„€á…¡\",\"á„†á…®á†¯á„€á…¥á†«\",\"á„†á…®á†¯á„€á…§á†¯\",\"á„†á…®á†¯á„€á…©á„€á…µ\",\"á„†á…®á†¯á„…á…©á†«\",\"á„†á…®á†¯á„…á…µá„’á…¡á†¨\",\"á„†á…®á†¯á„‹á…³á†·\",\"á„†á…®á†¯á„Œá…µá†¯\",\"á„†á…®á†¯á„Žá…¦\",\"á„†á…µá„€á…®á†¨\",\"á„†á…µá„ƒá…µá„‹á…¥\",\"á„†á…µá„‰á…¡á„‹á…µá†¯\",\"á„†á…µá„‰á…®á†¯\",\"á„†á…µá„‹á…§á†¨\",\"á„†á…µá„‹á…­á†¼á„‰á…µá†¯\",\"á„†á…µá„‹á…®á†·\",\"á„†á…µá„‹á…µá†«\",\"á„†á…µá„á…µá†¼\",\"á„†á…µá„’á…©á†«\",\"á„†á…µá†«á„€á…¡á†«\",\"á„†á…µá†«á„Œá…©á†¨\",\"á„†á…µá†«á„Œá…®\",\"á„†á…µá†®á„‹á…³á†·\",\"á„†á…µá†¯á„€á…¡á„…á…®\",\"á„†á…µá†¯á„…á…µá„†á…µá„á…¥\",\"á„†á…µá‡€á„‡á…¡á„ƒá…¡á†¨\",\"á„‡á…¡á„€á…¡á„Œá…µ\",\"á„‡á…¡á„€á…®á„‚á…µ\",\"á„‡á…¡á„‚á…¡á„‚á…¡\",\"á„‡á…¡á„‚á…³á†¯\",\"á„‡á…¡á„ƒá…¡á†¨\",\"á„‡á…¡á„ƒá…¡á†ºá„€á…¡\",\"á„‡á…¡á„…á…¡á†·\",\"á„‡á…¡á„‹á…µá„…á…¥á„‰á…³\",\"á„‡á…¡á„á…¡á†¼\",\"á„‡á…¡á†¨á„†á…®á†¯á„€á…ªá†«\",\"á„‡á…¡á†¨á„‰á…¡\",\"á„‡á…¡á†¨á„‰á…®\",\"á„‡á…¡á†«á„ƒá…¢\",\"á„‡á…¡á†«á„ƒá…³á„‰á…µ\",\"á„‡á…¡á†«á„†á…¡á†¯\",\"á„‡á…¡á†«á„‡á…¡á†¯\",\"á„‡á…¡á†«á„‰á…¥á†¼\",\"á„‡á…¡á†«á„‹á…³á†¼\",\"á„‡á…¡á†«á„Œá…¡á†¼\",\"á„‡á…¡á†«á„Œá…®á†¨\",\"á„‡á…¡á†«á„Œá…µ\",\"á„‡á…¡á†«á„Žá…¡á†«\",\"á„‡á…¡á†®á„Žá…µá†·\",\"á„‡á…¡á†¯á„€á…¡á„…á…¡á†¨\",\"á„‡á…¡á†¯á„€á…¥á†¯á„‹á…³á†·\",\"á„‡á…¡á†¯á„€á…§á†«\",\"á„‡á…¡á†¯á„ƒá…¡á†¯\",\"á„‡á…¡á†¯á„…á…¦\",\"á„‡á…¡á†¯á„†á…©á†¨\",\"á„‡á…¡á†¯á„‡á…¡á„ƒá…¡á†¨\",\"á„‡á…¡á†¯á„‰á…¢á†¼\",\"á„‡á…¡á†¯á„‹á…³á†·\",\"á„‡á…¡á†¯á„Œá…¡á„€á…®á†¨\",\"á„‡á…¡á†¯á„Œá…¥á†«\",\"á„‡á…¡á†¯á„á…©á†¸\",\"á„‡á…¡á†¯á„‘á…­\",\"á„‡á…¡á†·á„’á…¡á„‚á…³á†¯\",\"á„‡á…¡á†¸á„€á…³á„…á…³á†º\",\"á„‡á…¡á†¸á„†á…¡á†º\",\"á„‡á…¡á†¸á„‰á…¡á†¼\",\"á„‡á…¡á†¸á„‰á…©á‡€\",\"á„‡á…¡á†¼á„€á…³á†·\",\"á„‡á…¡á†¼á„†á…§á†«\",\"á„‡á…¡á†¼á„†á…®á†«\",\"á„‡á…¡á†¼á„‡á…¡á„ƒá…¡á†¨\",\"á„‡á…¡á†¼á„‡á…¥á†¸\",\"á„‡á…¡á†¼á„‰á…©á†¼\",\"á„‡á…¡á†¼á„‰á…µá†¨\",\"á„‡á…¡á†¼á„‹á…¡á†«\",\"á„‡á…¡á†¼á„‹á…®á†¯\",\"á„‡á…¡á†¼á„Œá…µ\",\"á„‡á…¡á†¼á„’á…¡á†¨\",\"á„‡á…¡á†¼á„’á…¢\",\"á„‡á…¡á†¼á„’á…£á†¼\",\"á„‡á…¢á„€á…§á†¼\",\"á„‡á…¢á„á…©á†¸\",\"á„‡á…¢á„ƒá…¡á†¯\",\"á„‡á…¢á„ƒá…³á„†á…µá†«á„á…¥á†«\",\"á„‡á…¢á†¨á„ƒá…®á„‰á…¡á†«\",\"á„‡á…¢á†¨á„‰á…¢á†¨\",\"á„‡á…¢á†¨á„‰á…¥á†¼\",\"á„‡á…¢á†¨á„‹á…µá†«\",\"á„‡á…¢á†¨á„Œá…¦\",\"á„‡á…¢á†¨á„’á…ªá„Œá…¥á†·\",\"á„‡á…¥á„…á…³á†º\",\"á„‡á…¥á„‰á…¥á†º\",\"á„‡á…¥á„á…³á†«\",\"á„‡á…¥á†«á„€á…¢\",\"á„‡á…¥á†«á„‹á…§á†¨\",\"á„‡á…¥á†«á„Œá…µ\",\"á„‡á…¥á†«á„’á…©\",\"á„‡á…¥á†¯á„€á…³á†·\",\"á„‡á…¥á†¯á„…á…¦\",\"á„‡á…¥á†¯á„Šá…¥\",\"á„‡á…¥á†·á„‹á…±\",\"á„‡á…¥á†·á„‹á…µá†«\",\"á„‡á…¥á†·á„Œá…¬\",\"á„‡á…¥á†¸á„…á…²á†¯\",\"á„‡á…¥á†¸á„‹á…¯á†«\",\"á„‡á…¥á†¸á„Œá…¥á†¨\",\"á„‡á…¥á†¸á„Žá…µá†¨\",\"á„‡á…¦á„‹á…µá„Œá…µá†¼\",\"á„‡á…¦á†¯á„á…³\",\"á„‡á…§á†«á„€á…§á†¼\",\"á„‡á…§á†«á„ƒá…©á†¼\",\"á„‡á…§á†«á„†á…§á†¼\",\"á„‡á…§á†«á„‰á…µá†«\",\"á„‡á…§á†«á„’á…©á„‰á…¡\",\"á„‡á…§á†«á„’á…ª\",\"á„‡á…§á†¯á„ƒá…©\",\"á„‡á…§á†¯á„†á…§á†¼\",\"á„‡á…§á†¯á„‹á…µá†¯\",\"á„‡á…§á†¼á„‰á…µá†¯\",\"á„‡á…§á†¼á„‹á…¡á„…á…µ\",\"á„‡á…§á†¼á„‹á…¯á†«\",\"á„‡á…©á„€á…ªá†«\",\"á„‡á…©á„‚á…¥á„‰á…³\",\"á„‡á…©á„…á…¡á„‰á…¢á†¨\",\"á„‡á…©á„…á…¡á†·\",\"á„‡á…©á„…á…³á†·\",\"á„‡á…©á„‰á…¡á†¼\",\"á„‡á…©á„‹á…¡á†«\",\"á„‡á…©á„Œá…¡á„€á…µ\",\"á„‡á…©á„Œá…¡á†¼\",\"á„‡á…©á„Œá…¥á†«\",\"á„‡á…©á„Œá…©á†«\",\"á„‡á…©á„á…©á†¼\",\"á„‡á…©á„‘á…§á†«á„Œá…¥á†¨\",\"á„‡á…©á„’á…¥á†·\",\"á„‡á…©á†¨á„ƒá…©\",\"á„‡á…©á†¨á„‰á…¡\",\"á„‡á…©á†¨á„‰á…®á†¼á„‹á…¡\",\"á„‡á…©á†¨á„‰á…³á†¸\",\"á„‡á…©á†©á„‹á…³á†·\",\"á„‡á…©á†«á„€á…§á†¨á„Œá…¥á†¨\",\"á„‡á…©á†«á„…á…¢\",\"á„‡á…©á†«á„‡á…®\",\"á„‡á…©á†«á„‰á…¡\",\"á„‡á…©á†«á„‰á…¥á†¼\",\"á„‡á…©á†«á„‹á…µá†«\",\"á„‡á…©á†«á„Œá…µá†¯\",\"á„‡á…©á†¯á„‘á…¦á†«\",\"á„‡á…©á†¼á„‰á…¡\",\"á„‡á…©á†¼á„Œá…µ\",\"á„‡á…©á†¼á„á…®\",\"á„‡á…®á„€á…³á†«\",\"á„‡á…®á„á…³á„…á…¥á„‹á…®á†·\",\"á„‡á…®á„ƒá…¡á†·\",\"á„‡á…®á„ƒá…©á†¼á„‰á…¡á†«\",\"á„‡á…®á„†á…®á†«\",\"á„‡á…®á„‡á…®á†«\",\"á„‡á…®á„‰á…¡á†«\",\"á„‡á…®á„‰á…¡á†¼\",\"á„‡á…®á„‹á…¥á†¿\",\"á„‡á…®á„‹á…µá†«\",\"á„‡á…®á„Œá…¡á†¨á„‹á…­á†¼\",\"á„‡á…®á„Œá…¡á†¼\",\"á„‡á…®á„Œá…¥á†¼\",\"á„‡á…®á„Œá…©á†¨\",\"á„‡á…®á„Œá…µá„…á…¥á†«á„’á…µ\",\"á„‡á…®á„Žá…µá†«\",\"á„‡á…®á„á…¡á†¨\",\"á„‡á…®á„‘á…®á†·\",\"á„‡á…®á„’á…¬á„Œá…¡á†¼\",\"á„‡á…®á†¨á„‡á…®\",\"á„‡á…®á†¨á„’á…¡á†«\",\"á„‡á…®á†«á„‚á…©\",\"á„‡á…®á†«á„…á…£á†¼\",\"á„‡á…®á†«á„…á…µ\",\"á„‡á…®á†«á„†á…§á†¼\",\"á„‡á…®á†«á„‰á…¥á†¨\",\"á„‡á…®á†«á„‹á…£\",\"á„‡á…®á†«á„‹á…±á„€á…µ\",\"á„‡á…®á†«á„‘á…µá†¯\",\"á„‡á…®á†«á„’á…©á†¼á„‰á…¢á†¨\",\"á„‡á…®á†¯á„€á…©á„€á…µ\",\"á„‡á…®á†¯á„€á…ª\",\"á„‡á…®á†¯á„€á…­\",\"á„‡á…®á†¯á„á…©á†¾\",\"á„‡á…®á†¯á„†á…¡á†«\",\"á„‡á…®á†¯á„‡á…¥á†¸\",\"á„‡á…®á†¯á„‡á…µá†¾\",\"á„‡á…®á†¯á„‹á…¡á†«\",\"á„‡á…®á†¯á„‹á…µá„‹á…µá†¨\",\"á„‡á…®á†¯á„’á…¢á†¼\",\"á„‡á…³á„…á…¢á†«á„ƒá…³\",\"á„‡á…µá„€á…³á†¨\",\"á„‡á…µá„‚á…¡á†«\",\"á„‡á…µá„‚á…µá†¯\",\"á„‡á…µá„ƒá…®á†¯á„€á…µ\",\"á„‡á…µá„ƒá…µá„‹á…©\",\"á„‡á…µá„…á…©á„‰á…©\",\"á„‡á…µá„†á…¡á†«\",\"á„‡á…µá„†á…§á†¼\",\"á„‡á…µá„†á…µá†¯\",\"á„‡á…µá„‡á…¡á„…á…¡á†·\",\"á„‡á…µá„‡á…µá†·á„‡á…¡á†¸\",\"á„‡á…µá„‰á…¡á†¼\",\"á„‡á…µá„‹á…­á†¼\",\"á„‡á…µá„‹á…²á†¯\",\"á„‡á…µá„Œá…®á†¼\",\"á„‡á…µá„á…¡á„†á…µá†«\",\"á„‡á…µá„‘á…¡á†«\",\"á„‡á…µá†¯á„ƒá…µá†¼\",\"á„‡á…µá†ºá„†á…®á†¯\",\"á„‡á…µá†ºá„‡á…¡á†¼á„‹á…®á†¯\",\"á„‡á…µá†ºá„Œá…®á†¯á„€á…µ\",\"á„‡á…µá†¾á„á…¡á†¯\",\"á„ˆá…¡á†¯á„€á…¡á†«á„‰á…¢á†¨\",\"á„ˆá…¡á†¯á„…á…¢\",\"á„ˆá…¡á†¯á„…á…µ\",\"á„‰á…¡á„€á…¥á†«\",\"á„‰á…¡á„€á…¨á„Œá…¥á†¯\",\"á„‰á…¡á„‚á…¡á„‹á…µ\",\"á„‰á…¡á„‚á…£á†¼\",\"á„‰á…¡á„…á…¡á†·\",\"á„‰á…¡á„…á…¡á†¼\",\"á„‰á…¡á„…á…µá†¸\",\"á„‰á…¡á„†á…©á„‚á…µá†·\",\"á„‰á…¡á„†á…®á†¯\",\"á„‰á…¡á„‡á…¡á†¼\",\"á„‰á…¡á„‰á…¡á†¼\",\"á„‰á…¡á„‰á…¢á†¼á„’á…ªá†¯\",\"á„‰á…¡á„‰á…¥á†¯\",\"á„‰á…¡á„‰á…³á†·\",\"á„‰á…¡á„‰á…µá†¯\",\"á„‰á…¡á„‹á…¥á†¸\",\"á„‰á…¡á„‹á…­á†¼\",\"á„‰á…¡á„‹á…¯á†¯\",\"á„‰á…¡á„Œá…¡á†¼\",\"á„‰á…¡á„Œá…¥á†«\",\"á„‰á…¡á„Œá…µá†«\",\"á„‰á…¡á„Žá…©á†«\",\"á„‰á…¡á„Žá…®á†«á„€á…µ\",\"á„‰á…¡á„á…¡á†¼\",\"á„‰á…¡á„á…®á„…á…µ\",\"á„‰á…¡á„’á…³á†¯\",\"á„‰á…¡á†«á„€á…µá†¯\",\"á„‰á…¡á†«á„‡á…®á„‹á…µá†«á„€á…ª\",\"á„‰á…¡á†«á„‹á…¥á†¸\",\"á„‰á…¡á†«á„Žá…¢á†¨\",\"á„‰á…¡á†¯á„…á…µá†·\",\"á„‰á…¡á†¯á„‹á…µá†«\",\"á„‰á…¡á†¯á„á…¡á†¨\",\"á„‰á…¡á†·á„€á…¨á„á…¡á†¼\",\"á„‰á…¡á†·á„€á…®á†¨\",\"á„‰á…¡á†·á„‰á…µá†¸\",\"á„‰á…¡á†·á„‹á…¯á†¯\",\"á„‰á…¡á†·á„Žá…©á†«\",\"á„‰á…¡á†¼á„€á…ªá†«\",\"á„‰á…¡á†¼á„€á…³á†·\",\"á„‰á…¡á†¼á„ƒá…¢\",\"á„‰á…¡á†¼á„…á…²\",\"á„‰á…¡á†¼á„‡á…¡á†«á„€á…µ\",\"á„‰á…¡á†¼á„‰á…¡á†¼\",\"á„‰á…¡á†¼á„‰á…µá†¨\",\"á„‰á…¡á†¼á„‹á…¥á†¸\",\"á„‰á…¡á†¼á„‹á…µá†«\",\"á„‰á…¡á†¼á„Œá…¡\",\"á„‰á…¡á†¼á„Œá…¥á†·\",\"á„‰á…¡á†¼á„Žá…¥\",\"á„‰á…¡á†¼á„Žá…®\",\"á„‰á…¡á†¼á„á…¢\",\"á„‰á…¡á†¼á„‘á…­\",\"á„‰á…¡á†¼á„‘á…®á†·\",\"á„‰á…¡á†¼á„’á…ªá†¼\",\"á„‰á…¢á„‡á…§á†¨\",\"á„‰á…¢á†¨á„á…¡á†¯\",\"á„‰á…¢á†¨á„‹á…§á†«á„‘á…µá†¯\",\"á„‰á…¢á†¼á„€á…¡á†¨\",\"á„‰á…¢á†¼á„†á…§á†¼\",\"á„‰á…¢á†¼á„†á…®á†¯\",\"á„‰á…¢á†¼á„‡á…¡á†¼á„‰á…©á†¼\",\"á„‰á…¢á†¼á„‰á…¡á†«\",\"á„‰á…¢á†¼á„‰á…¥á†«\",\"á„‰á…¢á†¼á„‰á…µá†«\",\"á„‰á…¢á†¼á„‹á…µá†¯\",\"á„‰á…¢á†¼á„’á…ªá†¯\",\"á„‰á…¥á„…á…¡á†¸\",\"á„‰á…¥á„…á…³á†«\",\"á„‰á…¥á„†á…§á†¼\",\"á„‰á…¥á„†á…µá†«\",\"á„‰á…¥á„‡á…µá„‰á…³\",\"á„‰á…¥á„‹á…£á†¼\",\"á„‰á…¥á„‹á…®á†¯\",\"á„‰á…¥á„Œá…¥á†¨\",\"á„‰á…¥á„Œá…¥á†·\",\"á„‰á…¥á„á…©á†¨\",\"á„‰á…¥á„á…³á†¯\",\"á„‰á…¥á†¨á„‰á…¡\",\"á„‰á…¥á†¨á„‹á…²\",\"á„‰á…¥á†«á„€á…¥\",\"á„‰á…¥á†«á„†á…®á†¯\",\"á„‰á…¥á†«á„‡á…¢\",\"á„‰á…¥á†«á„‰á…¢á†¼\",\"á„‰á…¥á†«á„‰á…®\",\"á„‰á…¥á†«á„‹á…¯á†«\",\"á„‰á…¥á†«á„Œá…¡á†¼\",\"á„‰á…¥á†«á„Œá…¥á†«\",\"á„‰á…¥á†«á„á…¢á†¨\",\"á„‰á…¥á†«á„‘á…®á†¼á„€á…µ\",\"á„‰á…¥á†¯á„€á…¥á„Œá…µ\",\"á„‰á…¥á†¯á„‚á…¡á†¯\",\"á„‰á…¥á†¯á„…á…¥á†¼á„á…¡á†¼\",\"á„‰á…¥á†¯á„†á…§á†¼\",\"á„‰á…¥á†¯á„†á…®á†«\",\"á„‰á…¥á†¯á„‰á…¡\",\"á„‰á…¥á†¯á„‹á…¡á†¨á„‰á…¡á†«\",\"á„‰á…¥á†¯á„Žá…µ\",\"á„‰á…¥á†¯á„á…¡á†¼\",\"á„‰á…¥á†¸á„Šá…µ\",\"á„‰á…¥á†¼á„€á…©á†¼\",\"á„‰á…¥á†¼á„ƒá…¡á†¼\",\"á„‰á…¥á†¼á„†á…§á†¼\",\"á„‰á…¥á†¼á„‡á…§á†¯\",\"á„‰á…¥á†¼á„‹á…µá†«\",\"á„‰á…¥á†¼á„Œá…¡á†¼\",\"á„‰á…¥á†¼á„Œá…¥á†¨\",\"á„‰á…¥á†¼á„Œá…µá†¯\",\"á„‰á…¥á†¼á„’á…¡á†·\",\"á„‰á…¦á„€á…³á†·\",\"á„‰á…¦á„†á…µá„‚á…¡\",\"á„‰á…¦á„‰á…¡á†¼\",\"á„‰á…¦á„‹á…¯á†¯\",\"á„‰á…¦á„Œá…©á†¼á„ƒá…¢á„‹á…ªá†¼\",\"á„‰á…¦á„á…¡á†¨\",\"á„‰á…¦á†«á„á…¥\",\"á„‰á…¦á†«á„á…µá„†á…µá„á…¥\",\"á„‰á…¦á†ºá„á…¢\",\"á„‰á…©á„€á…²á„†á…©\",\"á„‰á…©á„€á…³á†¨á„Œá…¥á†¨\",\"á„‰á…©á„€á…³á†·\",\"á„‰á…©á„‚á…¡á„€á…µ\",\"á„‰á…©á„‚á…§á†«\",\"á„‰á…©á„ƒá…³á†¨\",\"á„‰á…©á„†á…¡á†¼\",\"á„‰á…©á„†á…®á†«\",\"á„‰á…©á„‰á…¥á†¯\",\"á„‰á…©á„‰á…©á†¨\",\"á„‰á…©á„‹á…¡á„€á…ª\",\"á„‰á…©á„‹á…­á†¼\",\"á„‰á…©á„‹á…¯á†«\",\"á„‰á…©á„‹á…³á†·\",\"á„‰á…©á„Œá…®á†¼á„’á…µ\",\"á„‰á…©á„Œá…µá„‘á…®á†·\",\"á„‰á…©á„Œá…µá†¯\",\"á„‰á…©á„‘á…®á†¼\",\"á„‰á…©á„’á…§á†¼\",\"á„‰á…©á†¨á„ƒá…¡á†·\",\"á„‰á…©á†¨á„ƒá…©\",\"á„‰á…©á†¨á„‹á…©á†º\",\"á„‰á…©á†«á„€á…¡á„…á…¡á†¨\",\"á„‰á…©á†«á„€á…µá†¯\",\"á„‰á…©á†«á„‚á…§\",\"á„‰á…©á†«á„‚á…µá†·\",\"á„‰á…©á†«á„ƒá…³á†¼\",\"á„‰á…©á†«á„†á…©á†¨\",\"á„‰á…©á†«á„ˆá…§á†¨\",\"á„‰á…©á†«á„‰á…µá†¯\",\"á„‰á…©á†«á„Œá…µá†¯\",\"á„‰á…©á†«á„á…©á†¸\",\"á„‰á…©á†«á„’á…¢\",\"á„‰á…©á†¯á„Œá…µá†¨á„’á…µ\",\"á„‰á…©á†·á„Šá…µ\",\"á„‰á…©á†¼á„‹á…¡á„Œá…µ\",\"á„‰á…©á†¼á„‹á…µ\",\"á„‰á…©á†¼á„‘á…§á†«\",\"á„‰á…¬á„€á…©á„€á…µ\",\"á„‰á…­á„‘á…µá†¼\",\"á„‰á…®á„€á…¥á†«\",\"á„‰á…®á„‚á…§á†«\",\"á„‰á…®á„ƒá…¡á†«\",\"á„‰á…®á„ƒá…©á†ºá„†á…®á†¯\",\"á„‰á…®á„ƒá…©á†¼á„Œá…¥á†¨\",\"á„‰á…®á„†á…§á†«\",\"á„‰á…®á„†á…§á†¼\",\"á„‰á…®á„‡á…¡á†¨\",\"á„‰á…®á„‰á…¡á†¼\",\"á„‰á…®á„‰á…¥á†¨\",\"á„‰á…®á„‰á…®á†¯\",\"á„‰á…®á„‰á…µá„…á…©\",\"á„‰á…®á„‹á…¥á†¸\",\"á„‰á…®á„‹á…§á†·\",\"á„‰á…®á„‹á…§á†¼\",\"á„‰á…®á„‹á…µá†¸\",\"á„‰á…®á„Œá…®á†«\",\"á„‰á…®á„Œá…µá†¸\",\"á„‰á…®á„Žá…®á†¯\",\"á„‰á…®á„á…¥á†º\",\"á„‰á…®á„‘á…µá†¯\",\"á„‰á…®á„’á…¡á†¨\",\"á„‰á…®á„’á…¥á†·á„‰á…¢á†¼\",\"á„‰á…®á„’á…ªá„€á…µ\",\"á„‰á…®á†¨á„‚á…§\",\"á„‰á…®á†¨á„‰á…©\",\"á„‰á…®á†¨á„Œá…¦\",\"á„‰á…®á†«á„€á…¡á†«\",\"á„‰á…®á†«á„‰á…¥\",\"á„‰á…®á†«á„‰á…®\",\"á„‰á…®á†«á„‰á…µá†¨á„€á…¡á†«\",\"á„‰á…®á†«á„‹á…±\",\"á„‰á…®á†®á„€á…¡á„…á…¡á†¨\",\"á„‰á…®á†¯á„‡á…§á†¼\",\"á„‰á…®á†¯á„Œá…µá†¸\",\"á„‰á…®á†ºá„Œá…¡\",\"á„‰á…³á„‚á…µá†·\",\"á„‰á…³á„†á…®á†¯\",\"á„‰á…³á„‰á…³á„…á…©\",\"á„‰á…³á„‰á…³á†¼\",\"á„‰á…³á„‹á…°á„á…¥\",\"á„‰á…³á„‹á…±á„Žá…µ\",\"á„‰á…³á„á…¦á„‹á…µá„á…³\",\"á„‰á…³á„á…²á„ƒá…µá„‹á…©\",\"á„‰á…³á„á…³á„…á…¦á„‰á…³\",\"á„‰á…³á„‘á…©á„Žá…³\",\"á„‰á…³á†¯á„á…¥á†¨\",\"á„‰á…³á†¯á„‘á…³á†·\",\"á„‰á…³á†¸á„€á…ªá†«\",\"á„‰á…³á†¸á„€á…µ\",\"á„‰á…³á†¼á„€á…¢á†¨\",\"á„‰á…³á†¼á„…á…µ\",\"á„‰á…³á†¼á„‡á…®\",\"á„‰á…³á†¼á„‹á…­á†¼á„Žá…¡\",\"á„‰á…³á†¼á„Œá…µá†«\",\"á„‰á…µá„€á…¡á†¨\",\"á„‰á…µá„€á…¡á†«\",\"á„‰á…µá„€á…©á†¯\",\"á„‰á…µá„€á…³á†·á„Žá…µ\",\"á„‰á…µá„‚á…¡á„…á…µá„‹á…©\",\"á„‰á…µá„ƒá…¢á†¨\",\"á„‰á…µá„…á…µá„Œá…³\",\"á„‰á…µá„†á…¦á†«á„á…³\",\"á„‰á…µá„†á…µá†«\",\"á„‰á…µá„‡á…®á„†á…©\",\"á„‰á…µá„‰á…¥á†«\",\"á„‰á…µá„‰á…¥á†¯\",\"á„‰á…µá„‰á…³á„á…¦á†·\",\"á„‰á…µá„‹á…¡á„‡á…¥á„Œá…µ\",\"á„‰á…µá„‹á…¥á„†á…¥á„‚á…µ\",\"á„‰á…µá„‹á…¯á†¯\",\"á„‰á…µá„‹á…µá†«\",\"á„‰á…µá„‹á…µá†¯\",\"á„‰á…µá„Œá…¡á†¨\",\"á„‰á…µá„Œá…¡á†¼\",\"á„‰á…µá„Œá…¥á†¯\",\"á„‰á…µá„Œá…¥á†·\",\"á„‰á…µá„Œá…®á†¼\",\"á„‰á…µá„Œá…³á†«\",\"á„‰á…µá„Œá…µá†¸\",\"á„‰á…µá„Žá…¥á†¼\",\"á„‰á…µá„’á…¡á†¸\",\"á„‰á…µá„’á…¥á†·\",\"á„‰á…µá†¨á„€á…®\",\"á„‰á…µá†¨á„€á…µ\",\"á„‰á…µá†¨á„ƒá…¡á†¼\",\"á„‰á…µá†¨á„…á…£á†¼\",\"á„‰á…µá†¨á„…á…­á„‘á…®á†·\",\"á„‰á…µá†¨á„†á…®á†¯\",\"á„‰á…µá†¨á„ˆá…¡á†¼\",\"á„‰á…µá†¨á„‰á…¡\",\"á„‰á…µá†¨á„‰á…¢á†¼á„’á…ªá†¯\",\"á„‰á…µá†¨á„Žá…©\",\"á„‰á…µá†¨á„á…¡á†¨\",\"á„‰á…µá†¨á„‘á…®á†·\",\"á„‰á…µá†«á„€á…©\",\"á„‰á…µá†«á„€á…²\",\"á„‰á…µá†«á„‚á…§á†·\",\"á„‰á…µá†«á„†á…®á†«\",\"á„‰á…µá†«á„‡á…¡á†¯\",\"á„‰á…µá†«á„‡á…µ\",\"á„‰á…µá†«á„‰á…¡\",\"á„‰á…µá†«á„‰á…¦\",\"á„‰á…µá†«á„‹á…­á†¼\",\"á„‰á…µá†«á„Œá…¦á„‘á…®á†·\",\"á„‰á…µá†«á„Žá…¥á†¼\",\"á„‰á…µá†«á„Žá…¦\",\"á„‰á…µá†«á„’á…ª\",\"á„‰á…µá†¯á„€á…¡á†·\",\"á„‰á…µá†¯á„‚á…¢\",\"á„‰á…µá†¯á„…á…§á†¨\",\"á„‰á…µá†¯á„…á…¨\",\"á„‰á…µá†¯á„†á…¡á†¼\",\"á„‰á…µá†¯á„‰á…®\",\"á„‰á…µá†¯á„‰á…³á†¸\",\"á„‰á…µá†¯á„‰á…µ\",\"á„‰á…µá†¯á„Œá…¡á†¼\",\"á„‰á…µá†¯á„Œá…¥á†¼\",\"á„‰á…µá†¯á„Œá…µá†¯á„Œá…¥á†¨\",\"á„‰á…µá†¯á„Žá…¥á†«\",\"á„‰á…µá†¯á„Žá…¦\",\"á„‰á…µá†¯á„á…¥á†º\",\"á„‰á…µá†¯á„á…¢\",\"á„‰á…µá†¯á„‘á…¢\",\"á„‰á…µá†¯á„’á…¥á†·\",\"á„‰á…µá†¯á„’á…§á†«\",\"á„‰á…µá†·á„…á…µ\",\"á„‰á…µá†·á„‡á…®á„…á…³á†·\",\"á„‰á…µá†·á„‰á…¡\",\"á„‰á…µá†·á„Œá…¡á†¼\",\"á„‰á…µá†·á„Œá…¥á†¼\",\"á„‰á…µá†·á„‘á…¡á†«\",\"á„Šá…¡á†¼á„ƒá…®á†¼á„‹á…µ\",\"á„Šá…µá„…á…³á†·\",\"á„Šá…µá„‹á…¡á†º\",\"á„‹á…¡á„€á…¡á„Šá…µ\",\"á„‹á…¡á„‚á…¡á„‹á…®á†«á„‰á…¥\",\"á„‹á…¡á„ƒá…³á„‚á…µá†·\",\"á„‹á…¡á„ƒá…³á†¯\",\"á„‹á…¡á„‰á…±á„‹á…®á†·\",\"á„‹á…¡á„‰á…³á„‘á…¡á†¯á„á…³\",\"á„‹á…¡á„‰á…µá„‹á…¡\",\"á„‹á…¡á„‹á…®á†¯á„…á…¥\",\"á„‹á…¡á„Œá…¥á„Šá…µ\",\"á„‹á…¡á„Œá…®á†·á„†á…¡\",\"á„‹á…¡á„Œá…µá†¨\",\"á„‹á…¡á„Žá…µá†·\",\"á„‹á…¡á„‘á…¡á„á…³\",\"á„‹á…¡á„‘á…³á„…á…µá„á…¡\",\"á„‹á…¡á„‘á…³á†·\",\"á„‹á…¡á„’á…©á†¸\",\"á„‹á…¡á„’á…³á†«\",\"á„‹á…¡á†¨á„€á…µ\",\"á„‹á…¡á†¨á„†á…©á†¼\",\"á„‹á…¡á†¨á„‰á…®\",\"á„‹á…¡á†«á„€á…¢\",\"á„‹á…¡á†«á„€á…§á†¼\",\"á„‹á…¡á†«á„€á…ª\",\"á„‹á…¡á†«á„‚á…¢\",\"á„‹á…¡á†«á„‚á…§á†¼\",\"á„‹á…¡á†«á„ƒá…©á†¼\",\"á„‹á…¡á†«á„‡á…¡á†¼\",\"á„‹á…¡á†«á„‡á…®\",\"á„‹á…¡á†«á„Œá…®\",\"á„‹á…¡á†¯á„…á…®á„†á…µá„‚á…²á†·\",\"á„‹á…¡á†¯á„á…©á„‹á…©á†¯\",\"á„‹á…¡á†·á„‰á…µ\",\"á„‹á…¡á†·á„á…¥á†º\",\"á„‹á…¡á†¸á„…á…§á†¨\",\"á„‹á…¡á‡á„‚á…¡á†¯\",\"á„‹á…¡á‡á„†á…®á†«\",\"á„‹á…¢á„‹á…µá†«\",\"á„‹á…¢á„Œá…¥á†¼\",\"á„‹á…¢á†¨á„‰á…®\",\"á„‹á…¢á†¯á„‡á…¥á†·\",\"á„‹á…£á„€á…¡á†«\",\"á„‹á…£á„ƒá…¡á†«\",\"á„‹á…£á„‹á…©á†¼\",\"á„‹á…£á†¨á„€á…¡á†«\",\"á„‹á…£á†¨á„€á…®á†¨\",\"á„‹á…£á†¨á„‰á…©á†¨\",\"á„‹á…£á†¨á„‰á…®\",\"á„‹á…£á†¨á„Œá…¥á†·\",\"á„‹á…£á†¨á„‘á…®á†·\",\"á„‹á…£á†¨á„’á…©á†«á„‚á…§\",\"á„‹á…£á†¼á„‚á…§á†·\",\"á„‹á…£á†¼á„…á…§á†¨\",\"á„‹á…£á†¼á„†á…¡á†¯\",\"á„‹á…£á†¼á„‡á…¢á„Žá…®\",\"á„‹á…£á†¼á„Œá…®\",\"á„‹á…£á†¼á„‘á…¡\",\"á„‹á…¥á„ƒá…®á†·\",\"á„‹á…¥á„…á…§á„‹á…®á†·\",\"á„‹á…¥á„…á…³á†«\",\"á„‹á…¥á„Œá…¦á†ºá„‡á…¡á†·\",\"á„‹á…¥á„á…¢á†»á„ƒá…³á†«\",\"á„‹á…¥á„á…¥á„ƒá…¡á„€á…¡\",\"á„‹á…¥á„á…¥á†«á„Œá…µ\",\"á„‹á…¥á†«á„‚á…µ\",\"á„‹á…¥á†«á„ƒá…¥á†¨\",\"á„‹á…¥á†«á„…á…©á†«\",\"á„‹á…¥á†«á„‹á…¥\",\"á„‹á…¥á†¯á„€á…®á†¯\",\"á„‹á…¥á†¯á„…á…³á†«\",\"á„‹á…¥á†¯á„‹á…³á†·\",\"á„‹á…¥á†¯á„‘á…µá†º\",\"á„‹á…¥á†·á„†á…¡\",\"á„‹á…¥á†¸á„†á…®\",\"á„‹á…¥á†¸á„Œá…©á†¼\",\"á„‹á…¥á†¸á„Žá…¦\",\"á„‹á…¥á†¼á„ƒá…¥á†¼á„‹á…µ\",\"á„‹á…¥á†¼á„†á…¡á†¼\",\"á„‹á…¥á†¼á„á…¥á„…á…µ\",\"á„‹á…¥á†½á„€á…³á„Œá…¦\",\"á„‹á…¦á„‚á…¥á„Œá…µ\",\"á„‹á…¦á„‹á…¥á„á…¥á†«\",\"á„‹á…¦á†«á„Œá…µá†«\",\"á„‹á…§á„€á…¥á†«\",\"á„‹á…§á„€á…©á„‰á…¢á†¼\",\"á„‹á…§á„€á…ªá†«\",\"á„‹á…§á„€á…®á†«\",\"á„‹á…§á„€á…¯á†«\",\"á„‹á…§á„ƒá…¢á„‰á…¢á†¼\",\"á„‹á…§á„ƒá…¥á†²\",\"á„‹á…§á„ƒá…©á†¼á„‰á…¢á†¼\",\"á„‹á…§á„ƒá…³á†«\",\"á„‹á…§á„…á…©á†«\",\"á„‹á…§á„…á…³á†·\",\"á„‹á…§á„‰á…¥á†º\",\"á„‹á…§á„‰á…¥á†¼\",\"á„‹á…§á„‹á…ªá†¼\",\"á„‹á…§á„‹á…µá†«\",\"á„‹á…§á„Œá…¥á†«á„’á…µ\",\"á„‹á…§á„Œá…µá†¨á„‹á…¯á†«\",\"á„‹á…§á„’á…¡á†¨á„‰á…¢á†¼\",\"á„‹á…§á„’á…¢á†¼\",\"á„‹á…§á†¨á„‰á…¡\",\"á„‹á…§á†¨á„‰á…µ\",\"á„‹á…§á†¨á„’á…¡á†¯\",\"á„‹á…§á†«á„€á…§á†¯\",\"á„‹á…§á†«á„€á…®\",\"á„‹á…§á†«á„€á…³á†¨\",\"á„‹á…§á†«á„€á…µ\",\"á„‹á…§á†«á„…á…¡á†¨\",\"á„‹á…§á†«á„‰á…¥á†¯\",\"á„‹á…§á†«á„‰á…¦\",\"á„‹á…§á†«á„‰á…©á†¨\",\"á„‹á…§á†«á„‰á…³á†¸\",\"á„‹á…§á†«á„‹á…¢\",\"á„‹á…§á†«á„‹á…¨á„‹á…µá†«\",\"á„‹á…§á†«á„‹á…µá†«\",\"á„‹á…§á†«á„Œá…¡á†¼\",\"á„‹á…§á†«á„Œá…®\",\"á„‹á…§á†«á„Žá…®á†¯\",\"á„‹á…§á†«á„‘á…µá†¯\",\"á„‹á…§á†«á„’á…¡á†¸\",\"á„‹á…§á†«á„’á…²\",\"á„‹á…§á†¯á„€á…µ\",\"á„‹á…§á†¯á„†á…¢\",\"á„‹á…§á†¯á„‰á…¬\",\"á„‹á…§á†¯á„‰á…µá†·á„’á…µ\",\"á„‹á…§á†¯á„Œá…¥á†¼\",\"á„‹á…§á†¯á„Žá…¡\",\"á„‹á…§á†¯á„’á…³á†¯\",\"á„‹á…§á†·á„…á…§\",\"á„‹á…§á†¸á„‰á…¥\",\"á„‹á…§á†¼á„€á…®á†¨\",\"á„‹á…§á†¼á„‚á…¡á†·\",\"á„‹á…§á†¼á„‰á…¡á†¼\",\"á„‹á…§á†¼á„‹á…£á†¼\",\"á„‹á…§á†¼á„‹á…§á†¨\",\"á„‹á…§á†¼á„‹á…®á†¼\",\"á„‹á…§á†¼á„‹á…¯á†«á„’á…µ\",\"á„‹á…§á†¼á„’á…¡\",\"á„‹á…§á†¼á„’á…£á†¼\",\"á„‹á…§á†¼á„’á…©á†«\",\"á„‹á…§á†¼á„’á…ª\",\"á„‹á…§á‡á„€á…®á„…á…µ\",\"á„‹á…§á‡á„‡á…¡á†¼\",\"á„‹á…§á‡á„Œá…µá†¸\",\"á„‹á…¨á„€á…¡á†·\",\"á„‹á…¨á„€á…³á†·\",\"á„‹á…¨á„‡á…¡á†¼\",\"á„‹á…¨á„‰á…¡á†«\",\"á„‹á…¨á„‰á…¡á†¼\",\"á„‹á…¨á„‰á…¥á†«\",\"á„‹á…¨á„‰á…®á†¯\",\"á„‹á…¨á„‰á…³á†¸\",\"á„‹á…¨á„‰á…µá†¨á„Œá…¡á†¼\",\"á„‹á…¨á„‹á…£á†¨\",\"á„‹á…¨á„Œá…¥á†«\",\"á„‹á…¨á„Œá…¥á†¯\",\"á„‹á…¨á„Œá…¥á†¼\",\"á„‹á…¨á„á…¥á†«á„ƒá…¢\",\"á„‹á…¨á†ºá„‚á…¡á†¯\",\"á„‹á…©á„‚á…³á†¯\",\"á„‹á…©á„…á…¡á†¨\",\"á„‹á…©á„…á…¢á†ºá„ƒá…©á†¼á„‹á…¡á†«\",\"á„‹á…©á„…á…¦á†«á„Œá…µ\",\"á„‹á…©á„…á…©á„Œá…µ\",\"á„‹á…©á„…á…³á†«á„‡á…¡á†¯\",\"á„‹á…©á„‡á…³á†«\",\"á„‹á…©á„‰á…µá†¸\",\"á„‹á…©á„‹á…§á†·\",\"á„‹á…©á„‹á…¯á†¯\",\"á„‹á…©á„Œá…¥á†«\",\"á„‹á…©á„Œá…µá†¨\",\"á„‹á…©á„Œá…µá†¼á„‹á…¥\",\"á„‹á…©á„‘á…¦á„…á…¡\",\"á„‹á…©á„‘á…µá„‰á…³á„á…¦á†¯\",\"á„‹á…©á„’á…µá„…á…§\",\"á„‹á…©á†¨á„‰á…¡á†¼\",\"á„‹á…©á†¨á„‰á…®á„‰á…®\",\"á„‹á…©á†«á„€á…¡á†½\",\"á„‹á…©á†«á„…á…¡á„‹á…µá†«\",\"á„‹á…©á†«á„†á…©á†·\",\"á„‹á…©á†«á„Œá…©á†¼á„‹á…µá†¯\",\"á„‹á…©á†«á„á…©á†¼\",\"á„‹á…©á†¯á„€á…¡á„‹á…³á†¯\",\"á„‹á…©á†¯á„…á…µá†·á„‘á…µá†¨\",\"á„‹á…©á†¯á„’á…¢\",\"á„‹á…©á†ºá„Žá…¡á„…á…µá†·\",\"á„‹á…ªá„‹á…µá„‰á…§á„Žá…³\",\"á„‹á…ªá„‹á…µá†«\",\"á„‹á…ªá†«á„‰á…¥á†¼\",\"á„‹á…ªá†«á„Œá…¥á†«\",\"á„‹á…ªá†¼á„‡á…µ\",\"á„‹á…ªá†¼á„Œá…¡\",\"á„‹á…«á„‚á…£á„’á…¡á„†á…§á†«\",\"á„‹á…«á†«á„Œá…µ\",\"á„‹á…¬á„€á…¡á†ºá„Œá…µá†¸\",\"á„‹á…¬á„€á…®á†¨\",\"á„‹á…¬á„…á…©á„‹á…®á†·\",\"á„‹á…¬á„‰á…¡á†·á„Žá…©á†«\",\"á„‹á…¬á„Žá…®á†¯\",\"á„‹á…¬á„Žá…µá†·\",\"á„‹á…¬á„’á…¡á†¯á„†á…¥á„‚á…µ\",\"á„‹á…¬á†«á„‡á…¡á†¯\",\"á„‹á…¬á†«á„‰á…©á†«\",\"á„‹á…¬á†«á„á…©á†¨\",\"á„‹á…­á„€á…³á†·\",\"á„‹á…­á„‹á…µá†¯\",\"á„‹á…­á„Œá…³á†·\",\"á„‹á…­á„Žá…¥á†¼\",\"á„‹á…­á†¼á„€á…µ\",\"á„‹á…­á†¼á„‰á…¥\",\"á„‹á…­á†¼á„‹á…¥\",\"á„‹á…®á„‰á…¡á†«\",\"á„‹á…®á„‰á…¥á†«\",\"á„‹á…®á„‰á…³á†¼\",\"á„‹á…®á„‹á…§á†«á„’á…µ\",\"á„‹á…®á„Œá…¥á†¼\",\"á„‹á…®á„Žá…¦á„€á…®á†¨\",\"á„‹á…®á„‘á…§á†«\",\"á„‹á…®á†«á„ƒá…©á†¼\",\"á„‹á…®á†«á„†á…§á†¼\",\"á„‹á…®á†«á„‡á…¡á†«\",\"á„‹á…®á†«á„Œá…¥á†«\",\"á„‹á…®á†«á„’á…¢á†¼\",\"á„‹á…®á†¯á„‰á…¡á†«\",\"á„‹á…®á†¯á„‹á…³á†·\",\"á„‹á…®á†·á„Œá…µá†¨á„‹á…µá†·\",\"á„‹á…®á†ºá„‹á…¥á„…á…³á†«\",\"á„‹á…®á†ºá„‹á…³á†·\",\"á„‹á…¯á„‚á…¡á†¨\",\"á„‹á…¯á†«á„€á…©\",\"á„‹á…¯á†«á„…á…¢\",\"á„‹á…¯á†«á„‰á…¥\",\"á„‹á…¯á†«á„‰á…®á†¼á„‹á…µ\",\"á„‹á…¯á†«á„‹á…µá†«\",\"á„‹á…¯á†«á„Œá…¡á†¼\",\"á„‹á…¯á†«á„‘á…µá„‰á…³\",\"á„‹á…¯á†¯á„€á…³á†¸\",\"á„‹á…¯á†¯á„ƒá…³á„á…¥á†¸\",\"á„‹á…¯á†¯á„‰á…¦\",\"á„‹á…¯á†¯á„‹á…­á„‹á…µá†¯\",\"á„‹á…°á„‹á…µá„á…¥\",\"á„‹á…±á„‡á…¡á†«\",\"á„‹á…±á„‡á…¥á†¸\",\"á„‹á…±á„‰á…¥á†¼\",\"á„‹á…±á„‹á…¯á†«\",\"á„‹á…±á„’á…¥á†·\",\"á„‹á…±á„’á…§á†¸\",\"á„‹á…±á†ºá„‰á…¡á„…á…¡á†·\",\"á„‹á…²á„‚á…¡á†«á„’á…µ\",\"á„‹á…²á„…á…¥á†¸\",\"á„‹á…²á„†á…§á†¼\",\"á„‹á…²á„†á…®á†¯\",\"á„‹á…²á„‰á…¡á†«\",\"á„‹á…²á„Œá…¥á†¨\",\"á„‹á…²á„Žá…µá„‹á…¯á†«\",\"á„‹á…²á„’á…¡á†¨\",\"á„‹á…²á„’á…¢á†¼\",\"á„‹á…²á„’á…§á†¼\",\"á„‹á…²á†¨á„€á…®á†«\",\"á„‹á…²á†¨á„‰á…¡á†¼\",\"á„‹á…²á†¨á„‰á…µá†¸\",\"á„‹á…²á†¨á„Žá…¦\",\"á„‹á…³á†«á„’á…¢á†¼\",\"á„‹á…³á†·á„…á…§á†¨\",\"á„‹á…³á†·á„…á…­\",\"á„‹á…³á†·á„‡á…¡á†«\",\"á„‹á…³á†·á„‰á…¥á†¼\",\"á„‹á…³á†·á„‰á…µá†¨\",\"á„‹á…³á†·á„‹á…¡á†¨\",\"á„‹á…³á†·á„Œá…®\",\"á„‹á…´á„€á…§á†«\",\"á„‹á…´á„‚á…©á†«\",\"á„‹á…´á„†á…®á†«\",\"á„‹á…´á„‡á…©á†¨\",\"á„‹á…´á„‰á…µá†¨\",\"á„‹á…´á„‰á…µá†·\",\"á„‹á…´á„‹á…¬á„…á…©\",\"á„‹á…´á„‹á…­á†¨\",\"á„‹á…´á„‹á…¯á†«\",\"á„‹á…´á„’á…¡á†¨\",\"á„‹á…µá„€á…¥á†º\",\"á„‹á…µá„€á…©á†º\",\"á„‹á…µá„‚á…§á†·\",\"á„‹á…µá„‚á…©á†·\",\"á„‹á…µá„ƒá…¡á†¯\",\"á„‹á…µá„ƒá…¢á„…á…©\",\"á„‹á…µá„ƒá…©á†¼\",\"á„‹á…µá„…á…¥á‡‚á„€á…¦\",\"á„‹á…µá„…á…§á†¨á„‰á…¥\",\"á„‹á…µá„…á…©á†«á„Œá…¥á†¨\",\"á„‹á…µá„…á…³á†·\",\"á„‹á…µá„†á…µá†«\",\"á„‹á…µá„‡á…¡á†¯á„‰á…©\",\"á„‹á…µá„‡á…§á†¯\",\"á„‹á…µá„‡á…®á†¯\",\"á„‹á…µá„ˆá…¡á†¯\",\"á„‹á…µá„‰á…¡á†¼\",\"á„‹á…µá„‰á…¥á†¼\",\"á„‹á…µá„‰á…³á†¯\",\"á„‹á…µá„‹á…£á„€á…µ\",\"á„‹á…µá„‹á…­á†¼\",\"á„‹á…µá„‹á…®á†º\",\"á„‹á…µá„‹á…¯á†¯\",\"á„‹á…µá„‹á…³á†¨á„€á…©\",\"á„‹á…µá„‹á…µá†¨\",\"á„‹á…µá„Œá…¥á†«\",\"á„‹á…µá„Œá…®á†¼\",\"á„‹á…µá„á…³á†®á„‚á…¡á†¯\",\"á„‹á…µá„á…³á†¯\",\"á„‹á…µá„’á…©á†«\",\"á„‹á…µá†«á„€á…¡á†«\",\"á„‹á…µá†«á„€á…§á†¨\",\"á„‹á…µá†«á„€á…©á†¼\",\"á„‹á…µá†«á„€á…®\",\"á„‹á…µá†«á„€á…³á†«\",\"á„‹á…µá†«á„€á…µ\",\"á„‹á…µá†«á„ƒá…©\",\"á„‹á…µá†«á„…á…²\",\"á„‹á…µá†«á„†á…®á†¯\",\"á„‹á…µá†«á„‰á…¢á†¼\",\"á„‹á…µá†«á„‰á…«\",\"á„‹á…µá†«á„‹á…§á†«\",\"á„‹á…µá†«á„‹á…¯á†«\",\"á„‹á…µá†«á„Œá…¢\",\"á„‹á…µá†«á„Œá…©á†¼\",\"á„‹á…µá†«á„Žá…¥á†«\",\"á„‹á…µá†«á„Žá…¦\",\"á„‹á…µá†«á„á…¥á„‚á…¦á†º\",\"á„‹á…µá†«á„’á…¡\",\"á„‹á…µá†«á„’á…§á†¼\",\"á„‹á…µá†¯á„€á…©á†¸\",\"á„‹á…µá†¯á„€á…µ\",\"á„‹á…µá†¯á„ƒá…¡á†«\",\"á„‹á…µá†¯á„ƒá…¢\",\"á„‹á…µá†¯á„ƒá…³á†¼\",\"á„‹á…µá†¯á„‡á…¡á†«\",\"á„‹á…µá†¯á„‡á…©á†«\",\"á„‹á…µá†¯á„‡á…®\",\"á„‹á…µá†¯á„‰á…¡á†¼\",\"á„‹á…µá†¯á„‰á…¢á†¼\",\"á„‹á…µá†¯á„‰á…©á†«\",\"á„‹á…µá†¯á„‹á…­á„‹á…µá†¯\",\"á„‹á…µá†¯á„‹á…¯á†¯\",\"á„‹á…µá†¯á„Œá…¥á†¼\",\"á„‹á…µá†¯á„Œá…©á†¼\",\"á„‹á…µá†¯á„Œá…®á„‹á…µá†¯\",\"á„‹á…µá†¯á„á…µá†¨\",\"á„‹á…µá†¯á„Žá…¦\",\"á„‹á…µá†¯á„Žá…µ\",\"á„‹á…µá†¯á„’á…¢á†¼\",\"á„‹á…µá†¯á„’á…¬á„‹á…­á†¼\",\"á„‹á…µá†·á„€á…³á†·\",\"á„‹á…µá†·á„†á…®\",\"á„‹á…µá†¸á„ƒá…¢\",\"á„‹á…µá†¸á„…á…§á†¨\",\"á„‹á…µá†¸á„†á…¡á†º\",\"á„‹á…µá†¸á„‰á…¡\",\"á„‹á…µá†¸á„‰á…®á†¯\",\"á„‹á…µá†¸á„‰á…µ\",\"á„‹á…µá†¸á„‹á…¯á†«\",\"á„‹á…µá†¸á„Œá…¡á†¼\",\"á„‹á…µá†¸á„’á…¡á†¨\",\"á„Œá…¡á„€á…¡á„‹á…­á†¼\",\"á„Œá…¡á„€á…§á†¨\",\"á„Œá…¡á„€á…³á†¨\",\"á„Œá…¡á„ƒá…©á†¼\",\"á„Œá…¡á„…á…¡á†¼\",\"á„Œá…¡á„‡á…®á„‰á…µá†·\",\"á„Œá…¡á„‰á…µá†¨\",\"á„Œá…¡á„‰á…µá†«\",\"á„Œá…¡á„‹á…§á†«\",\"á„Œá…¡á„‹á…¯á†«\",\"á„Œá…¡á„‹á…²á†¯\",\"á„Œá…¡á„Œá…¥á†«á„€á…¥\",\"á„Œá…¡á„Œá…¥á†¼\",\"á„Œá…¡á„Œá…©á†«á„‰á…µá†·\",\"á„Œá…¡á„‘á…¡á†«\",\"á„Œá…¡á†¨á„€á…¡\",\"á„Œá…¡á†¨á„‚á…§á†«\",\"á„Œá…¡á†¨á„‰á…¥á†¼\",\"á„Œá…¡á†¨á„‹á…¥á†¸\",\"á„Œá…¡á†¨á„‹á…­á†¼\",\"á„Œá…¡á†¨á„‹á…³á†«á„„á…¡á†¯\",\"á„Œá…¡á†¨á„‘á…®á†·\",\"á„Œá…¡á†«á„ƒá…µ\",\"á„Œá…¡á†«á„„á…³á†¨\",\"á„Œá…¡á†«á„Žá…µ\",\"á„Œá…¡á†¯á„†á…©á†º\",\"á„Œá…¡á†·á„á…¡á†«\",\"á„Œá…¡á†·á„‰á…®á„’á…¡á†·\",\"á„Œá…¡á†·á„‰á…µ\",\"á„Œá…¡á†·á„‹á…©á†º\",\"á„Œá…¡á†·á„Œá…¡á„…á…µ\",\"á„Œá…¡á†¸á„Œá…µ\",\"á„Œá…¡á†¼á„€á…ªá†«\",\"á„Œá…¡á†¼á„€á…®á†«\",\"á„Œá…¡á†¼á„€á…µá„€á…¡á†«\",\"á„Œá…¡á†¼á„…á…¢\",\"á„Œá…¡á†¼á„…á…¨\",\"á„Œá…¡á†¼á„…á…³\",\"á„Œá…¡á†¼á„†á…¡\",\"á„Œá…¡á†¼á„†á…§á†«\",\"á„Œá…¡á†¼á„†á…©\",\"á„Œá…¡á†¼á„†á…µ\",\"á„Œá…¡á†¼á„‡á…µ\",\"á„Œá…¡á†¼á„‰á…¡\",\"á„Œá…¡á†¼á„‰á…©\",\"á„Œá…¡á†¼á„‰á…µá†¨\",\"á„Œá…¡á†¼á„‹á…¢á„‹á…µá†«\",\"á„Œá…¡á†¼á„‹á…µá†«\",\"á„Œá…¡á†¼á„Œá…¥á†·\",\"á„Œá…¡á†¼á„Žá…¡\",\"á„Œá…¡á†¼á„’á…¡á†¨á„€á…³á†·\",\"á„Œá…¢á„‚á…³á†¼\",\"á„Œá…¢á„ˆá…¡á†¯á„…á…µ\",\"á„Œá…¢á„‰á…¡á†«\",\"á„Œá…¢á„‰á…¢á†¼\",\"á„Œá…¢á„Œá…¡á†¨á„‚á…§á†«\",\"á„Œá…¢á„Œá…¥á†¼\",\"á„Œá…¢á„Žá…¢á„€á…µ\",\"á„Œá…¢á„‘á…¡á†«\",\"á„Œá…¢á„’á…¡á†¨\",\"á„Œá…¢á„’á…ªá†¯á„‹á…­á†¼\",\"á„Œá…¥á„€á…¥á†º\",\"á„Œá…¥á„€á…©á„…á…µ\",\"á„Œá…¥á„€á…©á†º\",\"á„Œá…¥á„‚á…§á†¨\",\"á„Œá…¥á„…á…¥á†«\",\"á„Œá…¥á„…á…¥á‡‚á„€á…¦\",\"á„Œá…¥á„‡á…¥á†«\",\"á„Œá…¥á„‹á…®á†¯\",\"á„Œá…¥á„Œá…¥á†¯á„…á…©\",\"á„Œá…¥á„Žá…®á†¨\",\"á„Œá…¥á†¨á„€á…³á†¨\",\"á„Œá…¥á†¨á„ƒá…¡á†¼á„’á…µ\",\"á„Œá…¥á†¨á„‰á…¥á†¼\",\"á„Œá…¥á†¨á„‹á…­á†¼\",\"á„Œá…¥á†¨á„‹á…³á†¼\",\"á„Œá…¥á†«á„€á…¢\",\"á„Œá…¥á†«á„€á…©á†¼\",\"á„Œá…¥á†«á„€á…µ\",\"á„Œá…¥á†«á„ƒá…¡á†¯\",\"á„Œá…¥á†«á„…á…¡á„ƒá…©\",\"á„Œá…¥á†«á„†á…¡á†¼\",\"á„Œá…¥á†«á„†á…®á†«\",\"á„Œá…¥á†«á„‡á…¡á†«\",\"á„Œá…¥á†«á„‡á…®\",\"á„Œá…¥á†«á„‰á…¦\",\"á„Œá…¥á†«á„‰á…µ\",\"á„Œá…¥á†«á„‹á…­á†¼\",\"á„Œá…¥á†«á„Œá…¡\",\"á„Œá…¥á†«á„Œá…¢á†¼\",\"á„Œá…¥á†«á„Œá…®\",\"á„Œá…¥á†«á„Žá…¥á†¯\",\"á„Œá…¥á†«á„Žá…¦\",\"á„Œá…¥á†«á„á…©á†¼\",\"á„Œá…¥á†«á„’á…§\",\"á„Œá…¥á†«á„’á…®\",\"á„Œá…¥á†¯á„ƒá…¢\",\"á„Œá…¥á†¯á„†á…¡á†¼\",\"á„Œá…¥á†¯á„‡á…¡á†«\",\"á„Œá…¥á†¯á„‹á…£á†¨\",\"á„Œá…¥á†¯á„Žá…¡\",\"á„Œá…¥á†·á„€á…¥á†·\",\"á„Œá…¥á†·á„‰á…®\",\"á„Œá…¥á†·á„‰á…µá†·\",\"á„Œá…¥á†·á„‹á…¯á†«\",\"á„Œá…¥á†·á„Œá…¥á†·\",\"á„Œá…¥á†·á„Žá…¡\",\"á„Œá…¥á†¸á„€á…³á†«\",\"á„Œá…¥á†¸á„‰á…µ\",\"á„Œá…¥á†¸á„Žá…©á†¨\",\"á„Œá…¥á†ºá„€á…¡á„…á…¡á†¨\",\"á„Œá…¥á†¼á„€á…¥á„Œá…¡á†¼\",\"á„Œá…¥á†¼á„ƒá…©\",\"á„Œá…¥á†¼á„…á…²á„Œá…¡á†¼\",\"á„Œá…¥á†¼á„…á…µ\",\"á„Œá…¥á†¼á„†á…¡á†¯\",\"á„Œá…¥á†¼á„†á…§á†«\",\"á„Œá…¥á†¼á„†á…®á†«\",\"á„Œá…¥á†¼á„‡á…¡á†«á„ƒá…¢\",\"á„Œá…¥á†¼á„‡á…©\",\"á„Œá…¥á†¼á„‡á…®\",\"á„Œá…¥á†¼á„‡á…µ\",\"á„Œá…¥á†¼á„‰á…¡á†¼\",\"á„Œá…¥á†¼á„‰á…¥á†¼\",\"á„Œá…¥á†¼á„‹á…©\",\"á„Œá…¥á†¼á„‹á…¯á†«\",\"á„Œá…¥á†¼á„Œá…¡á†¼\",\"á„Œá…¥á†¼á„Œá…µ\",\"á„Œá…¥á†¼á„Žá…µ\",\"á„Œá…¥á†¼á„’á…ªá†¨á„’á…µ\",\"á„Œá…¦á„€á…©á†¼\",\"á„Œá…¦á„€á…ªá„Œá…¥á†·\",\"á„Œá…¦á„ƒá…¢á„…á…©\",\"á„Œá…¦á„†á…©á†¨\",\"á„Œá…¦á„‡á…¡á†¯\",\"á„Œá…¦á„‡á…¥á†¸\",\"á„Œá…¦á„‰á…¡á†ºá„‚á…¡á†¯\",\"á„Œá…¦á„‹á…¡á†«\",\"á„Œá…¦á„‹á…µá†¯\",\"á„Œá…¦á„Œá…¡á†¨\",\"á„Œá…¦á„Œá…®á„ƒá…©\",\"á„Œá…¦á„Žá…®á†¯\",\"á„Œá…¦á„‘á…®á†·\",\"á„Œá…¦á„’á…¡á†«\",\"á„Œá…©á„€á…¡á†¨\",\"á„Œá…©á„€á…¥á†«\",\"á„Œá…©á„€á…³á†·\",\"á„Œá…©á„€á…µá†¼\",\"á„Œá…©á„†á…§á†¼\",\"á„Œá…©á„†á…µá„…á…­\",\"á„Œá…©á„‰á…¡á†¼\",\"á„Œá…©á„‰á…¥á†«\",\"á„Œá…©á„‹á…­á†¼á„’á…µ\",\"á„Œá…©á„Œá…¥á†¯\",\"á„Œá…©á„Œá…¥á†¼\",\"á„Œá…©á„Œá…µá†¨\",\"á„Œá…©á†«á„ƒá…¢á†ºá„†á…¡á†¯\",\"á„Œá…©á†«á„Œá…¢\",\"á„Œá…©á†¯á„‹á…¥á†¸\",\"á„Œá…©á†¯á„‹á…³á†·\",\"á„Œá…©á†¼á„€á…­\",\"á„Œá…©á†¼á„…á…©\",\"á„Œá…©á†¼á„…á…²\",\"á„Œá…©á†¼á„‰á…©á„…á…µ\",\"á„Œá…©á†¼á„‹á…¥á†¸á„‹á…¯á†«\",\"á„Œá…©á†¼á„Œá…©á†¼\",\"á„Œá…©á†¼á„’á…¡á†¸\",\"á„Œá…ªá„‰á…¥á†¨\",\"á„Œá…¬á„‹á…µá†«\",\"á„Œá…®á„€á…ªá†«á„Œá…¥á†¨\",\"á„Œá…®á„…á…³á†·\",\"á„Œá…®á„†á…¡á†¯\",\"á„Œá…®á„†á…¥á„‚á…µ\",\"á„Œá…®á„†á…¥á†¨\",\"á„Œá…®á„†á…®á†«\",\"á„Œá…®á„†á…µá†«\",\"á„Œá…®á„‡á…¡á†¼\",\"á„Œá…®á„‡á…§á†«\",\"á„Œá…®á„‰á…µá†¨\",\"á„Œá…®á„‹á…µá†«\",\"á„Œá…®á„‹á…µá†¯\",\"á„Œá…®á„Œá…¡á†¼\",\"á„Œá…®á„Œá…¥á†«á„Œá…¡\",\"á„Œá…®á„á…¢á†¨\",\"á„Œá…®á†«á„‡á…µ\",\"á„Œá…®á†¯á„€á…¥á„…á…µ\",\"á„Œá…®á†¯á„€á…µ\",\"á„Œá…®á†¯á„†á…®á„‚á…´\",\"á„Œá…®á†¼á„€á…¡á†«\",\"á„Œá…®á†¼á„€á…¨á„‡á…¡á†¼á„‰á…©á†¼\",\"á„Œá…®á†¼á„€á…®á†¨\",\"á„Œá…®á†¼á„‚á…§á†«\",\"á„Œá…®á†¼á„ƒá…¡á†«\",\"á„Œá…®á†¼á„ƒá…©á†¨\",\"á„Œá…®á†¼á„‡á…¡á†«\",\"á„Œá…®á†¼á„‡á…®\",\"á„Œá…®á†¼á„‰á…¦\",\"á„Œá…®á†¼á„‰á…©á„€á…µá„‹á…¥á†¸\",\"á„Œá…®á†¼á„‰á…®á†«\",\"á„Œá…®á†¼á„‹á…¡á†¼\",\"á„Œá…®á†¼á„‹á…­\",\"á„Œá…®á†¼á„’á…¡á†¨á„€á…­\",\"á„Œá…³á†¨á„‰á…¥á†¨\",\"á„Œá…³á†¨á„‰á…µ\",\"á„Œá…³á†¯á„€á…¥á„‹á…®á†·\",\"á„Œá…³á†¼á„€á…¡\",\"á„Œá…³á†¼á„€á…¥\",\"á„Œá…³á†¼á„€á…¯á†«\",\"á„Œá…³á†¼á„‰á…¡á†¼\",\"á„Œá…³á†¼á„‰á…¦\",\"á„Œá…µá„€á…¡á†¨\",\"á„Œá…µá„€á…¡á†¸\",\"á„Œá…µá„€á…§á†¼\",\"á„Œá…µá„€á…³á†¨á„’á…µ\",\"á„Œá…µá„€á…³á†·\",\"á„Œá…µá„€á…³á†¸\",\"á„Œá…µá„‚á…³á†¼\",\"á„Œá…µá„…á…³á†·á„€á…µá†¯\",\"á„Œá…µá„…á…µá„‰á…¡á†«\",\"á„Œá…µá„‡á…¡á†¼\",\"á„Œá…µá„‡á…®á†¼\",\"á„Œá…µá„‰á…µá†¨\",\"á„Œá…µá„‹á…§á†¨\",\"á„Œá…µá„‹á…®á„€á…¢\",\"á„Œá…µá„‹á…¯á†«\",\"á„Œá…µá„Œá…¥á†¨\",\"á„Œá…µá„Œá…¥á†·\",\"á„Œá…µá„Œá…µá†«\",\"á„Œá…µá„Žá…®á†¯\",\"á„Œá…µá†¨á„‰á…¥á†«\",\"á„Œá…µá†¨á„‹á…¥á†¸\",\"á„Œá…µá†¨á„‹á…¯á†«\",\"á„Œá…µá†¨á„Œá…¡á†¼\",\"á„Œá…µá†«á„€á…³á†¸\",\"á„Œá…µá†«á„ƒá…©á†¼\",\"á„Œá…µá†«á„…á…©\",\"á„Œá…µá†«á„…á…­\",\"á„Œá…µá†«á„…á…µ\",\"á„Œá…µá†«á„á…¡\",\"á„Œá…µá†«á„Žá…¡á†¯\",\"á„Œá…µá†«á„Žá…®á†¯\",\"á„Œá…µá†«á„á…©á†¼\",\"á„Œá…µá†«á„’á…¢á†¼\",\"á„Œá…µá†¯á„†á…®á†«\",\"á„Œá…µá†¯á„‡á…§á†¼\",\"á„Œá…µá†¯á„‰á…¥\",\"á„Œá…µá†·á„Œá…¡á†¨\",\"á„Œá…µá†¸á„ƒá…¡á†«\",\"á„Œá…µá†¸á„‹á…¡á†«\",\"á„Œá…µá†¸á„Œá…®á†¼\",\"á„á…¡á„Œá…³á†¼\",\"á„á…µá„á…¥á„€á…µ\",\"á„Žá…¡á„‚á…¡á†·\",\"á„Žá…¡á„…á…¡á„…á…µ\",\"á„Žá…¡á„…á…£á†¼\",\"á„Žá…¡á„…á…µá†·\",\"á„Žá…¡á„‡á…§á†¯\",\"á„Žá…¡á„‰á…¥á†«\",\"á„Žá…¡á„Žá…³á†·\",\"á„Žá…¡á†¨á„€á…¡á†¨\",\"á„Žá…¡á†«á„†á…®á†¯\",\"á„Žá…¡á†«á„‰á…¥á†¼\",\"á„Žá…¡á†·á„€á…¡\",\"á„Žá…¡á†·á„€á…µá„…á…³á†·\",\"á„Žá…¡á†·á„‰á…¢\",\"á„Žá…¡á†·á„‰á…¥á†¨\",\"á„Žá…¡á†·á„‹á…§\",\"á„Žá…¡á†·á„‹á…¬\",\"á„Žá…¡á†·á„Œá…©\",\"á„Žá…¡á†ºá„Œá…¡á†«\",\"á„Žá…¡á†¼á„€á…¡\",\"á„Žá…¡á†¼á„€á…©\",\"á„Žá…¡á†¼á„€á…®\",\"á„Žá…¡á†¼á„†á…®á†«\",\"á„Žá…¡á†¼á„‡á…¡á†©\",\"á„Žá…¡á†¼á„Œá…¡á†¨\",\"á„Žá…¡á†¼á„Œá…©\",\"á„Žá…¢á„‚á…¥á†¯\",\"á„Žá…¢á„Œá…¥á†·\",\"á„Žá…¢á†¨á„€á…¡á„‡á…¡á†¼\",\"á„Žá…¢á†¨á„‡á…¡á†¼\",\"á„Žá…¢á†¨á„‰á…¡á†¼\",\"á„Žá…¢á†¨á„‹á…µá†·\",\"á„Žá…¢á†·á„‘á…µá„‹á…¥á†«\",\"á„Žá…¥á„‡á…¥á†¯\",\"á„Žá…¥á„‹á…³á†·\",\"á„Žá…¥á†«á„€á…®á†¨\",\"á„Žá…¥á†«á„ƒá…®á†¼\",\"á„Žá…¥á†«á„Œá…¡á†¼\",\"á„Žá…¥á†«á„Œá…¢\",\"á„Žá…¥á†«á„Žá…¥á†«á„’á…µ\",\"á„Žá…¥á†¯á„ƒá…©\",\"á„Žá…¥á†¯á„Œá…¥á„’á…µ\",\"á„Žá…¥á†¯á„’á…¡á†¨\",\"á„Žá…¥á†ºá„‚á…¡á†¯\",\"á„Žá…¥á†ºá„á…¢\",\"á„Žá…¥á†¼á„‚á…§á†«\",\"á„Žá…¥á†¼á„‡á…¡á„Œá…µ\",\"á„Žá…¥á†¼á„‰á…©\",\"á„Žá…¥á†¼á„Žá…®á†«\",\"á„Žá…¦á„€á…¨\",\"á„Žá…¦á„…á…§á†¨\",\"á„Žá…¦á„‹á…©á†«\",\"á„Žá…¦á„‹á…²á†¨\",\"á„Žá…¦á„Œá…®á†¼\",\"á„Žá…¦á„’á…¥á†·\",\"á„Žá…©á„ƒá…³á†¼á„’á…¡á†¨á„‰á…¢á†¼\",\"á„Žá…©á„‡á…¡á†«\",\"á„Žá…©á„‡á…¡á†¸\",\"á„Žá…©á„‰á…¡á†¼á„’á…ª\",\"á„Žá…©á„‰á…®á†«\",\"á„Žá…©á„‹á…§á„…á…³á†·\",\"á„Žá…©á„‹á…¯á†«\",\"á„Žá…©á„Œá…¥á„‚á…§á†¨\",\"á„Žá…©á„Œá…¥á†·\",\"á„Žá…©á„Žá…¥á†¼\",\"á„Žá…©á„á…©á†¯á„…á…µá†º\",\"á„Žá…©á†ºá„‡á…®á†¯\",\"á„Žá…©á†¼á„€á…¡á†¨\",\"á„Žá…©á†¼á„…á…µ\",\"á„Žá…©á†¼á„Œá…¡á†¼\",\"á„Žá…ªá†¯á„‹á…§á†¼\",\"á„Žá…¬á„€á…³á†«\",\"á„Žá…¬á„‰á…¡á†¼\",\"á„Žá…¬á„‰á…¥á†«\",\"á„Žá…¬á„‰á…µá†«\",\"á„Žá…¬á„‹á…¡á†¨\",\"á„Žá…¬á„Œá…©á†¼\",\"á„Žá…®á„‰á…¥á†¨\",\"á„Žá…®á„‹á…¥á†¨\",\"á„Žá…®á„Œá…µá†«\",\"á„Žá…®á„Žá…¥á†«\",\"á„Žá…®á„Žá…³á†¨\",\"á„Žá…®á†¨á„€á…®\",\"á„Žá…®á†¨á„‰á…©\",\"á„Žá…®á†¨á„Œá…¦\",\"á„Žá…®á†¨á„’á…¡\",\"á„Žá…®á†¯á„€á…³á†«\",\"á„Žá…®á†¯á„‡á…¡á†¯\",\"á„Žá…®á†¯á„‰á…¡á†«\",\"á„Žá…®á†¯á„‰á…µá†«\",\"á„Žá…®á†¯á„‹á…§á†«\",\"á„Žá…®á†¯á„‹á…µá†¸\",\"á„Žá…®á†¯á„Œá…¡á†¼\",\"á„Žá…®á†¯á„‘á…¡á†«\",\"á„Žá…®á†¼á„€á…§á†¨\",\"á„Žá…®á†¼á„€á…©\",\"á„Žá…®á†¼á„ƒá…©á†¯\",\"á„Žá…®á†¼á„‡á…®á†«á„’á…µ\",\"á„Žá…®á†¼á„Žá…¥á†¼á„ƒá…©\",\"á„Žá…±á„‹á…¥á†¸\",\"á„Žá…±á„Œá…µá†¨\",\"á„Žá…±á„’á…£á†¼\",\"á„Žá…µá„‹á…£á†¨\",\"á„Žá…µá†«á„€á…®\",\"á„Žá…µá†«á„Žá…¥á†¨\",\"á„Žá…µá†¯á„‰á…µá†¸\",\"á„Žá…µá†¯á„‹á…¯á†¯\",\"á„Žá…µá†¯á„‘á…¡á†«\",\"á„Žá…µá†·á„ƒá…¢\",\"á„Žá…µá†·á„†á…®á†¨\",\"á„Žá…µá†·á„‰á…µá†¯\",\"á„Žá…µá†ºá„‰á…©á†¯\",\"á„Žá…µá†¼á„Žá…¡á†«\",\"á„á…¡á„†á…¦á„…á…¡\",\"á„á…¡á„‹á…®á†«á„á…¥\",\"á„á…¡á†¯á„€á…®á†¨á„‰á…®\",\"á„á…¢á„…á…µá†¨á„á…¥\",\"á„á…¢á†·á„‘á…¥á„‰á…³\",\"á„á…¢á†·á„‘á…¦á„‹á…µá†«\",\"á„á…¥á„á…³á†«\",\"á„á…¥á†«á„ƒá…µá„‰á…§á†«\",\"á„á…¥á†¯á„…á…¥\",\"á„á…¥á†·á„‘á…²á„á…¥\",\"á„á…©á„á…µá„…á…µ\",\"á„á…©á„†á…µá„ƒá…µ\",\"á„á…©á†«á„‰á…¥á„á…³\",\"á„á…©á†¯á„…á…¡\",\"á„á…©á†·á„‘á…³á†¯á„…á…¦á†¨á„‰á…³\",\"á„á…©á†¼á„‚á…¡á„†á…®á†¯\",\"á„á…«á„€á…¡á†·\",\"á„á…®á„ƒá…¦á„á…¡\",\"á„á…³á„…á…µá†·\",\"á„á…³á†«á„€á…µá†¯\",\"á„á…³á†«á„„á…¡á†¯\",\"á„á…³á†«á„‰á…©á„…á…µ\",\"á„á…³á†«á„‹á…¡á„ƒá…³á†¯\",\"á„á…³á†«á„‹á…¥á„†á…¥á„‚á…µ\",\"á„á…³á†«á„‹á…µá†¯\",\"á„á…³á†«á„Œá…¥á†¯\",\"á„á…³á†¯á„…á…¢á„‰á…µá†¨\",\"á„á…³á†¯á„…á…¥á†¸\",\"á„á…µá†¯á„…á…©\",\"á„á…¡á„‹á…µá†¸\",\"á„á…¡á„Œá…¡á„€á…µ\",\"á„á…¡á†¨á„€á…®\",\"á„á…¡á†¨á„Œá…¡\",\"á„á…¡á†«á„‰á…¢á†¼\",\"á„á…¢á„€á…¯á†«á„ƒá…©\",\"á„á…¢á„‹á…£á†¼\",\"á„á…¢á„‘á…®á†¼\",\"á„á…¢á†¨á„‰á…µ\",\"á„á…¢á†¯á„…á…¥á†«á„á…³\",\"á„á…¥á„‚á…¥á†¯\",\"á„á…¥á„†á…µá„‚á…¥á†¯\",\"á„á…¦á„‚á…µá„‰á…³\",\"á„á…¦á„‰á…³á„á…³\",\"á„á…¦á„‹á…µá„‡á…³á†¯\",\"á„á…¦á†¯á„…á…¦á„‡á…µá„Œá…¥á†«\",\"á„á…©á„…á…©á†«\",\"á„á…©á„†á…¡á„á…©\",\"á„á…©á„‹á…­á„‹á…µá†¯\",\"á„á…©á†¼á„€á…¨\",\"á„á…©á†¼á„€á…ª\",\"á„á…©á†¼á„…á…©\",\"á„á…©á†¼á„‰á…µá†«\",\"á„á…©á†¼á„‹á…§á†¨\",\"á„á…©á†¼á„‹á…µá†¯\",\"á„á…©á†¼á„Œá…¡á†¼\",\"á„á…©á†¼á„Œá…¦\",\"á„á…©á†¼á„Œá…³á†¼\",\"á„á…©á†¼á„’á…¡á†¸\",\"á„á…©á†¼á„’á…ª\",\"á„á…¬á„€á…³á†«\",\"á„á…¬á„‹á…¯á†«\",\"á„á…¬á„Œá…µá†¨á„€á…³á†·\",\"á„á…±á„€á…µá†·\",\"á„á…³á„…á…¥á†¨\",\"á„á…³á†¨á„€á…³á†¸\",\"á„á…³á†¨á„‡á…§á†¯\",\"á„á…³á†¨á„‰á…¥á†¼\",\"á„á…³á†¨á„‰á…®\",\"á„á…³á†¨á„Œá…µá†¼\",\"á„á…³á†¨á„’á…µ\",\"á„á…³á†«á„á…³á†«á„’á…µ\",\"á„á…µá„‰á…§á„Žá…³\",\"á„‘á…¡á„…á…¡á†«á„‰á…¢á†¨\",\"á„‘á…¡á„‹á…µá†¯\",\"á„‘á…¡á„Žá…®á†¯á„‰á…©\",\"á„‘á…¡á†«á„€á…§á†¯\",\"á„‘á…¡á†«á„ƒá…¡á†«\",\"á„‘á…¡á†«á„†á…¢\",\"á„‘á…¡á†«á„‰á…¡\",\"á„‘á…¡á†¯á„‰á…µá†¸\",\"á„‘á…¡á†¯á„‹á…¯á†¯\",\"á„‘á…¡á†¸á„‰á…©á†¼\",\"á„‘á…¢á„‰á…§á†«\",\"á„‘á…¢á†¨á„‰á…³\",\"á„‘á…¢á†¨á„‰á…µá„†á…µá†¯á„…á…µ\",\"á„‘á…¢á†«á„á…µ\",\"á„‘á…¥á„‰á…¦á†«á„á…³\",\"á„‘á…¦á„‹á…µá†«á„á…³\",\"á„‘á…§á†«á„€á…§á†«\",\"á„‘á…§á†«á„‹á…´\",\"á„‘á…§á†«á„Œá…µ\",\"á„‘á…§á†«á„’á…µ\",\"á„‘á…§á†¼á„€á…¡\",\"á„‘á…§á†¼á„€á…²á†«\",\"á„‘á…§á†¼á„‰á…¢á†¼\",\"á„‘á…§á†¼á„‰á…©\",\"á„‘á…§á†¼á„‹á…£á†¼\",\"á„‘á…§á†¼á„‹á…µá†¯\",\"á„‘á…§á†¼á„’á…ª\",\"á„‘á…©á„‰á…³á„á…¥\",\"á„‘á…©á„‹á…µá†«á„á…³\",\"á„‘á…©á„Œá…¡á†¼\",\"á„‘á…©á„’á…¡á†·\",\"á„‘á…­á„†á…§á†«\",\"á„‘á…­á„Œá…¥á†¼\",\"á„‘á…­á„Œá…®á†«\",\"á„‘á…­á„’á…§á†«\",\"á„‘á…®á†·á„†á…©á†¨\",\"á„‘á…®á†·á„Œá…µá†¯\",\"á„‘á…®á†¼á„€á…§á†¼\",\"á„‘á…®á†¼á„‰á…©á†¨\",\"á„‘á…®á†¼á„‰á…³á†¸\",\"á„‘á…³á„…á…¡á†¼á„‰á…³\",\"á„‘á…³á„…á…µá†«á„á…¥\",\"á„‘á…³á†¯á„…á…¡á„‰á…³á„á…µá†¨\",\"á„‘á…µá„€á…©á†«\",\"á„‘á…µá„†á…¡á†¼\",\"á„‘á…µá„‹á…¡á„‚á…©\",\"á„‘á…µá†¯á„…á…³á†·\",\"á„‘á…µá†¯á„‰á…®\",\"á„‘á…µá†¯á„‹á…­\",\"á„‘á…µá†¯á„Œá…¡\",\"á„‘á…µá†¯á„á…©á†¼\",\"á„‘á…µá†¼á„€á…¨\",\"á„’á…¡á„‚á…³á„‚á…µá†·\",\"á„’á…¡á„‚á…³á†¯\",\"á„’á…¡á„ƒá…³á„‹á…°á„‹á…¥\",\"á„’á…¡á„…á…®á†ºá„‡á…¡á†·\",\"á„’á…¡á„‡á…¡á†«á„€á…µ\",\"á„’á…¡á„‰á…®á†¨á„Œá…µá†¸\",\"á„’á…¡á„‰á…®á†«\",\"á„’á…¡á„‹á…§á„á…³á†«\",\"á„’á…¡á„Œá…µá„†á…¡á†«\",\"á„’á…¡á„Žá…¥á†«\",\"á„’á…¡á„‘á…®á†·\",\"á„’á…¡á„‘á…µá†¯\",\"á„’á…¡á†¨á„€á…ª\",\"á„’á…¡á†¨á„€á…­\",\"á„’á…¡á†¨á„€á…³á†¸\",\"á„’á…¡á†¨á„€á…µ\",\"á„’á…¡á†¨á„‚á…§á†«\",\"á„’á…¡á†¨á„…á…§á†¨\",\"á„’á…¡á†¨á„‡á…¥á†«\",\"á„’á…¡á†¨á„‡á…®á„†á…©\",\"á„’á…¡á†¨á„‡á…µ\",\"á„’á…¡á†¨á„‰á…¢á†¼\",\"á„’á…¡á†¨á„‰á…®á†¯\",\"á„’á…¡á†¨á„‰á…³á†¸\",\"á„’á…¡á†¨á„‹á…­á†¼á„‘á…®á†·\",\"á„’á…¡á†¨á„‹á…¯á†«\",\"á„’á…¡á†¨á„‹á…±\",\"á„’á…¡á†¨á„Œá…¡\",\"á„’á…¡á†¨á„Œá…¥á†·\",\"á„’á…¡á†«á„€á…¨\",\"á„’á…¡á†«á„€á…³á†¯\",\"á„’á…¡á†«á„á…¥á„‡á…¥á†«á„‹á…¦\",\"á„’á…¡á†«á„‚á…¡á†½\",\"á„’á…¡á†«á„‚á…®á†«\",\"á„’á…¡á†«á„ƒá…©á†¼á„‹á…¡á†«\",\"á„’á…¡á†«á„„á…¢\",\"á„’á…¡á†«á„…á…¡á„‰á…¡á†«\",\"á„’á…¡á†«á„†á…¡á„ƒá…µ\",\"á„’á…¡á†«á„†á…®á†«\",\"á„’á…¡á†«á„‡á…¥á†«\",\"á„’á…¡á†«á„‡á…©á†¨\",\"á„’á…¡á†«á„‰á…µá†¨\",\"á„’á…¡á†«á„‹á…§á„…á…³á†·\",\"á„’á…¡á†«á„á…©á†¨\",\"á„’á…¡á†¯á„†á…¥á„‚á…µ\",\"á„’á…¡á†¯á„‹á…¡á„‡á…¥á„Œá…µ\",\"á„’á…¡á†¯á„‹á…µá†«\",\"á„’á…¡á†·á„á…¦\",\"á„’á…¡á†·á„‡á…®á„…á…©\",\"á„’á…¡á†¸á„€á…§á†¨\",\"á„’á…¡á†¸á„…á…µá„Œá…¥á†¨\",\"á„’á…¡á†¼á„€á…©á†¼\",\"á„’á…¡á†¼á„€á…®\",\"á„’á…¡á†¼á„‰á…¡á†¼\",\"á„’á…¡á†¼á„‹á…´\",\"á„’á…¢á„€á…§á†¯\",\"á„’á…¢á„€á…®á†«\",\"á„’á…¢á„ƒá…¡á†¸\",\"á„’á…¢á„ƒá…¡á†¼\",\"á„’á…¢á„†á…®á†¯\",\"á„’á…¢á„‰á…¥á†¨\",\"á„’á…¢á„‰á…¥á†¯\",\"á„’á…¢á„‰á…®á„‹á…­á†¨á„Œá…¡á†¼\",\"á„’á…¢á„‹á…¡á†«\",\"á„’á…¢á†¨á„‰á…µá†·\",\"á„’á…¢á†«á„ƒá…³á„‡á…¢á†¨\",\"á„’á…¢á†·á„‡á…¥á„€á…¥\",\"á„’á…¢á†ºá„‡á…§á‡€\",\"á„’á…¢á†ºá„‰á…¡á†¯\",\"á„’á…¢á†¼á„ƒá…©á†¼\",\"á„’á…¢á†¼á„‡á…©á†¨\",\"á„’á…¢á†¼á„‰á…¡\",\"á„’á…¢á†¼á„‹á…®á†«\",\"á„’á…¢á†¼á„‹á…±\",\"á„’á…£á†¼á„€á…µ\",\"á„’á…£á†¼á„‰á…¡á†¼\",\"á„’á…£á†¼á„‰á…®\",\"á„’á…¥á„…á…¡á†¨\",\"á„’á…¥á„‹á…­á†¼\",\"á„’á…¦á†¯á„€á…µ\",\"á„’á…§á†«á„€á…ªá†«\",\"á„’á…§á†«á„€á…³á†·\",\"á„’á…§á†«á„ƒá…¢\",\"á„’á…§á†«á„‰á…¡á†¼\",\"á„’á…§á†«á„‰á…µá†¯\",\"á„’á…§á†«á„Œá…¡á†¼\",\"á„’á…§á†«á„Œá…¢\",\"á„’á…§á†«á„Œá…µ\",\"á„’á…§á†¯á„‹á…¢á†¨\",\"á„’á…§á†¸á„…á…§á†¨\",\"á„’á…§á†¼á„‡á…®\",\"á„’á…§á†¼á„‰á…¡\",\"á„’á…§á†¼á„‰á…®\",\"á„’á…§á†¼á„‰á…µá†¨\",\"á„’á…§á†¼á„Œá…¦\",\"á„’á…§á†¼á„á…¢\",\"á„’á…§á†¼á„‘á…§á†«\",\"á„’á…¨á„á…¢á†¨\",\"á„’á…©á„€á…µá„‰á…µá†·\",\"á„’á…©á„‚á…¡á†·\",\"á„’á…©á„…á…¡á†¼á„‹á…µ\",\"á„’á…©á„‡á…¡á†¨\",\"á„’á…©á„á…¦á†¯\",\"á„’á…©á„’á…³á†¸\",\"á„’á…©á†¨á„‰á…µ\",\"á„’á…©á†¯á„…á…©\",\"á„’á…©á†·á„‘á…¦á„‹á…µá„Œá…µ\",\"á„’á…©á†¼á„‡á…©\",\"á„’á…©á†¼á„‰á…®\",\"á„’á…©á†¼á„Žá…¡\",\"á„’á…ªá„†á…§á†«\",\"á„’á…ªá„‡á…®á†«\",\"á„’á…ªá„‰á…¡á†¯\",\"á„’á…ªá„‹á…­á„‹á…µá†¯\",\"á„’á…ªá„Œá…¡á†¼\",\"á„’á…ªá„’á…¡á†¨\",\"á„’á…ªá†¨á„‡á…©\",\"á„’á…ªá†¨á„‹á…µá†«\",\"á„’á…ªá†¨á„Œá…¡á†¼\",\"á„’á…ªá†¨á„Œá…¥á†¼\",\"á„’á…ªá†«á„€á…¡á†¸\",\"á„’á…ªá†«á„€á…§á†¼\",\"á„’á…ªá†«á„‹á…§á†¼\",\"á„’á…ªá†«á„‹á…²á†¯\",\"á„’á…ªá†«á„Œá…¡\",\"á„’á…ªá†¯á„€á…µ\",\"á„’á…ªá†¯á„ƒá…©á†¼\",\"á„’á…ªá†¯á„‡á…¡á†¯á„’á…µ\",\"á„’á…ªá†¯á„‹á…­á†¼\",\"á„’á…ªá†¯á„á…¡á†¨\",\"á„’á…¬á„€á…§á†«\",\"á„’á…¬á„€á…ªá†«\",\"á„’á…¬á„‡á…©á†¨\",\"á„’á…¬á„‰á…¢á†¨\",\"á„’á…¬á„‹á…¯á†«\",\"á„’á…¬á„Œá…¡á†¼\",\"á„’á…¬á„Œá…¥á†«\",\"á„’á…¬á†ºá„‰á…®\",\"á„’á…¬á†¼á„ƒá…¡á†«á„‡á…©á„ƒá…©\",\"á„’á…­á„‹á…²á†¯á„Œá…¥á†¨\",\"á„’á…®á„‡á…¡á†«\",\"á„’á…®á„Žá…®á†ºá„€á…¡á„…á…®\",\"á„’á…®á†«á„…á…§á†«\",\"á„’á…¯á†¯á„Šá…µá†«\",\"á„’á…²á„‰á…µá†¨\",\"á„’á…²á„‹á…µá†¯\",\"á„’á…²á†¼á„‚á…¢\",\"á„’á…³á„…á…³á†·\",\"á„’á…³á†¨á„‡á…¢á†¨\",\"á„’á…³á†¨á„‹á…µá†«\",\"á„’á…³á†«á„Œá…¥á†¨\",\"á„’á…³á†«á„’á…µ\",\"á„’á…³á†¼á„†á…µ\",\"á„’á…³á†¼á„‡á…®á†«\",\"á„’á…´á„€á…©á†¨\",\"á„’á…´á„†á…¡á†¼\",\"á„’á…´á„‰á…¢á†¼\",\"á„’á…´á†«á„‰á…¢á†¨\",\"á„’á…µá†·á„á…¥á†º\"]");

const require$$4 = /* #__PURE__ */ JSON.parse("[\"abaisser\",\"abandon\",\"abdiquer\",\"abeille\",\"abolir\",\"aborder\",\"aboutir\",\"aboyer\",\"abrasif\",\"abreuver\",\"abriter\",\"abroger\",\"abrupt\",\"absence\",\"absolu\",\"absurde\",\"abusif\",\"abyssal\",\"acadeÌmie\",\"acajou\",\"acarien\",\"accabler\",\"accepter\",\"acclamer\",\"accolade\",\"accroche\",\"accuser\",\"acerbe\",\"achat\",\"acheter\",\"aciduler\",\"acier\",\"acompte\",\"acqueÌrir\",\"acronyme\",\"acteur\",\"actif\",\"actuel\",\"adepte\",\"adeÌquat\",\"adheÌsif\",\"adjectif\",\"adjuger\",\"admettre\",\"admirer\",\"adopter\",\"adorer\",\"adoucir\",\"adresse\",\"adroit\",\"adulte\",\"adverbe\",\"aeÌrer\",\"aeÌronef\",\"affaire\",\"affecter\",\"affiche\",\"affreux\",\"affubler\",\"agacer\",\"agencer\",\"agile\",\"agiter\",\"agrafer\",\"agreÌable\",\"agrume\",\"aider\",\"aiguille\",\"ailier\",\"aimable\",\"aisance\",\"ajouter\",\"ajuster\",\"alarmer\",\"alchimie\",\"alerte\",\"algeÌ€bre\",\"algue\",\"alieÌner\",\"aliment\",\"alleÌger\",\"alliage\",\"allouer\",\"allumer\",\"alourdir\",\"alpaga\",\"altesse\",\"alveÌole\",\"amateur\",\"ambigu\",\"ambre\",\"ameÌnager\",\"amertume\",\"amidon\",\"amiral\",\"amorcer\",\"amour\",\"amovible\",\"amphibie\",\"ampleur\",\"amusant\",\"analyse\",\"anaphore\",\"anarchie\",\"anatomie\",\"ancien\",\"aneÌantir\",\"angle\",\"angoisse\",\"anguleux\",\"animal\",\"annexer\",\"annonce\",\"annuel\",\"anodin\",\"anomalie\",\"anonyme\",\"anormal\",\"antenne\",\"antidote\",\"anxieux\",\"apaiser\",\"apeÌritif\",\"aplanir\",\"apologie\",\"appareil\",\"appeler\",\"apporter\",\"appuyer\",\"aquarium\",\"aqueduc\",\"arbitre\",\"arbuste\",\"ardeur\",\"ardoise\",\"argent\",\"arlequin\",\"armature\",\"armement\",\"armoire\",\"armure\",\"arpenter\",\"arracher\",\"arriver\",\"arroser\",\"arsenic\",\"arteÌriel\",\"article\",\"aspect\",\"asphalte\",\"aspirer\",\"assaut\",\"asservir\",\"assiette\",\"associer\",\"assurer\",\"asticot\",\"astre\",\"astuce\",\"atelier\",\"atome\",\"atrium\",\"atroce\",\"attaque\",\"attentif\",\"attirer\",\"attraper\",\"aubaine\",\"auberge\",\"audace\",\"audible\",\"augurer\",\"aurore\",\"automne\",\"autruche\",\"avaler\",\"avancer\",\"avarice\",\"avenir\",\"averse\",\"aveugle\",\"aviateur\",\"avide\",\"avion\",\"aviser\",\"avoine\",\"avouer\",\"avril\",\"axial\",\"axiome\",\"badge\",\"bafouer\",\"bagage\",\"baguette\",\"baignade\",\"balancer\",\"balcon\",\"baleine\",\"balisage\",\"bambin\",\"bancaire\",\"bandage\",\"banlieue\",\"bannieÌ€re\",\"banquier\",\"barbier\",\"baril\",\"baron\",\"barque\",\"barrage\",\"bassin\",\"bastion\",\"bataille\",\"bateau\",\"batterie\",\"baudrier\",\"bavarder\",\"belette\",\"beÌlier\",\"belote\",\"beÌneÌfice\",\"berceau\",\"berger\",\"berline\",\"bermuda\",\"besace\",\"besogne\",\"beÌtail\",\"beurre\",\"biberon\",\"bicycle\",\"bidule\",\"bijou\",\"bilan\",\"bilingue\",\"billard\",\"binaire\",\"biologie\",\"biopsie\",\"biotype\",\"biscuit\",\"bison\",\"bistouri\",\"bitume\",\"bizarre\",\"blafard\",\"blague\",\"blanchir\",\"blessant\",\"blinder\",\"blond\",\"bloquer\",\"blouson\",\"bobard\",\"bobine\",\"boire\",\"boiser\",\"bolide\",\"bonbon\",\"bondir\",\"bonheur\",\"bonifier\",\"bonus\",\"bordure\",\"borne\",\"botte\",\"boucle\",\"boueux\",\"bougie\",\"boulon\",\"bouquin\",\"bourse\",\"boussole\",\"boutique\",\"boxeur\",\"branche\",\"brasier\",\"brave\",\"brebis\",\"breÌ€che\",\"breuvage\",\"bricoler\",\"brigade\",\"brillant\",\"brioche\",\"brique\",\"brochure\",\"broder\",\"bronzer\",\"brousse\",\"broyeur\",\"brume\",\"brusque\",\"brutal\",\"bruyant\",\"buffle\",\"buisson\",\"bulletin\",\"bureau\",\"burin\",\"bustier\",\"butiner\",\"butoir\",\"buvable\",\"buvette\",\"cabanon\",\"cabine\",\"cachette\",\"cadeau\",\"cadre\",\"cafeÌine\",\"caillou\",\"caisson\",\"calculer\",\"calepin\",\"calibre\",\"calmer\",\"calomnie\",\"calvaire\",\"camarade\",\"cameÌra\",\"camion\",\"campagne\",\"canal\",\"caneton\",\"canon\",\"cantine\",\"canular\",\"capable\",\"caporal\",\"caprice\",\"capsule\",\"capter\",\"capuche\",\"carabine\",\"carbone\",\"caresser\",\"caribou\",\"carnage\",\"carotte\",\"carreau\",\"carton\",\"cascade\",\"casier\",\"casque\",\"cassure\",\"causer\",\"caution\",\"cavalier\",\"caverne\",\"caviar\",\"ceÌdille\",\"ceinture\",\"ceÌleste\",\"cellule\",\"cendrier\",\"censurer\",\"central\",\"cercle\",\"ceÌreÌbral\",\"cerise\",\"cerner\",\"cerveau\",\"cesser\",\"chagrin\",\"chaise\",\"chaleur\",\"chambre\",\"chance\",\"chapitre\",\"charbon\",\"chasseur\",\"chaton\",\"chausson\",\"chavirer\",\"chemise\",\"chenille\",\"cheÌquier\",\"chercher\",\"cheval\",\"chien\",\"chiffre\",\"chignon\",\"chimeÌ€re\",\"chiot\",\"chlorure\",\"chocolat\",\"choisir\",\"chose\",\"chouette\",\"chrome\",\"chute\",\"cigare\",\"cigogne\",\"cimenter\",\"cineÌma\",\"cintrer\",\"circuler\",\"cirer\",\"cirque\",\"citerne\",\"citoyen\",\"citron\",\"civil\",\"clairon\",\"clameur\",\"claquer\",\"classe\",\"clavier\",\"client\",\"cligner\",\"climat\",\"clivage\",\"cloche\",\"clonage\",\"cloporte\",\"cobalt\",\"cobra\",\"cocasse\",\"cocotier\",\"coder\",\"codifier\",\"coffre\",\"cogner\",\"coheÌsion\",\"coiffer\",\"coincer\",\"coleÌ€re\",\"colibri\",\"colline\",\"colmater\",\"colonel\",\"combat\",\"comeÌdie\",\"commande\",\"compact\",\"concert\",\"conduire\",\"confier\",\"congeler\",\"connoter\",\"consonne\",\"contact\",\"convexe\",\"copain\",\"copie\",\"corail\",\"corbeau\",\"cordage\",\"corniche\",\"corpus\",\"correct\",\"corteÌ€ge\",\"cosmique\",\"costume\",\"coton\",\"coude\",\"coupure\",\"courage\",\"couteau\",\"couvrir\",\"coyote\",\"crabe\",\"crainte\",\"cravate\",\"crayon\",\"creÌature\",\"creÌditer\",\"creÌmeux\",\"creuser\",\"crevette\",\"cribler\",\"crier\",\"cristal\",\"criteÌ€re\",\"croire\",\"croquer\",\"crotale\",\"crucial\",\"cruel\",\"crypter\",\"cubique\",\"cueillir\",\"cuilleÌ€re\",\"cuisine\",\"cuivre\",\"culminer\",\"cultiver\",\"cumuler\",\"cupide\",\"curatif\",\"curseur\",\"cyanure\",\"cycle\",\"cylindre\",\"cynique\",\"daigner\",\"damier\",\"danger\",\"danseur\",\"dauphin\",\"deÌbattre\",\"deÌbiter\",\"deÌborder\",\"deÌbrider\",\"deÌbutant\",\"deÌcaler\",\"deÌcembre\",\"deÌchirer\",\"deÌcider\",\"deÌclarer\",\"deÌcorer\",\"deÌcrire\",\"deÌcupler\",\"deÌdale\",\"deÌductif\",\"deÌesse\",\"deÌfensif\",\"deÌfiler\",\"deÌfrayer\",\"deÌgager\",\"deÌgivrer\",\"deÌglutir\",\"deÌgrafer\",\"deÌjeuner\",\"deÌlice\",\"deÌloger\",\"demander\",\"demeurer\",\"deÌmolir\",\"deÌnicher\",\"deÌnouer\",\"dentelle\",\"deÌnuder\",\"deÌpart\",\"deÌpenser\",\"deÌphaser\",\"deÌplacer\",\"deÌposer\",\"deÌranger\",\"deÌrober\",\"deÌsastre\",\"descente\",\"deÌsert\",\"deÌsigner\",\"deÌsobeÌir\",\"dessiner\",\"destrier\",\"deÌtacher\",\"deÌtester\",\"deÌtourer\",\"deÌtresse\",\"devancer\",\"devenir\",\"deviner\",\"devoir\",\"diable\",\"dialogue\",\"diamant\",\"dicter\",\"diffeÌrer\",\"digeÌrer\",\"digital\",\"digne\",\"diluer\",\"dimanche\",\"diminuer\",\"dioxyde\",\"directif\",\"diriger\",\"discuter\",\"disposer\",\"dissiper\",\"distance\",\"divertir\",\"diviser\",\"docile\",\"docteur\",\"dogme\",\"doigt\",\"domaine\",\"domicile\",\"dompter\",\"donateur\",\"donjon\",\"donner\",\"dopamine\",\"dortoir\",\"dorure\",\"dosage\",\"doseur\",\"dossier\",\"dotation\",\"douanier\",\"double\",\"douceur\",\"douter\",\"doyen\",\"dragon\",\"draper\",\"dresser\",\"dribbler\",\"droiture\",\"duperie\",\"duplexe\",\"durable\",\"durcir\",\"dynastie\",\"eÌblouir\",\"eÌcarter\",\"eÌcharpe\",\"eÌchelle\",\"eÌclairer\",\"eÌclipse\",\"eÌclore\",\"eÌcluse\",\"eÌcole\",\"eÌconomie\",\"eÌcorce\",\"eÌcouter\",\"eÌcraser\",\"eÌcreÌmer\",\"eÌcrivain\",\"eÌcrou\",\"eÌcume\",\"eÌcureuil\",\"eÌdifier\",\"eÌduquer\",\"effacer\",\"effectif\",\"effigie\",\"effort\",\"effrayer\",\"effusion\",\"eÌgaliser\",\"eÌgarer\",\"eÌjecter\",\"eÌlaborer\",\"eÌlargir\",\"eÌlectron\",\"eÌleÌgant\",\"eÌleÌphant\",\"eÌleÌ€ve\",\"eÌligible\",\"eÌlitisme\",\"eÌloge\",\"eÌlucider\",\"eÌluder\",\"emballer\",\"embellir\",\"embryon\",\"eÌmeraude\",\"eÌmission\",\"emmener\",\"eÌmotion\",\"eÌmouvoir\",\"empereur\",\"employer\",\"emporter\",\"emprise\",\"eÌmulsion\",\"encadrer\",\"encheÌ€re\",\"enclave\",\"encoche\",\"endiguer\",\"endosser\",\"endroit\",\"enduire\",\"eÌnergie\",\"enfance\",\"enfermer\",\"enfouir\",\"engager\",\"engin\",\"englober\",\"eÌnigme\",\"enjamber\",\"enjeu\",\"enlever\",\"ennemi\",\"ennuyeux\",\"enrichir\",\"enrobage\",\"enseigne\",\"entasser\",\"entendre\",\"entier\",\"entourer\",\"entraver\",\"eÌnumeÌrer\",\"envahir\",\"enviable\",\"envoyer\",\"enzyme\",\"eÌolien\",\"eÌpaissir\",\"eÌpargne\",\"eÌpatant\",\"eÌpaule\",\"eÌpicerie\",\"eÌpideÌmie\",\"eÌpier\",\"eÌpilogue\",\"eÌpine\",\"eÌpisode\",\"eÌpitaphe\",\"eÌpoque\",\"eÌpreuve\",\"eÌprouver\",\"eÌpuisant\",\"eÌquerre\",\"eÌquipe\",\"eÌriger\",\"eÌrosion\",\"erreur\",\"eÌruption\",\"escalier\",\"espadon\",\"espeÌ€ce\",\"espieÌ€gle\",\"espoir\",\"esprit\",\"esquiver\",\"essayer\",\"essence\",\"essieu\",\"essorer\",\"estime\",\"estomac\",\"estrade\",\"eÌtageÌ€re\",\"eÌtaler\",\"eÌtanche\",\"eÌtatique\",\"eÌteindre\",\"eÌtendoir\",\"eÌternel\",\"eÌthanol\",\"eÌthique\",\"ethnie\",\"eÌtirer\",\"eÌtoffer\",\"eÌtoile\",\"eÌtonnant\",\"eÌtourdir\",\"eÌtrange\",\"eÌtroit\",\"eÌtude\",\"euphorie\",\"eÌvaluer\",\"eÌvasion\",\"eÌventail\",\"eÌvidence\",\"eÌviter\",\"eÌvolutif\",\"eÌvoquer\",\"exact\",\"exageÌrer\",\"exaucer\",\"exceller\",\"excitant\",\"exclusif\",\"excuse\",\"exeÌcuter\",\"exemple\",\"exercer\",\"exhaler\",\"exhorter\",\"exigence\",\"exiler\",\"exister\",\"exotique\",\"expeÌdier\",\"explorer\",\"exposer\",\"exprimer\",\"exquis\",\"extensif\",\"extraire\",\"exulter\",\"fable\",\"fabuleux\",\"facette\",\"facile\",\"facture\",\"faiblir\",\"falaise\",\"fameux\",\"famille\",\"farceur\",\"farfelu\",\"farine\",\"farouche\",\"fasciner\",\"fatal\",\"fatigue\",\"faucon\",\"fautif\",\"faveur\",\"favori\",\"feÌbrile\",\"feÌconder\",\"feÌdeÌrer\",\"feÌlin\",\"femme\",\"feÌmur\",\"fendoir\",\"feÌodal\",\"fermer\",\"feÌroce\",\"ferveur\",\"festival\",\"feuille\",\"feutre\",\"feÌvrier\",\"fiasco\",\"ficeler\",\"fictif\",\"fideÌ€le\",\"figure\",\"filature\",\"filetage\",\"filieÌ€re\",\"filleul\",\"filmer\",\"filou\",\"filtrer\",\"financer\",\"finir\",\"fiole\",\"firme\",\"fissure\",\"fixer\",\"flairer\",\"flamme\",\"flasque\",\"flatteur\",\"fleÌau\",\"fleÌ€che\",\"fleur\",\"flexion\",\"flocon\",\"flore\",\"fluctuer\",\"fluide\",\"fluvial\",\"folie\",\"fonderie\",\"fongible\",\"fontaine\",\"forcer\",\"forgeron\",\"formuler\",\"fortune\",\"fossile\",\"foudre\",\"fougeÌ€re\",\"fouiller\",\"foulure\",\"fourmi\",\"fragile\",\"fraise\",\"franchir\",\"frapper\",\"frayeur\",\"freÌgate\",\"freiner\",\"frelon\",\"freÌmir\",\"freÌneÌsie\",\"freÌ€re\",\"friable\",\"friction\",\"frisson\",\"frivole\",\"froid\",\"fromage\",\"frontal\",\"frotter\",\"fruit\",\"fugitif\",\"fuite\",\"fureur\",\"furieux\",\"furtif\",\"fusion\",\"futur\",\"gagner\",\"galaxie\",\"galerie\",\"gambader\",\"garantir\",\"gardien\",\"garnir\",\"garrigue\",\"gazelle\",\"gazon\",\"geÌant\",\"geÌlatine\",\"geÌlule\",\"gendarme\",\"geÌneÌral\",\"geÌnie\",\"genou\",\"gentil\",\"geÌologie\",\"geÌomeÌ€tre\",\"geÌranium\",\"germe\",\"gestuel\",\"geyser\",\"gibier\",\"gicler\",\"girafe\",\"givre\",\"glace\",\"glaive\",\"glisser\",\"globe\",\"gloire\",\"glorieux\",\"golfeur\",\"gomme\",\"gonfler\",\"gorge\",\"gorille\",\"goudron\",\"gouffre\",\"goulot\",\"goupille\",\"gourmand\",\"goutte\",\"graduel\",\"graffiti\",\"graine\",\"grand\",\"grappin\",\"gratuit\",\"gravir\",\"grenat\",\"griffure\",\"griller\",\"grimper\",\"grogner\",\"gronder\",\"grotte\",\"groupe\",\"gruger\",\"grutier\",\"gruyeÌ€re\",\"gueÌpard\",\"guerrier\",\"guide\",\"guimauve\",\"guitare\",\"gustatif\",\"gymnaste\",\"gyrostat\",\"habitude\",\"hachoir\",\"halte\",\"hameau\",\"hangar\",\"hanneton\",\"haricot\",\"harmonie\",\"harpon\",\"hasard\",\"heÌlium\",\"heÌmatome\",\"herbe\",\"heÌrisson\",\"hermine\",\"heÌron\",\"heÌsiter\",\"heureux\",\"hiberner\",\"hibou\",\"hilarant\",\"histoire\",\"hiver\",\"homard\",\"hommage\",\"homogeÌ€ne\",\"honneur\",\"honorer\",\"honteux\",\"horde\",\"horizon\",\"horloge\",\"hormone\",\"horrible\",\"houleux\",\"housse\",\"hublot\",\"huileux\",\"humain\",\"humble\",\"humide\",\"humour\",\"hurler\",\"hydromel\",\"hygieÌ€ne\",\"hymne\",\"hypnose\",\"idylle\",\"ignorer\",\"iguane\",\"illicite\",\"illusion\",\"image\",\"imbiber\",\"imiter\",\"immense\",\"immobile\",\"immuable\",\"impact\",\"impeÌrial\",\"implorer\",\"imposer\",\"imprimer\",\"imputer\",\"incarner\",\"incendie\",\"incident\",\"incliner\",\"incolore\",\"indexer\",\"indice\",\"inductif\",\"ineÌdit\",\"ineptie\",\"inexact\",\"infini\",\"infliger\",\"informer\",\"infusion\",\"ingeÌrer\",\"inhaler\",\"inhiber\",\"injecter\",\"injure\",\"innocent\",\"inoculer\",\"inonder\",\"inscrire\",\"insecte\",\"insigne\",\"insolite\",\"inspirer\",\"instinct\",\"insulter\",\"intact\",\"intense\",\"intime\",\"intrigue\",\"intuitif\",\"inutile\",\"invasion\",\"inventer\",\"inviter\",\"invoquer\",\"ironique\",\"irradier\",\"irreÌel\",\"irriter\",\"isoler\",\"ivoire\",\"ivresse\",\"jaguar\",\"jaillir\",\"jambe\",\"janvier\",\"jardin\",\"jauger\",\"jaune\",\"javelot\",\"jetable\",\"jeton\",\"jeudi\",\"jeunesse\",\"joindre\",\"joncher\",\"jongler\",\"joueur\",\"jouissif\",\"journal\",\"jovial\",\"joyau\",\"joyeux\",\"jubiler\",\"jugement\",\"junior\",\"jupon\",\"juriste\",\"justice\",\"juteux\",\"juveÌnile\",\"kayak\",\"kimono\",\"kiosque\",\"label\",\"labial\",\"labourer\",\"laceÌrer\",\"lactose\",\"lagune\",\"laine\",\"laisser\",\"laitier\",\"lambeau\",\"lamelle\",\"lampe\",\"lanceur\",\"langage\",\"lanterne\",\"lapin\",\"largeur\",\"larme\",\"laurier\",\"lavabo\",\"lavoir\",\"lecture\",\"leÌgal\",\"leÌger\",\"leÌgume\",\"lessive\",\"lettre\",\"levier\",\"lexique\",\"leÌzard\",\"liasse\",\"libeÌrer\",\"libre\",\"licence\",\"licorne\",\"lieÌ€ge\",\"lieÌ€vre\",\"ligature\",\"ligoter\",\"ligue\",\"limer\",\"limite\",\"limonade\",\"limpide\",\"lineÌaire\",\"lingot\",\"lionceau\",\"liquide\",\"lisieÌ€re\",\"lister\",\"lithium\",\"litige\",\"littoral\",\"livreur\",\"logique\",\"lointain\",\"loisir\",\"lombric\",\"loterie\",\"louer\",\"lourd\",\"loutre\",\"louve\",\"loyal\",\"lubie\",\"lucide\",\"lucratif\",\"lueur\",\"lugubre\",\"luisant\",\"lumieÌ€re\",\"lunaire\",\"lundi\",\"luron\",\"lutter\",\"luxueux\",\"machine\",\"magasin\",\"magenta\",\"magique\",\"maigre\",\"maillon\",\"maintien\",\"mairie\",\"maison\",\"majorer\",\"malaxer\",\"maleÌfice\",\"malheur\",\"malice\",\"mallette\",\"mammouth\",\"mandater\",\"maniable\",\"manquant\",\"manteau\",\"manuel\",\"marathon\",\"marbre\",\"marchand\",\"mardi\",\"maritime\",\"marqueur\",\"marron\",\"marteler\",\"mascotte\",\"massif\",\"mateÌriel\",\"matieÌ€re\",\"matraque\",\"maudire\",\"maussade\",\"mauve\",\"maximal\",\"meÌchant\",\"meÌconnu\",\"meÌdaille\",\"meÌdecin\",\"meÌditer\",\"meÌduse\",\"meilleur\",\"meÌlange\",\"meÌlodie\",\"membre\",\"meÌmoire\",\"menacer\",\"mener\",\"menhir\",\"mensonge\",\"mentor\",\"mercredi\",\"meÌrite\",\"merle\",\"messager\",\"mesure\",\"meÌtal\",\"meÌteÌore\",\"meÌthode\",\"meÌtier\",\"meuble\",\"miauler\",\"microbe\",\"miette\",\"mignon\",\"migrer\",\"milieu\",\"million\",\"mimique\",\"mince\",\"mineÌral\",\"minimal\",\"minorer\",\"minute\",\"miracle\",\"miroiter\",\"missile\",\"mixte\",\"mobile\",\"moderne\",\"moelleux\",\"mondial\",\"moniteur\",\"monnaie\",\"monotone\",\"monstre\",\"montagne\",\"monument\",\"moqueur\",\"morceau\",\"morsure\",\"mortier\",\"moteur\",\"motif\",\"mouche\",\"moufle\",\"moulin\",\"mousson\",\"mouton\",\"mouvant\",\"multiple\",\"munition\",\"muraille\",\"mureÌ€ne\",\"murmure\",\"muscle\",\"museÌum\",\"musicien\",\"mutation\",\"muter\",\"mutuel\",\"myriade\",\"myrtille\",\"mysteÌ€re\",\"mythique\",\"nageur\",\"nappe\",\"narquois\",\"narrer\",\"natation\",\"nation\",\"nature\",\"naufrage\",\"nautique\",\"navire\",\"neÌbuleux\",\"nectar\",\"neÌfaste\",\"neÌgation\",\"neÌgliger\",\"neÌgocier\",\"neige\",\"nerveux\",\"nettoyer\",\"neurone\",\"neutron\",\"neveu\",\"niche\",\"nickel\",\"nitrate\",\"niveau\",\"noble\",\"nocif\",\"nocturne\",\"noirceur\",\"noisette\",\"nomade\",\"nombreux\",\"nommer\",\"normatif\",\"notable\",\"notifier\",\"notoire\",\"nourrir\",\"nouveau\",\"novateur\",\"novembre\",\"novice\",\"nuage\",\"nuancer\",\"nuire\",\"nuisible\",\"numeÌro\",\"nuptial\",\"nuque\",\"nutritif\",\"obeÌir\",\"objectif\",\"obliger\",\"obscur\",\"observer\",\"obstacle\",\"obtenir\",\"obturer\",\"occasion\",\"occuper\",\"oceÌan\",\"octobre\",\"octroyer\",\"octupler\",\"oculaire\",\"odeur\",\"odorant\",\"offenser\",\"officier\",\"offrir\",\"ogive\",\"oiseau\",\"oisillon\",\"olfactif\",\"olivier\",\"ombrage\",\"omettre\",\"onctueux\",\"onduler\",\"oneÌreux\",\"onirique\",\"opale\",\"opaque\",\"opeÌrer\",\"opinion\",\"opportun\",\"opprimer\",\"opter\",\"optique\",\"orageux\",\"orange\",\"orbite\",\"ordonner\",\"oreille\",\"organe\",\"orgueil\",\"orifice\",\"ornement\",\"orque\",\"ortie\",\"osciller\",\"osmose\",\"ossature\",\"otarie\",\"ouragan\",\"ourson\",\"outil\",\"outrager\",\"ouvrage\",\"ovation\",\"oxyde\",\"oxygeÌ€ne\",\"ozone\",\"paisible\",\"palace\",\"palmareÌ€s\",\"palourde\",\"palper\",\"panache\",\"panda\",\"pangolin\",\"paniquer\",\"panneau\",\"panorama\",\"pantalon\",\"papaye\",\"papier\",\"papoter\",\"papyrus\",\"paradoxe\",\"parcelle\",\"paresse\",\"parfumer\",\"parler\",\"parole\",\"parrain\",\"parsemer\",\"partager\",\"parure\",\"parvenir\",\"passion\",\"pasteÌ€que\",\"paternel\",\"patience\",\"patron\",\"pavillon\",\"pavoiser\",\"payer\",\"paysage\",\"peigne\",\"peintre\",\"pelage\",\"peÌlican\",\"pelle\",\"pelouse\",\"peluche\",\"pendule\",\"peÌneÌtrer\",\"peÌnible\",\"pensif\",\"peÌnurie\",\"peÌpite\",\"peÌplum\",\"perdrix\",\"perforer\",\"peÌriode\",\"permuter\",\"perplexe\",\"persil\",\"perte\",\"peser\",\"peÌtale\",\"petit\",\"peÌtrir\",\"peuple\",\"pharaon\",\"phobie\",\"phoque\",\"photon\",\"phrase\",\"physique\",\"piano\",\"pictural\",\"pieÌ€ce\",\"pierre\",\"pieuvre\",\"pilote\",\"pinceau\",\"pipette\",\"piquer\",\"pirogue\",\"piscine\",\"piston\",\"pivoter\",\"pixel\",\"pizza\",\"placard\",\"plafond\",\"plaisir\",\"planer\",\"plaque\",\"plastron\",\"plateau\",\"pleurer\",\"plexus\",\"pliage\",\"plomb\",\"plonger\",\"pluie\",\"plumage\",\"pochette\",\"poeÌsie\",\"poeÌ€te\",\"pointe\",\"poirier\",\"poisson\",\"poivre\",\"polaire\",\"policier\",\"pollen\",\"polygone\",\"pommade\",\"pompier\",\"ponctuel\",\"pondeÌrer\",\"poney\",\"portique\",\"position\",\"posseÌder\",\"posture\",\"potager\",\"poteau\",\"potion\",\"pouce\",\"poulain\",\"poumon\",\"pourpre\",\"poussin\",\"pouvoir\",\"prairie\",\"pratique\",\"preÌcieux\",\"preÌdire\",\"preÌfixe\",\"preÌlude\",\"preÌnom\",\"preÌsence\",\"preÌtexte\",\"preÌvoir\",\"primitif\",\"prince\",\"prison\",\"priver\",\"probleÌ€me\",\"proceÌder\",\"prodige\",\"profond\",\"progreÌ€s\",\"proie\",\"projeter\",\"prologue\",\"promener\",\"propre\",\"prospeÌ€re\",\"proteÌger\",\"prouesse\",\"proverbe\",\"prudence\",\"pruneau\",\"psychose\",\"public\",\"puceron\",\"puiser\",\"pulpe\",\"pulsar\",\"punaise\",\"punitif\",\"pupitre\",\"purifier\",\"puzzle\",\"pyramide\",\"quasar\",\"querelle\",\"question\",\"quieÌtude\",\"quitter\",\"quotient\",\"racine\",\"raconter\",\"radieux\",\"ragondin\",\"raideur\",\"raisin\",\"ralentir\",\"rallonge\",\"ramasser\",\"rapide\",\"rasage\",\"ratisser\",\"ravager\",\"ravin\",\"rayonner\",\"reÌactif\",\"reÌagir\",\"reÌaliser\",\"reÌanimer\",\"recevoir\",\"reÌciter\",\"reÌclamer\",\"reÌcolter\",\"recruter\",\"reculer\",\"recycler\",\"reÌdiger\",\"redouter\",\"refaire\",\"reÌflexe\",\"reÌformer\",\"refrain\",\"refuge\",\"reÌgalien\",\"reÌgion\",\"reÌglage\",\"reÌgulier\",\"reÌiteÌrer\",\"rejeter\",\"rejouer\",\"relatif\",\"relever\",\"relief\",\"remarque\",\"remeÌ€de\",\"remise\",\"remonter\",\"remplir\",\"remuer\",\"renard\",\"renfort\",\"renifler\",\"renoncer\",\"rentrer\",\"renvoi\",\"replier\",\"reporter\",\"reprise\",\"reptile\",\"requin\",\"reÌserve\",\"reÌsineux\",\"reÌsoudre\",\"respect\",\"rester\",\"reÌsultat\",\"reÌtablir\",\"retenir\",\"reÌticule\",\"retomber\",\"retracer\",\"reÌunion\",\"reÌussir\",\"revanche\",\"revivre\",\"reÌvolte\",\"reÌvulsif\",\"richesse\",\"rideau\",\"rieur\",\"rigide\",\"rigoler\",\"rincer\",\"riposter\",\"risible\",\"risque\",\"rituel\",\"rival\",\"rivieÌ€re\",\"rocheux\",\"romance\",\"rompre\",\"ronce\",\"rondin\",\"roseau\",\"rosier\",\"rotatif\",\"rotor\",\"rotule\",\"rouge\",\"rouille\",\"rouleau\",\"routine\",\"royaume\",\"ruban\",\"rubis\",\"ruche\",\"ruelle\",\"rugueux\",\"ruiner\",\"ruisseau\",\"ruser\",\"rustique\",\"rythme\",\"sabler\",\"saboter\",\"sabre\",\"sacoche\",\"safari\",\"sagesse\",\"saisir\",\"salade\",\"salive\",\"salon\",\"saluer\",\"samedi\",\"sanction\",\"sanglier\",\"sarcasme\",\"sardine\",\"saturer\",\"saugrenu\",\"saumon\",\"sauter\",\"sauvage\",\"savant\",\"savonner\",\"scalpel\",\"scandale\",\"sceÌleÌrat\",\"sceÌnario\",\"sceptre\",\"scheÌma\",\"science\",\"scinder\",\"score\",\"scrutin\",\"sculpter\",\"seÌance\",\"seÌcable\",\"seÌcher\",\"secouer\",\"seÌcreÌter\",\"seÌdatif\",\"seÌduire\",\"seigneur\",\"seÌjour\",\"seÌlectif\",\"semaine\",\"sembler\",\"semence\",\"seÌminal\",\"seÌnateur\",\"sensible\",\"sentence\",\"seÌparer\",\"seÌquence\",\"serein\",\"sergent\",\"seÌrieux\",\"serrure\",\"seÌrum\",\"service\",\"seÌsame\",\"seÌvir\",\"sevrage\",\"sextuple\",\"sideÌral\",\"sieÌ€cle\",\"sieÌger\",\"siffler\",\"sigle\",\"signal\",\"silence\",\"silicium\",\"simple\",\"sinceÌ€re\",\"sinistre\",\"siphon\",\"sirop\",\"sismique\",\"situer\",\"skier\",\"social\",\"socle\",\"sodium\",\"soigneux\",\"soldat\",\"soleil\",\"solitude\",\"soluble\",\"sombre\",\"sommeil\",\"somnoler\",\"sonde\",\"songeur\",\"sonnette\",\"sonore\",\"sorcier\",\"sortir\",\"sosie\",\"sottise\",\"soucieux\",\"soudure\",\"souffle\",\"soulever\",\"soupape\",\"source\",\"soutirer\",\"souvenir\",\"spacieux\",\"spatial\",\"speÌcial\",\"spheÌ€re\",\"spiral\",\"stable\",\"station\",\"sternum\",\"stimulus\",\"stipuler\",\"strict\",\"studieux\",\"stupeur\",\"styliste\",\"sublime\",\"substrat\",\"subtil\",\"subvenir\",\"succeÌ€s\",\"sucre\",\"suffixe\",\"suggeÌrer\",\"suiveur\",\"sulfate\",\"superbe\",\"supplier\",\"surface\",\"suricate\",\"surmener\",\"surprise\",\"sursaut\",\"survie\",\"suspect\",\"syllabe\",\"symbole\",\"symeÌtrie\",\"synapse\",\"syntaxe\",\"systeÌ€me\",\"tabac\",\"tablier\",\"tactile\",\"tailler\",\"talent\",\"talisman\",\"talonner\",\"tambour\",\"tamiser\",\"tangible\",\"tapis\",\"taquiner\",\"tarder\",\"tarif\",\"tartine\",\"tasse\",\"tatami\",\"tatouage\",\"taupe\",\"taureau\",\"taxer\",\"teÌmoin\",\"temporel\",\"tenaille\",\"tendre\",\"teneur\",\"tenir\",\"tension\",\"terminer\",\"terne\",\"terrible\",\"teÌtine\",\"texte\",\"theÌ€me\",\"theÌorie\",\"theÌrapie\",\"thorax\",\"tibia\",\"tieÌ€de\",\"timide\",\"tirelire\",\"tiroir\",\"tissu\",\"titane\",\"titre\",\"tituber\",\"toboggan\",\"toleÌrant\",\"tomate\",\"tonique\",\"tonneau\",\"toponyme\",\"torche\",\"tordre\",\"tornade\",\"torpille\",\"torrent\",\"torse\",\"tortue\",\"totem\",\"toucher\",\"tournage\",\"tousser\",\"toxine\",\"traction\",\"trafic\",\"tragique\",\"trahir\",\"train\",\"trancher\",\"travail\",\"treÌ€fle\",\"tremper\",\"treÌsor\",\"treuil\",\"triage\",\"tribunal\",\"tricoter\",\"trilogie\",\"triomphe\",\"tripler\",\"triturer\",\"trivial\",\"trombone\",\"tronc\",\"tropical\",\"troupeau\",\"tuile\",\"tulipe\",\"tumulte\",\"tunnel\",\"turbine\",\"tuteur\",\"tutoyer\",\"tuyau\",\"tympan\",\"typhon\",\"typique\",\"tyran\",\"ubuesque\",\"ultime\",\"ultrason\",\"unanime\",\"unifier\",\"union\",\"unique\",\"unitaire\",\"univers\",\"uranium\",\"urbain\",\"urticant\",\"usage\",\"usine\",\"usuel\",\"usure\",\"utile\",\"utopie\",\"vacarme\",\"vaccin\",\"vagabond\",\"vague\",\"vaillant\",\"vaincre\",\"vaisseau\",\"valable\",\"valise\",\"vallon\",\"valve\",\"vampire\",\"vanille\",\"vapeur\",\"varier\",\"vaseux\",\"vassal\",\"vaste\",\"vecteur\",\"vedette\",\"veÌgeÌtal\",\"veÌhicule\",\"veinard\",\"veÌloce\",\"vendredi\",\"veÌneÌrer\",\"venger\",\"venimeux\",\"ventouse\",\"verdure\",\"veÌrin\",\"vernir\",\"verrou\",\"verser\",\"vertu\",\"veston\",\"veÌteÌran\",\"veÌtuste\",\"vexant\",\"vexer\",\"viaduc\",\"viande\",\"victoire\",\"vidange\",\"videÌo\",\"vignette\",\"vigueur\",\"vilain\",\"village\",\"vinaigre\",\"violon\",\"vipeÌ€re\",\"virement\",\"virtuose\",\"virus\",\"visage\",\"viseur\",\"vision\",\"visqueux\",\"visuel\",\"vital\",\"vitesse\",\"viticole\",\"vitrine\",\"vivace\",\"vivipare\",\"vocation\",\"voguer\",\"voile\",\"voisin\",\"voiture\",\"volaille\",\"volcan\",\"voltiger\",\"volume\",\"vorace\",\"vortex\",\"voter\",\"vouloir\",\"voyage\",\"voyelle\",\"wagon\",\"xeÌnon\",\"yacht\",\"zeÌ€bre\",\"zeÌnith\",\"zeste\",\"zoologie\"]");

const require$$5 = /* #__PURE__ */ JSON.parse("[\"abaco\",\"abbaglio\",\"abbinato\",\"abete\",\"abisso\",\"abolire\",\"abrasivo\",\"abrogato\",\"accadere\",\"accenno\",\"accusato\",\"acetone\",\"achille\",\"acido\",\"acqua\",\"acre\",\"acrilico\",\"acrobata\",\"acuto\",\"adagio\",\"addebito\",\"addome\",\"adeguato\",\"aderire\",\"adipe\",\"adottare\",\"adulare\",\"affabile\",\"affetto\",\"affisso\",\"affranto\",\"aforisma\",\"afoso\",\"africano\",\"agave\",\"agente\",\"agevole\",\"aggancio\",\"agire\",\"agitare\",\"agonismo\",\"agricolo\",\"agrumeto\",\"aguzzo\",\"alabarda\",\"alato\",\"albatro\",\"alberato\",\"albo\",\"albume\",\"alce\",\"alcolico\",\"alettone\",\"alfa\",\"algebra\",\"aliante\",\"alibi\",\"alimento\",\"allagato\",\"allegro\",\"allievo\",\"allodola\",\"allusivo\",\"almeno\",\"alogeno\",\"alpaca\",\"alpestre\",\"altalena\",\"alterno\",\"alticcio\",\"altrove\",\"alunno\",\"alveolo\",\"alzare\",\"amalgama\",\"amanita\",\"amarena\",\"ambito\",\"ambrato\",\"ameba\",\"america\",\"ametista\",\"amico\",\"ammasso\",\"ammenda\",\"ammirare\",\"ammonito\",\"amore\",\"ampio\",\"ampliare\",\"amuleto\",\"anacardo\",\"anagrafe\",\"analista\",\"anarchia\",\"anatra\",\"anca\",\"ancella\",\"ancora\",\"andare\",\"andrea\",\"anello\",\"angelo\",\"angolare\",\"angusto\",\"anima\",\"annegare\",\"annidato\",\"anno\",\"annuncio\",\"anonimo\",\"anticipo\",\"anzi\",\"apatico\",\"apertura\",\"apode\",\"apparire\",\"appetito\",\"appoggio\",\"approdo\",\"appunto\",\"aprile\",\"arabica\",\"arachide\",\"aragosta\",\"araldica\",\"arancio\",\"aratura\",\"arazzo\",\"arbitro\",\"archivio\",\"ardito\",\"arenile\",\"argento\",\"argine\",\"arguto\",\"aria\",\"armonia\",\"arnese\",\"arredato\",\"arringa\",\"arrosto\",\"arsenico\",\"arso\",\"artefice\",\"arzillo\",\"asciutto\",\"ascolto\",\"asepsi\",\"asettico\",\"asfalto\",\"asino\",\"asola\",\"aspirato\",\"aspro\",\"assaggio\",\"asse\",\"assoluto\",\"assurdo\",\"asta\",\"astenuto\",\"astice\",\"astratto\",\"atavico\",\"ateismo\",\"atomico\",\"atono\",\"attesa\",\"attivare\",\"attorno\",\"attrito\",\"attuale\",\"ausilio\",\"austria\",\"autista\",\"autonomo\",\"autunno\",\"avanzato\",\"avere\",\"avvenire\",\"avviso\",\"avvolgere\",\"azione\",\"azoto\",\"azzimo\",\"azzurro\",\"babele\",\"baccano\",\"bacino\",\"baco\",\"badessa\",\"badilata\",\"bagnato\",\"baita\",\"balcone\",\"baldo\",\"balena\",\"ballata\",\"balzano\",\"bambino\",\"bandire\",\"baraonda\",\"barbaro\",\"barca\",\"baritono\",\"barlume\",\"barocco\",\"basilico\",\"basso\",\"batosta\",\"battuto\",\"baule\",\"bava\",\"bavosa\",\"becco\",\"beffa\",\"belgio\",\"belva\",\"benda\",\"benevole\",\"benigno\",\"benzina\",\"bere\",\"berlina\",\"beta\",\"bibita\",\"bici\",\"bidone\",\"bifido\",\"biga\",\"bilancia\",\"bimbo\",\"binocolo\",\"biologo\",\"bipede\",\"bipolare\",\"birbante\",\"birra\",\"biscotto\",\"bisesto\",\"bisnonno\",\"bisonte\",\"bisturi\",\"bizzarro\",\"blando\",\"blatta\",\"bollito\",\"bonifico\",\"bordo\",\"bosco\",\"botanico\",\"bottino\",\"bozzolo\",\"braccio\",\"bradipo\",\"brama\",\"branca\",\"bravura\",\"bretella\",\"brevetto\",\"brezza\",\"briglia\",\"brillante\",\"brindare\",\"broccolo\",\"brodo\",\"bronzina\",\"brullo\",\"bruno\",\"bubbone\",\"buca\",\"budino\",\"buffone\",\"buio\",\"bulbo\",\"buono\",\"burlone\",\"burrasca\",\"bussola\",\"busta\",\"cadetto\",\"caduco\",\"calamaro\",\"calcolo\",\"calesse\",\"calibro\",\"calmo\",\"caloria\",\"cambusa\",\"camerata\",\"camicia\",\"cammino\",\"camola\",\"campale\",\"canapa\",\"candela\",\"cane\",\"canino\",\"canotto\",\"cantina\",\"capace\",\"capello\",\"capitolo\",\"capogiro\",\"cappero\",\"capra\",\"capsula\",\"carapace\",\"carcassa\",\"cardo\",\"carisma\",\"carovana\",\"carretto\",\"cartolina\",\"casaccio\",\"cascata\",\"caserma\",\"caso\",\"cassone\",\"castello\",\"casuale\",\"catasta\",\"catena\",\"catrame\",\"cauto\",\"cavillo\",\"cedibile\",\"cedrata\",\"cefalo\",\"celebre\",\"cellulare\",\"cena\",\"cenone\",\"centesimo\",\"ceramica\",\"cercare\",\"certo\",\"cerume\",\"cervello\",\"cesoia\",\"cespo\",\"ceto\",\"chela\",\"chiaro\",\"chicca\",\"chiedere\",\"chimera\",\"china\",\"chirurgo\",\"chitarra\",\"ciao\",\"ciclismo\",\"cifrare\",\"cigno\",\"cilindro\",\"ciottolo\",\"circa\",\"cirrosi\",\"citrico\",\"cittadino\",\"ciuffo\",\"civetta\",\"civile\",\"classico\",\"clinica\",\"cloro\",\"cocco\",\"codardo\",\"codice\",\"coerente\",\"cognome\",\"collare\",\"colmato\",\"colore\",\"colposo\",\"coltivato\",\"colza\",\"coma\",\"cometa\",\"commando\",\"comodo\",\"computer\",\"comune\",\"conciso\",\"condurre\",\"conferma\",\"congelare\",\"coniuge\",\"connesso\",\"conoscere\",\"consumo\",\"continuo\",\"convegno\",\"coperto\",\"copione\",\"coppia\",\"copricapo\",\"corazza\",\"cordata\",\"coricato\",\"cornice\",\"corolla\",\"corpo\",\"corredo\",\"corsia\",\"cortese\",\"cosmico\",\"costante\",\"cottura\",\"covato\",\"cratere\",\"cravatta\",\"creato\",\"credere\",\"cremoso\",\"crescita\",\"creta\",\"criceto\",\"crinale\",\"crisi\",\"critico\",\"croce\",\"cronaca\",\"crostata\",\"cruciale\",\"crusca\",\"cucire\",\"cuculo\",\"cugino\",\"cullato\",\"cupola\",\"curatore\",\"cursore\",\"curvo\",\"cuscino\",\"custode\",\"dado\",\"daino\",\"dalmata\",\"damerino\",\"daniela\",\"dannoso\",\"danzare\",\"datato\",\"davanti\",\"davvero\",\"debutto\",\"decennio\",\"deciso\",\"declino\",\"decollo\",\"decreto\",\"dedicato\",\"definito\",\"deforme\",\"degno\",\"delegare\",\"delfino\",\"delirio\",\"delta\",\"demenza\",\"denotato\",\"dentro\",\"deposito\",\"derapata\",\"derivare\",\"deroga\",\"descritto\",\"deserto\",\"desiderio\",\"desumere\",\"detersivo\",\"devoto\",\"diametro\",\"dicembre\",\"diedro\",\"difeso\",\"diffuso\",\"digerire\",\"digitale\",\"diluvio\",\"dinamico\",\"dinnanzi\",\"dipinto\",\"diploma\",\"dipolo\",\"diradare\",\"dire\",\"dirotto\",\"dirupo\",\"disagio\",\"discreto\",\"disfare\",\"disgelo\",\"disposto\",\"distanza\",\"disumano\",\"dito\",\"divano\",\"divelto\",\"dividere\",\"divorato\",\"doblone\",\"docente\",\"doganale\",\"dogma\",\"dolce\",\"domato\",\"domenica\",\"dominare\",\"dondolo\",\"dono\",\"dormire\",\"dote\",\"dottore\",\"dovuto\",\"dozzina\",\"drago\",\"druido\",\"dubbio\",\"dubitare\",\"ducale\",\"duna\",\"duomo\",\"duplice\",\"duraturo\",\"ebano\",\"eccesso\",\"ecco\",\"eclissi\",\"economia\",\"edera\",\"edicola\",\"edile\",\"editoria\",\"educare\",\"egemonia\",\"egli\",\"egoismo\",\"egregio\",\"elaborato\",\"elargire\",\"elegante\",\"elencato\",\"eletto\",\"elevare\",\"elfico\",\"elica\",\"elmo\",\"elsa\",\"eluso\",\"emanato\",\"emblema\",\"emesso\",\"emiro\",\"emotivo\",\"emozione\",\"empirico\",\"emulo\",\"endemico\",\"enduro\",\"energia\",\"enfasi\",\"enoteca\",\"entrare\",\"enzima\",\"epatite\",\"epilogo\",\"episodio\",\"epocale\",\"eppure\",\"equatore\",\"erario\",\"erba\",\"erboso\",\"erede\",\"eremita\",\"erigere\",\"ermetico\",\"eroe\",\"erosivo\",\"errante\",\"esagono\",\"esame\",\"esanime\",\"esaudire\",\"esca\",\"esempio\",\"esercito\",\"esibito\",\"esigente\",\"esistere\",\"esito\",\"esofago\",\"esortato\",\"esoso\",\"espanso\",\"espresso\",\"essenza\",\"esso\",\"esteso\",\"estimare\",\"estonia\",\"estroso\",\"esultare\",\"etilico\",\"etnico\",\"etrusco\",\"etto\",\"euclideo\",\"europa\",\"evaso\",\"evidenza\",\"evitato\",\"evoluto\",\"evviva\",\"fabbrica\",\"faccenda\",\"fachiro\",\"falco\",\"famiglia\",\"fanale\",\"fanfara\",\"fango\",\"fantasma\",\"fare\",\"farfalla\",\"farinoso\",\"farmaco\",\"fascia\",\"fastoso\",\"fasullo\",\"faticare\",\"fato\",\"favoloso\",\"febbre\",\"fecola\",\"fede\",\"fegato\",\"felpa\",\"feltro\",\"femmina\",\"fendere\",\"fenomeno\",\"fermento\",\"ferro\",\"fertile\",\"fessura\",\"festivo\",\"fetta\",\"feudo\",\"fiaba\",\"fiducia\",\"fifa\",\"figurato\",\"filo\",\"finanza\",\"finestra\",\"finire\",\"fiore\",\"fiscale\",\"fisico\",\"fiume\",\"flacone\",\"flamenco\",\"flebo\",\"flemma\",\"florido\",\"fluente\",\"fluoro\",\"fobico\",\"focaccia\",\"focoso\",\"foderato\",\"foglio\",\"folata\",\"folclore\",\"folgore\",\"fondente\",\"fonetico\",\"fonia\",\"fontana\",\"forbito\",\"forchetta\",\"foresta\",\"formica\",\"fornaio\",\"foro\",\"fortezza\",\"forzare\",\"fosfato\",\"fosso\",\"fracasso\",\"frana\",\"frassino\",\"fratello\",\"freccetta\",\"frenata\",\"fresco\",\"frigo\",\"frollino\",\"fronde\",\"frugale\",\"frutta\",\"fucilata\",\"fucsia\",\"fuggente\",\"fulmine\",\"fulvo\",\"fumante\",\"fumetto\",\"fumoso\",\"fune\",\"funzione\",\"fuoco\",\"furbo\",\"furgone\",\"furore\",\"fuso\",\"futile\",\"gabbiano\",\"gaffe\",\"galateo\",\"gallina\",\"galoppo\",\"gambero\",\"gamma\",\"garanzia\",\"garbo\",\"garofano\",\"garzone\",\"gasdotto\",\"gasolio\",\"gastrico\",\"gatto\",\"gaudio\",\"gazebo\",\"gazzella\",\"geco\",\"gelatina\",\"gelso\",\"gemello\",\"gemmato\",\"gene\",\"genitore\",\"gennaio\",\"genotipo\",\"gergo\",\"ghepardo\",\"ghiaccio\",\"ghisa\",\"giallo\",\"gilda\",\"ginepro\",\"giocare\",\"gioiello\",\"giorno\",\"giove\",\"girato\",\"girone\",\"gittata\",\"giudizio\",\"giurato\",\"giusto\",\"globulo\",\"glutine\",\"gnomo\",\"gobba\",\"golf\",\"gomito\",\"gommone\",\"gonfio\",\"gonna\",\"governo\",\"gracile\",\"grado\",\"grafico\",\"grammo\",\"grande\",\"grattare\",\"gravoso\",\"grazia\",\"greca\",\"gregge\",\"grifone\",\"grigio\",\"grinza\",\"grotta\",\"gruppo\",\"guadagno\",\"guaio\",\"guanto\",\"guardare\",\"gufo\",\"guidare\",\"ibernato\",\"icona\",\"identico\",\"idillio\",\"idolo\",\"idra\",\"idrico\",\"idrogeno\",\"igiene\",\"ignaro\",\"ignorato\",\"ilare\",\"illeso\",\"illogico\",\"illudere\",\"imballo\",\"imbevuto\",\"imbocco\",\"imbuto\",\"immane\",\"immerso\",\"immolato\",\"impacco\",\"impeto\",\"impiego\",\"importo\",\"impronta\",\"inalare\",\"inarcare\",\"inattivo\",\"incanto\",\"incendio\",\"inchino\",\"incisivo\",\"incluso\",\"incontro\",\"incrocio\",\"incubo\",\"indagine\",\"india\",\"indole\",\"inedito\",\"infatti\",\"infilare\",\"inflitto\",\"ingaggio\",\"ingegno\",\"inglese\",\"ingordo\",\"ingrosso\",\"innesco\",\"inodore\",\"inoltrare\",\"inondato\",\"insano\",\"insetto\",\"insieme\",\"insonnia\",\"insulina\",\"intasato\",\"intero\",\"intonaco\",\"intuito\",\"inumidire\",\"invalido\",\"invece\",\"invito\",\"iperbole\",\"ipnotico\",\"ipotesi\",\"ippica\",\"iride\",\"irlanda\",\"ironico\",\"irrigato\",\"irrorare\",\"isolato\",\"isotopo\",\"isterico\",\"istituto\",\"istrice\",\"italia\",\"iterare\",\"labbro\",\"labirinto\",\"lacca\",\"lacerato\",\"lacrima\",\"lacuna\",\"laddove\",\"lago\",\"lampo\",\"lancetta\",\"lanterna\",\"lardoso\",\"larga\",\"laringe\",\"lastra\",\"latenza\",\"latino\",\"lattuga\",\"lavagna\",\"lavoro\",\"legale\",\"leggero\",\"lembo\",\"lentezza\",\"lenza\",\"leone\",\"lepre\",\"lesivo\",\"lessato\",\"lesto\",\"letterale\",\"leva\",\"levigato\",\"libero\",\"lido\",\"lievito\",\"lilla\",\"limatura\",\"limitare\",\"limpido\",\"lineare\",\"lingua\",\"liquido\",\"lira\",\"lirica\",\"lisca\",\"lite\",\"litigio\",\"livrea\",\"locanda\",\"lode\",\"logica\",\"lombare\",\"londra\",\"longevo\",\"loquace\",\"lorenzo\",\"loto\",\"lotteria\",\"luce\",\"lucidato\",\"lumaca\",\"luminoso\",\"lungo\",\"lupo\",\"luppolo\",\"lusinga\",\"lusso\",\"lutto\",\"macabro\",\"macchina\",\"macero\",\"macinato\",\"madama\",\"magico\",\"maglia\",\"magnete\",\"magro\",\"maiolica\",\"malafede\",\"malgrado\",\"malinteso\",\"malsano\",\"malto\",\"malumore\",\"mana\",\"mancia\",\"mandorla\",\"mangiare\",\"manifesto\",\"mannaro\",\"manovra\",\"mansarda\",\"mantide\",\"manubrio\",\"mappa\",\"maratona\",\"marcire\",\"maretta\",\"marmo\",\"marsupio\",\"maschera\",\"massaia\",\"mastino\",\"materasso\",\"matricola\",\"mattone\",\"maturo\",\"mazurca\",\"meandro\",\"meccanico\",\"mecenate\",\"medesimo\",\"meditare\",\"mega\",\"melassa\",\"melis\",\"melodia\",\"meninge\",\"meno\",\"mensola\",\"mercurio\",\"merenda\",\"merlo\",\"meschino\",\"mese\",\"messere\",\"mestolo\",\"metallo\",\"metodo\",\"mettere\",\"miagolare\",\"mica\",\"micelio\",\"michele\",\"microbo\",\"midollo\",\"miele\",\"migliore\",\"milano\",\"milite\",\"mimosa\",\"minerale\",\"mini\",\"minore\",\"mirino\",\"mirtillo\",\"miscela\",\"missiva\",\"misto\",\"misurare\",\"mitezza\",\"mitigare\",\"mitra\",\"mittente\",\"mnemonico\",\"modello\",\"modifica\",\"modulo\",\"mogano\",\"mogio\",\"mole\",\"molosso\",\"monastero\",\"monco\",\"mondina\",\"monetario\",\"monile\",\"monotono\",\"monsone\",\"montato\",\"monviso\",\"mora\",\"mordere\",\"morsicato\",\"mostro\",\"motivato\",\"motosega\",\"motto\",\"movenza\",\"movimento\",\"mozzo\",\"mucca\",\"mucosa\",\"muffa\",\"mughetto\",\"mugnaio\",\"mulatto\",\"mulinello\",\"multiplo\",\"mummia\",\"munto\",\"muovere\",\"murale\",\"musa\",\"muscolo\",\"musica\",\"mutevole\",\"muto\",\"nababbo\",\"nafta\",\"nanometro\",\"narciso\",\"narice\",\"narrato\",\"nascere\",\"nastrare\",\"naturale\",\"nautica\",\"naviglio\",\"nebulosa\",\"necrosi\",\"negativo\",\"negozio\",\"nemmeno\",\"neofita\",\"neretto\",\"nervo\",\"nessuno\",\"nettuno\",\"neutrale\",\"neve\",\"nevrotico\",\"nicchia\",\"ninfa\",\"nitido\",\"nobile\",\"nocivo\",\"nodo\",\"nome\",\"nomina\",\"nordico\",\"normale\",\"norvegese\",\"nostrano\",\"notare\",\"notizia\",\"notturno\",\"novella\",\"nucleo\",\"nulla\",\"numero\",\"nuovo\",\"nutrire\",\"nuvola\",\"nuziale\",\"oasi\",\"obbedire\",\"obbligo\",\"obelisco\",\"oblio\",\"obolo\",\"obsoleto\",\"occasione\",\"occhio\",\"occidente\",\"occorrere\",\"occultare\",\"ocra\",\"oculato\",\"odierno\",\"odorare\",\"offerta\",\"offrire\",\"offuscato\",\"oggetto\",\"oggi\",\"ognuno\",\"olandese\",\"olfatto\",\"oliato\",\"oliva\",\"ologramma\",\"oltre\",\"omaggio\",\"ombelico\",\"ombra\",\"omega\",\"omissione\",\"ondoso\",\"onere\",\"onice\",\"onnivoro\",\"onorevole\",\"onta\",\"operato\",\"opinione\",\"opposto\",\"oracolo\",\"orafo\",\"ordine\",\"orecchino\",\"orefice\",\"orfano\",\"organico\",\"origine\",\"orizzonte\",\"orma\",\"ormeggio\",\"ornativo\",\"orologio\",\"orrendo\",\"orribile\",\"ortensia\",\"ortica\",\"orzata\",\"orzo\",\"osare\",\"oscurare\",\"osmosi\",\"ospedale\",\"ospite\",\"ossa\",\"ossidare\",\"ostacolo\",\"oste\",\"otite\",\"otre\",\"ottagono\",\"ottimo\",\"ottobre\",\"ovale\",\"ovest\",\"ovino\",\"oviparo\",\"ovocito\",\"ovunque\",\"ovviare\",\"ozio\",\"pacchetto\",\"pace\",\"pacifico\",\"padella\",\"padrone\",\"paese\",\"paga\",\"pagina\",\"palazzina\",\"palesare\",\"pallido\",\"palo\",\"palude\",\"pandoro\",\"pannello\",\"paolo\",\"paonazzo\",\"paprica\",\"parabola\",\"parcella\",\"parere\",\"pargolo\",\"pari\",\"parlato\",\"parola\",\"partire\",\"parvenza\",\"parziale\",\"passivo\",\"pasticca\",\"patacca\",\"patologia\",\"pattume\",\"pavone\",\"peccato\",\"pedalare\",\"pedonale\",\"peggio\",\"peloso\",\"penare\",\"pendice\",\"penisola\",\"pennuto\",\"penombra\",\"pensare\",\"pentola\",\"pepe\",\"pepita\",\"perbene\",\"percorso\",\"perdonato\",\"perforare\",\"pergamena\",\"periodo\",\"permesso\",\"perno\",\"perplesso\",\"persuaso\",\"pertugio\",\"pervaso\",\"pesatore\",\"pesista\",\"peso\",\"pestifero\",\"petalo\",\"pettine\",\"petulante\",\"pezzo\",\"piacere\",\"pianta\",\"piattino\",\"piccino\",\"picozza\",\"piega\",\"pietra\",\"piffero\",\"pigiama\",\"pigolio\",\"pigro\",\"pila\",\"pilifero\",\"pillola\",\"pilota\",\"pimpante\",\"pineta\",\"pinna\",\"pinolo\",\"pioggia\",\"piombo\",\"piramide\",\"piretico\",\"pirite\",\"pirolisi\",\"pitone\",\"pizzico\",\"placebo\",\"planare\",\"plasma\",\"platano\",\"plenario\",\"pochezza\",\"poderoso\",\"podismo\",\"poesia\",\"poggiare\",\"polenta\",\"poligono\",\"pollice\",\"polmonite\",\"polpetta\",\"polso\",\"poltrona\",\"polvere\",\"pomice\",\"pomodoro\",\"ponte\",\"popoloso\",\"porfido\",\"poroso\",\"porpora\",\"porre\",\"portata\",\"posa\",\"positivo\",\"possesso\",\"postulato\",\"potassio\",\"potere\",\"pranzo\",\"prassi\",\"pratica\",\"precluso\",\"predica\",\"prefisso\",\"pregiato\",\"prelievo\",\"premere\",\"prenotare\",\"preparato\",\"presenza\",\"pretesto\",\"prevalso\",\"prima\",\"principe\",\"privato\",\"problema\",\"procura\",\"produrre\",\"profumo\",\"progetto\",\"prolunga\",\"promessa\",\"pronome\",\"proposta\",\"proroga\",\"proteso\",\"prova\",\"prudente\",\"prugna\",\"prurito\",\"psiche\",\"pubblico\",\"pudica\",\"pugilato\",\"pugno\",\"pulce\",\"pulito\",\"pulsante\",\"puntare\",\"pupazzo\",\"pupilla\",\"puro\",\"quadro\",\"qualcosa\",\"quasi\",\"querela\",\"quota\",\"raccolto\",\"raddoppio\",\"radicale\",\"radunato\",\"raffica\",\"ragazzo\",\"ragione\",\"ragno\",\"ramarro\",\"ramingo\",\"ramo\",\"randagio\",\"rantolare\",\"rapato\",\"rapina\",\"rappreso\",\"rasatura\",\"raschiato\",\"rasente\",\"rassegna\",\"rastrello\",\"rata\",\"ravveduto\",\"reale\",\"recepire\",\"recinto\",\"recluta\",\"recondito\",\"recupero\",\"reddito\",\"redimere\",\"regalato\",\"registro\",\"regola\",\"regresso\",\"relazione\",\"remare\",\"remoto\",\"renna\",\"replica\",\"reprimere\",\"reputare\",\"resa\",\"residente\",\"responso\",\"restauro\",\"rete\",\"retina\",\"retorica\",\"rettifica\",\"revocato\",\"riassunto\",\"ribadire\",\"ribelle\",\"ribrezzo\",\"ricarica\",\"ricco\",\"ricevere\",\"riciclato\",\"ricordo\",\"ricreduto\",\"ridicolo\",\"ridurre\",\"rifasare\",\"riflesso\",\"riforma\",\"rifugio\",\"rigare\",\"rigettato\",\"righello\",\"rilassato\",\"rilevato\",\"rimanere\",\"rimbalzo\",\"rimedio\",\"rimorchio\",\"rinascita\",\"rincaro\",\"rinforzo\",\"rinnovo\",\"rinomato\",\"rinsavito\",\"rintocco\",\"rinuncia\",\"rinvenire\",\"riparato\",\"ripetuto\",\"ripieno\",\"riportare\",\"ripresa\",\"ripulire\",\"risata\",\"rischio\",\"riserva\",\"risibile\",\"riso\",\"rispetto\",\"ristoro\",\"risultato\",\"risvolto\",\"ritardo\",\"ritegno\",\"ritmico\",\"ritrovo\",\"riunione\",\"riva\",\"riverso\",\"rivincita\",\"rivolto\",\"rizoma\",\"roba\",\"robotico\",\"robusto\",\"roccia\",\"roco\",\"rodaggio\",\"rodere\",\"roditore\",\"rogito\",\"rollio\",\"romantico\",\"rompere\",\"ronzio\",\"rosolare\",\"rospo\",\"rotante\",\"rotondo\",\"rotula\",\"rovescio\",\"rubizzo\",\"rubrica\",\"ruga\",\"rullino\",\"rumine\",\"rumoroso\",\"ruolo\",\"rupe\",\"russare\",\"rustico\",\"sabato\",\"sabbiare\",\"sabotato\",\"sagoma\",\"salasso\",\"saldatura\",\"salgemma\",\"salivare\",\"salmone\",\"salone\",\"saltare\",\"saluto\",\"salvo\",\"sapere\",\"sapido\",\"saporito\",\"saraceno\",\"sarcasmo\",\"sarto\",\"sassoso\",\"satellite\",\"satira\",\"satollo\",\"saturno\",\"savana\",\"savio\",\"saziato\",\"sbadiglio\",\"sbalzo\",\"sbancato\",\"sbarra\",\"sbattere\",\"sbavare\",\"sbendare\",\"sbirciare\",\"sbloccato\",\"sbocciato\",\"sbrinare\",\"sbruffone\",\"sbuffare\",\"scabroso\",\"scadenza\",\"scala\",\"scambiare\",\"scandalo\",\"scapola\",\"scarso\",\"scatenare\",\"scavato\",\"scelto\",\"scenico\",\"scettro\",\"scheda\",\"schiena\",\"sciarpa\",\"scienza\",\"scindere\",\"scippo\",\"sciroppo\",\"scivolo\",\"sclerare\",\"scodella\",\"scolpito\",\"scomparto\",\"sconforto\",\"scoprire\",\"scorta\",\"scossone\",\"scozzese\",\"scriba\",\"scrollare\",\"scrutinio\",\"scuderia\",\"scultore\",\"scuola\",\"scuro\",\"scusare\",\"sdebitare\",\"sdoganare\",\"seccatura\",\"secondo\",\"sedano\",\"seggiola\",\"segnalato\",\"segregato\",\"seguito\",\"selciato\",\"selettivo\",\"sella\",\"selvaggio\",\"semaforo\",\"sembrare\",\"seme\",\"seminato\",\"sempre\",\"senso\",\"sentire\",\"sepolto\",\"sequenza\",\"serata\",\"serbato\",\"sereno\",\"serio\",\"serpente\",\"serraglio\",\"servire\",\"sestina\",\"setola\",\"settimana\",\"sfacelo\",\"sfaldare\",\"sfamato\",\"sfarzoso\",\"sfaticato\",\"sfera\",\"sfida\",\"sfilato\",\"sfinge\",\"sfocato\",\"sfoderare\",\"sfogo\",\"sfoltire\",\"sforzato\",\"sfratto\",\"sfruttato\",\"sfuggito\",\"sfumare\",\"sfuso\",\"sgabello\",\"sgarbato\",\"sgonfiare\",\"sgorbio\",\"sgrassato\",\"sguardo\",\"sibilo\",\"siccome\",\"sierra\",\"sigla\",\"signore\",\"silenzio\",\"sillaba\",\"simbolo\",\"simpatico\",\"simulato\",\"sinfonia\",\"singolo\",\"sinistro\",\"sino\",\"sintesi\",\"sinusoide\",\"sipario\",\"sisma\",\"sistole\",\"situato\",\"slitta\",\"slogatura\",\"sloveno\",\"smarrito\",\"smemorato\",\"smentito\",\"smeraldo\",\"smilzo\",\"smontare\",\"smottato\",\"smussato\",\"snellire\",\"snervato\",\"snodo\",\"sobbalzo\",\"sobrio\",\"soccorso\",\"sociale\",\"sodale\",\"soffitto\",\"sogno\",\"soldato\",\"solenne\",\"solido\",\"sollazzo\",\"solo\",\"solubile\",\"solvente\",\"somatico\",\"somma\",\"sonda\",\"sonetto\",\"sonnifero\",\"sopire\",\"soppeso\",\"sopra\",\"sorgere\",\"sorpasso\",\"sorriso\",\"sorso\",\"sorteggio\",\"sorvolato\",\"sospiro\",\"sosta\",\"sottile\",\"spada\",\"spalla\",\"spargere\",\"spatola\",\"spavento\",\"spazzola\",\"specie\",\"spedire\",\"spegnere\",\"spelatura\",\"speranza\",\"spessore\",\"spettrale\",\"spezzato\",\"spia\",\"spigoloso\",\"spillato\",\"spinoso\",\"spirale\",\"splendido\",\"sportivo\",\"sposo\",\"spranga\",\"sprecare\",\"spronato\",\"spruzzo\",\"spuntino\",\"squillo\",\"sradicare\",\"srotolato\",\"stabile\",\"stacco\",\"staffa\",\"stagnare\",\"stampato\",\"stantio\",\"starnuto\",\"stasera\",\"statuto\",\"stelo\",\"steppa\",\"sterzo\",\"stiletto\",\"stima\",\"stirpe\",\"stivale\",\"stizzoso\",\"stonato\",\"storico\",\"strappo\",\"stregato\",\"stridulo\",\"strozzare\",\"strutto\",\"stuccare\",\"stufo\",\"stupendo\",\"subentro\",\"succoso\",\"sudore\",\"suggerito\",\"sugo\",\"sultano\",\"suonare\",\"superbo\",\"supporto\",\"surgelato\",\"surrogato\",\"sussurro\",\"sutura\",\"svagare\",\"svedese\",\"sveglio\",\"svelare\",\"svenuto\",\"svezia\",\"sviluppo\",\"svista\",\"svizzera\",\"svolta\",\"svuotare\",\"tabacco\",\"tabulato\",\"tacciare\",\"taciturno\",\"tale\",\"talismano\",\"tampone\",\"tannino\",\"tara\",\"tardivo\",\"targato\",\"tariffa\",\"tarpare\",\"tartaruga\",\"tasto\",\"tattico\",\"taverna\",\"tavolata\",\"tazza\",\"teca\",\"tecnico\",\"telefono\",\"temerario\",\"tempo\",\"temuto\",\"tendone\",\"tenero\",\"tensione\",\"tentacolo\",\"teorema\",\"terme\",\"terrazzo\",\"terzetto\",\"tesi\",\"tesserato\",\"testato\",\"tetro\",\"tettoia\",\"tifare\",\"tigella\",\"timbro\",\"tinto\",\"tipico\",\"tipografo\",\"tiraggio\",\"tiro\",\"titanio\",\"titolo\",\"titubante\",\"tizio\",\"tizzone\",\"toccare\",\"tollerare\",\"tolto\",\"tombola\",\"tomo\",\"tonfo\",\"tonsilla\",\"topazio\",\"topologia\",\"toppa\",\"torba\",\"tornare\",\"torrone\",\"tortora\",\"toscano\",\"tossire\",\"tostatura\",\"totano\",\"trabocco\",\"trachea\",\"trafila\",\"tragedia\",\"tralcio\",\"tramonto\",\"transito\",\"trapano\",\"trarre\",\"trasloco\",\"trattato\",\"trave\",\"treccia\",\"tremolio\",\"trespolo\",\"tributo\",\"tricheco\",\"trifoglio\",\"trillo\",\"trincea\",\"trio\",\"tristezza\",\"triturato\",\"trivella\",\"tromba\",\"trono\",\"troppo\",\"trottola\",\"trovare\",\"truccato\",\"tubatura\",\"tuffato\",\"tulipano\",\"tumulto\",\"tunisia\",\"turbare\",\"turchino\",\"tuta\",\"tutela\",\"ubicato\",\"uccello\",\"uccisore\",\"udire\",\"uditivo\",\"uffa\",\"ufficio\",\"uguale\",\"ulisse\",\"ultimato\",\"umano\",\"umile\",\"umorismo\",\"uncinetto\",\"ungere\",\"ungherese\",\"unicorno\",\"unificato\",\"unisono\",\"unitario\",\"unte\",\"uovo\",\"upupa\",\"uragano\",\"urgenza\",\"urlo\",\"usanza\",\"usato\",\"uscito\",\"usignolo\",\"usuraio\",\"utensile\",\"utilizzo\",\"utopia\",\"vacante\",\"vaccinato\",\"vagabondo\",\"vagliato\",\"valanga\",\"valgo\",\"valico\",\"valletta\",\"valoroso\",\"valutare\",\"valvola\",\"vampata\",\"vangare\",\"vanitoso\",\"vano\",\"vantaggio\",\"vanvera\",\"vapore\",\"varano\",\"varcato\",\"variante\",\"vasca\",\"vedetta\",\"vedova\",\"veduto\",\"vegetale\",\"veicolo\",\"velcro\",\"velina\",\"velluto\",\"veloce\",\"venato\",\"vendemmia\",\"vento\",\"verace\",\"verbale\",\"vergogna\",\"verifica\",\"vero\",\"verruca\",\"verticale\",\"vescica\",\"vessillo\",\"vestale\",\"veterano\",\"vetrina\",\"vetusto\",\"viandante\",\"vibrante\",\"vicenda\",\"vichingo\",\"vicinanza\",\"vidimare\",\"vigilia\",\"vigneto\",\"vigore\",\"vile\",\"villano\",\"vimini\",\"vincitore\",\"viola\",\"vipera\",\"virgola\",\"virologo\",\"virulento\",\"viscoso\",\"visione\",\"vispo\",\"vissuto\",\"visura\",\"vita\",\"vitello\",\"vittima\",\"vivanda\",\"vivido\",\"viziare\",\"voce\",\"voga\",\"volatile\",\"volere\",\"volpe\",\"voragine\",\"vulcano\",\"zampogna\",\"zanna\",\"zappato\",\"zattera\",\"zavorra\",\"zefiro\",\"zelante\",\"zelo\",\"zenzero\",\"zerbino\",\"zibetto\",\"zinco\",\"zircone\",\"zitto\",\"zolla\",\"zotico\",\"zucchero\",\"zufolo\",\"zulu\",\"zuppa\"]");

const require$$6 = /* #__PURE__ */ JSON.parse("[\"aÌbaco\",\"abdomen\",\"abeja\",\"abierto\",\"abogado\",\"abono\",\"aborto\",\"abrazo\",\"abrir\",\"abuelo\",\"abuso\",\"acabar\",\"academia\",\"acceso\",\"accioÌn\",\"aceite\",\"acelga\",\"acento\",\"aceptar\",\"aÌcido\",\"aclarar\",\"acneÌ\",\"acoger\",\"acoso\",\"activo\",\"acto\",\"actriz\",\"actuar\",\"acudir\",\"acuerdo\",\"acusar\",\"adicto\",\"admitir\",\"adoptar\",\"adorno\",\"aduana\",\"adulto\",\"aeÌreo\",\"afectar\",\"aficioÌn\",\"afinar\",\"afirmar\",\"aÌgil\",\"agitar\",\"agoniÌa\",\"agosto\",\"agotar\",\"agregar\",\"agrio\",\"agua\",\"agudo\",\"aÌguila\",\"aguja\",\"ahogo\",\"ahorro\",\"aire\",\"aislar\",\"ajedrez\",\"ajeno\",\"ajuste\",\"alacraÌn\",\"alambre\",\"alarma\",\"alba\",\"aÌlbum\",\"alcalde\",\"aldea\",\"alegre\",\"alejar\",\"alerta\",\"aleta\",\"alfiler\",\"alga\",\"algodoÌn\",\"aliado\",\"aliento\",\"alivio\",\"alma\",\"almeja\",\"almiÌbar\",\"altar\",\"alteza\",\"altivo\",\"alto\",\"altura\",\"alumno\",\"alzar\",\"amable\",\"amante\",\"amapola\",\"amargo\",\"amasar\",\"aÌmbar\",\"aÌmbito\",\"ameno\",\"amigo\",\"amistad\",\"amor\",\"amparo\",\"amplio\",\"ancho\",\"anciano\",\"ancla\",\"andar\",\"andeÌn\",\"anemia\",\"aÌngulo\",\"anillo\",\"aÌnimo\",\"aniÌs\",\"anotar\",\"antena\",\"antiguo\",\"antojo\",\"anual\",\"anular\",\"anuncio\",\"anÌƒadir\",\"anÌƒejo\",\"anÌƒo\",\"apagar\",\"aparato\",\"apetito\",\"apio\",\"aplicar\",\"apodo\",\"aporte\",\"apoyo\",\"aprender\",\"aprobar\",\"apuesta\",\"apuro\",\"arado\",\"aranÌƒa\",\"arar\",\"aÌrbitro\",\"aÌrbol\",\"arbusto\",\"archivo\",\"arco\",\"arder\",\"ardilla\",\"arduo\",\"aÌrea\",\"aÌrido\",\"aries\",\"armoniÌa\",\"arneÌs\",\"aroma\",\"arpa\",\"arpoÌn\",\"arreglo\",\"arroz\",\"arruga\",\"arte\",\"artista\",\"asa\",\"asado\",\"asalto\",\"ascenso\",\"asegurar\",\"aseo\",\"asesor\",\"asiento\",\"asilo\",\"asistir\",\"asno\",\"asombro\",\"aÌspero\",\"astilla\",\"astro\",\"astuto\",\"asumir\",\"asunto\",\"atajo\",\"ataque\",\"atar\",\"atento\",\"ateo\",\"aÌtico\",\"atleta\",\"aÌtomo\",\"atraer\",\"atroz\",\"atuÌn\",\"audaz\",\"audio\",\"auge\",\"aula\",\"aumento\",\"ausente\",\"autor\",\"aval\",\"avance\",\"avaro\",\"ave\",\"avellana\",\"avena\",\"avestruz\",\"avioÌn\",\"aviso\",\"ayer\",\"ayuda\",\"ayuno\",\"azafraÌn\",\"azar\",\"azote\",\"azuÌcar\",\"azufre\",\"azul\",\"baba\",\"babor\",\"bache\",\"bahiÌa\",\"baile\",\"bajar\",\"balanza\",\"balcoÌn\",\"balde\",\"bambuÌ\",\"banco\",\"banda\",\"banÌƒo\",\"barba\",\"barco\",\"barniz\",\"barro\",\"baÌscula\",\"bastoÌn\",\"basura\",\"batalla\",\"bateriÌa\",\"batir\",\"batuta\",\"bauÌl\",\"bazar\",\"bebeÌ\",\"bebida\",\"bello\",\"besar\",\"beso\",\"bestia\",\"bicho\",\"bien\",\"bingo\",\"blanco\",\"bloque\",\"blusa\",\"boa\",\"bobina\",\"bobo\",\"boca\",\"bocina\",\"boda\",\"bodega\",\"boina\",\"bola\",\"bolero\",\"bolsa\",\"bomba\",\"bondad\",\"bonito\",\"bono\",\"bonsaÌi\",\"borde\",\"borrar\",\"bosque\",\"bote\",\"botiÌn\",\"boÌveda\",\"bozal\",\"bravo\",\"brazo\",\"brecha\",\"breve\",\"brillo\",\"brinco\",\"brisa\",\"broca\",\"broma\",\"bronce\",\"brote\",\"bruja\",\"brusco\",\"bruto\",\"buceo\",\"bucle\",\"bueno\",\"buey\",\"bufanda\",\"bufoÌn\",\"buÌho\",\"buitre\",\"bulto\",\"burbuja\",\"burla\",\"burro\",\"buscar\",\"butaca\",\"buzoÌn\",\"caballo\",\"cabeza\",\"cabina\",\"cabra\",\"cacao\",\"cadaÌver\",\"cadena\",\"caer\",\"cafeÌ\",\"caiÌda\",\"caimaÌn\",\"caja\",\"cajoÌn\",\"cal\",\"calamar\",\"calcio\",\"caldo\",\"calidad\",\"calle\",\"calma\",\"calor\",\"calvo\",\"cama\",\"cambio\",\"camello\",\"camino\",\"campo\",\"caÌncer\",\"candil\",\"canela\",\"canguro\",\"canica\",\"canto\",\"canÌƒa\",\"canÌƒoÌn\",\"caoba\",\"caos\",\"capaz\",\"capitaÌn\",\"capote\",\"captar\",\"capucha\",\"cara\",\"carboÌn\",\"caÌrcel\",\"careta\",\"carga\",\"carinÌƒo\",\"carne\",\"carpeta\",\"carro\",\"carta\",\"casa\",\"casco\",\"casero\",\"caspa\",\"castor\",\"catorce\",\"catre\",\"caudal\",\"causa\",\"cazo\",\"cebolla\",\"ceder\",\"cedro\",\"celda\",\"ceÌlebre\",\"celoso\",\"ceÌlula\",\"cemento\",\"ceniza\",\"centro\",\"cerca\",\"cerdo\",\"cereza\",\"cero\",\"cerrar\",\"certeza\",\"ceÌsped\",\"cetro\",\"chacal\",\"chaleco\",\"champuÌ\",\"chancla\",\"chapa\",\"charla\",\"chico\",\"chiste\",\"chivo\",\"choque\",\"choza\",\"chuleta\",\"chupar\",\"cicloÌn\",\"ciego\",\"cielo\",\"cien\",\"cierto\",\"cifra\",\"cigarro\",\"cima\",\"cinco\",\"cine\",\"cinta\",\"cipreÌs\",\"circo\",\"ciruela\",\"cisne\",\"cita\",\"ciudad\",\"clamor\",\"clan\",\"claro\",\"clase\",\"clave\",\"cliente\",\"clima\",\"cliÌnica\",\"cobre\",\"coccioÌn\",\"cochino\",\"cocina\",\"coco\",\"coÌdigo\",\"codo\",\"cofre\",\"coger\",\"cohete\",\"cojiÌn\",\"cojo\",\"cola\",\"colcha\",\"colegio\",\"colgar\",\"colina\",\"collar\",\"colmo\",\"columna\",\"combate\",\"comer\",\"comida\",\"coÌmodo\",\"compra\",\"conde\",\"conejo\",\"conga\",\"conocer\",\"consejo\",\"contar\",\"copa\",\"copia\",\"corazoÌn\",\"corbata\",\"corcho\",\"cordoÌn\",\"corona\",\"correr\",\"coser\",\"cosmos\",\"costa\",\"craÌneo\",\"craÌter\",\"crear\",\"crecer\",\"creiÌdo\",\"crema\",\"criÌa\",\"crimen\",\"cripta\",\"crisis\",\"cromo\",\"croÌnica\",\"croqueta\",\"crudo\",\"cruz\",\"cuadro\",\"cuarto\",\"cuatro\",\"cubo\",\"cubrir\",\"cuchara\",\"cuello\",\"cuento\",\"cuerda\",\"cuesta\",\"cueva\",\"cuidar\",\"culebra\",\"culpa\",\"culto\",\"cumbre\",\"cumplir\",\"cuna\",\"cuneta\",\"cuota\",\"cupoÌn\",\"cuÌpula\",\"curar\",\"curioso\",\"curso\",\"curva\",\"cutis\",\"dama\",\"danza\",\"dar\",\"dardo\",\"daÌtil\",\"deber\",\"deÌbil\",\"deÌcada\",\"decir\",\"dedo\",\"defensa\",\"definir\",\"dejar\",\"delfiÌn\",\"delgado\",\"delito\",\"demora\",\"denso\",\"dental\",\"deporte\",\"derecho\",\"derrota\",\"desayuno\",\"deseo\",\"desfile\",\"desnudo\",\"destino\",\"desviÌo\",\"detalle\",\"detener\",\"deuda\",\"diÌa\",\"diablo\",\"diadema\",\"diamante\",\"diana\",\"diario\",\"dibujo\",\"dictar\",\"diente\",\"dieta\",\"diez\",\"difiÌcil\",\"digno\",\"dilema\",\"diluir\",\"dinero\",\"directo\",\"dirigir\",\"disco\",\"disenÌƒo\",\"disfraz\",\"diva\",\"divino\",\"doble\",\"doce\",\"dolor\",\"domingo\",\"don\",\"donar\",\"dorado\",\"dormir\",\"dorso\",\"dos\",\"dosis\",\"dragoÌn\",\"droga\",\"ducha\",\"duda\",\"duelo\",\"duenÌƒo\",\"dulce\",\"duÌo\",\"duque\",\"durar\",\"dureza\",\"duro\",\"eÌbano\",\"ebrio\",\"echar\",\"eco\",\"ecuador\",\"edad\",\"edicioÌn\",\"edificio\",\"editor\",\"educar\",\"efecto\",\"eficaz\",\"eje\",\"ejemplo\",\"elefante\",\"elegir\",\"elemento\",\"elevar\",\"elipse\",\"eÌlite\",\"elixir\",\"elogio\",\"eludir\",\"embudo\",\"emitir\",\"emocioÌn\",\"empate\",\"empenÌƒo\",\"empleo\",\"empresa\",\"enano\",\"encargo\",\"enchufe\",\"enciÌa\",\"enemigo\",\"enero\",\"enfado\",\"enfermo\",\"enganÌƒo\",\"enigma\",\"enlace\",\"enorme\",\"enredo\",\"ensayo\",\"ensenÌƒar\",\"entero\",\"entrar\",\"envase\",\"enviÌo\",\"eÌpoca\",\"equipo\",\"erizo\",\"escala\",\"escena\",\"escolar\",\"escribir\",\"escudo\",\"esencia\",\"esfera\",\"esfuerzo\",\"espada\",\"espejo\",\"espiÌa\",\"esposa\",\"espuma\",\"esquiÌ\",\"estar\",\"este\",\"estilo\",\"estufa\",\"etapa\",\"eterno\",\"eÌtica\",\"etnia\",\"evadir\",\"evaluar\",\"evento\",\"evitar\",\"exacto\",\"examen\",\"exceso\",\"excusa\",\"exento\",\"exigir\",\"exilio\",\"existir\",\"eÌxito\",\"experto\",\"explicar\",\"exponer\",\"extremo\",\"faÌbrica\",\"faÌbula\",\"fachada\",\"faÌcil\",\"factor\",\"faena\",\"faja\",\"falda\",\"fallo\",\"falso\",\"faltar\",\"fama\",\"familia\",\"famoso\",\"faraoÌn\",\"farmacia\",\"farol\",\"farsa\",\"fase\",\"fatiga\",\"fauna\",\"favor\",\"fax\",\"febrero\",\"fecha\",\"feliz\",\"feo\",\"feria\",\"feroz\",\"feÌrtil\",\"fervor\",\"festiÌn\",\"fiable\",\"fianza\",\"fiar\",\"fibra\",\"ficcioÌn\",\"ficha\",\"fideo\",\"fiebre\",\"fiel\",\"fiera\",\"fiesta\",\"figura\",\"fijar\",\"fijo\",\"fila\",\"filete\",\"filial\",\"filtro\",\"fin\",\"finca\",\"fingir\",\"finito\",\"firma\",\"flaco\",\"flauta\",\"flecha\",\"flor\",\"flota\",\"fluir\",\"flujo\",\"fluÌor\",\"fobia\",\"foca\",\"fogata\",\"fogoÌn\",\"folio\",\"folleto\",\"fondo\",\"forma\",\"forro\",\"fortuna\",\"forzar\",\"fosa\",\"foto\",\"fracaso\",\"fraÌgil\",\"franja\",\"frase\",\"fraude\",\"freiÌr\",\"freno\",\"fresa\",\"friÌo\",\"frito\",\"fruta\",\"fuego\",\"fuente\",\"fuerza\",\"fuga\",\"fumar\",\"funcioÌn\",\"funda\",\"furgoÌn\",\"furia\",\"fusil\",\"fuÌtbol\",\"futuro\",\"gacela\",\"gafas\",\"gaita\",\"gajo\",\"gala\",\"galeriÌa\",\"gallo\",\"gamba\",\"ganar\",\"gancho\",\"ganga\",\"ganso\",\"garaje\",\"garza\",\"gasolina\",\"gastar\",\"gato\",\"gavilaÌn\",\"gemelo\",\"gemir\",\"gen\",\"geÌnero\",\"genio\",\"gente\",\"geranio\",\"gerente\",\"germen\",\"gesto\",\"gigante\",\"gimnasio\",\"girar\",\"giro\",\"glaciar\",\"globo\",\"gloria\",\"gol\",\"golfo\",\"goloso\",\"golpe\",\"goma\",\"gordo\",\"gorila\",\"gorra\",\"gota\",\"goteo\",\"gozar\",\"grada\",\"graÌfico\",\"grano\",\"grasa\",\"gratis\",\"grave\",\"grieta\",\"grillo\",\"gripe\",\"gris\",\"grito\",\"grosor\",\"gruÌa\",\"grueso\",\"grumo\",\"grupo\",\"guante\",\"guapo\",\"guardia\",\"guerra\",\"guiÌa\",\"guinÌƒo\",\"guion\",\"guiso\",\"guitarra\",\"gusano\",\"gustar\",\"haber\",\"haÌbil\",\"hablar\",\"hacer\",\"hacha\",\"hada\",\"hallar\",\"hamaca\",\"harina\",\"haz\",\"hazanÌƒa\",\"hebilla\",\"hebra\",\"hecho\",\"helado\",\"helio\",\"hembra\",\"herir\",\"hermano\",\"heÌroe\",\"hervir\",\"hielo\",\"hierro\",\"hiÌgado\",\"higiene\",\"hijo\",\"himno\",\"historia\",\"hocico\",\"hogar\",\"hoguera\",\"hoja\",\"hombre\",\"hongo\",\"honor\",\"honra\",\"hora\",\"hormiga\",\"horno\",\"hostil\",\"hoyo\",\"hueco\",\"huelga\",\"huerta\",\"hueso\",\"huevo\",\"huida\",\"huir\",\"humano\",\"huÌmedo\",\"humilde\",\"humo\",\"hundir\",\"huracaÌn\",\"hurto\",\"icono\",\"ideal\",\"idioma\",\"iÌdolo\",\"iglesia\",\"igluÌ\",\"igual\",\"ilegal\",\"ilusioÌn\",\"imagen\",\"imaÌn\",\"imitar\",\"impar\",\"imperio\",\"imponer\",\"impulso\",\"incapaz\",\"iÌndice\",\"inerte\",\"infiel\",\"informe\",\"ingenio\",\"inicio\",\"inmenso\",\"inmune\",\"innato\",\"insecto\",\"instante\",\"intereÌs\",\"iÌntimo\",\"intuir\",\"inuÌtil\",\"invierno\",\"ira\",\"iris\",\"ironiÌa\",\"isla\",\"islote\",\"jabaliÌ\",\"jaboÌn\",\"jamoÌn\",\"jarabe\",\"jardiÌn\",\"jarra\",\"jaula\",\"jazmiÌn\",\"jefe\",\"jeringa\",\"jinete\",\"jornada\",\"joroba\",\"joven\",\"joya\",\"juerga\",\"jueves\",\"juez\",\"jugador\",\"jugo\",\"juguete\",\"juicio\",\"junco\",\"jungla\",\"junio\",\"juntar\",\"juÌpiter\",\"jurar\",\"justo\",\"juvenil\",\"juzgar\",\"kilo\",\"koala\",\"labio\",\"lacio\",\"lacra\",\"lado\",\"ladroÌn\",\"lagarto\",\"laÌgrima\",\"laguna\",\"laico\",\"lamer\",\"laÌmina\",\"laÌmpara\",\"lana\",\"lancha\",\"langosta\",\"lanza\",\"laÌpiz\",\"largo\",\"larva\",\"laÌstima\",\"lata\",\"laÌtex\",\"latir\",\"laurel\",\"lavar\",\"lazo\",\"leal\",\"leccioÌn\",\"leche\",\"lector\",\"leer\",\"legioÌn\",\"legumbre\",\"lejano\",\"lengua\",\"lento\",\"lenÌƒa\",\"leoÌn\",\"leopardo\",\"lesioÌn\",\"letal\",\"letra\",\"leve\",\"leyenda\",\"libertad\",\"libro\",\"licor\",\"liÌder\",\"lidiar\",\"lienzo\",\"liga\",\"ligero\",\"lima\",\"liÌmite\",\"limoÌn\",\"limpio\",\"lince\",\"lindo\",\"liÌnea\",\"lingote\",\"lino\",\"linterna\",\"liÌquido\",\"liso\",\"lista\",\"litera\",\"litio\",\"litro\",\"llaga\",\"llama\",\"llanto\",\"llave\",\"llegar\",\"llenar\",\"llevar\",\"llorar\",\"llover\",\"lluvia\",\"lobo\",\"locioÌn\",\"loco\",\"locura\",\"loÌgica\",\"logro\",\"lombriz\",\"lomo\",\"lonja\",\"lote\",\"lucha\",\"lucir\",\"lugar\",\"lujo\",\"luna\",\"lunes\",\"lupa\",\"lustro\",\"luto\",\"luz\",\"maceta\",\"macho\",\"madera\",\"madre\",\"maduro\",\"maestro\",\"mafia\",\"magia\",\"mago\",\"maiÌz\",\"maldad\",\"maleta\",\"malla\",\"malo\",\"mamaÌ\",\"mambo\",\"mamut\",\"manco\",\"mando\",\"manejar\",\"manga\",\"maniquiÌ\",\"manjar\",\"mano\",\"manso\",\"manta\",\"manÌƒana\",\"mapa\",\"maÌquina\",\"mar\",\"marco\",\"marea\",\"marfil\",\"margen\",\"marido\",\"maÌrmol\",\"marroÌn\",\"martes\",\"marzo\",\"masa\",\"maÌscara\",\"masivo\",\"matar\",\"materia\",\"matiz\",\"matriz\",\"maÌximo\",\"mayor\",\"mazorca\",\"mecha\",\"medalla\",\"medio\",\"meÌdula\",\"mejilla\",\"mejor\",\"melena\",\"meloÌn\",\"memoria\",\"menor\",\"mensaje\",\"mente\",\"menuÌ\",\"mercado\",\"merengue\",\"meÌrito\",\"mes\",\"mesoÌn\",\"meta\",\"meter\",\"meÌtodo\",\"metro\",\"mezcla\",\"miedo\",\"miel\",\"miembro\",\"miga\",\"mil\",\"milagro\",\"militar\",\"milloÌn\",\"mimo\",\"mina\",\"minero\",\"miÌnimo\",\"minuto\",\"miope\",\"mirar\",\"misa\",\"miseria\",\"misil\",\"mismo\",\"mitad\",\"mito\",\"mochila\",\"mocioÌn\",\"moda\",\"modelo\",\"moho\",\"mojar\",\"molde\",\"moler\",\"molino\",\"momento\",\"momia\",\"monarca\",\"moneda\",\"monja\",\"monto\",\"monÌƒo\",\"morada\",\"morder\",\"moreno\",\"morir\",\"morro\",\"morsa\",\"mortal\",\"mosca\",\"mostrar\",\"motivo\",\"mover\",\"moÌvil\",\"mozo\",\"mucho\",\"mudar\",\"mueble\",\"muela\",\"muerte\",\"muestra\",\"mugre\",\"mujer\",\"mula\",\"muleta\",\"multa\",\"mundo\",\"munÌƒeca\",\"mural\",\"muro\",\"muÌsculo\",\"museo\",\"musgo\",\"muÌsica\",\"muslo\",\"naÌcar\",\"nacioÌn\",\"nadar\",\"naipe\",\"naranja\",\"nariz\",\"narrar\",\"nasal\",\"natal\",\"nativo\",\"natural\",\"naÌusea\",\"naval\",\"nave\",\"navidad\",\"necio\",\"neÌctar\",\"negar\",\"negocio\",\"negro\",\"neoÌn\",\"nervio\",\"neto\",\"neutro\",\"nevar\",\"nevera\",\"nicho\",\"nido\",\"niebla\",\"nieto\",\"ninÌƒez\",\"ninÌƒo\",\"niÌtido\",\"nivel\",\"nobleza\",\"noche\",\"noÌmina\",\"noria\",\"norma\",\"norte\",\"nota\",\"noticia\",\"novato\",\"novela\",\"novio\",\"nube\",\"nuca\",\"nuÌcleo\",\"nudillo\",\"nudo\",\"nuera\",\"nueve\",\"nuez\",\"nulo\",\"nuÌmero\",\"nutria\",\"oasis\",\"obeso\",\"obispo\",\"objeto\",\"obra\",\"obrero\",\"observar\",\"obtener\",\"obvio\",\"oca\",\"ocaso\",\"oceÌano\",\"ochenta\",\"ocho\",\"ocio\",\"ocre\",\"octavo\",\"octubre\",\"oculto\",\"ocupar\",\"ocurrir\",\"odiar\",\"odio\",\"odisea\",\"oeste\",\"ofensa\",\"oferta\",\"oficio\",\"ofrecer\",\"ogro\",\"oiÌdo\",\"oiÌr\",\"ojo\",\"ola\",\"oleada\",\"olfato\",\"olivo\",\"olla\",\"olmo\",\"olor\",\"olvido\",\"ombligo\",\"onda\",\"onza\",\"opaco\",\"opcioÌn\",\"oÌpera\",\"opinar\",\"oponer\",\"optar\",\"oÌptica\",\"opuesto\",\"oracioÌn\",\"orador\",\"oral\",\"oÌrbita\",\"orca\",\"orden\",\"oreja\",\"oÌrgano\",\"orgiÌa\",\"orgullo\",\"oriente\",\"origen\",\"orilla\",\"oro\",\"orquesta\",\"oruga\",\"osadiÌa\",\"oscuro\",\"osezno\",\"oso\",\"ostra\",\"otonÌƒo\",\"otro\",\"oveja\",\"oÌvulo\",\"oÌxido\",\"oxiÌgeno\",\"oyente\",\"ozono\",\"pacto\",\"padre\",\"paella\",\"paÌgina\",\"pago\",\"paiÌs\",\"paÌjaro\",\"palabra\",\"palco\",\"paleta\",\"paÌlido\",\"palma\",\"paloma\",\"palpar\",\"pan\",\"panal\",\"paÌnico\",\"pantera\",\"panÌƒuelo\",\"papaÌ\",\"papel\",\"papilla\",\"paquete\",\"parar\",\"parcela\",\"pared\",\"parir\",\"paro\",\"paÌrpado\",\"parque\",\"paÌrrafo\",\"parte\",\"pasar\",\"paseo\",\"pasioÌn\",\"paso\",\"pasta\",\"pata\",\"patio\",\"patria\",\"pausa\",\"pauta\",\"pavo\",\"payaso\",\"peatoÌn\",\"pecado\",\"pecera\",\"pecho\",\"pedal\",\"pedir\",\"pegar\",\"peine\",\"pelar\",\"peldanÌƒo\",\"pelea\",\"peligro\",\"pellejo\",\"pelo\",\"peluca\",\"pena\",\"pensar\",\"penÌƒoÌn\",\"peoÌn\",\"peor\",\"pepino\",\"pequenÌƒo\",\"pera\",\"percha\",\"perder\",\"pereza\",\"perfil\",\"perico\",\"perla\",\"permiso\",\"perro\",\"persona\",\"pesa\",\"pesca\",\"peÌsimo\",\"pestanÌƒa\",\"peÌtalo\",\"petroÌleo\",\"pez\",\"pezunÌƒa\",\"picar\",\"pichoÌn\",\"pie\",\"piedra\",\"pierna\",\"pieza\",\"pijama\",\"pilar\",\"piloto\",\"pimienta\",\"pino\",\"pintor\",\"pinza\",\"pinÌƒa\",\"piojo\",\"pipa\",\"pirata\",\"pisar\",\"piscina\",\"piso\",\"pista\",\"pitoÌn\",\"pizca\",\"placa\",\"plan\",\"plata\",\"playa\",\"plaza\",\"pleito\",\"pleno\",\"plomo\",\"pluma\",\"plural\",\"pobre\",\"poco\",\"poder\",\"podio\",\"poema\",\"poesiÌa\",\"poeta\",\"polen\",\"policiÌa\",\"pollo\",\"polvo\",\"pomada\",\"pomelo\",\"pomo\",\"pompa\",\"poner\",\"porcioÌn\",\"portal\",\"posada\",\"poseer\",\"posible\",\"poste\",\"potencia\",\"potro\",\"pozo\",\"prado\",\"precoz\",\"pregunta\",\"premio\",\"prensa\",\"preso\",\"previo\",\"primo\",\"priÌncipe\",\"prisioÌn\",\"privar\",\"proa\",\"probar\",\"proceso\",\"producto\",\"proeza\",\"profesor\",\"programa\",\"prole\",\"promesa\",\"pronto\",\"propio\",\"proÌximo\",\"prueba\",\"puÌblico\",\"puchero\",\"pudor\",\"pueblo\",\"puerta\",\"puesto\",\"pulga\",\"pulir\",\"pulmoÌn\",\"pulpo\",\"pulso\",\"puma\",\"punto\",\"punÌƒal\",\"punÌƒo\",\"pupa\",\"pupila\",\"pureÌ\",\"quedar\",\"queja\",\"quemar\",\"querer\",\"queso\",\"quieto\",\"quiÌmica\",\"quince\",\"quitar\",\"raÌbano\",\"rabia\",\"rabo\",\"racioÌn\",\"radical\",\"raiÌz\",\"rama\",\"rampa\",\"rancho\",\"rango\",\"rapaz\",\"raÌpido\",\"rapto\",\"rasgo\",\"raspa\",\"rato\",\"rayo\",\"raza\",\"razoÌn\",\"reaccioÌn\",\"realidad\",\"rebanÌƒo\",\"rebote\",\"recaer\",\"receta\",\"rechazo\",\"recoger\",\"recreo\",\"recto\",\"recurso\",\"red\",\"redondo\",\"reducir\",\"reflejo\",\"reforma\",\"refraÌn\",\"refugio\",\"regalo\",\"regir\",\"regla\",\"regreso\",\"reheÌn\",\"reino\",\"reiÌr\",\"reja\",\"relato\",\"relevo\",\"relieve\",\"relleno\",\"reloj\",\"remar\",\"remedio\",\"remo\",\"rencor\",\"rendir\",\"renta\",\"reparto\",\"repetir\",\"reposo\",\"reptil\",\"res\",\"rescate\",\"resina\",\"respeto\",\"resto\",\"resumen\",\"retiro\",\"retorno\",\"retrato\",\"reunir\",\"reveÌs\",\"revista\",\"rey\",\"rezar\",\"rico\",\"riego\",\"rienda\",\"riesgo\",\"rifa\",\"riÌgido\",\"rigor\",\"rincoÌn\",\"rinÌƒoÌn\",\"riÌo\",\"riqueza\",\"risa\",\"ritmo\",\"rito\",\"rizo\",\"roble\",\"roce\",\"rociar\",\"rodar\",\"rodeo\",\"rodilla\",\"roer\",\"rojizo\",\"rojo\",\"romero\",\"romper\",\"ron\",\"ronco\",\"ronda\",\"ropa\",\"ropero\",\"rosa\",\"rosca\",\"rostro\",\"rotar\",\"rubiÌ\",\"rubor\",\"rudo\",\"rueda\",\"rugir\",\"ruido\",\"ruina\",\"ruleta\",\"rulo\",\"rumbo\",\"rumor\",\"ruptura\",\"ruta\",\"rutina\",\"saÌbado\",\"saber\",\"sabio\",\"sable\",\"sacar\",\"sagaz\",\"sagrado\",\"sala\",\"saldo\",\"salero\",\"salir\",\"salmoÌn\",\"saloÌn\",\"salsa\",\"salto\",\"salud\",\"salvar\",\"samba\",\"sancioÌn\",\"sandiÌa\",\"sanear\",\"sangre\",\"sanidad\",\"sano\",\"santo\",\"sapo\",\"saque\",\"sardina\",\"sarteÌn\",\"sastre\",\"sataÌn\",\"sauna\",\"saxofoÌn\",\"seccioÌn\",\"seco\",\"secreto\",\"secta\",\"sed\",\"seguir\",\"seis\",\"sello\",\"selva\",\"semana\",\"semilla\",\"senda\",\"sensor\",\"senÌƒal\",\"senÌƒor\",\"separar\",\"sepia\",\"sequiÌa\",\"ser\",\"serie\",\"sermoÌn\",\"servir\",\"sesenta\",\"sesioÌn\",\"seta\",\"setenta\",\"severo\",\"sexo\",\"sexto\",\"sidra\",\"siesta\",\"siete\",\"siglo\",\"signo\",\"siÌlaba\",\"silbar\",\"silencio\",\"silla\",\"siÌmbolo\",\"simio\",\"sirena\",\"sistema\",\"sitio\",\"situar\",\"sobre\",\"socio\",\"sodio\",\"sol\",\"solapa\",\"soldado\",\"soledad\",\"soÌlido\",\"soltar\",\"solucioÌn\",\"sombra\",\"sondeo\",\"sonido\",\"sonoro\",\"sonrisa\",\"sopa\",\"soplar\",\"soporte\",\"sordo\",\"sorpresa\",\"sorteo\",\"sosteÌn\",\"soÌtano\",\"suave\",\"subir\",\"suceso\",\"sudor\",\"suegra\",\"suelo\",\"suenÌƒo\",\"suerte\",\"sufrir\",\"sujeto\",\"sultaÌn\",\"sumar\",\"superar\",\"suplir\",\"suponer\",\"supremo\",\"sur\",\"surco\",\"surenÌƒo\",\"surgir\",\"susto\",\"sutil\",\"tabaco\",\"tabique\",\"tabla\",\"tabuÌ\",\"taco\",\"tacto\",\"tajo\",\"talar\",\"talco\",\"talento\",\"talla\",\"taloÌn\",\"tamanÌƒo\",\"tambor\",\"tango\",\"tanque\",\"tapa\",\"tapete\",\"tapia\",\"tapoÌn\",\"taquilla\",\"tarde\",\"tarea\",\"tarifa\",\"tarjeta\",\"tarot\",\"tarro\",\"tarta\",\"tatuaje\",\"tauro\",\"taza\",\"tazoÌn\",\"teatro\",\"techo\",\"tecla\",\"teÌcnica\",\"tejado\",\"tejer\",\"tejido\",\"tela\",\"teleÌfono\",\"tema\",\"temor\",\"templo\",\"tenaz\",\"tender\",\"tener\",\"tenis\",\"tenso\",\"teoriÌa\",\"terapia\",\"terco\",\"teÌrmino\",\"ternura\",\"terror\",\"tesis\",\"tesoro\",\"testigo\",\"tetera\",\"texto\",\"tez\",\"tibio\",\"tiburoÌn\",\"tiempo\",\"tienda\",\"tierra\",\"tieso\",\"tigre\",\"tijera\",\"tilde\",\"timbre\",\"tiÌmido\",\"timo\",\"tinta\",\"tiÌo\",\"tiÌpico\",\"tipo\",\"tira\",\"tiroÌn\",\"titaÌn\",\"tiÌtere\",\"tiÌtulo\",\"tiza\",\"toalla\",\"tobillo\",\"tocar\",\"tocino\",\"todo\",\"toga\",\"toldo\",\"tomar\",\"tono\",\"tonto\",\"topar\",\"tope\",\"toque\",\"toÌrax\",\"torero\",\"tormenta\",\"torneo\",\"toro\",\"torpedo\",\"torre\",\"torso\",\"tortuga\",\"tos\",\"tosco\",\"toser\",\"toÌxico\",\"trabajo\",\"tractor\",\"traer\",\"traÌfico\",\"trago\",\"traje\",\"tramo\",\"trance\",\"trato\",\"trauma\",\"trazar\",\"treÌbol\",\"tregua\",\"treinta\",\"tren\",\"trepar\",\"tres\",\"tribu\",\"trigo\",\"tripa\",\"triste\",\"triunfo\",\"trofeo\",\"trompa\",\"tronco\",\"tropa\",\"trote\",\"trozo\",\"truco\",\"trueno\",\"trufa\",\"tuberiÌa\",\"tubo\",\"tuerto\",\"tumba\",\"tumor\",\"tuÌnel\",\"tuÌnica\",\"turbina\",\"turismo\",\"turno\",\"tutor\",\"ubicar\",\"uÌlcera\",\"umbral\",\"unidad\",\"unir\",\"universo\",\"uno\",\"untar\",\"unÌƒa\",\"urbano\",\"urbe\",\"urgente\",\"urna\",\"usar\",\"usuario\",\"uÌtil\",\"utopiÌa\",\"uva\",\"vaca\",\"vaciÌo\",\"vacuna\",\"vagar\",\"vago\",\"vaina\",\"vajilla\",\"vale\",\"vaÌlido\",\"valle\",\"valor\",\"vaÌlvula\",\"vampiro\",\"vara\",\"variar\",\"varoÌn\",\"vaso\",\"vecino\",\"vector\",\"vehiÌculo\",\"veinte\",\"vejez\",\"vela\",\"velero\",\"veloz\",\"vena\",\"vencer\",\"venda\",\"veneno\",\"vengar\",\"venir\",\"venta\",\"venus\",\"ver\",\"verano\",\"verbo\",\"verde\",\"vereda\",\"verja\",\"verso\",\"verter\",\"viÌa\",\"viaje\",\"vibrar\",\"vicio\",\"viÌctima\",\"vida\",\"viÌdeo\",\"vidrio\",\"viejo\",\"viernes\",\"vigor\",\"vil\",\"villa\",\"vinagre\",\"vino\",\"vinÌƒedo\",\"violiÌn\",\"viral\",\"virgo\",\"virtud\",\"visor\",\"viÌspera\",\"vista\",\"vitamina\",\"viudo\",\"vivaz\",\"vivero\",\"vivir\",\"vivo\",\"volcaÌn\",\"volumen\",\"volver\",\"voraz\",\"votar\",\"voto\",\"voz\",\"vuelo\",\"vulgar\",\"yacer\",\"yate\",\"yegua\",\"yema\",\"yerno\",\"yeso\",\"yodo\",\"yoga\",\"yogur\",\"zafiro\",\"zanja\",\"zapato\",\"zarza\",\"zona\",\"zorro\",\"zumo\",\"zurdo\"]");

const require$$7 = /* #__PURE__ */ JSON.parse("[\"ã‚ã„ã“ãã—ã‚“\",\"ã‚ã„ã•ã¤\",\"ã‚ã„ãŸã‚™\",\"ã‚ãŠãã‚™ã‚‰\",\"ã‚ã‹ã¡ã‚ƒã‚“\",\"ã‚ãã‚‹\",\"ã‚ã‘ã‹ã‚™ãŸ\",\"ã‚ã‘ã‚‹\",\"ã‚ã“ã‹ã‚™ã‚Œã‚‹\",\"ã‚ã•ã„\",\"ã‚ã•ã²\",\"ã‚ã—ã‚ã¨\",\"ã‚ã—ã‚™ã‚ã†\",\"ã‚ã™ã‚™ã‹ã‚‹\",\"ã‚ã™ã‚™ã\",\"ã‚ããµã‚™\",\"ã‚ãŸãˆã‚‹\",\"ã‚ãŸãŸã‚ã‚‹\",\"ã‚ãŸã‚Šã¾ãˆ\",\"ã‚ãŸã‚‹\",\"ã‚ã¤ã„\",\"ã‚ã¤ã‹ã†\",\"ã‚ã£ã—ã‚…ã\",\"ã‚ã¤ã¾ã‚Š\",\"ã‚ã¤ã‚ã‚‹\",\"ã‚ã¦ãª\",\"ã‚ã¦ã¯ã¾ã‚‹\",\"ã‚ã²ã‚‹\",\"ã‚ãµã‚™ã‚‰\",\"ã‚ãµã‚™ã‚‹\",\"ã‚ãµã‚Œã‚‹\",\"ã‚ã¾ã„\",\"ã‚ã¾ã¨ã‚™\",\"ã‚ã¾ã‚„ã‹ã™\",\"ã‚ã¾ã‚Š\",\"ã‚ã¿ã‚‚ã®\",\"ã‚ã‚ã‚Šã‹\",\"ã‚ã‚„ã¾ã‚‹\",\"ã‚ã‚†ã‚€\",\"ã‚ã‚‰ã„ãã‚™ã¾\",\"ã‚ã‚‰ã—\",\"ã‚ã‚‰ã™ã—ã‚™\",\"ã‚ã‚‰ãŸã‚ã‚‹\",\"ã‚ã‚‰ã‚†ã‚‹\",\"ã‚ã‚‰ã‚ã™\",\"ã‚ã‚Šã‹ã‚™ã¨ã†\",\"ã‚ã‚ã›ã‚‹\",\"ã‚ã‚ã¦ã‚‹\",\"ã‚ã‚“ã„\",\"ã‚ã‚“ã‹ã‚™ã„\",\"ã‚ã‚“ã“\",\"ã‚ã‚“ã›ã‚™ã‚“\",\"ã‚ã‚“ã¦ã„\",\"ã‚ã‚“ãªã„\",\"ã‚ã‚“ã¾ã‚Š\",\"ã„ã„ãŸã‚™ã™\",\"ã„ãŠã‚“\",\"ã„ã‹ã‚™ã„\",\"ã„ã‹ã‚™ã\",\"ã„ããŠã„\",\"ã„ããªã‚Š\",\"ã„ãã‚‚ã®\",\"ã„ãã‚‹\",\"ã„ãã—ã‚™\",\"ã„ããµã‚™ã‚“\",\"ã„ã‘ã¯ã‚™ãª\",\"ã„ã‘ã‚“\",\"ã„ã“ã†\",\"ã„ã“ã\",\"ã„ã“ã¤\",\"ã„ã•ã¾ã—ã„\",\"ã„ã•ã‚“\",\"ã„ã—ã\",\"ã„ã—ã‚™ã‚…ã†\",\"ã„ã—ã‚™ã‚‡ã†\",\"ã„ã—ã‚™ã‚ã‚‹\",\"ã„ã™ã‚™ã¿\",\"ã„ã™ã‚™ã‚Œ\",\"ã„ã›ã„\",\"ã„ã›ãˆã²ã‚™\",\"ã„ã›ã‹ã„\",\"ã„ã›ã\",\"ã„ã›ã‚™ã‚“\",\"ã„ãã†ã‚ã†\",\"ã„ãã‹ã‚™ã—ã„\",\"ã„ãŸã‚™ã„\",\"ã„ãŸã‚™ã\",\"ã„ãŸã™ã‚™ã‚‰\",\"ã„ãŸã¿\",\"ã„ãŸã‚Šã‚\",\"ã„ã¡ãŠã†\",\"ã„ã¡ã—ã‚™\",\"ã„ã¡ã¨ã‚™\",\"ã„ã¡ã¯ã‚™\",\"ã„ã¡ãµã‚™\",\"ã„ã¡ã‚Šã‚…ã†\",\"ã„ã¤ã‹\",\"ã„ã£ã—ã‚…ã‚“\",\"ã„ã£ã›ã„\",\"ã„ã£ãã†\",\"ã„ã£ãŸã‚“\",\"ã„ã£ã¡\",\"ã„ã£ã¦ã„\",\"ã„ã£ã»ã‚šã†\",\"ã„ã¦ã•ã‚™\",\"ã„ã¦ã‚“\",\"ã„ã¨ã‚™ã†\",\"ã„ã¨ã“\",\"ã„ãªã„\",\"ã„ãªã‹\",\"ã„ã­ã‚€ã‚Š\",\"ã„ã®ã¡\",\"ã„ã®ã‚‹\",\"ã„ã¯ã¤\",\"ã„ã¯ã‚™ã‚‹\",\"ã„ã¯ã‚“\",\"ã„ã²ã‚™ã\",\"ã„ã²ã‚“\",\"ã„ãµã\",\"ã„ã¸ã‚“\",\"ã„ã»ã†\",\"ã„ã¿ã‚“\",\"ã„ã‚‚ã†ã¨\",\"ã„ã‚‚ãŸã‚Œ\",\"ã„ã‚‚ã‚Š\",\"ã„ã‚„ã‹ã‚™ã‚‹\",\"ã„ã‚„ã™\",\"ã„ã‚ˆã‹ã‚“\",\"ã„ã‚ˆã\",\"ã„ã‚‰ã„\",\"ã„ã‚‰ã™ã¨\",\"ã„ã‚Šãã‚™ã¡\",\"ã„ã‚Šã‚‡ã†\",\"ã„ã‚Œã„\",\"ã„ã‚Œã‚‚ã®\",\"ã„ã‚Œã‚‹\",\"ã„ã‚ãˆã‚“ã²ã‚šã¤\",\"ã„ã‚ã„\",\"ã„ã‚ã†\",\"ã„ã‚ã‹ã‚“\",\"ã„ã‚ã¯ã‚™\",\"ã„ã‚ã‚†ã‚‹\",\"ã„ã‚“ã‘ã‚™ã‚“ã¾ã‚\",\"ã„ã‚“ã•ã¤\",\"ã„ã‚“ã—ã‚‡ã†\",\"ã„ã‚“ã‚ˆã†\",\"ã†ãˆã\",\"ã†ãˆã‚‹\",\"ã†ãŠã•ã‚™\",\"ã†ã‹ã‚™ã„\",\"ã†ã‹ãµã‚™\",\"ã†ã‹ã¸ã‚™ã‚‹\",\"ã†ãã‚\",\"ã†ãã‚‰ã„ãª\",\"ã†ãã‚Œã‚Œ\",\"ã†ã‘ãŸã¾ã‚ã‚‹\",\"ã†ã‘ã¤ã‘\",\"ã†ã‘ã¨ã‚‹\",\"ã†ã‘ã‚‚ã¤\",\"ã†ã‘ã‚‹\",\"ã†ã“ã‚™ã‹ã™\",\"ã†ã“ã‚™ã\",\"ã†ã“ã‚“\",\"ã†ã•ãã‚™\",\"ã†ã—ãªã†\",\"ã†ã—ã‚ã‹ã‚™ã¿\",\"ã†ã™ã„\",\"ã†ã™ãã‚™\",\"ã†ã™ãã‚™ã‚‰ã„\",\"ã†ã™ã‚ã‚‹\",\"ã†ã›ã¤\",\"ã†ã¡ã‚ã‚ã›\",\"ã†ã¡ã‹ã‚™ã‚\",\"ã†ã¡ã\",\"ã†ã¡ã‚…ã†\",\"ã†ã£ã‹ã‚Š\",\"ã†ã¤ãã—ã„\",\"ã†ã£ãŸãˆã‚‹\",\"ã†ã¤ã‚‹\",\"ã†ã¨ã‚™ã‚“\",\"ã†ãªãã‚™\",\"ã†ãªã—ã‚™\",\"ã†ãªã™ã‚™ã\",\"ã†ãªã‚‹\",\"ã†ã­ã‚‹\",\"ã†ã®ã†\",\"ã†ãµã‚™ã‘ã‚™\",\"ã†ãµã‚™ã“ã‚™ãˆ\",\"ã†ã¾ã‚Œã‚‹\",\"ã†ã‚ã‚‹\",\"ã†ã‚‚ã†\",\"ã†ã‚„ã¾ã†\",\"ã†ã‚ˆã\",\"ã†ã‚‰ã‹ã‚™ãˆã™\",\"ã†ã‚‰ãã‚™ã¡\",\"ã†ã‚‰ãªã„\",\"ã†ã‚Šã‚ã‘ã‚™\",\"ã†ã‚Šãã‚Œ\",\"ã†ã‚‹ã•ã„\",\"ã†ã‚Œã—ã„\",\"ã†ã‚Œã‚†ã\",\"ã†ã‚Œã‚‹\",\"ã†ã‚ã“\",\"ã†ã‚ã\",\"ã†ã‚ã•\",\"ã†ã‚“ã“ã†\",\"ã†ã‚“ã¡ã‚“\",\"ã†ã‚“ã¦ã‚“\",\"ã†ã‚“ã¨ã‚™ã†\",\"ãˆã„ãˆã‚“\",\"ãˆã„ã‹ã‚™\",\"ãˆã„ãã‚‡ã†\",\"ãˆã„ã“ã‚™\",\"ãˆã„ã›ã„\",\"ãˆã„ãµã‚™ã‚“\",\"ãˆã„ã‚ˆã†\",\"ãˆã„ã‚\",\"ãˆãŠã‚Š\",\"ãˆã‹ã‚™ãŠ\",\"ãˆã‹ã‚™ã\",\"ãˆããŸã„\",\"ãˆãã›ã‚‹\",\"ãˆã—ã‚ƒã\",\"ãˆã™ã¦\",\"ãˆã¤ã‚‰ã‚“\",\"ãˆã®ãã‚™\",\"ãˆã»ã†ã¾ã\",\"ãˆã»ã‚“\",\"ãˆã¾ã\",\"ãˆã‚‚ã—ã‚™\",\"ãˆã‚‚ã®\",\"ãˆã‚‰ã„\",\"ãˆã‚‰ãµã‚™\",\"ãˆã‚Šã‚\",\"ãˆã‚“ãˆã‚“\",\"ãˆã‚“ã‹ã„\",\"ãˆã‚“ãã‚™\",\"ãˆã‚“ã‘ã‚™ã\",\"ãˆã‚“ã—ã‚…ã†\",\"ãˆã‚“ã›ã‚™ã¤\",\"ãˆã‚“ãã\",\"ãˆã‚“ã¡ã‚‡ã†\",\"ãˆã‚“ã¨ã¤\",\"ãŠã„ã‹ã‘ã‚‹\",\"ãŠã„ã“ã™\",\"ãŠã„ã—ã„\",\"ãŠã„ã¤ã\",\"ãŠã†ãˆã‚“\",\"ãŠã†ã•ã¾\",\"ãŠã†ã—ã‚™\",\"ãŠã†ã›ã¤\",\"ãŠã†ãŸã„\",\"ãŠã†ãµã\",\"ãŠã†ã¸ã‚™ã„\",\"ãŠã†ã‚ˆã†\",\"ãŠãˆã‚‹\",\"ãŠãŠã„\",\"ãŠãŠã†\",\"ãŠãŠã¨ã‚™ãŠã‚Š\",\"ãŠãŠã‚„\",\"ãŠãŠã‚ˆã\",\"ãŠã‹ãˆã‚Š\",\"ãŠã‹ã™ã‚™\",\"ãŠã‹ã‚™ã‚€\",\"ãŠã‹ã‚ã‚Š\",\"ãŠãã‚™ãªã†\",\"ãŠãã‚‹\",\"ãŠãã•ã¾\",\"ãŠãã—ã‚™ã‚‡ã†\",\"ãŠãã‚Šã‹ã‚™ãª\",\"ãŠãã‚‹\",\"ãŠãã‚Œã‚‹\",\"ãŠã“ã™\",\"ãŠã“ãªã†\",\"ãŠã“ã‚‹\",\"ãŠã•ãˆã‚‹\",\"ãŠã•ãªã„\",\"ãŠã•ã‚ã‚‹\",\"ãŠã—ã„ã‚Œ\",\"ãŠã—ãˆã‚‹\",\"ãŠã—ã‚™ãã‚™\",\"ãŠã—ã‚™ã•ã‚“\",\"ãŠã—ã‚ƒã‚Œ\",\"ãŠãã‚‰ã\",\"ãŠãã‚ã‚‹\",\"ãŠãŸã‹ã‚™ã„\",\"ãŠãŸã\",\"ãŠãŸã‚™ã‚„ã‹\",\"ãŠã¡ã¤ã\",\"ãŠã£ã¨\",\"ãŠã¤ã‚Š\",\"ãŠã¦ã‚™ã‹ã‘\",\"ãŠã¨ã—ã‚‚ã®\",\"ãŠã¨ãªã—ã„\",\"ãŠã¨ã‚™ã‚Š\",\"ãŠã¨ã‚™ã‚ã‹ã™\",\"ãŠã¯ã‚™ã•ã‚“\",\"ãŠã¾ã„ã‚Š\",\"ãŠã‚ã¦ã‚™ã¨ã†\",\"ãŠã‚‚ã„ã¦ã‚™\",\"ãŠã‚‚ã†\",\"ãŠã‚‚ãŸã„\",\"ãŠã‚‚ã¡ã‚ƒ\",\"ãŠã‚„ã¤\",\"ãŠã‚„ã‚†ã²ã‚™\",\"ãŠã‚ˆã»ã‚™ã™\",\"ãŠã‚‰ã‚“ãŸã‚™\",\"ãŠã‚ã™\",\"ãŠã‚“ã‹ã‚™ã\",\"ãŠã‚“ã‘ã„\",\"ãŠã‚“ã—ã‚ƒ\",\"ãŠã‚“ã›ã‚“\",\"ãŠã‚“ãŸã‚™ã‚“\",\"ãŠã‚“ã¡ã‚…ã†\",\"ãŠã‚“ã¨ã‚™ã‘ã„\",\"ã‹ã‚ã¤\",\"ã‹ã„ã‹ã‚™\",\"ã‹ã‚™ã„ã\",\"ã‹ã‚™ã„ã‘ã‚“\",\"ã‹ã‚™ã„ã“ã†\",\"ã‹ã„ã•ã¤\",\"ã‹ã„ã—ã‚ƒ\",\"ã‹ã„ã™ã„ã‚ˆã\",\"ã‹ã„ã›ã‚™ã‚“\",\"ã‹ã„ãã‚™ã†ã¨ã‚™\",\"ã‹ã„ã¤ã†\",\"ã‹ã„ã¦ã‚“\",\"ã‹ã„ã¨ã†\",\"ã‹ã„ãµã\",\"ã‹ã‚™ã„ã¸ã\",\"ã‹ã„ã»ã†\",\"ã‹ã„ã‚ˆã†\",\"ã‹ã‚™ã„ã‚‰ã„\",\"ã‹ã„ã‚\",\"ã‹ãˆã‚‹\",\"ã‹ãŠã‚Š\",\"ã‹ã‹ãˆã‚‹\",\"ã‹ã‹ã‚™ã\",\"ã‹ã‹ã‚™ã—\",\"ã‹ã‹ã‚™ã¿\",\"ã‹ãã“ã‚™\",\"ã‹ãã¨ã\",\"ã‹ã•ã‚™ã‚‹\",\"ã‹ã‚™ãã‚™ã†\",\"ã‹ãŸã„\",\"ã‹ãŸã¡\",\"ã‹ã‚™ã¡ã‚‡ã†\",\"ã‹ã‚™ã£ãã‚…ã†\",\"ã‹ã‚™ã£ã“ã†\",\"ã‹ã‚™ã£ã•ã‚“\",\"ã‹ã‚™ã£ã—ã‚‡ã†\",\"ã‹ãªã•ã‚™ã‚ã—\",\"ã‹ã®ã†\",\"ã‹ã‚™ã¯ã\",\"ã‹ãµã‚™ã‹\",\"ã‹ã»ã†\",\"ã‹ã»ã“ã‚™\",\"ã‹ã¾ã†\",\"ã‹ã¾ã»ã‚™ã“\",\"ã‹ã‚ã‚ŒãŠã‚“\",\"ã‹ã‚†ã„\",\"ã‹ã‚ˆã†ã²ã‚™\",\"ã‹ã‚‰ã„\",\"ã‹ã‚‹ã„\",\"ã‹ã‚ã†\",\"ã‹ã‚ã\",\"ã‹ã‚ã‚‰\",\"ã‹ã‚™ã‚“ã‹\",\"ã‹ã‚“ã‘ã„\",\"ã‹ã‚“ã“ã†\",\"ã‹ã‚“ã—ã‚ƒ\",\"ã‹ã‚“ãã†\",\"ã‹ã‚“ãŸã‚“\",\"ã‹ã‚“ã¡\",\"ã‹ã‚™ã‚“ã¯ã‚™ã‚‹\",\"ãã‚ã„\",\"ãã‚ã¤\",\"ãã„ã‚\",\"ãã‚™ã„ã‚“\",\"ãã†ã„\",\"ãã†ã‚“\",\"ããˆã‚‹\",\"ããŠã†\",\"ããŠã\",\"ããŠã¡\",\"ããŠã‚“\",\"ãã‹ã„\",\"ãã‹ã\",\"ãã‹ã‚“ã—ã‚ƒ\",\"ããã¦\",\"ããã¯ã‚™ã‚Š\",\"ããã‚‰ã‘ã‚™\",\"ãã‘ã‚“ã›ã„\",\"ãã“ã†\",\"ãã“ãˆã‚‹\",\"ãã“ã\",\"ãã•ã„\",\"ãã•ã\",\"ãã•ã¾\",\"ãã•ã‚‰ãã‚™\",\"ãã‚™ã—ã‚™ã‹ã‹ã‚™ã\",\"ãã‚™ã—ã\",\"ãã‚™ã—ã‚™ãŸã„ã‘ã‚“\",\"ãã‚™ã—ã‚™ã«ã£ã¦ã„\",\"ãã‚™ã—ã‚™ã‚…ã¤ã—ã‚ƒ\",\"ãã™ã†\",\"ãã›ã„\",\"ãã›ã\",\"ãã›ã¤\",\"ããã†\",\"ããã‚™ã\",\"ããã‚™ã‚“\",\"ããŸãˆã‚‹\",\"ãã¡ã‚‡ã†\",\"ãã¤ãˆã‚“\",\"ãã‚™ã£ã¡ã‚Š\",\"ãã¤ã¤ã\",\"ãã¤ã­\",\"ãã¦ã„\",\"ãã¨ã‚™ã†\",\"ãã¨ã‚™ã\",\"ããªã„\",\"ããªã‹ã‚™\",\"ããªã“\",\"ãã¬ã“ã‚™ã—\",\"ãã­ã‚“\",\"ãã®ã†\",\"ãã®ã—ãŸ\",\"ãã¯ã\",\"ãã²ã‚™ã—ã„\",\"ãã²ã‚“\",\"ããµã\",\"ããµã‚™ã‚“\",\"ãã»ã‚™ã†\",\"ãã»ã‚“\",\"ãã¾ã‚‹\",\"ãã¿ã¤\",\"ãã‚€ã™ã‚™ã‹ã—ã„\",\"ãã‚ã‚‹\",\"ãã‚‚ãŸã‚™ã‚ã—\",\"ãã‚‚ã¡\",\"ãã‚‚ã®\",\"ãã‚ƒã\",\"ãã‚„ã\",\"ãã‚™ã‚…ã†ã«ã\",\"ãã‚ˆã†\",\"ãã‚‡ã†ã‚Šã‚…ã†\",\"ãã‚‰ã„\",\"ãã‚‰ã\",\"ãã‚Šã‚“\",\"ãã‚Œã„\",\"ãã‚Œã¤\",\"ãã‚ã\",\"ãã‚™ã‚ã‚“\",\"ãã‚ã‚ã‚‹\",\"ãã‚™ã‚“ã„ã‚\",\"ãã‚“ã‹ãã—ã‚™\",\"ãã‚“ã—ã‚™ã‚‡\",\"ãã‚“ã‚ˆã†ã²ã‚™\",\"ãã‚™ã‚ã„\",\"ãã„ã™ã‚™\",\"ãã†ã‹ã‚“\",\"ãã†ã\",\"ãã†ãã‚™ã‚“\",\"ãã†ã“ã†\",\"ãã‚™ã†ã›ã„\",\"ãã†ãã†\",\"ãã‚™ã†ãŸã‚‰\",\"ãã†ãµã\",\"ãã†ã»ã‚™\",\"ãã‹ã‚“\",\"ããã‚‡ã†\",\"ãã‘ã‚™ã‚“\",\"ãã‚™ã“ã†\",\"ãã•ã„\",\"ãã•ã\",\"ãã•ã¯ã‚™ãª\",\"ãã•ã‚‹\",\"ãã—ã‚ƒã¿\",\"ãã—ã‚‡ã†\",\"ãã™ã®ã\",\"ãã™ã‚Šã‚†ã²ã‚™\",\"ãã›ã‘ã‚™\",\"ãã›ã‚“\",\"ãã‚™ãŸã„ã¦ã\",\"ããŸã‚™ã•ã‚‹\",\"ããŸã²ã‚™ã‚Œã‚‹\",\"ãã¡ã“ã¿\",\"ãã¡ã•ã\",\"ãã¤ã—ãŸ\",\"ãã‚™ã£ã™ã‚Š\",\"ãã¤ã‚ãã‚™\",\"ãã¨ã†ã¦ã‚“\",\"ãã¨ã‚™ã\",\"ããªã‚“\",\"ãã­ãã­\",\"ãã®ã†\",\"ããµã†\",\"ãã¿ã‚ã‚ã›\",\"ãã¿ãŸã¦ã‚‹\",\"ãã‚ã‚‹\",\"ãã‚„ãã—ã‚‡\",\"ãã‚‰ã™\",\"ãã‚‰ã¸ã‚™ã‚‹\",\"ãã‚‹ã¾\",\"ãã‚Œã‚‹\",\"ãã‚ã†\",\"ãã‚ã—ã„\",\"ãã‚™ã‚“ã‹ã‚“\",\"ãã‚™ã‚“ã—ã‚‡ã\",\"ãã‚™ã‚“ãŸã„\",\"ãã‚™ã‚“ã¦\",\"ã‘ã‚ãª\",\"ã‘ã„ã‹ã\",\"ã‘ã„ã‘ã‚“\",\"ã‘ã„ã“\",\"ã‘ã„ã•ã¤\",\"ã‘ã‚™ã„ã—ã‚™ã‚…ã¤\",\"ã‘ã„ãŸã„\",\"ã‘ã‚™ã„ã®ã†ã—ã‚™ã‚“\",\"ã‘ã„ã‚Œã\",\"ã‘ã„ã‚\",\"ã‘ãŠã¨ã™\",\"ã‘ãŠã‚Šã‚‚ã®\",\"ã‘ã‚™ãã‹\",\"ã‘ã‚™ãã‘ã‚™ã‚“\",\"ã‘ã‚™ããŸã‚™ã‚“\",\"ã‘ã‚™ãã¡ã‚“\",\"ã‘ã‚™ãã¨ã¤\",\"ã‘ã‚™ãã¯\",\"ã‘ã‚™ãã‚„ã\",\"ã‘ã‚™ã“ã†\",\"ã‘ã‚™ã“ãã—ã‚™ã‚‡ã†\",\"ã‘ã‚™ã•ã‚™ã„\",\"ã‘ã•ã\",\"ã‘ã‚™ã•ã‚™ã‚“\",\"ã‘ã—ã\",\"ã‘ã—ã“ã‚™ã‚€\",\"ã‘ã—ã‚‡ã†\",\"ã‘ã‚™ã™ã¨\",\"ã‘ãŸã¯ã‚™\",\"ã‘ã¡ã‚ƒã£ãµã‚š\",\"ã‘ã¡ã‚‰ã™\",\"ã‘ã¤ã‚ã¤\",\"ã‘ã¤ã„\",\"ã‘ã¤ãˆã\",\"ã‘ã£ã“ã‚“\",\"ã‘ã¤ã—ã‚™ã‚‡\",\"ã‘ã£ã›ã\",\"ã‘ã£ã¦ã„\",\"ã‘ã¤ã¾ã¤\",\"ã‘ã‚™ã¤ã‚ˆã†ã²ã‚™\",\"ã‘ã‚™ã¤ã‚Œã„\",\"ã‘ã¤ã‚ã‚“\",\"ã‘ã‚™ã¨ã‚™ã\",\"ã‘ã¨ã¯ã‚™ã™\",\"ã‘ã¨ã‚‹\",\"ã‘ãªã‘ã‚™\",\"ã‘ãªã™\",\"ã‘ãªã¿\",\"ã‘ã¬ã\",\"ã‘ã‚™ã­ã¤\",\"ã‘ã­ã‚“\",\"ã‘ã¯ã„\",\"ã‘ã‚™ã²ã‚“\",\"ã‘ãµã‚™ã‹ã„\",\"ã‘ã‚™ã»ã‚™ã\",\"ã‘ã¾ã‚Š\",\"ã‘ã¿ã‹ã‚‹\",\"ã‘ã‚€ã—\",\"ã‘ã‚€ã‚Š\",\"ã‘ã‚‚ã®\",\"ã‘ã‚‰ã„\",\"ã‘ã‚ã‘ã‚\",\"ã‘ã‚ã—ã„\",\"ã‘ã‚“ã„\",\"ã‘ã‚“ãˆã¤\",\"ã‘ã‚“ãŠ\",\"ã‘ã‚“ã‹\",\"ã‘ã‚™ã‚“ã\",\"ã‘ã‚“ã‘ã‚™ã‚“\",\"ã‘ã‚“ã“ã†\",\"ã‘ã‚“ã•ã\",\"ã‘ã‚“ã—ã‚…ã†\",\"ã‘ã‚“ã™ã†\",\"ã‘ã‚™ã‚“ãã†\",\"ã‘ã‚“ã¡ã\",\"ã‘ã‚“ã¦ã„\",\"ã‘ã‚“ã¨ã†\",\"ã‘ã‚“ãªã„\",\"ã‘ã‚“ã«ã‚“\",\"ã‘ã‚™ã‚“ãµã‚™ã¤\",\"ã‘ã‚“ã¾\",\"ã‘ã‚“ã¿ã‚“\",\"ã‘ã‚“ã‚ã„\",\"ã‘ã‚“ã‚‰ã‚“\",\"ã‘ã‚“ã‚Š\",\"ã“ã‚ãã¾\",\"ã“ã„ã¬\",\"ã“ã„ã²ã‚™ã¨\",\"ã“ã‚™ã†ã„\",\"ã“ã†ãˆã‚“\",\"ã“ã†ãŠã‚“\",\"ã“ã†ã‹ã‚“\",\"ã“ã‚™ã†ãã‚…ã†\",\"ã“ã‚™ã†ã‘ã„\",\"ã“ã†ã“ã†\",\"ã“ã†ã•ã„\",\"ã“ã†ã—ã‚™\",\"ã“ã†ã™ã„\",\"ã“ã‚™ã†ã›ã„\",\"ã“ã†ãã\",\"ã“ã†ãŸã„\",\"ã“ã†ã¡ã‚ƒ\",\"ã“ã†ã¤ã†\",\"ã“ã†ã¦ã„\",\"ã“ã†ã¨ã‚™ã†\",\"ã“ã†ãªã„\",\"ã“ã†ã¯ã„\",\"ã“ã‚™ã†ã»ã†\",\"ã“ã‚™ã†ã¾ã‚“\",\"ã“ã†ã‚‚ã\",\"ã“ã†ã‚Šã¤\",\"ã“ãˆã‚‹\",\"ã“ãŠã‚Š\",\"ã“ã‚™ã‹ã„\",\"ã“ã‚™ã‹ã‚™ã¤\",\"ã“ã‚™ã‹ã‚“\",\"ã“ãã“ã‚™\",\"ã“ãã•ã„\",\"ã“ãã¨ã†\",\"ã“ããªã„\",\"ã“ãã¯ã\",\"ã“ãã‚™ã¾\",\"ã“ã‘ã„\",\"ã“ã‘ã‚‹\",\"ã“ã“ã®ã‹\",\"ã“ã“ã‚\",\"ã“ã•ã‚\",\"ã“ã—ã¤\",\"ã“ã™ã†\",\"ã“ã›ã„\",\"ã“ã›ã\",\"ã“ã›ã‚™ã‚“\",\"ã“ããŸã‚™ã¦\",\"ã“ãŸã„\",\"ã“ãŸãˆã‚‹\",\"ã“ãŸã¤\",\"ã“ã¡ã‚‡ã†\",\"ã“ã£ã‹\",\"ã“ã¤ã“ã¤\",\"ã“ã¤ã¯ã‚™ã‚“\",\"ã“ã¤ãµã‚™\",\"ã“ã¦ã„\",\"ã“ã¦ã‚“\",\"ã“ã¨ã‹ã‚™ã‚‰\",\"ã“ã¨ã—\",\"ã“ã¨ã¯ã‚™\",\"ã“ã¨ã‚Š\",\"ã“ãªã“ã‚™ãª\",\"ã“ã­ã“ã­\",\"ã“ã®ã¾ã¾\",\"ã“ã®ã¿\",\"ã“ã®ã‚ˆ\",\"ã“ã‚™ã¯ã‚“\",\"ã“ã²ã¤ã—ã‚™\",\"ã“ãµã†\",\"ã“ãµã‚“\",\"ã“ã»ã‚™ã‚Œã‚‹\",\"ã“ã‚™ã¾ã‚ãµã‚™ã‚‰\",\"ã“ã¾ã‹ã„\",\"ã“ã‚™ã¾ã™ã‚Š\",\"ã“ã¾ã¤ãª\",\"ã“ã¾ã‚‹\",\"ã“ã‚€ãã‚™ã“\",\"ã“ã‚‚ã—ã‚™\",\"ã“ã‚‚ã¡\",\"ã“ã‚‚ã®\",\"ã“ã‚‚ã‚“\",\"ã“ã‚„ã\",\"ã“ã‚„ã¾\",\"ã“ã‚†ã†\",\"ã“ã‚†ã²ã‚™\",\"ã“ã‚ˆã„\",\"ã“ã‚ˆã†\",\"ã“ã‚Šã‚‹\",\"ã“ã‚Œãã—ã‚‡ã‚“\",\"ã“ã‚ã£ã‘\",\"ã“ã‚ã‚‚ã¦\",\"ã“ã‚ã‚Œã‚‹\",\"ã“ã‚“ã„ã‚“\",\"ã“ã‚“ã‹ã„\",\"ã“ã‚“ã\",\"ã“ã‚“ã—ã‚…ã†\",\"ã“ã‚“ã™ã„\",\"ã“ã‚“ãŸã‚™ã¦\",\"ã“ã‚“ã¨ã‚“\",\"ã“ã‚“ãªã‚“\",\"ã“ã‚“ã²ã‚™ã«\",\"ã“ã‚“ã»ã‚šã‚“\",\"ã“ã‚“ã¾ã‘\",\"ã“ã‚“ã‚„\",\"ã“ã‚“ã‚Œã„\",\"ã“ã‚“ã‚ã\",\"ã•ã‚™ã„ãˆã\",\"ã•ã„ã‹ã„\",\"ã•ã„ãã‚“\",\"ã•ã‚™ã„ã‘ã‚™ã‚“\",\"ã•ã‚™ã„ã“\",\"ã•ã„ã—ã‚‡\",\"ã•ã„ã›ã„\",\"ã•ã‚™ã„ãŸã\",\"ã•ã‚™ã„ã¡ã‚…ã†\",\"ã•ã„ã¦ã\",\"ã•ã‚™ã„ã‚Šã‚‡ã†\",\"ã•ã†ãª\",\"ã•ã‹ã„ã—\",\"ã•ã‹ã‚™ã™\",\"ã•ã‹ãª\",\"ã•ã‹ã¿ã¡\",\"ã•ã‹ã‚™ã‚‹\",\"ã•ãã‚™ã‚‡ã†\",\"ã•ãã—\",\"ã•ãã²ã‚“\",\"ã•ãã‚‰\",\"ã•ã“ã\",\"ã•ã“ã¤\",\"ã•ã™ã‚™ã‹ã‚‹\",\"ã•ã‚™ã›ã\",\"ã•ãŸã‚“\",\"ã•ã¤ãˆã„\",\"ã•ã‚™ã¤ãŠã‚“\",\"ã•ã‚™ã£ã‹\",\"ã•ã‚™ã¤ã‹ã‚™ã\",\"ã•ã£ãã‚‡ã\",\"ã•ã‚™ã£ã—\",\"ã•ã¤ã—ã‚™ã‚“\",\"ã•ã‚™ã£ãã†\",\"ã•ã¤ãŸã¯ã‚™\",\"ã•ã¤ã¾ã„ã‚‚\",\"ã•ã¦ã„\",\"ã•ã¨ã„ã‚‚\",\"ã•ã¨ã†\",\"ã•ã¨ãŠã‚„\",\"ã•ã¨ã—\",\"ã•ã¨ã‚‹\",\"ã•ã®ã†\",\"ã•ã¯ã‚™ã\",\"ã•ã²ã‚™ã—ã„\",\"ã•ã¸ã‚™ã¤\",\"ã•ã»ã†\",\"ã•ã»ã¨ã‚™\",\"ã•ã¾ã™\",\"ã•ã¿ã—ã„\",\"ã•ã¿ãŸã‚™ã‚Œ\",\"ã•ã‚€ã‘\",\"ã•ã‚ã‚‹\",\"ã•ã‚„ãˆã‚“ã¨ã‚™ã†\",\"ã•ã‚†ã†\",\"ã•ã‚ˆã†\",\"ã•ã‚ˆã\",\"ã•ã‚‰ãŸã‚™\",\"ã•ã‚™ã‚‹ãã¯ã‚™\",\"ã•ã‚ã‚„ã‹\",\"ã•ã‚ã‚‹\",\"ã•ã‚“ã„ã‚“\",\"ã•ã‚“ã‹\",\"ã•ã‚“ãã‚ƒã\",\"ã•ã‚“ã“ã†\",\"ã•ã‚“ã•ã„\",\"ã•ã‚™ã‚“ã—ã‚‡\",\"ã•ã‚“ã™ã†\",\"ã•ã‚“ã›ã„\",\"ã•ã‚“ã\",\"ã•ã‚“ã¡\",\"ã•ã‚“ã¾\",\"ã•ã‚“ã¿\",\"ã•ã‚“ã‚‰ã‚“\",\"ã—ã‚ã„\",\"ã—ã‚ã‘ã‚™\",\"ã—ã‚ã•ã£ã¦\",\"ã—ã‚ã‚ã›\",\"ã—ã„ã\",\"ã—ã„ã‚“\",\"ã—ã†ã¡\",\"ã—ãˆã„\",\"ã—ãŠã‘\",\"ã—ã‹ã„\",\"ã—ã‹ã\",\"ã—ã‚™ã‹ã‚“\",\"ã—ã“ã‚™ã¨\",\"ã—ã™ã†\",\"ã—ã‚™ãŸã‚™ã„\",\"ã—ãŸã†ã‘\",\"ã—ãŸãã‚™\",\"ã—ãŸã¦\",\"ã—ãŸã¿\",\"ã—ã¡ã‚‡ã†\",\"ã—ã¡ã‚Šã‚“\",\"ã—ã£ã‹ã‚Š\",\"ã—ã¤ã—ã‚™\",\"ã—ã¤ã‚‚ã‚“\",\"ã—ã¦ã„\",\"ã—ã¦ã\",\"ã—ã¦ã¤\",\"ã—ã‚™ã¦ã‚“\",\"ã—ã‚™ã¨ã‚™ã†\",\"ã—ãªãã‚™ã‚Œ\",\"ã—ãªã‚‚ã®\",\"ã—ãªã‚“\",\"ã—ã­ã¾\",\"ã—ã­ã‚“\",\"ã—ã®ãã‚™\",\"ã—ã®ãµã‚™\",\"ã—ã¯ã„\",\"ã—ã¯ã‚™ã‹ã‚Š\",\"ã—ã¯ã¤\",\"ã—ã¯ã‚‰ã„\",\"ã—ã¯ã‚“\",\"ã—ã²ã‚‡ã†\",\"ã—ãµã\",\"ã—ã‚™ãµã‚™ã‚“\",\"ã—ã¸ã„\",\"ã—ã»ã†\",\"ã—ã»ã‚“\",\"ã—ã¾ã†\",\"ã—ã¾ã‚‹\",\"ã—ã¿ã‚“\",\"ã—ã‚€ã‘ã‚‹\",\"ã—ã‚™ã‚€ã—ã‚‡\",\"ã—ã‚ã„\",\"ã—ã‚ã‚‹\",\"ã—ã‚‚ã‚“\",\"ã—ã‚ƒã„ã‚“\",\"ã—ã‚ƒã†ã‚“\",\"ã—ã‚ƒãŠã‚“\",\"ã—ã‚™ã‚ƒã‹ã‚™ã„ã‚‚\",\"ã—ã‚„ãã—ã‚‡\",\"ã—ã‚ƒãã»ã†\",\"ã—ã‚ƒã‘ã‚“\",\"ã—ã‚ƒã“\",\"ã—ã‚ƒã•ã‚™ã„\",\"ã—ã‚ƒã—ã‚“\",\"ã—ã‚ƒã›ã‚“\",\"ã—ã‚ƒãã†\",\"ã—ã‚ƒãŸã„\",\"ã—ã‚ƒã¡ã‚‡ã†\",\"ã—ã‚ƒã£ãã‚“\",\"ã—ã‚™ã‚ƒã¾\",\"ã—ã‚ƒã‚Šã‚“\",\"ã—ã‚ƒã‚Œã„\",\"ã—ã‚™ã‚†ã†\",\"ã—ã‚™ã‚…ã†ã—ã‚‡\",\"ã—ã‚…ãã¯ã\",\"ã—ã‚™ã‚…ã—ã‚“\",\"ã—ã‚…ã£ã›ã\",\"ã—ã‚…ã¿\",\"ã—ã‚…ã‚‰ã¯ã‚™\",\"ã—ã‚™ã‚…ã‚“ã¯ã‚™ã‚“\",\"ã—ã‚‡ã†ã‹ã„\",\"ã—ã‚‡ããŸã\",\"ã—ã‚‡ã£ã‘ã‚“\",\"ã—ã‚‡ã¨ã‚™ã†\",\"ã—ã‚‡ã‚‚ã¤\",\"ã—ã‚‰ã›ã‚‹\",\"ã—ã‚‰ã¸ã‚™ã‚‹\",\"ã—ã‚“ã‹\",\"ã—ã‚“ã“ã†\",\"ã—ã‚™ã‚“ã—ã‚™ã‚ƒ\",\"ã—ã‚“ã›ã„ã—ã‚™\",\"ã—ã‚“ã¡ã\",\"ã—ã‚“ã‚Šã‚“\",\"ã™ã‚ã‘ã‚™\",\"ã™ã‚ã—\",\"ã™ã‚ãª\",\"ã™ã‚™ã‚ã‚“\",\"ã™ã„ãˆã„\",\"ã™ã„ã‹\",\"ã™ã„ã¨ã†\",\"ã™ã‚™ã„ãµã‚™ã‚“\",\"ã™ã„ã‚ˆã†ã²ã‚™\",\"ã™ã†ã‹ã‚™ã\",\"ã™ã†ã—ã‚™ã¤\",\"ã™ã†ã›ã‚“\",\"ã™ãŠã¨ã‚™ã‚Š\",\"ã™ãã¾\",\"ã™ãã†\",\"ã™ããªã„\",\"ã™ã‘ã‚‹\",\"ã™ã“ã‚™ã„\",\"ã™ã“ã—\",\"ã™ã‚™ã•ã‚“\",\"ã™ã™ã‚™ã—ã„\",\"ã™ã™ã‚€\",\"ã™ã™ã‚ã‚‹\",\"ã™ã£ã‹ã‚Š\",\"ã™ã‚™ã£ã—ã‚Š\",\"ã™ã‚™ã£ã¨\",\"ã™ã¦ã\",\"ã™ã¦ã‚‹\",\"ã™ã­ã‚‹\",\"ã™ã®ã“\",\"ã™ã¯ãŸã‚™\",\"ã™ã¯ã‚™ã‚‰ã—ã„\",\"ã™ã‚™ã²ã‚‡ã†\",\"ã™ã‚™ãµã‚™ã¬ã‚Œ\",\"ã™ãµã‚™ã‚Š\",\"ã™ãµã‚Œ\",\"ã™ã¸ã‚™ã¦\",\"ã™ã¸ã‚™ã‚‹\",\"ã™ã‚™ã»ã†\",\"ã™ã»ã‚™ã‚“\",\"ã™ã¾ã„\",\"ã™ã‚ã—\",\"ã™ã‚‚ã†\",\"ã™ã‚„ã\",\"ã™ã‚‰ã™ã‚‰\",\"ã™ã‚‹ã‚\",\"ã™ã‚Œã¡ã‹ã‚™ã†\",\"ã™ã‚ã£ã¨\",\"ã™ã‚ã‚‹\",\"ã™ã‚“ã›ã‚™ã‚“\",\"ã™ã‚“ã»ã‚šã†\",\"ã›ã‚ãµã‚™ã‚‰\",\"ã›ã„ã‹ã¤\",\"ã›ã„ã‘ã‚™ã‚“\",\"ã›ã„ã—ã‚™\",\"ã›ã„ã‚ˆã†\",\"ã›ãŠã†\",\"ã›ã‹ã„ã‹ã‚“\",\"ã›ãã«ã‚“\",\"ã›ãã‚€\",\"ã›ãã‚†\",\"ã›ãã‚‰ã‚“ã†ã‚“\",\"ã›ã‘ã‚“\",\"ã›ã“ã†\",\"ã›ã™ã—ã‚™\",\"ã›ãŸã„\",\"ã›ãŸã‘\",\"ã›ã£ã‹ã\",\"ã›ã£ãã‚ƒã\",\"ã›ã‚™ã£ã\",\"ã›ã£ã‘ã‚“\",\"ã›ã£ã“ã¤\",\"ã›ã£ã•ãŸãã¾\",\"ã›ã¤ãã‚™ã\",\"ã›ã¤ãŸã‚™ã‚“\",\"ã›ã¤ã¦ã‚™ã‚“\",\"ã›ã£ã¯ã‚šã‚“\",\"ã›ã¤ã²ã‚™\",\"ã›ã¤ãµã‚™ã‚“\",\"ã›ã¤ã‚ã„\",\"ã›ã¤ã‚Šã¤\",\"ã›ãªã‹\",\"ã›ã®ã²ã‚™\",\"ã›ã¯ã¯ã‚™\",\"ã›ã²ã‚™ã‚\",\"ã›ã»ã‚™ã­\",\"ã›ã¾ã„\",\"ã›ã¾ã‚‹\",\"ã›ã‚ã‚‹\",\"ã›ã‚‚ãŸã‚Œ\",\"ã›ã‚Šãµ\",\"ã›ã‚™ã‚“ã‚ã\",\"ã›ã‚“ã„\",\"ã›ã‚“ãˆã„\",\"ã›ã‚“ã‹\",\"ã›ã‚“ãã‚‡\",\"ã›ã‚“ã\",\"ã›ã‚“ã‘ã‚™ã‚“\",\"ã›ã‚™ã‚“ã“ã‚™\",\"ã›ã‚“ã•ã„\",\"ã›ã‚“ã—ã‚…\",\"ã›ã‚“ã™ã„\",\"ã›ã‚“ã›ã„\",\"ã›ã‚“ãã‚™\",\"ã›ã‚“ãŸã\",\"ã›ã‚“ã¡ã‚‡ã†\",\"ã›ã‚“ã¦ã„\",\"ã›ã‚“ã¨ã†\",\"ã›ã‚“ã¬ã\",\"ã›ã‚“ã­ã‚“\",\"ã›ã‚“ã¯ã‚šã„\",\"ã›ã‚™ã‚“ãµã‚™\",\"ã›ã‚™ã‚“ã»ã‚šã†\",\"ã›ã‚“ã‚€\",\"ã›ã‚“ã‚ã‚“ã—ã‚™ã‚‡\",\"ã›ã‚“ã‚‚ã‚“\",\"ã›ã‚“ã‚„ã\",\"ã›ã‚“ã‚†ã†\",\"ã›ã‚“ã‚ˆã†\",\"ã›ã‚™ã‚“ã‚‰\",\"ã›ã‚™ã‚“ã‚Šã‚ƒã\",\"ã›ã‚“ã‚Œã„\",\"ã›ã‚“ã‚\",\"ãã‚ã\",\"ãã„ã¨ã‘ã‚™ã‚‹\",\"ãã„ã­\",\"ãã†ã‹ã‚™ã‚“ãã‚‡ã†\",\"ãã†ã\",\"ãã†ã“ã‚™\",\"ãã†ã—ã‚“\",\"ãã†ãŸã‚™ã‚“\",\"ãã†ãªã‚“\",\"ãã†ã²ã‚™\",\"ãã†ã‚ã‚“\",\"ãã†ã‚Š\",\"ããˆã‚‚ã®\",\"ããˆã‚“\",\"ãã‹ã‚™ã„\",\"ãã‘ã‚™ã\",\"ãã“ã†\",\"ãã“ãã“\",\"ãã•ã‚™ã„\",\"ãã—ãª\",\"ãã›ã„\",\"ãã›ã‚“\",\"ãããã‚™\",\"ããŸã‚™ã¦ã‚‹\",\"ãã¤ã†\",\"ãã¤ãˆã‚“\",\"ãã£ã‹ã‚“\",\"ãã¤ãã‚™ã‚‡ã†\",\"ãã£ã‘ã¤\",\"ãã£ã“ã†\",\"ãã£ã›ã‚“\",\"ãã£ã¨\",\"ãã¨ã‹ã‚™ã‚\",\"ãã¨ã¤ã‚™ã‚‰\",\"ããªãˆã‚‹\",\"ããªãŸ\",\"ããµã»ã‚™\",\"ãã»ã‚™ã\",\"ãã»ã‚™ã‚\",\"ãã¾ã¤\",\"ãã¾ã‚‹\",\"ãã‚€ã\",\"ãã‚€ã‚Šãˆ\",\"ãã‚ã‚‹\",\"ãã‚‚ãã‚‚\",\"ãã‚ˆã‹ã›ã‚™\",\"ãã‚‰ã¾ã‚\",\"ãã‚ã†\",\"ãã‚“ã‹ã„\",\"ãã‚“ã‘ã„\",\"ãã‚“ã•ã‚™ã„\",\"ãã‚“ã—ã¤\",\"ãã‚“ãã‚™ã\",\"ãã‚“ã¡ã‚‡ã†\",\"ãã‚™ã‚“ã²ã‚™\",\"ãã‚™ã‚“ãµã‚™ã‚“\",\"ãã‚“ã¿ã‚“\",\"ãŸã‚ã„\",\"ãŸã„ã„ã‚“\",\"ãŸã„ã†ã‚“\",\"ãŸã„ãˆã\",\"ãŸã„ãŠã†\",\"ãŸã‚™ã„ã‹ã‚™ã\",\"ãŸã„ã\",\"ãŸã„ãã‚™ã†\",\"ãŸã„ã‘ã‚“\",\"ãŸã„ã“\",\"ãŸã„ã•ã‚™ã„\",\"ãŸã‚™ã„ã—ã‚™ã‚‡ã†ãµã‚™\",\"ãŸã‚™ã„ã™ã\",\"ãŸã„ã›ã¤\",\"ãŸã„ãã†\",\"ãŸã‚™ã„ãŸã„\",\"ãŸã„ã¡ã‚‡ã†\",\"ãŸã„ã¦ã„\",\"ãŸã‚™ã„ã¨ã‚™ã“ã‚\",\"ãŸã„ãªã„\",\"ãŸã„ã­ã¤\",\"ãŸã„ã®ã†\",\"ãŸã„ã¯ã‚“\",\"ãŸã‚™ã„ã²ã‚‡ã†\",\"ãŸã„ãµã†\",\"ãŸã„ã¸ã‚“\",\"ãŸã„ã»\",\"ãŸã„ã¾ã¤ã¯ã‚™ãª\",\"ãŸã„ã¿ã‚“ãã‚™\",\"ãŸã„ã‚€\",\"ãŸã„ã‚ã‚“\",\"ãŸã„ã‚„ã\",\"ãŸã„ã‚ˆã†\",\"ãŸã„ã‚‰\",\"ãŸã„ã‚Šã‚‡ã\",\"ãŸã„ã‚‹\",\"ãŸã„ã‚ã‚“\",\"ãŸã†ãˆ\",\"ãŸãˆã‚‹\",\"ãŸãŠã™\",\"ãŸãŠã‚‹\",\"ãŸãŠã‚Œã‚‹\",\"ãŸã‹ã„\",\"ãŸã‹ã­\",\"ãŸãã²ã‚™\",\"ãŸãã•ã‚“\",\"ãŸã“ã\",\"ãŸã“ã‚„ã\",\"ãŸã•ã„\",\"ãŸã—ã•ã‚™ã‚“\",\"ãŸã‚™ã—ã‚™ã‚ƒã‚Œ\",\"ãŸã™ã‘ã‚‹\",\"ãŸã™ã‚™ã•ã‚ã‚‹\",\"ãŸãã‹ã‚™ã‚Œ\",\"ãŸãŸã‹ã†\",\"ãŸãŸã\",\"ãŸãŸã‚™ã—ã„\",\"ãŸãŸã¿\",\"ãŸã¡ã¯ã‚™ãª\",\"ãŸã‚™ã£ã‹ã„\",\"ãŸã‚™ã£ãã‚ƒã\",\"ãŸã‚™ã£ã“\",\"ãŸã‚™ã£ã—ã‚…ã¤\",\"ãŸã‚™ã£ãŸã„\",\"ãŸã¦ã‚‹\",\"ãŸã¨ãˆã‚‹\",\"ãŸãªã¯ã‚™ãŸ\",\"ãŸã«ã‚“\",\"ãŸã¬ã\",\"ãŸã®ã—ã¿\",\"ãŸã¯ã¤\",\"ãŸãµã‚™ã‚“\",\"ãŸã¸ã‚™ã‚‹\",\"ãŸã»ã‚™ã†\",\"ãŸã¾ã“ã‚™\",\"ãŸã¾ã‚‹\",\"ãŸã‚™ã‚€ã‚‹\",\"ãŸã‚ã„ã\",\"ãŸã‚ã™\",\"ãŸã‚ã‚‹\",\"ãŸã‚‚ã¤\",\"ãŸã‚„ã™ã„\",\"ãŸã‚ˆã‚‹\",\"ãŸã‚‰ã™\",\"ãŸã‚Šãã»ã‚“ã‹ã‚™ã‚“\",\"ãŸã‚Šã‚‡ã†\",\"ãŸã‚Šã‚‹\",\"ãŸã‚‹ã¨\",\"ãŸã‚Œã‚‹\",\"ãŸã‚Œã‚“ã¨\",\"ãŸã‚ã£ã¨\",\"ãŸã‚ã‚€ã‚Œã‚‹\",\"ãŸã‚™ã‚“ã‚ã¤\",\"ãŸã‚“ã„\",\"ãŸã‚“ãŠã‚“\",\"ãŸã‚“ã‹\",\"ãŸã‚“ã\",\"ãŸã‚“ã‘ã‚“\",\"ãŸã‚“ã“ã‚™\",\"ãŸã‚“ã•ã‚“\",\"ãŸã‚“ã—ã‚™ã‚‡ã†ã²ã‚™\",\"ãŸã‚™ã‚“ã›ã„\",\"ãŸã‚“ãã\",\"ãŸã‚“ãŸã„\",\"ãŸã‚™ã‚“ã¡\",\"ãŸã‚“ã¦ã„\",\"ãŸã‚“ã¨ã†\",\"ãŸã‚™ã‚“ãª\",\"ãŸã‚“ã«ã‚“\",\"ãŸã‚™ã‚“ã­ã¤\",\"ãŸã‚“ã®ã†\",\"ãŸã‚“ã²ã‚šã‚“\",\"ãŸã‚™ã‚“ã»ã‚™ã†\",\"ãŸã‚“ã¾ã¤\",\"ãŸã‚“ã‚ã„\",\"ãŸã‚™ã‚“ã‚Œã¤\",\"ãŸã‚™ã‚“ã‚\",\"ãŸã‚™ã‚“ã‚\",\"ã¡ã‚ã„\",\"ã¡ã‚ã‚“\",\"ã¡ã„ã\",\"ã¡ã„ã•ã„\",\"ã¡ãˆã‚“\",\"ã¡ã‹ã„\",\"ã¡ã‹ã‚‰\",\"ã¡ãã‚…ã†\",\"ã¡ãã‚“\",\"ã¡ã‘ã„ã™ã‚™\",\"ã¡ã‘ã‚“\",\"ã¡ã“ã\",\"ã¡ã•ã„\",\"ã¡ã—ã\",\"ã¡ã—ã‚Šã‚‡ã†\",\"ã¡ã›ã„\",\"ã¡ãã†\",\"ã¡ãŸã„\",\"ã¡ãŸã‚“\",\"ã¡ã¡ãŠã‚„\",\"ã¡ã¤ã—ã‚™ã‚‡\",\"ã¡ã¦ã\",\"ã¡ã¦ã‚“\",\"ã¡ã¬ã\",\"ã¡ã¬ã‚Š\",\"ã¡ã®ã†\",\"ã¡ã²ã‚‡ã†\",\"ã¡ã¸ã„ã›ã‚“\",\"ã¡ã»ã†\",\"ã¡ã¾ãŸ\",\"ã¡ã¿ã¤\",\"ã¡ã¿ã¨ã‚™ã‚\",\"ã¡ã‚ã„ã¨ã‚™\",\"ã¡ã‚ƒã‚“ã“ãªã¸ã‚™\",\"ã¡ã‚…ã†ã„\",\"ã¡ã‚†ã‚Šã‚‡ã\",\"ã¡ã‚‡ã†ã—\",\"ã¡ã‚‡ã•ãã‘ã‚“\",\"ã¡ã‚‰ã—\",\"ã¡ã‚‰ã¿\",\"ã¡ã‚Šã‹ã‚™ã¿\",\"ã¡ã‚Šã‚‡ã†\",\"ã¡ã‚‹ã¨ã‚™\",\"ã¡ã‚ã‚\",\"ã¡ã‚“ãŸã„\",\"ã¡ã‚“ã‚‚ã\",\"ã¤ã„ã‹\",\"ã¤ã„ãŸã¡\",\"ã¤ã†ã‹\",\"ã¤ã†ã—ã‚™ã‚‡ã†\",\"ã¤ã†ã¯ã‚“\",\"ã¤ã†ã‚\",\"ã¤ã‹ã†\",\"ã¤ã‹ã‚Œã‚‹\",\"ã¤ãã­\",\"ã¤ãã‚‹\",\"ã¤ã‘ã­\",\"ã¤ã‘ã‚‹\",\"ã¤ã“ã‚™ã†\",\"ã¤ãŸãˆã‚‹\",\"ã¤ã¤ã‚™ã\",\"ã¤ã¤ã—ã‚™\",\"ã¤ã¤ã‚€\",\"ã¤ã¨ã‚ã‚‹\",\"ã¤ãªã‹ã‚™ã‚‹\",\"ã¤ãªã¿\",\"ã¤ã­ã¤ã‚™ã­\",\"ã¤ã®ã‚‹\",\"ã¤ãµã‚™ã™\",\"ã¤ã¾ã‚‰ãªã„\",\"ã¤ã¾ã‚‹\",\"ã¤ã¿ã\",\"ã¤ã‚ãŸã„\",\"ã¤ã‚‚ã‚Š\",\"ã¤ã‚‚ã‚‹\",\"ã¤ã‚ˆã„\",\"ã¤ã‚‹ã»ã‚™\",\"ã¤ã‚‹ã¿ã\",\"ã¤ã‚ã‚‚ã®\",\"ã¤ã‚ã‚Š\",\"ã¦ã‚ã—\",\"ã¦ã‚ã¦\",\"ã¦ã‚ã¿\",\"ã¦ã„ãŠã‚“\",\"ã¦ã„ã‹\",\"ã¦ã„ã\",\"ã¦ã„ã‘ã„\",\"ã¦ã„ã“ã\",\"ã¦ã„ã•ã¤\",\"ã¦ã„ã—\",\"ã¦ã„ã›ã„\",\"ã¦ã„ãŸã„\",\"ã¦ã„ã¨ã‚™\",\"ã¦ã„ã­ã„\",\"ã¦ã„ã²ã‚‡ã†\",\"ã¦ã„ã¸ã‚“\",\"ã¦ã„ã»ã‚™ã†\",\"ã¦ã†ã¡\",\"ã¦ãŠãã‚Œ\",\"ã¦ãã¨ã†\",\"ã¦ãã²ã‚™\",\"ã¦ã‚™ã“ã»ã‚™ã“\",\"ã¦ã•ãã‚™ã‚‡ã†\",\"ã¦ã•ã‘ã‚™\",\"ã¦ã™ã‚Š\",\"ã¦ãã†\",\"ã¦ã¡ã‹ã‚™ã„\",\"ã¦ã¡ã‚‡ã†\",\"ã¦ã¤ã‹ã‚™ã\",\"ã¦ã¤ã¤ã‚™ã\",\"ã¦ã‚™ã£ã¯ã‚š\",\"ã¦ã¤ã»ã‚™ã†\",\"ã¦ã¤ã‚„\",\"ã¦ã‚™ã¬ã‹ãˆ\",\"ã¦ã¬ã\",\"ã¦ã¬ãã‚™ã„\",\"ã¦ã®ã²ã‚‰\",\"ã¦ã¯ã„\",\"ã¦ãµã‚™ãã‚\",\"ã¦ãµãŸã‚™\",\"ã¦ã»ã¨ã‚™ã\",\"ã¦ã»ã‚“\",\"ã¦ã¾ãˆ\",\"ã¦ã¾ãã™ã‚™ã—\",\"ã¦ã¿ã—ã‚™ã‹\",\"ã¦ã¿ã‚„ã‘ã‚™\",\"ã¦ã‚‰ã™\",\"ã¦ã‚Œã²ã‚™\",\"ã¦ã‚ã‘\",\"ã¦ã‚ãŸã—\",\"ã¦ã‚™ã‚“ã‚ã¤\",\"ã¦ã‚“ã„ã‚“\",\"ã¦ã‚“ã‹ã„\",\"ã¦ã‚“ã\",\"ã¦ã‚“ãã‚™\",\"ã¦ã‚“ã‘ã‚“\",\"ã¦ã‚“ã“ã‚™ã\",\"ã¦ã‚“ã•ã„\",\"ã¦ã‚“ã—\",\"ã¦ã‚“ã™ã†\",\"ã¦ã‚™ã‚“ã¡\",\"ã¦ã‚“ã¦ã\",\"ã¦ã‚“ã¨ã†\",\"ã¦ã‚“ãªã„\",\"ã¦ã‚“ãµã‚šã‚‰\",\"ã¦ã‚“ã»ã‚™ã†ãŸã‚™ã„\",\"ã¦ã‚“ã‚ã¤\",\"ã¦ã‚“ã‚‰ã‚“ã‹ã„\",\"ã¦ã‚™ã‚“ã‚Šã‚‡ã\",\"ã¦ã‚™ã‚“ã‚\",\"ã¨ã‚™ã‚ã„\",\"ã¨ã„ã‚Œ\",\"ã¨ã‚™ã†ã‹ã‚“\",\"ã¨ã†ãã‚…ã†\",\"ã¨ã‚™ã†ãã‚™\",\"ã¨ã†ã—\",\"ã¨ã†ã‚€ãã‚™\",\"ã¨ãŠã„\",\"ã¨ãŠã‹\",\"ã¨ãŠã\",\"ã¨ãŠã™\",\"ã¨ãŠã‚‹\",\"ã¨ã‹ã„\",\"ã¨ã‹ã™\",\"ã¨ããŠã‚Š\",\"ã¨ãã¨ã‚™ã\",\"ã¨ãã„\",\"ã¨ãã—ã‚…ã†\",\"ã¨ãã¦ã‚“\",\"ã¨ãã«\",\"ã¨ãã¸ã‚™ã¤\",\"ã¨ã‘ã„\",\"ã¨ã‘ã‚‹\",\"ã¨ã“ã‚„\",\"ã¨ã•ã‹\",\"ã¨ã—ã‚‡ã‹ã‚“\",\"ã¨ãã†\",\"ã¨ãŸã‚“\",\"ã¨ã¡ã‚…ã†\",\"ã¨ã£ãã‚…ã†\",\"ã¨ã£ãã‚“\",\"ã¨ã¤ã›ã‚™ã‚“\",\"ã¨ã¤ã«ã‚…ã†\",\"ã¨ã¨ã‚™ã‘ã‚‹\",\"ã¨ã¨ã®ãˆã‚‹\",\"ã¨ãªã„\",\"ã¨ãªãˆã‚‹\",\"ã¨ãªã‚Š\",\"ã¨ã®ã•ã¾\",\"ã¨ã¯ã‚™ã™\",\"ã¨ã‚™ãµã‚™ã‹ã‚™ã‚\",\"ã¨ã»ã†\",\"ã¨ã¾ã‚‹\",\"ã¨ã‚ã‚‹\",\"ã¨ã‚‚ãŸã‚™ã¡\",\"ã¨ã‚‚ã‚‹\",\"ã¨ã‚™ã‚ˆã†ã²ã‚™\",\"ã¨ã‚‰ãˆã‚‹\",\"ã¨ã‚“ã‹ã¤\",\"ã¨ã‚™ã‚“ãµã‚™ã‚Š\",\"ãªã„ã‹ã\",\"ãªã„ã“ã†\",\"ãªã„ã—ã‚‡\",\"ãªã„ã™\",\"ãªã„ã›ã‚“\",\"ãªã„ãã†\",\"ãªãŠã™\",\"ãªã‹ã‚™ã„\",\"ãªãã™\",\"ãªã‘ã‚™ã‚‹\",\"ãªã“ã†ã¨ã‚™\",\"ãªã•ã‘\",\"ãªãŸã¦ã‚™ã“ã“\",\"ãªã£ã¨ã†\",\"ãªã¤ã‚„ã™ã¿\",\"ãªãªãŠã—\",\"ãªã«ã“ã‚™ã¨\",\"ãªã«ã‚‚ã®\",\"ãªã«ã‚\",\"ãªã®ã‹\",\"ãªãµãŸã‚™\",\"ãªã¾ã„ã\",\"ãªã¾ãˆ\",\"ãªã¾ã¿\",\"ãªã¿ãŸã‚™\",\"ãªã‚ã‚‰ã‹\",\"ãªã‚ã‚‹\",\"ãªã‚„ã‚€\",\"ãªã‚‰ã†\",\"ãªã‚‰ã²ã‚™\",\"ãªã‚‰ãµã‚™\",\"ãªã‚Œã‚‹\",\"ãªã‚ã¨ã²ã‚™\",\"ãªã‚ã¯ã‚™ã‚Š\",\"ã«ã‚ã†\",\"ã«ã„ã‹ã‚™ãŸ\",\"ã«ã†ã‘\",\"ã«ãŠã„\",\"ã«ã‹ã„\",\"ã«ã‹ã‚™ã¦\",\"ã«ãã²ã‚™\",\"ã«ãã—ã¿\",\"ã«ãã¾ã‚“\",\"ã«ã‘ã‚™ã‚‹\",\"ã«ã•ã‚“ã‹ãŸã‚“ã\",\"ã«ã—ã\",\"ã«ã›ã‚‚ã®\",\"ã«ã¡ã—ã‚™ã‚‡ã†\",\"ã«ã¡ã‚ˆã†ã²ã‚™\",\"ã«ã£ã‹\",\"ã«ã£ã\",\"ã«ã£ã‘ã„\",\"ã«ã£ã“ã†\",\"ã«ã£ã•ã‚“\",\"ã«ã£ã—ã‚‡ã\",\"ã«ã£ã™ã†\",\"ã«ã£ã›ã\",\"ã«ã£ã¦ã„\",\"ã«ãªã†\",\"ã«ã»ã‚“\",\"ã«ã¾ã‚\",\"ã«ã‚‚ã¤\",\"ã«ã‚„ã‚Š\",\"ã«ã‚…ã†ã„ã‚“\",\"ã«ã‚Šã‚“ã—ã‚ƒ\",\"ã«ã‚ã¨ã‚Š\",\"ã«ã‚“ã„\",\"ã«ã‚“ã‹\",\"ã«ã‚“ã\",\"ã«ã‚“ã‘ã‚™ã‚“\",\"ã«ã‚“ã—ã\",\"ã«ã‚“ã™ã‚™ã†\",\"ã«ã‚“ãã†\",\"ã«ã‚“ãŸã„\",\"ã«ã‚“ã¡\",\"ã«ã‚“ã¦ã„\",\"ã«ã‚“ã«ã\",\"ã«ã‚“ãµã‚š\",\"ã«ã‚“ã¾ã‚Š\",\"ã«ã‚“ã‚€\",\"ã«ã‚“ã‚ã„\",\"ã«ã‚“ã‚ˆã†\",\"ã¬ã„ããã‚™\",\"ã¬ã‹ã™\",\"ã¬ãã‚™ã„ã¨ã‚‹\",\"ã¬ãã‚™ã†\",\"ã¬ãã‚‚ã‚Š\",\"ã¬ã™ã‚€\",\"ã¬ã¾ãˆã²ã‚™\",\"ã¬ã‚ã‚Š\",\"ã¬ã‚‰ã™\",\"ã¬ã‚“ã¡ã‚ƒã\",\"ã­ã‚ã‘ã‚™\",\"ã­ã„ã\",\"ã­ã„ã‚‹\",\"ã­ã„ã‚\",\"ã­ãã‚™ã›\",\"ã­ããŸã„\",\"ã­ãã‚‰\",\"ã­ã“ã›ã‚™\",\"ã­ã“ã‚€\",\"ã­ã•ã‘ã‚™\",\"ã­ã™ã“ã‚™ã™\",\"ã­ãã¸ã‚™ã‚‹\",\"ã­ãŸã‚™ã‚“\",\"ã­ã¤ã„\",\"ã­ã£ã—ã‚“\",\"ã­ã¤ãã‚™ã†\",\"ã­ã£ãŸã„ãã‚™ã‚‡\",\"ã­ãµã‚™ãã\",\"ã­ãµãŸã‚™\",\"ã­ã»ã‚™ã†\",\"ã­ã»ã‚Šã¯ã»ã‚Š\",\"ã­ã¾ã\",\"ã­ã¾ã‚ã—\",\"ã­ã¿ã¿\",\"ã­ã‚€ã„\",\"ã­ã‚€ãŸã„\",\"ã­ã‚‚ã¨\",\"ã­ã‚‰ã†\",\"ã­ã‚ã•ã‚™\",\"ã­ã‚“ã„ã‚Š\",\"ã­ã‚“ãŠã—\",\"ã­ã‚“ã‹ã‚“\",\"ã­ã‚“ãã‚“\",\"ã­ã‚“ãã‚™\",\"ã­ã‚“ã•ã‚™\",\"ã­ã‚“ã—\",\"ã­ã‚“ã¡ã‚ƒã\",\"ã­ã‚“ã¨ã‚™\",\"ã­ã‚“ã²ã‚š\",\"ã­ã‚“ãµã‚™ã¤\",\"ã­ã‚“ã¾ã¤\",\"ã­ã‚“ã‚Šã‚‡ã†\",\"ã­ã‚“ã‚Œã„\",\"ã®ã„ã™ã‚™\",\"ã®ãŠã¤ã‚™ã¾\",\"ã®ã‹ã‚™ã™\",\"ã®ããªã¿\",\"ã®ã“ãã‚™ã‚Š\",\"ã®ã“ã™\",\"ã®ã“ã‚‹\",\"ã®ã›ã‚‹\",\"ã®ãã‚™ã\",\"ã®ãã‚™ã‚€\",\"ã®ãŸã¾ã†\",\"ã®ã¡ã»ã¨ã‚™\",\"ã®ã£ã\",\"ã®ã¯ã‚™ã™\",\"ã®ã¯ã‚‰\",\"ã®ã¸ã‚™ã‚‹\",\"ã®ã»ã‚™ã‚‹\",\"ã®ã¿ã‚‚ã®\",\"ã®ã‚„ã¾\",\"ã®ã‚‰ã„ã¬\",\"ã®ã‚‰ã­ã“\",\"ã®ã‚Šã‚‚ã®\",\"ã®ã‚Šã‚†ã\",\"ã®ã‚Œã‚“\",\"ã®ã‚“ã\",\"ã¯ã‚™ã‚ã„\",\"ã¯ã‚ã\",\"ã¯ã‚™ã‚ã•ã‚“\",\"ã¯ã‚™ã„ã‹\",\"ã¯ã‚™ã„ã\",\"ã¯ã„ã‘ã‚“\",\"ã¯ã„ã“ã‚™\",\"ã¯ã„ã—ã‚“\",\"ã¯ã„ã™ã„\",\"ã¯ã„ã›ã‚“\",\"ã¯ã„ãã†\",\"ã¯ã„ã¡\",\"ã¯ã‚™ã„ã¯ã‚™ã„\",\"ã¯ã„ã‚Œã¤\",\"ã¯ãˆã‚‹\",\"ã¯ãŠã‚‹\",\"ã¯ã‹ã„\",\"ã¯ã‚™ã‹ã‚Š\",\"ã¯ã‹ã‚‹\",\"ã¯ãã—ã‚…\",\"ã¯ã‘ã‚“\",\"ã¯ã“ãµã‚™\",\"ã¯ã•ã¿\",\"ã¯ã•ã‚“\",\"ã¯ã—ã“ã‚™\",\"ã¯ã‚™ã—ã‚‡\",\"ã¯ã—ã‚‹\",\"ã¯ã›ã‚‹\",\"ã¯ã‚šãã“ã‚“\",\"ã¯ãã‚“\",\"ã¯ãŸã‚“\",\"ã¯ã¡ã¿ã¤\",\"ã¯ã¤ãŠã‚“\",\"ã¯ã£ã‹ã\",\"ã¯ã¤ã‚™ã\",\"ã¯ã£ãã‚Š\",\"ã¯ã£ãã¤\",\"ã¯ã£ã‘ã‚“\",\"ã¯ã£ã“ã†\",\"ã¯ã£ã•ã‚“\",\"ã¯ã£ã—ã‚“\",\"ã¯ã£ãŸã¤\",\"ã¯ã£ã¡ã‚…ã†\",\"ã¯ã£ã¦ã‚“\",\"ã¯ã£ã²ã‚šã‚‡ã†\",\"ã¯ã£ã»ã‚šã†\",\"ã¯ãªã™\",\"ã¯ãªã²ã‚™\",\"ã¯ã«ã‹ã‚€\",\"ã¯ãµã‚™ã‚‰ã—\",\"ã¯ã¿ã‹ã‚™ã\",\"ã¯ã‚€ã‹ã†\",\"ã¯ã‚ã¤\",\"ã¯ã‚„ã„\",\"ã¯ã‚„ã—\",\"ã¯ã‚‰ã†\",\"ã¯ã‚ã†ãƒã‚“\",\"ã¯ã‚ã„\",\"ã¯ã‚“ã„\",\"ã¯ã‚“ãˆã„\",\"ã¯ã‚“ãŠã‚“\",\"ã¯ã‚“ã‹ã\",\"ã¯ã‚“ãã‚‡ã†\",\"ã¯ã‚™ã‚“ãã‚™ã¿\",\"ã¯ã‚“ã“\",\"ã¯ã‚“ã—ã‚ƒ\",\"ã¯ã‚“ã™ã†\",\"ã¯ã‚“ãŸã‚™ã‚“\",\"ã¯ã‚šã‚“ã¡\",\"ã¯ã‚šã‚“ã¤\",\"ã¯ã‚“ã¦ã„\",\"ã¯ã‚“ã¨ã—\",\"ã¯ã‚“ã®ã†\",\"ã¯ã‚“ã¯ã‚š\",\"ã¯ã‚“ãµã‚™ã‚“\",\"ã¯ã‚“ã¸ã‚šã‚“\",\"ã¯ã‚“ã»ã‚™ã†ã\",\"ã¯ã‚“ã‚ã„\",\"ã¯ã‚“ã‚‰ã‚“\",\"ã¯ã‚“ã‚ã‚“\",\"ã²ã„ã\",\"ã²ã†ã‚“\",\"ã²ãˆã‚‹\",\"ã²ã‹ã\",\"ã²ã‹ã‚Š\",\"ã²ã‹ã‚‹\",\"ã²ã‹ã‚“\",\"ã²ãã„\",\"ã²ã‘ã¤\",\"ã²ã“ã†ã\",\"ã²ã“ã\",\"ã²ã•ã„\",\"ã²ã•ã—ãµã‚™ã‚Š\",\"ã²ã•ã‚“\",\"ã²ã‚™ã—ã‚™ã‚…ã¤ã‹ã‚“\",\"ã²ã—ã‚‡\",\"ã²ãã‹\",\"ã²ãã‚€\",\"ã²ãŸã‚€ã\",\"ã²ãŸã‚™ã‚Š\",\"ã²ãŸã‚‹\",\"ã²ã¤ãã‚™\",\"ã²ã£ã“ã—\",\"ã²ã£ã—\",\"ã²ã¤ã—ã‚™ã‚…ã²ã‚“\",\"ã²ã£ã™\",\"ã²ã¤ã›ã‚™ã‚“\",\"ã²ã‚šã£ãŸã‚Š\",\"ã²ã‚šã£ã¡ã‚Š\",\"ã²ã¤ã‚ˆã†\",\"ã²ã¦ã„\",\"ã²ã¨ã“ã‚™ã¿\",\"ã²ãªã¾ã¤ã‚Š\",\"ã²ãªã‚“\",\"ã²ã­ã‚‹\",\"ã²ã¯ã‚“\",\"ã²ã²ã‚™ã\",\"ã²ã²ã‚‡ã†\",\"ã²ã»ã†\",\"ã²ã¾ã‚ã‚Š\",\"ã²ã¾ã‚“\",\"ã²ã¿ã¤\",\"ã²ã‚ã„\",\"ã²ã‚ã—ã‚™ã—\",\"ã²ã‚„ã‘\",\"ã²ã‚„ã™\",\"ã²ã‚ˆã†\",\"ã²ã‚™ã‚‡ã†ã\",\"ã²ã‚‰ã‹ã‚™ãª\",\"ã²ã‚‰ã\",\"ã²ã‚Šã¤\",\"ã²ã‚Šã‚‡ã†\",\"ã²ã‚‹ã¾\",\"ã²ã‚‹ã‚„ã™ã¿\",\"ã²ã‚Œã„\",\"ã²ã‚ã„\",\"ã²ã‚ã†\",\"ã²ã‚ã\",\"ã²ã‚ã‚†ã\",\"ã²ã‚“ã‹ã\",\"ã²ã‚“ã‘ã¤\",\"ã²ã‚“ã“ã‚“\",\"ã²ã‚“ã—ã‚…\",\"ã²ã‚“ãã†\",\"ã²ã‚šã‚“ã¡\",\"ã²ã‚“ã¯ã‚šã‚“\",\"ã²ã‚™ã‚“ã»ã‚™ã†\",\"ãµã‚ã‚“\",\"ãµã„ã†ã¡\",\"ãµã†ã‘ã„\",\"ãµã†ã›ã‚“\",\"ãµã‚šã†ãŸã‚ã†\",\"ãµã†ã¨ã†\",\"ãµã†ãµ\",\"ãµãˆã‚‹\",\"ãµãŠã‚“\",\"ãµã‹ã„\",\"ãµãã‚“\",\"ãµãã•ã‚™ã¤\",\"ãµããµã‚™ãã‚\",\"ãµã“ã†\",\"ãµã•ã„\",\"ãµã—ãã‚™\",\"ãµã—ã‚™ã¿\",\"ãµã™ã¾\",\"ãµã›ã„\",\"ãµã›ãã‚™\",\"ãµãã\",\"ãµã‚™ãŸã«ã\",\"ãµãŸã‚“\",\"ãµã¡ã‚‡ã†\",\"ãµã¤ã†\",\"ãµã¤ã‹\",\"ãµã£ã‹ã¤\",\"ãµã£ã\",\"ãµã£ã“ã\",\"ãµã‚™ã¨ã‚™ã†\",\"ãµã¨ã‚‹\",\"ãµã¨ã‚“\",\"ãµã®ã†\",\"ãµã¯ã„\",\"ãµã²ã‚‡ã†\",\"ãµã¸ã‚“\",\"ãµã¾ã‚“\",\"ãµã¿ã‚“\",\"ãµã‚ã¤\",\"ãµã‚ã‚“\",\"ãµã‚ˆã†\",\"ãµã‚Šã“\",\"ãµã‚Šã‚‹\",\"ãµã‚‹ã„\",\"ãµã‚“ã„ã\",\"ãµã‚™ã‚“ã‹ã‚™ã\",\"ãµã‚™ã‚“ãã‚™\",\"ãµã‚“ã—ã¤\",\"ãµã‚™ã‚“ã›ã\",\"ãµã‚“ãã†\",\"ãµã‚™ã‚“ã»ã‚šã†\",\"ã¸ã„ã‚ã‚“\",\"ã¸ã„ãŠã‚“\",\"ã¸ã„ã‹ã‚™ã„\",\"ã¸ã„ã\",\"ã¸ã„ã‘ã‚™ã‚“\",\"ã¸ã„ã“ã†\",\"ã¸ã„ã•\",\"ã¸ã„ã—ã‚ƒ\",\"ã¸ã„ã›ã¤\",\"ã¸ã„ã\",\"ã¸ã„ãŸã\",\"ã¸ã„ã¦ã‚“\",\"ã¸ã„ã­ã¤\",\"ã¸ã„ã‚\",\"ã¸ãã‹ã‚™\",\"ã¸ã“ã‚€\",\"ã¸ã‚™ã«ã„ã‚\",\"ã¸ã‚™ã«ã—ã‚‡ã†ã‹ã‚™\",\"ã¸ã‚‰ã™\",\"ã¸ã‚“ã‹ã‚“\",\"ã¸ã‚™ã‚“ãã‚‡ã†\",\"ã¸ã‚™ã‚“ã“ã‚™ã—\",\"ã¸ã‚“ã•ã„\",\"ã¸ã‚“ãŸã„\",\"ã¸ã‚™ã‚“ã‚Š\",\"ã»ã‚ã‚“\",\"ã»ã„ã\",\"ã»ã‚™ã†ãã‚™ã‚‡\",\"ã»ã†ã“ã\",\"ã»ã†ãã†\",\"ã»ã†ã»ã†\",\"ã»ã†ã‚‚ã‚“\",\"ã»ã†ã‚Šã¤\",\"ã»ãˆã‚‹\",\"ã»ãŠã‚“\",\"ã»ã‹ã‚“\",\"ã»ãã‚‡ã†\",\"ã»ã‚™ãã‚“\",\"ã»ãã‚\",\"ã»ã‘ã¤\",\"ã»ã‘ã‚“\",\"ã»ã“ã†\",\"ã»ã“ã‚‹\",\"ã»ã—ã„\",\"ã»ã—ã¤\",\"ã»ã—ã‚…\",\"ã»ã—ã‚‡ã†\",\"ã»ã›ã„\",\"ã»ãã„\",\"ã»ãã\",\"ã»ãŸã¦\",\"ã»ãŸã‚‹\",\"ã»ã‚šã¡ãµã‚™ãã‚\",\"ã»ã£ãã‚‡ã\",\"ã»ã£ã•\",\"ã»ã£ãŸã‚“\",\"ã»ã¨ã‚“ã¨ã‚™\",\"ã»ã‚ã‚‹\",\"ã»ã‚“ã„\",\"ã»ã‚“ã\",\"ã»ã‚“ã‘\",\"ã»ã‚“ã—ã¤\",\"ã»ã‚“ã‚„ã\",\"ã¾ã„ã«ã¡\",\"ã¾ã‹ã„\",\"ã¾ã‹ã›ã‚‹\",\"ã¾ã‹ã‚™ã‚‹\",\"ã¾ã‘ã‚‹\",\"ã¾ã“ã¨\",\"ã¾ã•ã¤\",\"ã¾ã—ã‚™ã‚\",\"ã¾ã™ã\",\"ã¾ã›ã‚™ã‚‹\",\"ã¾ã¤ã‚Š\",\"ã¾ã¨ã‚\",\"ã¾ãªãµã‚™\",\"ã¾ã¬ã‘\",\"ã¾ã­ã\",\"ã¾ã»ã†\",\"ã¾ã‚‚ã‚‹\",\"ã¾ã‚†ã‘ã‚™\",\"ã¾ã‚ˆã†\",\"ã¾ã‚ã‚„ã‹\",\"ã¾ã‚ã™\",\"ã¾ã‚ã‚Š\",\"ã¾ã‚ã‚‹\",\"ã¾ã‚“ã‹ã‚™\",\"ã¾ã‚“ãã¤\",\"ã¾ã‚“ãã‚™ã\",\"ã¾ã‚“ãªã‹\",\"ã¿ã„ã‚‰\",\"ã¿ã†ã¡\",\"ã¿ãˆã‚‹\",\"ã¿ã‹ã‚™ã\",\"ã¿ã‹ãŸ\",\"ã¿ã‹ã‚“\",\"ã¿ã‘ã‚“\",\"ã¿ã“ã‚“\",\"ã¿ã—ã‚™ã‹ã„\",\"ã¿ã™ã„\",\"ã¿ã™ãˆã‚‹\",\"ã¿ã›ã‚‹\",\"ã¿ã£ã‹\",\"ã¿ã¤ã‹ã‚‹\",\"ã¿ã¤ã‘ã‚‹\",\"ã¿ã¦ã„\",\"ã¿ã¨ã‚ã‚‹\",\"ã¿ãªã¨\",\"ã¿ãªã¿ã‹ã•ã„\",\"ã¿ã­ã‚‰ã‚‹\",\"ã¿ã®ã†\",\"ã¿ã®ã‹ã‚™ã™\",\"ã¿ã»ã‚“\",\"ã¿ã‚‚ã¨\",\"ã¿ã‚„ã‘ã‚™\",\"ã¿ã‚‰ã„\",\"ã¿ã‚Šã‚‡ã\",\"ã¿ã‚ã\",\"ã¿ã‚“ã‹\",\"ã¿ã‚“ãã‚™ã\",\"ã‚€ã„ã‹\",\"ã‚€ãˆã\",\"ã‚€ãˆã‚“\",\"ã‚€ã‹ã„\",\"ã‚€ã‹ã†\",\"ã‚€ã‹ãˆ\",\"ã‚€ã‹ã—\",\"ã‚€ãã‚™ã¡ã‚ƒ\",\"ã‚€ã‘ã‚‹\",\"ã‚€ã‘ã‚™ã‚“\",\"ã‚€ã•ã»ã‚™ã‚‹\",\"ã‚€ã—ã‚ã¤ã„\",\"ã‚€ã—ã¯ã‚™\",\"ã‚€ã—ã‚™ã‚…ã‚“\",\"ã‚€ã—ã‚\",\"ã‚€ã™ã†\",\"ã‚€ã™ã“\",\"ã‚€ã™ãµã‚™\",\"ã‚€ã™ã‚\",\"ã‚€ã›ã‚‹\",\"ã‚€ã›ã‚“\",\"ã‚€ã¡ã‚…ã†\",\"ã‚€ãªã—ã„\",\"ã‚€ã®ã†\",\"ã‚€ã‚„ã¿\",\"ã‚€ã‚ˆã†\",\"ã‚€ã‚‰ã•ã\",\"ã‚€ã‚Šã‚‡ã†\",\"ã‚€ã‚ã‚“\",\"ã‚ã„ã‚ã‚“\",\"ã‚ã„ã†ã‚“\",\"ã‚ã„ãˆã‚“\",\"ã‚ã„ã‹ã\",\"ã‚ã„ãã‚‡ã\",\"ã‚ã„ã•ã„\",\"ã‚ã„ã—\",\"ã‚ã„ãã†\",\"ã‚ã„ãµã‚™ã¤\",\"ã‚ã„ã‚Œã„\",\"ã‚ã„ã‚ã\",\"ã‚ãã‚™ã¾ã‚Œã‚‹\",\"ã‚ã•ã‚™ã™\",\"ã‚ã—ãŸ\",\"ã‚ã™ã‚™ã‚‰ã—ã„\",\"ã‚ãŸã‚™ã¤\",\"ã‚ã¾ã„\",\"ã‚ã‚„ã™\",\"ã‚ã‚“ãã‚‡\",\"ã‚ã‚“ã›ã\",\"ã‚ã‚“ã¨ã‚™ã†\",\"ã‚‚ã†ã—ã‚ã‘ã‚™ã‚‹\",\"ã‚‚ã†ã¨ã‚™ã†ã‘ã‚“\",\"ã‚‚ãˆã‚‹\",\"ã‚‚ãã—\",\"ã‚‚ãã¦ã\",\"ã‚‚ãã‚ˆã†ã²ã‚™\",\"ã‚‚ã¡ã‚ã‚“\",\"ã‚‚ã¨ã‚™ã‚‹\",\"ã‚‚ã‚‰ã†\",\"ã‚‚ã‚“ã\",\"ã‚‚ã‚“ãŸã‚™ã„\",\"ã‚„ãŠã‚„\",\"ã‚„ã‘ã‚‹\",\"ã‚„ã•ã„\",\"ã‚„ã•ã—ã„\",\"ã‚„ã™ã„\",\"ã‚„ã™ãŸã‚ã†\",\"ã‚„ã™ã¿\",\"ã‚„ã›ã‚‹\",\"ã‚„ãã†\",\"ã‚„ãŸã„\",\"ã‚„ã¡ã‚“\",\"ã‚„ã£ã¨\",\"ã‚„ã£ã¯ã‚šã‚Š\",\"ã‚„ãµã‚™ã‚‹\",\"ã‚„ã‚ã‚‹\",\"ã‚„ã‚„ã“ã—ã„\",\"ã‚„ã‚ˆã„\",\"ã‚„ã‚ã‚‰ã‹ã„\",\"ã‚†ã†ã\",\"ã‚†ã†ã²ã‚™ã‚“ãã‚‡ã\",\"ã‚†ã†ã¸ã‚™\",\"ã‚†ã†ã‚ã„\",\"ã‚†ã‘ã¤\",\"ã‚†ã—ã‚…ã¤\",\"ã‚†ã›ã‚“\",\"ã‚†ãã†\",\"ã‚†ãŸã‹\",\"ã‚†ã¡ã‚ƒã\",\"ã‚†ã¦ã‚™ã‚‹\",\"ã‚†ã«ã‚…ã†\",\"ã‚†ã²ã‚™ã‚\",\"ã‚†ã‚‰ã„\",\"ã‚†ã‚Œã‚‹\",\"ã‚ˆã†ã„\",\"ã‚ˆã†ã‹\",\"ã‚ˆã†ãã‚…ã†\",\"ã‚ˆã†ã—ã‚™\",\"ã‚ˆã†ã™\",\"ã‚ˆã†ã¡ãˆã‚“\",\"ã‚ˆã‹ã›ã‚™\",\"ã‚ˆã‹ã‚“\",\"ã‚ˆãã‚“\",\"ã‚ˆãã›ã„\",\"ã‚ˆãã»ã‚™ã†\",\"ã‚ˆã‘ã„\",\"ã‚ˆã“ã‚™ã‚Œã‚‹\",\"ã‚ˆã•ã‚“\",\"ã‚ˆã—ã‚…ã†\",\"ã‚ˆãã†\",\"ã‚ˆãã\",\"ã‚ˆã£ã‹\",\"ã‚ˆã¦ã„\",\"ã‚ˆã¨ã‚™ã‹ã‚™ã‚ã\",\"ã‚ˆã­ã¤\",\"ã‚ˆã‚„ã\",\"ã‚ˆã‚†ã†\",\"ã‚ˆã‚ã“ãµã‚™\",\"ã‚ˆã‚ã—ã„\",\"ã‚‰ã„ã†\",\"ã‚‰ãã‹ã‚™ã\",\"ã‚‰ãã“ã‚™\",\"ã‚‰ãã•ã¤\",\"ã‚‰ããŸã‚™\",\"ã‚‰ã—ã‚“ã¯ã‚™ã‚“\",\"ã‚‰ã›ã‚“\",\"ã‚‰ãã‚™ã\",\"ã‚‰ãŸã„\",\"ã‚‰ã£ã‹\",\"ã‚‰ã‚Œã¤\",\"ã‚Šãˆã\",\"ã‚Šã‹ã„\",\"ã‚Šãã•ã\",\"ã‚Šãã›ã¤\",\"ã‚Šããã‚™ã‚“\",\"ã‚Šãã¤\",\"ã‚Šã‘ã‚“\",\"ã‚Šã“ã†\",\"ã‚Šã›ã„\",\"ã‚Šãã†\",\"ã‚Šãã\",\"ã‚Šã¦ã‚“\",\"ã‚Šã­ã‚“\",\"ã‚Šã‚†ã†\",\"ã‚Šã‚…ã†ã‹ã‚™ã\",\"ã‚Šã‚ˆã†\",\"ã‚Šã‚‡ã†ã‚Š\",\"ã‚Šã‚‡ã‹ã‚“\",\"ã‚Šã‚‡ãã¡ã‚ƒ\",\"ã‚Šã‚‡ã“ã†\",\"ã‚Šã‚Šã\",\"ã‚Šã‚Œã\",\"ã‚Šã‚ã‚“\",\"ã‚Šã‚“ã“ã‚™\",\"ã‚‹ã„ã‘ã„\",\"ã‚‹ã„ã•ã„\",\"ã‚‹ã„ã—ã‚™\",\"ã‚‹ã„ã›ã\",\"ã‚‹ã™ã¯ã‚™ã‚“\",\"ã‚‹ã‚Šã‹ã‚™ã‚ã‚‰\",\"ã‚Œã„ã‹ã‚“\",\"ã‚Œã„ãã‚™\",\"ã‚Œã„ã›ã„\",\"ã‚Œã„ãã‚™ã†ã“\",\"ã‚Œã„ã¨ã†\",\"ã‚Œã„ã»ã‚™ã†\",\"ã‚Œãã—\",\"ã‚ŒããŸã‚™ã„\",\"ã‚Œã‚“ã‚ã„\",\"ã‚Œã‚“ã‘ã„\",\"ã‚Œã‚“ã“ã‚“\",\"ã‚Œã‚“ã•ã„\",\"ã‚Œã‚“ã—ã‚…ã†\",\"ã‚Œã‚“ãã‚™ã\",\"ã‚Œã‚“ã‚‰ã\",\"ã‚ã†ã‹\",\"ã‚ã†ã“ã‚™\",\"ã‚ã†ã—ã‚™ã‚“\",\"ã‚ã†ãã\",\"ã‚ãã‹ã‚™\",\"ã‚ã“ã¤\",\"ã‚ã—ã‚™ã†ã‚‰\",\"ã‚ã—ã‚…ã¤\",\"ã‚ã›ã‚“\",\"ã‚ã¦ã‚“\",\"ã‚ã‚ã‚“\",\"ã‚ã‚Œã¤\",\"ã‚ã‚“ãã‚™\",\"ã‚ã‚“ã¯ã‚š\",\"ã‚ã‚“ãµã‚™ã‚“\",\"ã‚ã‚“ã‚Š\",\"ã‚ã‹ã™\",\"ã‚ã‹ã‚\",\"ã‚ã‹ã‚„ã¾\",\"ã‚ã‹ã‚Œã‚‹\",\"ã‚ã—ã¤\",\"ã‚ã—ã‚™ã¾ã—\",\"ã‚ã™ã‚Œã‚‚ã®\",\"ã‚ã‚‰ã†\",\"ã‚ã‚Œã‚‹\"]");

const require$$8 = /* #__PURE__ */ JSON.parse("[\"abacate\",\"abaixo\",\"abalar\",\"abater\",\"abduzir\",\"abelha\",\"aberto\",\"abismo\",\"abotoar\",\"abranger\",\"abreviar\",\"abrigar\",\"abrupto\",\"absinto\",\"absoluto\",\"absurdo\",\"abutre\",\"acabado\",\"acalmar\",\"acampar\",\"acanhar\",\"acaso\",\"aceitar\",\"acelerar\",\"acenar\",\"acervo\",\"acessar\",\"acetona\",\"achatar\",\"acidez\",\"acima\",\"acionado\",\"acirrar\",\"aclamar\",\"aclive\",\"acolhida\",\"acomodar\",\"acoplar\",\"acordar\",\"acumular\",\"acusador\",\"adaptar\",\"adega\",\"adentro\",\"adepto\",\"adequar\",\"aderente\",\"adesivo\",\"adeus\",\"adiante\",\"aditivo\",\"adjetivo\",\"adjunto\",\"admirar\",\"adorar\",\"adquirir\",\"adubo\",\"adverso\",\"advogado\",\"aeronave\",\"afastar\",\"aferir\",\"afetivo\",\"afinador\",\"afivelar\",\"aflito\",\"afluente\",\"afrontar\",\"agachar\",\"agarrar\",\"agasalho\",\"agenciar\",\"agilizar\",\"agiota\",\"agitado\",\"agora\",\"agradar\",\"agreste\",\"agrupar\",\"aguardar\",\"agulha\",\"ajoelhar\",\"ajudar\",\"ajustar\",\"alameda\",\"alarme\",\"alastrar\",\"alavanca\",\"albergue\",\"albino\",\"alcatra\",\"aldeia\",\"alecrim\",\"alegria\",\"alertar\",\"alface\",\"alfinete\",\"algum\",\"alheio\",\"aliar\",\"alicate\",\"alienar\",\"alinhar\",\"aliviar\",\"almofada\",\"alocar\",\"alpiste\",\"alterar\",\"altitude\",\"alucinar\",\"alugar\",\"aluno\",\"alusivo\",\"alvo\",\"amaciar\",\"amador\",\"amarelo\",\"amassar\",\"ambas\",\"ambiente\",\"ameixa\",\"amenizar\",\"amido\",\"amistoso\",\"amizade\",\"amolador\",\"amontoar\",\"amoroso\",\"amostra\",\"amparar\",\"ampliar\",\"ampola\",\"anagrama\",\"analisar\",\"anarquia\",\"anatomia\",\"andaime\",\"anel\",\"anexo\",\"angular\",\"animar\",\"anjo\",\"anomalia\",\"anotado\",\"ansioso\",\"anterior\",\"anuidade\",\"anunciar\",\"anzol\",\"apagador\",\"apalpar\",\"apanhado\",\"apego\",\"apelido\",\"apertada\",\"apesar\",\"apetite\",\"apito\",\"aplauso\",\"aplicada\",\"apoio\",\"apontar\",\"aposta\",\"aprendiz\",\"aprovar\",\"aquecer\",\"arame\",\"aranha\",\"arara\",\"arcada\",\"ardente\",\"areia\",\"arejar\",\"arenito\",\"aresta\",\"argiloso\",\"argola\",\"arma\",\"arquivo\",\"arraial\",\"arrebate\",\"arriscar\",\"arroba\",\"arrumar\",\"arsenal\",\"arterial\",\"artigo\",\"arvoredo\",\"asfaltar\",\"asilado\",\"aspirar\",\"assador\",\"assinar\",\"assoalho\",\"assunto\",\"astral\",\"atacado\",\"atadura\",\"atalho\",\"atarefar\",\"atear\",\"atender\",\"aterro\",\"ateu\",\"atingir\",\"atirador\",\"ativo\",\"atoleiro\",\"atracar\",\"atrevido\",\"atriz\",\"atual\",\"atum\",\"auditor\",\"aumentar\",\"aura\",\"aurora\",\"autismo\",\"autoria\",\"autuar\",\"avaliar\",\"avante\",\"avaria\",\"avental\",\"avesso\",\"aviador\",\"avisar\",\"avulso\",\"axila\",\"azarar\",\"azedo\",\"azeite\",\"azulejo\",\"babar\",\"babosa\",\"bacalhau\",\"bacharel\",\"bacia\",\"bagagem\",\"baiano\",\"bailar\",\"baioneta\",\"bairro\",\"baixista\",\"bajular\",\"baleia\",\"baliza\",\"balsa\",\"banal\",\"bandeira\",\"banho\",\"banir\",\"banquete\",\"barato\",\"barbado\",\"baronesa\",\"barraca\",\"barulho\",\"baseado\",\"bastante\",\"batata\",\"batedor\",\"batida\",\"batom\",\"batucar\",\"baunilha\",\"beber\",\"beijo\",\"beirada\",\"beisebol\",\"beldade\",\"beleza\",\"belga\",\"beliscar\",\"bendito\",\"bengala\",\"benzer\",\"berimbau\",\"berlinda\",\"berro\",\"besouro\",\"bexiga\",\"bezerro\",\"bico\",\"bicudo\",\"bienal\",\"bifocal\",\"bifurcar\",\"bigorna\",\"bilhete\",\"bimestre\",\"bimotor\",\"biologia\",\"biombo\",\"biosfera\",\"bipolar\",\"birrento\",\"biscoito\",\"bisneto\",\"bispo\",\"bissexto\",\"bitola\",\"bizarro\",\"blindado\",\"bloco\",\"bloquear\",\"boato\",\"bobagem\",\"bocado\",\"bocejo\",\"bochecha\",\"boicotar\",\"bolada\",\"boletim\",\"bolha\",\"bolo\",\"bombeiro\",\"bonde\",\"boneco\",\"bonita\",\"borbulha\",\"borda\",\"boreal\",\"borracha\",\"bovino\",\"boxeador\",\"branco\",\"brasa\",\"braveza\",\"breu\",\"briga\",\"brilho\",\"brincar\",\"broa\",\"brochura\",\"bronzear\",\"broto\",\"bruxo\",\"bucha\",\"budismo\",\"bufar\",\"bule\",\"buraco\",\"busca\",\"busto\",\"buzina\",\"cabana\",\"cabelo\",\"cabide\",\"cabo\",\"cabrito\",\"cacau\",\"cacetada\",\"cachorro\",\"cacique\",\"cadastro\",\"cadeado\",\"cafezal\",\"caiaque\",\"caipira\",\"caixote\",\"cajado\",\"caju\",\"calafrio\",\"calcular\",\"caldeira\",\"calibrar\",\"calmante\",\"calota\",\"camada\",\"cambista\",\"camisa\",\"camomila\",\"campanha\",\"camuflar\",\"canavial\",\"cancelar\",\"caneta\",\"canguru\",\"canhoto\",\"canivete\",\"canoa\",\"cansado\",\"cantar\",\"canudo\",\"capacho\",\"capela\",\"capinar\",\"capotar\",\"capricho\",\"captador\",\"capuz\",\"caracol\",\"carbono\",\"cardeal\",\"careca\",\"carimbar\",\"carneiro\",\"carpete\",\"carreira\",\"cartaz\",\"carvalho\",\"casaco\",\"casca\",\"casebre\",\"castelo\",\"casulo\",\"catarata\",\"cativar\",\"caule\",\"causador\",\"cautelar\",\"cavalo\",\"caverna\",\"cebola\",\"cedilha\",\"cegonha\",\"celebrar\",\"celular\",\"cenoura\",\"censo\",\"centeio\",\"cercar\",\"cerrado\",\"certeiro\",\"cerveja\",\"cetim\",\"cevada\",\"chacota\",\"chaleira\",\"chamado\",\"chapada\",\"charme\",\"chatice\",\"chave\",\"chefe\",\"chegada\",\"cheiro\",\"cheque\",\"chicote\",\"chifre\",\"chinelo\",\"chocalho\",\"chover\",\"chumbo\",\"chutar\",\"chuva\",\"cicatriz\",\"ciclone\",\"cidade\",\"cidreira\",\"ciente\",\"cigana\",\"cimento\",\"cinto\",\"cinza\",\"ciranda\",\"circuito\",\"cirurgia\",\"citar\",\"clareza\",\"clero\",\"clicar\",\"clone\",\"clube\",\"coado\",\"coagir\",\"cobaia\",\"cobertor\",\"cobrar\",\"cocada\",\"coelho\",\"coentro\",\"coeso\",\"cogumelo\",\"coibir\",\"coifa\",\"coiote\",\"colar\",\"coleira\",\"colher\",\"colidir\",\"colmeia\",\"colono\",\"coluna\",\"comando\",\"combinar\",\"comentar\",\"comitiva\",\"comover\",\"complexo\",\"comum\",\"concha\",\"condor\",\"conectar\",\"confuso\",\"congelar\",\"conhecer\",\"conjugar\",\"consumir\",\"contrato\",\"convite\",\"cooperar\",\"copeiro\",\"copiador\",\"copo\",\"coquetel\",\"coragem\",\"cordial\",\"corneta\",\"coronha\",\"corporal\",\"correio\",\"cortejo\",\"coruja\",\"corvo\",\"cosseno\",\"costela\",\"cotonete\",\"couro\",\"couve\",\"covil\",\"cozinha\",\"cratera\",\"cravo\",\"creche\",\"credor\",\"creme\",\"crer\",\"crespo\",\"criada\",\"criminal\",\"crioulo\",\"crise\",\"criticar\",\"crosta\",\"crua\",\"cruzeiro\",\"cubano\",\"cueca\",\"cuidado\",\"cujo\",\"culatra\",\"culminar\",\"culpar\",\"cultura\",\"cumprir\",\"cunhado\",\"cupido\",\"curativo\",\"curral\",\"cursar\",\"curto\",\"cuspir\",\"custear\",\"cutelo\",\"damasco\",\"datar\",\"debater\",\"debitar\",\"deboche\",\"debulhar\",\"decalque\",\"decimal\",\"declive\",\"decote\",\"decretar\",\"dedal\",\"dedicado\",\"deduzir\",\"defesa\",\"defumar\",\"degelo\",\"degrau\",\"degustar\",\"deitado\",\"deixar\",\"delator\",\"delegado\",\"delinear\",\"delonga\",\"demanda\",\"demitir\",\"demolido\",\"dentista\",\"depenado\",\"depilar\",\"depois\",\"depressa\",\"depurar\",\"deriva\",\"derramar\",\"desafio\",\"desbotar\",\"descanso\",\"desenho\",\"desfiado\",\"desgaste\",\"desigual\",\"deslize\",\"desmamar\",\"desova\",\"despesa\",\"destaque\",\"desviar\",\"detalhar\",\"detentor\",\"detonar\",\"detrito\",\"deusa\",\"dever\",\"devido\",\"devotado\",\"dezena\",\"diagrama\",\"dialeto\",\"didata\",\"difuso\",\"digitar\",\"dilatado\",\"diluente\",\"diminuir\",\"dinastia\",\"dinheiro\",\"diocese\",\"direto\",\"discreta\",\"disfarce\",\"disparo\",\"disquete\",\"dissipar\",\"distante\",\"ditador\",\"diurno\",\"diverso\",\"divisor\",\"divulgar\",\"dizer\",\"dobrador\",\"dolorido\",\"domador\",\"dominado\",\"donativo\",\"donzela\",\"dormente\",\"dorsal\",\"dosagem\",\"dourado\",\"doutor\",\"drenagem\",\"drible\",\"drogaria\",\"duelar\",\"duende\",\"dueto\",\"duplo\",\"duquesa\",\"durante\",\"duvidoso\",\"eclodir\",\"ecoar\",\"ecologia\",\"edificar\",\"edital\",\"educado\",\"efeito\",\"efetivar\",\"ejetar\",\"elaborar\",\"eleger\",\"eleitor\",\"elenco\",\"elevador\",\"eliminar\",\"elogiar\",\"embargo\",\"embolado\",\"embrulho\",\"embutido\",\"emenda\",\"emergir\",\"emissor\",\"empatia\",\"empenho\",\"empinado\",\"empolgar\",\"emprego\",\"empurrar\",\"emulador\",\"encaixe\",\"encenado\",\"enchente\",\"encontro\",\"endeusar\",\"endossar\",\"enfaixar\",\"enfeite\",\"enfim\",\"engajado\",\"engenho\",\"englobar\",\"engomado\",\"engraxar\",\"enguia\",\"enjoar\",\"enlatar\",\"enquanto\",\"enraizar\",\"enrolado\",\"enrugar\",\"ensaio\",\"enseada\",\"ensino\",\"ensopado\",\"entanto\",\"enteado\",\"entidade\",\"entortar\",\"entrada\",\"entulho\",\"envergar\",\"enviado\",\"envolver\",\"enxame\",\"enxerto\",\"enxofre\",\"enxuto\",\"epiderme\",\"equipar\",\"ereto\",\"erguido\",\"errata\",\"erva\",\"ervilha\",\"esbanjar\",\"esbelto\",\"escama\",\"escola\",\"escrita\",\"escuta\",\"esfinge\",\"esfolar\",\"esfregar\",\"esfumado\",\"esgrima\",\"esmalte\",\"espanto\",\"espelho\",\"espiga\",\"esponja\",\"espreita\",\"espumar\",\"esquerda\",\"estaca\",\"esteira\",\"esticar\",\"estofado\",\"estrela\",\"estudo\",\"esvaziar\",\"etanol\",\"etiqueta\",\"euforia\",\"europeu\",\"evacuar\",\"evaporar\",\"evasivo\",\"eventual\",\"evidente\",\"evoluir\",\"exagero\",\"exalar\",\"examinar\",\"exato\",\"exausto\",\"excesso\",\"excitar\",\"exclamar\",\"executar\",\"exemplo\",\"exibir\",\"exigente\",\"exonerar\",\"expandir\",\"expelir\",\"expirar\",\"explanar\",\"exposto\",\"expresso\",\"expulsar\",\"externo\",\"extinto\",\"extrato\",\"fabricar\",\"fabuloso\",\"faceta\",\"facial\",\"fada\",\"fadiga\",\"faixa\",\"falar\",\"falta\",\"familiar\",\"fandango\",\"fanfarra\",\"fantoche\",\"fardado\",\"farelo\",\"farinha\",\"farofa\",\"farpa\",\"fartura\",\"fatia\",\"fator\",\"favorita\",\"faxina\",\"fazenda\",\"fechado\",\"feijoada\",\"feirante\",\"felino\",\"feminino\",\"fenda\",\"feno\",\"fera\",\"feriado\",\"ferrugem\",\"ferver\",\"festejar\",\"fetal\",\"feudal\",\"fiapo\",\"fibrose\",\"ficar\",\"ficheiro\",\"figurado\",\"fileira\",\"filho\",\"filme\",\"filtrar\",\"firmeza\",\"fisgada\",\"fissura\",\"fita\",\"fivela\",\"fixador\",\"fixo\",\"flacidez\",\"flamingo\",\"flanela\",\"flechada\",\"flora\",\"flutuar\",\"fluxo\",\"focal\",\"focinho\",\"fofocar\",\"fogo\",\"foguete\",\"foice\",\"folgado\",\"folheto\",\"forjar\",\"formiga\",\"forno\",\"forte\",\"fosco\",\"fossa\",\"fragata\",\"fralda\",\"frango\",\"frasco\",\"fraterno\",\"freira\",\"frente\",\"fretar\",\"frieza\",\"friso\",\"fritura\",\"fronha\",\"frustrar\",\"fruteira\",\"fugir\",\"fulano\",\"fuligem\",\"fundar\",\"fungo\",\"funil\",\"furador\",\"furioso\",\"futebol\",\"gabarito\",\"gabinete\",\"gado\",\"gaiato\",\"gaiola\",\"gaivota\",\"galega\",\"galho\",\"galinha\",\"galocha\",\"ganhar\",\"garagem\",\"garfo\",\"gargalo\",\"garimpo\",\"garoupa\",\"garrafa\",\"gasoduto\",\"gasto\",\"gata\",\"gatilho\",\"gaveta\",\"gazela\",\"gelado\",\"geleia\",\"gelo\",\"gemada\",\"gemer\",\"gemido\",\"generoso\",\"gengiva\",\"genial\",\"genoma\",\"genro\",\"geologia\",\"gerador\",\"germinar\",\"gesso\",\"gestor\",\"ginasta\",\"gincana\",\"gingado\",\"girafa\",\"girino\",\"glacial\",\"glicose\",\"global\",\"glorioso\",\"goela\",\"goiaba\",\"golfe\",\"golpear\",\"gordura\",\"gorjeta\",\"gorro\",\"gostoso\",\"goteira\",\"governar\",\"gracejo\",\"gradual\",\"grafite\",\"gralha\",\"grampo\",\"granada\",\"gratuito\",\"graveto\",\"graxa\",\"grego\",\"grelhar\",\"greve\",\"grilo\",\"grisalho\",\"gritaria\",\"grosso\",\"grotesco\",\"grudado\",\"grunhido\",\"gruta\",\"guache\",\"guarani\",\"guaxinim\",\"guerrear\",\"guiar\",\"guincho\",\"guisado\",\"gula\",\"guloso\",\"guru\",\"habitar\",\"harmonia\",\"haste\",\"haver\",\"hectare\",\"herdar\",\"heresia\",\"hesitar\",\"hiato\",\"hibernar\",\"hidratar\",\"hiena\",\"hino\",\"hipismo\",\"hipnose\",\"hipoteca\",\"hoje\",\"holofote\",\"homem\",\"honesto\",\"honrado\",\"hormonal\",\"hospedar\",\"humorado\",\"iate\",\"ideia\",\"idoso\",\"ignorado\",\"igreja\",\"iguana\",\"ileso\",\"ilha\",\"iludido\",\"iluminar\",\"ilustrar\",\"imagem\",\"imediato\",\"imenso\",\"imersivo\",\"iminente\",\"imitador\",\"imortal\",\"impacto\",\"impedir\",\"implante\",\"impor\",\"imprensa\",\"impune\",\"imunizar\",\"inalador\",\"inapto\",\"inativo\",\"incenso\",\"inchar\",\"incidir\",\"incluir\",\"incolor\",\"indeciso\",\"indireto\",\"indutor\",\"ineficaz\",\"inerente\",\"infantil\",\"infestar\",\"infinito\",\"inflamar\",\"informal\",\"infrator\",\"ingerir\",\"inibido\",\"inicial\",\"inimigo\",\"injetar\",\"inocente\",\"inodoro\",\"inovador\",\"inox\",\"inquieto\",\"inscrito\",\"inseto\",\"insistir\",\"inspetor\",\"instalar\",\"insulto\",\"intacto\",\"integral\",\"intimar\",\"intocado\",\"intriga\",\"invasor\",\"inverno\",\"invicto\",\"invocar\",\"iogurte\",\"iraniano\",\"ironizar\",\"irreal\",\"irritado\",\"isca\",\"isento\",\"isolado\",\"isqueiro\",\"italiano\",\"janeiro\",\"jangada\",\"janta\",\"jararaca\",\"jardim\",\"jarro\",\"jasmim\",\"jato\",\"javali\",\"jazida\",\"jejum\",\"joaninha\",\"joelhada\",\"jogador\",\"joia\",\"jornal\",\"jorrar\",\"jovem\",\"juba\",\"judeu\",\"judoca\",\"juiz\",\"julgador\",\"julho\",\"jurado\",\"jurista\",\"juro\",\"justa\",\"labareda\",\"laboral\",\"lacre\",\"lactante\",\"ladrilho\",\"lagarta\",\"lagoa\",\"laje\",\"lamber\",\"lamentar\",\"laminar\",\"lampejo\",\"lanche\",\"lapidar\",\"lapso\",\"laranja\",\"lareira\",\"largura\",\"lasanha\",\"lastro\",\"lateral\",\"latido\",\"lavanda\",\"lavoura\",\"lavrador\",\"laxante\",\"lazer\",\"lealdade\",\"lebre\",\"legado\",\"legendar\",\"legista\",\"leigo\",\"leiloar\",\"leitura\",\"lembrete\",\"leme\",\"lenhador\",\"lentilha\",\"leoa\",\"lesma\",\"leste\",\"letivo\",\"letreiro\",\"levar\",\"leveza\",\"levitar\",\"liberal\",\"libido\",\"liderar\",\"ligar\",\"ligeiro\",\"limitar\",\"limoeiro\",\"limpador\",\"linda\",\"linear\",\"linhagem\",\"liquidez\",\"listagem\",\"lisura\",\"litoral\",\"livro\",\"lixa\",\"lixeira\",\"locador\",\"locutor\",\"lojista\",\"lombo\",\"lona\",\"longe\",\"lontra\",\"lorde\",\"lotado\",\"loteria\",\"loucura\",\"lousa\",\"louvar\",\"luar\",\"lucidez\",\"lucro\",\"luneta\",\"lustre\",\"lutador\",\"luva\",\"macaco\",\"macete\",\"machado\",\"macio\",\"madeira\",\"madrinha\",\"magnata\",\"magreza\",\"maior\",\"mais\",\"malandro\",\"malha\",\"malote\",\"maluco\",\"mamilo\",\"mamoeiro\",\"mamute\",\"manada\",\"mancha\",\"mandato\",\"manequim\",\"manhoso\",\"manivela\",\"manobrar\",\"mansa\",\"manter\",\"manusear\",\"mapeado\",\"maquinar\",\"marcador\",\"maresia\",\"marfim\",\"margem\",\"marinho\",\"marmita\",\"maroto\",\"marquise\",\"marreco\",\"martelo\",\"marujo\",\"mascote\",\"masmorra\",\"massagem\",\"mastigar\",\"matagal\",\"materno\",\"matinal\",\"matutar\",\"maxilar\",\"medalha\",\"medida\",\"medusa\",\"megafone\",\"meiga\",\"melancia\",\"melhor\",\"membro\",\"memorial\",\"menino\",\"menos\",\"mensagem\",\"mental\",\"merecer\",\"mergulho\",\"mesada\",\"mesclar\",\"mesmo\",\"mesquita\",\"mestre\",\"metade\",\"meteoro\",\"metragem\",\"mexer\",\"mexicano\",\"micro\",\"migalha\",\"migrar\",\"milagre\",\"milenar\",\"milhar\",\"mimado\",\"minerar\",\"minhoca\",\"ministro\",\"minoria\",\"miolo\",\"mirante\",\"mirtilo\",\"misturar\",\"mocidade\",\"moderno\",\"modular\",\"moeda\",\"moer\",\"moinho\",\"moita\",\"moldura\",\"moleza\",\"molho\",\"molinete\",\"molusco\",\"montanha\",\"moqueca\",\"morango\",\"morcego\",\"mordomo\",\"morena\",\"mosaico\",\"mosquete\",\"mostarda\",\"motel\",\"motim\",\"moto\",\"motriz\",\"muda\",\"muito\",\"mulata\",\"mulher\",\"multar\",\"mundial\",\"munido\",\"muralha\",\"murcho\",\"muscular\",\"museu\",\"musical\",\"nacional\",\"nadador\",\"naja\",\"namoro\",\"narina\",\"narrado\",\"nascer\",\"nativa\",\"natureza\",\"navalha\",\"navegar\",\"navio\",\"neblina\",\"nebuloso\",\"negativa\",\"negociar\",\"negrito\",\"nervoso\",\"neta\",\"neural\",\"nevasca\",\"nevoeiro\",\"ninar\",\"ninho\",\"nitidez\",\"nivelar\",\"nobreza\",\"noite\",\"noiva\",\"nomear\",\"nominal\",\"nordeste\",\"nortear\",\"notar\",\"noticiar\",\"noturno\",\"novelo\",\"novilho\",\"novo\",\"nublado\",\"nudez\",\"numeral\",\"nupcial\",\"nutrir\",\"nuvem\",\"obcecado\",\"obedecer\",\"objetivo\",\"obrigado\",\"obscuro\",\"obstetra\",\"obter\",\"obturar\",\"ocidente\",\"ocioso\",\"ocorrer\",\"oculista\",\"ocupado\",\"ofegante\",\"ofensiva\",\"oferenda\",\"oficina\",\"ofuscado\",\"ogiva\",\"olaria\",\"oleoso\",\"olhar\",\"oliveira\",\"ombro\",\"omelete\",\"omisso\",\"omitir\",\"ondulado\",\"oneroso\",\"ontem\",\"opcional\",\"operador\",\"oponente\",\"oportuno\",\"oposto\",\"orar\",\"orbitar\",\"ordem\",\"ordinal\",\"orfanato\",\"orgasmo\",\"orgulho\",\"oriental\",\"origem\",\"oriundo\",\"orla\",\"ortodoxo\",\"orvalho\",\"oscilar\",\"ossada\",\"osso\",\"ostentar\",\"otimismo\",\"ousadia\",\"outono\",\"outubro\",\"ouvido\",\"ovelha\",\"ovular\",\"oxidar\",\"oxigenar\",\"pacato\",\"paciente\",\"pacote\",\"pactuar\",\"padaria\",\"padrinho\",\"pagar\",\"pagode\",\"painel\",\"pairar\",\"paisagem\",\"palavra\",\"palestra\",\"palheta\",\"palito\",\"palmada\",\"palpitar\",\"pancada\",\"panela\",\"panfleto\",\"panqueca\",\"pantanal\",\"papagaio\",\"papelada\",\"papiro\",\"parafina\",\"parcial\",\"pardal\",\"parede\",\"partida\",\"pasmo\",\"passado\",\"pastel\",\"patamar\",\"patente\",\"patinar\",\"patrono\",\"paulada\",\"pausar\",\"peculiar\",\"pedalar\",\"pedestre\",\"pediatra\",\"pedra\",\"pegada\",\"peitoral\",\"peixe\",\"pele\",\"pelicano\",\"penca\",\"pendurar\",\"peneira\",\"penhasco\",\"pensador\",\"pente\",\"perceber\",\"perfeito\",\"pergunta\",\"perito\",\"permitir\",\"perna\",\"perplexo\",\"persiana\",\"pertence\",\"peruca\",\"pescado\",\"pesquisa\",\"pessoa\",\"petiscar\",\"piada\",\"picado\",\"piedade\",\"pigmento\",\"pilastra\",\"pilhado\",\"pilotar\",\"pimenta\",\"pincel\",\"pinguim\",\"pinha\",\"pinote\",\"pintar\",\"pioneiro\",\"pipoca\",\"piquete\",\"piranha\",\"pires\",\"pirueta\",\"piscar\",\"pistola\",\"pitanga\",\"pivete\",\"planta\",\"plaqueta\",\"platina\",\"plebeu\",\"plumagem\",\"pluvial\",\"pneu\",\"poda\",\"poeira\",\"poetisa\",\"polegada\",\"policiar\",\"poluente\",\"polvilho\",\"pomar\",\"pomba\",\"ponderar\",\"pontaria\",\"populoso\",\"porta\",\"possuir\",\"postal\",\"pote\",\"poupar\",\"pouso\",\"povoar\",\"praia\",\"prancha\",\"prato\",\"praxe\",\"prece\",\"predador\",\"prefeito\",\"premiar\",\"prensar\",\"preparar\",\"presilha\",\"pretexto\",\"prevenir\",\"prezar\",\"primata\",\"princesa\",\"prisma\",\"privado\",\"processo\",\"produto\",\"profeta\",\"proibido\",\"projeto\",\"prometer\",\"propagar\",\"prosa\",\"protetor\",\"provador\",\"publicar\",\"pudim\",\"pular\",\"pulmonar\",\"pulseira\",\"punhal\",\"punir\",\"pupilo\",\"pureza\",\"puxador\",\"quadra\",\"quantia\",\"quarto\",\"quase\",\"quebrar\",\"queda\",\"queijo\",\"quente\",\"querido\",\"quimono\",\"quina\",\"quiosque\",\"rabanada\",\"rabisco\",\"rachar\",\"racionar\",\"radial\",\"raiar\",\"rainha\",\"raio\",\"raiva\",\"rajada\",\"ralado\",\"ramal\",\"ranger\",\"ranhura\",\"rapadura\",\"rapel\",\"rapidez\",\"raposa\",\"raquete\",\"raridade\",\"rasante\",\"rascunho\",\"rasgar\",\"raspador\",\"rasteira\",\"rasurar\",\"ratazana\",\"ratoeira\",\"realeza\",\"reanimar\",\"reaver\",\"rebaixar\",\"rebelde\",\"rebolar\",\"recado\",\"recente\",\"recheio\",\"recibo\",\"recordar\",\"recrutar\",\"recuar\",\"rede\",\"redimir\",\"redonda\",\"reduzida\",\"reenvio\",\"refinar\",\"refletir\",\"refogar\",\"refresco\",\"refugiar\",\"regalia\",\"regime\",\"regra\",\"reinado\",\"reitor\",\"rejeitar\",\"relativo\",\"remador\",\"remendo\",\"remorso\",\"renovado\",\"reparo\",\"repelir\",\"repleto\",\"repolho\",\"represa\",\"repudiar\",\"requerer\",\"resenha\",\"resfriar\",\"resgatar\",\"residir\",\"resolver\",\"respeito\",\"ressaca\",\"restante\",\"resumir\",\"retalho\",\"reter\",\"retirar\",\"retomada\",\"retratar\",\"revelar\",\"revisor\",\"revolta\",\"riacho\",\"rica\",\"rigidez\",\"rigoroso\",\"rimar\",\"ringue\",\"risada\",\"risco\",\"risonho\",\"robalo\",\"rochedo\",\"rodada\",\"rodeio\",\"rodovia\",\"roedor\",\"roleta\",\"romano\",\"roncar\",\"rosado\",\"roseira\",\"rosto\",\"rota\",\"roteiro\",\"rotina\",\"rotular\",\"rouco\",\"roupa\",\"roxo\",\"rubro\",\"rugido\",\"rugoso\",\"ruivo\",\"rumo\",\"rupestre\",\"russo\",\"sabor\",\"saciar\",\"sacola\",\"sacudir\",\"sadio\",\"safira\",\"saga\",\"sagrada\",\"saibro\",\"salada\",\"saleiro\",\"salgado\",\"saliva\",\"salpicar\",\"salsicha\",\"saltar\",\"salvador\",\"sambar\",\"samurai\",\"sanar\",\"sanfona\",\"sangue\",\"sanidade\",\"sapato\",\"sarda\",\"sargento\",\"sarjeta\",\"saturar\",\"saudade\",\"saxofone\",\"sazonal\",\"secar\",\"secular\",\"seda\",\"sedento\",\"sediado\",\"sedoso\",\"sedutor\",\"segmento\",\"segredo\",\"segundo\",\"seiva\",\"seleto\",\"selvagem\",\"semanal\",\"semente\",\"senador\",\"senhor\",\"sensual\",\"sentado\",\"separado\",\"sereia\",\"seringa\",\"serra\",\"servo\",\"setembro\",\"setor\",\"sigilo\",\"silhueta\",\"silicone\",\"simetria\",\"simpatia\",\"simular\",\"sinal\",\"sincero\",\"singular\",\"sinopse\",\"sintonia\",\"sirene\",\"siri\",\"situado\",\"soberano\",\"sobra\",\"socorro\",\"sogro\",\"soja\",\"solda\",\"soletrar\",\"solteiro\",\"sombrio\",\"sonata\",\"sondar\",\"sonegar\",\"sonhador\",\"sono\",\"soprano\",\"soquete\",\"sorrir\",\"sorteio\",\"sossego\",\"sotaque\",\"soterrar\",\"sovado\",\"sozinho\",\"suavizar\",\"subida\",\"submerso\",\"subsolo\",\"subtrair\",\"sucata\",\"sucesso\",\"suco\",\"sudeste\",\"sufixo\",\"sugador\",\"sugerir\",\"sujeito\",\"sulfato\",\"sumir\",\"suor\",\"superior\",\"suplicar\",\"suposto\",\"suprimir\",\"surdina\",\"surfista\",\"surpresa\",\"surreal\",\"surtir\",\"suspiro\",\"sustento\",\"tabela\",\"tablete\",\"tabuada\",\"tacho\",\"tagarela\",\"talher\",\"talo\",\"talvez\",\"tamanho\",\"tamborim\",\"tampa\",\"tangente\",\"tanto\",\"tapar\",\"tapioca\",\"tardio\",\"tarefa\",\"tarja\",\"tarraxa\",\"tatuagem\",\"taurino\",\"taxativo\",\"taxista\",\"teatral\",\"tecer\",\"tecido\",\"teclado\",\"tedioso\",\"teia\",\"teimar\",\"telefone\",\"telhado\",\"tempero\",\"tenente\",\"tensor\",\"tentar\",\"termal\",\"terno\",\"terreno\",\"tese\",\"tesoura\",\"testado\",\"teto\",\"textura\",\"texugo\",\"tiara\",\"tigela\",\"tijolo\",\"timbrar\",\"timidez\",\"tingido\",\"tinteiro\",\"tiragem\",\"titular\",\"toalha\",\"tocha\",\"tolerar\",\"tolice\",\"tomada\",\"tomilho\",\"tonel\",\"tontura\",\"topete\",\"tora\",\"torcido\",\"torneio\",\"torque\",\"torrada\",\"torto\",\"tostar\",\"touca\",\"toupeira\",\"toxina\",\"trabalho\",\"tracejar\",\"tradutor\",\"trafegar\",\"trajeto\",\"trama\",\"trancar\",\"trapo\",\"traseiro\",\"tratador\",\"travar\",\"treino\",\"tremer\",\"trepidar\",\"trevo\",\"triagem\",\"tribo\",\"triciclo\",\"tridente\",\"trilogia\",\"trindade\",\"triplo\",\"triturar\",\"triunfal\",\"trocar\",\"trombeta\",\"trova\",\"trunfo\",\"truque\",\"tubular\",\"tucano\",\"tudo\",\"tulipa\",\"tupi\",\"turbo\",\"turma\",\"turquesa\",\"tutelar\",\"tutorial\",\"uivar\",\"umbigo\",\"unha\",\"unidade\",\"uniforme\",\"urologia\",\"urso\",\"urtiga\",\"urubu\",\"usado\",\"usina\",\"usufruir\",\"vacina\",\"vadiar\",\"vagaroso\",\"vaidoso\",\"vala\",\"valente\",\"validade\",\"valores\",\"vantagem\",\"vaqueiro\",\"varanda\",\"vareta\",\"varrer\",\"vascular\",\"vasilha\",\"vassoura\",\"vazar\",\"vazio\",\"veado\",\"vedar\",\"vegetar\",\"veicular\",\"veleiro\",\"velhice\",\"veludo\",\"vencedor\",\"vendaval\",\"venerar\",\"ventre\",\"verbal\",\"verdade\",\"vereador\",\"vergonha\",\"vermelho\",\"verniz\",\"versar\",\"vertente\",\"vespa\",\"vestido\",\"vetorial\",\"viaduto\",\"viagem\",\"viajar\",\"viatura\",\"vibrador\",\"videira\",\"vidraria\",\"viela\",\"viga\",\"vigente\",\"vigiar\",\"vigorar\",\"vilarejo\",\"vinco\",\"vinheta\",\"vinil\",\"violeta\",\"virada\",\"virtude\",\"visitar\",\"visto\",\"vitral\",\"viveiro\",\"vizinho\",\"voador\",\"voar\",\"vogal\",\"volante\",\"voleibol\",\"voltagem\",\"volumoso\",\"vontade\",\"vulto\",\"vuvuzela\",\"xadrez\",\"xarope\",\"xeque\",\"xeretar\",\"xerife\",\"xingar\",\"zangado\",\"zarpar\",\"zebu\",\"zelador\",\"zombar\",\"zoologia\",\"zumbido\"]");

const require$$9 = /* #__PURE__ */ JSON.parse("[\"abandon\",\"ability\",\"able\",\"about\",\"above\",\"absent\",\"absorb\",\"abstract\",\"absurd\",\"abuse\",\"access\",\"accident\",\"account\",\"accuse\",\"achieve\",\"acid\",\"acoustic\",\"acquire\",\"across\",\"act\",\"action\",\"actor\",\"actress\",\"actual\",\"adapt\",\"add\",\"addict\",\"address\",\"adjust\",\"admit\",\"adult\",\"advance\",\"advice\",\"aerobic\",\"affair\",\"afford\",\"afraid\",\"again\",\"age\",\"agent\",\"agree\",\"ahead\",\"aim\",\"air\",\"airport\",\"aisle\",\"alarm\",\"album\",\"alcohol\",\"alert\",\"alien\",\"all\",\"alley\",\"allow\",\"almost\",\"alone\",\"alpha\",\"already\",\"also\",\"alter\",\"always\",\"amateur\",\"amazing\",\"among\",\"amount\",\"amused\",\"analyst\",\"anchor\",\"ancient\",\"anger\",\"angle\",\"angry\",\"animal\",\"ankle\",\"announce\",\"annual\",\"another\",\"answer\",\"antenna\",\"antique\",\"anxiety\",\"any\",\"apart\",\"apology\",\"appear\",\"apple\",\"approve\",\"april\",\"arch\",\"arctic\",\"area\",\"arena\",\"argue\",\"arm\",\"armed\",\"armor\",\"army\",\"around\",\"arrange\",\"arrest\",\"arrive\",\"arrow\",\"art\",\"artefact\",\"artist\",\"artwork\",\"ask\",\"aspect\",\"assault\",\"asset\",\"assist\",\"assume\",\"asthma\",\"athlete\",\"atom\",\"attack\",\"attend\",\"attitude\",\"attract\",\"auction\",\"audit\",\"august\",\"aunt\",\"author\",\"auto\",\"autumn\",\"average\",\"avocado\",\"avoid\",\"awake\",\"aware\",\"away\",\"awesome\",\"awful\",\"awkward\",\"axis\",\"baby\",\"bachelor\",\"bacon\",\"badge\",\"bag\",\"balance\",\"balcony\",\"ball\",\"bamboo\",\"banana\",\"banner\",\"bar\",\"barely\",\"bargain\",\"barrel\",\"base\",\"basic\",\"basket\",\"battle\",\"beach\",\"bean\",\"beauty\",\"because\",\"become\",\"beef\",\"before\",\"begin\",\"behave\",\"behind\",\"believe\",\"below\",\"belt\",\"bench\",\"benefit\",\"best\",\"betray\",\"better\",\"between\",\"beyond\",\"bicycle\",\"bid\",\"bike\",\"bind\",\"biology\",\"bird\",\"birth\",\"bitter\",\"black\",\"blade\",\"blame\",\"blanket\",\"blast\",\"bleak\",\"bless\",\"blind\",\"blood\",\"blossom\",\"blouse\",\"blue\",\"blur\",\"blush\",\"board\",\"boat\",\"body\",\"boil\",\"bomb\",\"bone\",\"bonus\",\"book\",\"boost\",\"border\",\"boring\",\"borrow\",\"boss\",\"bottom\",\"bounce\",\"box\",\"boy\",\"bracket\",\"brain\",\"brand\",\"brass\",\"brave\",\"bread\",\"breeze\",\"brick\",\"bridge\",\"brief\",\"bright\",\"bring\",\"brisk\",\"broccoli\",\"broken\",\"bronze\",\"broom\",\"brother\",\"brown\",\"brush\",\"bubble\",\"buddy\",\"budget\",\"buffalo\",\"build\",\"bulb\",\"bulk\",\"bullet\",\"bundle\",\"bunker\",\"burden\",\"burger\",\"burst\",\"bus\",\"business\",\"busy\",\"butter\",\"buyer\",\"buzz\",\"cabbage\",\"cabin\",\"cable\",\"cactus\",\"cage\",\"cake\",\"call\",\"calm\",\"camera\",\"camp\",\"can\",\"canal\",\"cancel\",\"candy\",\"cannon\",\"canoe\",\"canvas\",\"canyon\",\"capable\",\"capital\",\"captain\",\"car\",\"carbon\",\"card\",\"cargo\",\"carpet\",\"carry\",\"cart\",\"case\",\"cash\",\"casino\",\"castle\",\"casual\",\"cat\",\"catalog\",\"catch\",\"category\",\"cattle\",\"caught\",\"cause\",\"caution\",\"cave\",\"ceiling\",\"celery\",\"cement\",\"census\",\"century\",\"cereal\",\"certain\",\"chair\",\"chalk\",\"champion\",\"change\",\"chaos\",\"chapter\",\"charge\",\"chase\",\"chat\",\"cheap\",\"check\",\"cheese\",\"chef\",\"cherry\",\"chest\",\"chicken\",\"chief\",\"child\",\"chimney\",\"choice\",\"choose\",\"chronic\",\"chuckle\",\"chunk\",\"churn\",\"cigar\",\"cinnamon\",\"circle\",\"citizen\",\"city\",\"civil\",\"claim\",\"clap\",\"clarify\",\"claw\",\"clay\",\"clean\",\"clerk\",\"clever\",\"click\",\"client\",\"cliff\",\"climb\",\"clinic\",\"clip\",\"clock\",\"clog\",\"close\",\"cloth\",\"cloud\",\"clown\",\"club\",\"clump\",\"cluster\",\"clutch\",\"coach\",\"coast\",\"coconut\",\"code\",\"coffee\",\"coil\",\"coin\",\"collect\",\"color\",\"column\",\"combine\",\"come\",\"comfort\",\"comic\",\"common\",\"company\",\"concert\",\"conduct\",\"confirm\",\"congress\",\"connect\",\"consider\",\"control\",\"convince\",\"cook\",\"cool\",\"copper\",\"copy\",\"coral\",\"core\",\"corn\",\"correct\",\"cost\",\"cotton\",\"couch\",\"country\",\"couple\",\"course\",\"cousin\",\"cover\",\"coyote\",\"crack\",\"cradle\",\"craft\",\"cram\",\"crane\",\"crash\",\"crater\",\"crawl\",\"crazy\",\"cream\",\"credit\",\"creek\",\"crew\",\"cricket\",\"crime\",\"crisp\",\"critic\",\"crop\",\"cross\",\"crouch\",\"crowd\",\"crucial\",\"cruel\",\"cruise\",\"crumble\",\"crunch\",\"crush\",\"cry\",\"crystal\",\"cube\",\"culture\",\"cup\",\"cupboard\",\"curious\",\"current\",\"curtain\",\"curve\",\"cushion\",\"custom\",\"cute\",\"cycle\",\"dad\",\"damage\",\"damp\",\"dance\",\"danger\",\"daring\",\"dash\",\"daughter\",\"dawn\",\"day\",\"deal\",\"debate\",\"debris\",\"decade\",\"december\",\"decide\",\"decline\",\"decorate\",\"decrease\",\"deer\",\"defense\",\"define\",\"defy\",\"degree\",\"delay\",\"deliver\",\"demand\",\"demise\",\"denial\",\"dentist\",\"deny\",\"depart\",\"depend\",\"deposit\",\"depth\",\"deputy\",\"derive\",\"describe\",\"desert\",\"design\",\"desk\",\"despair\",\"destroy\",\"detail\",\"detect\",\"develop\",\"device\",\"devote\",\"diagram\",\"dial\",\"diamond\",\"diary\",\"dice\",\"diesel\",\"diet\",\"differ\",\"digital\",\"dignity\",\"dilemma\",\"dinner\",\"dinosaur\",\"direct\",\"dirt\",\"disagree\",\"discover\",\"disease\",\"dish\",\"dismiss\",\"disorder\",\"display\",\"distance\",\"divert\",\"divide\",\"divorce\",\"dizzy\",\"doctor\",\"document\",\"dog\",\"doll\",\"dolphin\",\"domain\",\"donate\",\"donkey\",\"donor\",\"door\",\"dose\",\"double\",\"dove\",\"draft\",\"dragon\",\"drama\",\"drastic\",\"draw\",\"dream\",\"dress\",\"drift\",\"drill\",\"drink\",\"drip\",\"drive\",\"drop\",\"drum\",\"dry\",\"duck\",\"dumb\",\"dune\",\"during\",\"dust\",\"dutch\",\"duty\",\"dwarf\",\"dynamic\",\"eager\",\"eagle\",\"early\",\"earn\",\"earth\",\"easily\",\"east\",\"easy\",\"echo\",\"ecology\",\"economy\",\"edge\",\"edit\",\"educate\",\"effort\",\"egg\",\"eight\",\"either\",\"elbow\",\"elder\",\"electric\",\"elegant\",\"element\",\"elephant\",\"elevator\",\"elite\",\"else\",\"embark\",\"embody\",\"embrace\",\"emerge\",\"emotion\",\"employ\",\"empower\",\"empty\",\"enable\",\"enact\",\"end\",\"endless\",\"endorse\",\"enemy\",\"energy\",\"enforce\",\"engage\",\"engine\",\"enhance\",\"enjoy\",\"enlist\",\"enough\",\"enrich\",\"enroll\",\"ensure\",\"enter\",\"entire\",\"entry\",\"envelope\",\"episode\",\"equal\",\"equip\",\"era\",\"erase\",\"erode\",\"erosion\",\"error\",\"erupt\",\"escape\",\"essay\",\"essence\",\"estate\",\"eternal\",\"ethics\",\"evidence\",\"evil\",\"evoke\",\"evolve\",\"exact\",\"example\",\"excess\",\"exchange\",\"excite\",\"exclude\",\"excuse\",\"execute\",\"exercise\",\"exhaust\",\"exhibit\",\"exile\",\"exist\",\"exit\",\"exotic\",\"expand\",\"expect\",\"expire\",\"explain\",\"expose\",\"express\",\"extend\",\"extra\",\"eye\",\"eyebrow\",\"fabric\",\"face\",\"faculty\",\"fade\",\"faint\",\"faith\",\"fall\",\"false\",\"fame\",\"family\",\"famous\",\"fan\",\"fancy\",\"fantasy\",\"farm\",\"fashion\",\"fat\",\"fatal\",\"father\",\"fatigue\",\"fault\",\"favorite\",\"feature\",\"february\",\"federal\",\"fee\",\"feed\",\"feel\",\"female\",\"fence\",\"festival\",\"fetch\",\"fever\",\"few\",\"fiber\",\"fiction\",\"field\",\"figure\",\"file\",\"film\",\"filter\",\"final\",\"find\",\"fine\",\"finger\",\"finish\",\"fire\",\"firm\",\"first\",\"fiscal\",\"fish\",\"fit\",\"fitness\",\"fix\",\"flag\",\"flame\",\"flash\",\"flat\",\"flavor\",\"flee\",\"flight\",\"flip\",\"float\",\"flock\",\"floor\",\"flower\",\"fluid\",\"flush\",\"fly\",\"foam\",\"focus\",\"fog\",\"foil\",\"fold\",\"follow\",\"food\",\"foot\",\"force\",\"forest\",\"forget\",\"fork\",\"fortune\",\"forum\",\"forward\",\"fossil\",\"foster\",\"found\",\"fox\",\"fragile\",\"frame\",\"frequent\",\"fresh\",\"friend\",\"fringe\",\"frog\",\"front\",\"frost\",\"frown\",\"frozen\",\"fruit\",\"fuel\",\"fun\",\"funny\",\"furnace\",\"fury\",\"future\",\"gadget\",\"gain\",\"galaxy\",\"gallery\",\"game\",\"gap\",\"garage\",\"garbage\",\"garden\",\"garlic\",\"garment\",\"gas\",\"gasp\",\"gate\",\"gather\",\"gauge\",\"gaze\",\"general\",\"genius\",\"genre\",\"gentle\",\"genuine\",\"gesture\",\"ghost\",\"giant\",\"gift\",\"giggle\",\"ginger\",\"giraffe\",\"girl\",\"give\",\"glad\",\"glance\",\"glare\",\"glass\",\"glide\",\"glimpse\",\"globe\",\"gloom\",\"glory\",\"glove\",\"glow\",\"glue\",\"goat\",\"goddess\",\"gold\",\"good\",\"goose\",\"gorilla\",\"gospel\",\"gossip\",\"govern\",\"gown\",\"grab\",\"grace\",\"grain\",\"grant\",\"grape\",\"grass\",\"gravity\",\"great\",\"green\",\"grid\",\"grief\",\"grit\",\"grocery\",\"group\",\"grow\",\"grunt\",\"guard\",\"guess\",\"guide\",\"guilt\",\"guitar\",\"gun\",\"gym\",\"habit\",\"hair\",\"half\",\"hammer\",\"hamster\",\"hand\",\"happy\",\"harbor\",\"hard\",\"harsh\",\"harvest\",\"hat\",\"have\",\"hawk\",\"hazard\",\"head\",\"health\",\"heart\",\"heavy\",\"hedgehog\",\"height\",\"hello\",\"helmet\",\"help\",\"hen\",\"hero\",\"hidden\",\"high\",\"hill\",\"hint\",\"hip\",\"hire\",\"history\",\"hobby\",\"hockey\",\"hold\",\"hole\",\"holiday\",\"hollow\",\"home\",\"honey\",\"hood\",\"hope\",\"horn\",\"horror\",\"horse\",\"hospital\",\"host\",\"hotel\",\"hour\",\"hover\",\"hub\",\"huge\",\"human\",\"humble\",\"humor\",\"hundred\",\"hungry\",\"hunt\",\"hurdle\",\"hurry\",\"hurt\",\"husband\",\"hybrid\",\"ice\",\"icon\",\"idea\",\"identify\",\"idle\",\"ignore\",\"ill\",\"illegal\",\"illness\",\"image\",\"imitate\",\"immense\",\"immune\",\"impact\",\"impose\",\"improve\",\"impulse\",\"inch\",\"include\",\"income\",\"increase\",\"index\",\"indicate\",\"indoor\",\"industry\",\"infant\",\"inflict\",\"inform\",\"inhale\",\"inherit\",\"initial\",\"inject\",\"injury\",\"inmate\",\"inner\",\"innocent\",\"input\",\"inquiry\",\"insane\",\"insect\",\"inside\",\"inspire\",\"install\",\"intact\",\"interest\",\"into\",\"invest\",\"invite\",\"involve\",\"iron\",\"island\",\"isolate\",\"issue\",\"item\",\"ivory\",\"jacket\",\"jaguar\",\"jar\",\"jazz\",\"jealous\",\"jeans\",\"jelly\",\"jewel\",\"job\",\"join\",\"joke\",\"journey\",\"joy\",\"judge\",\"juice\",\"jump\",\"jungle\",\"junior\",\"junk\",\"just\",\"kangaroo\",\"keen\",\"keep\",\"ketchup\",\"key\",\"kick\",\"kid\",\"kidney\",\"kind\",\"kingdom\",\"kiss\",\"kit\",\"kitchen\",\"kite\",\"kitten\",\"kiwi\",\"knee\",\"knife\",\"knock\",\"know\",\"lab\",\"label\",\"labor\",\"ladder\",\"lady\",\"lake\",\"lamp\",\"language\",\"laptop\",\"large\",\"later\",\"latin\",\"laugh\",\"laundry\",\"lava\",\"law\",\"lawn\",\"lawsuit\",\"layer\",\"lazy\",\"leader\",\"leaf\",\"learn\",\"leave\",\"lecture\",\"left\",\"leg\",\"legal\",\"legend\",\"leisure\",\"lemon\",\"lend\",\"length\",\"lens\",\"leopard\",\"lesson\",\"letter\",\"level\",\"liar\",\"liberty\",\"library\",\"license\",\"life\",\"lift\",\"light\",\"like\",\"limb\",\"limit\",\"link\",\"lion\",\"liquid\",\"list\",\"little\",\"live\",\"lizard\",\"load\",\"loan\",\"lobster\",\"local\",\"lock\",\"logic\",\"lonely\",\"long\",\"loop\",\"lottery\",\"loud\",\"lounge\",\"love\",\"loyal\",\"lucky\",\"luggage\",\"lumber\",\"lunar\",\"lunch\",\"luxury\",\"lyrics\",\"machine\",\"mad\",\"magic\",\"magnet\",\"maid\",\"mail\",\"main\",\"major\",\"make\",\"mammal\",\"man\",\"manage\",\"mandate\",\"mango\",\"mansion\",\"manual\",\"maple\",\"marble\",\"march\",\"margin\",\"marine\",\"market\",\"marriage\",\"mask\",\"mass\",\"master\",\"match\",\"material\",\"math\",\"matrix\",\"matter\",\"maximum\",\"maze\",\"meadow\",\"mean\",\"measure\",\"meat\",\"mechanic\",\"medal\",\"media\",\"melody\",\"melt\",\"member\",\"memory\",\"mention\",\"menu\",\"mercy\",\"merge\",\"merit\",\"merry\",\"mesh\",\"message\",\"metal\",\"method\",\"middle\",\"midnight\",\"milk\",\"million\",\"mimic\",\"mind\",\"minimum\",\"minor\",\"minute\",\"miracle\",\"mirror\",\"misery\",\"miss\",\"mistake\",\"mix\",\"mixed\",\"mixture\",\"mobile\",\"model\",\"modify\",\"mom\",\"moment\",\"monitor\",\"monkey\",\"monster\",\"month\",\"moon\",\"moral\",\"more\",\"morning\",\"mosquito\",\"mother\",\"motion\",\"motor\",\"mountain\",\"mouse\",\"move\",\"movie\",\"much\",\"muffin\",\"mule\",\"multiply\",\"muscle\",\"museum\",\"mushroom\",\"music\",\"must\",\"mutual\",\"myself\",\"mystery\",\"myth\",\"naive\",\"name\",\"napkin\",\"narrow\",\"nasty\",\"nation\",\"nature\",\"near\",\"neck\",\"need\",\"negative\",\"neglect\",\"neither\",\"nephew\",\"nerve\",\"nest\",\"net\",\"network\",\"neutral\",\"never\",\"news\",\"next\",\"nice\",\"night\",\"noble\",\"noise\",\"nominee\",\"noodle\",\"normal\",\"north\",\"nose\",\"notable\",\"note\",\"nothing\",\"notice\",\"novel\",\"now\",\"nuclear\",\"number\",\"nurse\",\"nut\",\"oak\",\"obey\",\"object\",\"oblige\",\"obscure\",\"observe\",\"obtain\",\"obvious\",\"occur\",\"ocean\",\"october\",\"odor\",\"off\",\"offer\",\"office\",\"often\",\"oil\",\"okay\",\"old\",\"olive\",\"olympic\",\"omit\",\"once\",\"one\",\"onion\",\"online\",\"only\",\"open\",\"opera\",\"opinion\",\"oppose\",\"option\",\"orange\",\"orbit\",\"orchard\",\"order\",\"ordinary\",\"organ\",\"orient\",\"original\",\"orphan\",\"ostrich\",\"other\",\"outdoor\",\"outer\",\"output\",\"outside\",\"oval\",\"oven\",\"over\",\"own\",\"owner\",\"oxygen\",\"oyster\",\"ozone\",\"pact\",\"paddle\",\"page\",\"pair\",\"palace\",\"palm\",\"panda\",\"panel\",\"panic\",\"panther\",\"paper\",\"parade\",\"parent\",\"park\",\"parrot\",\"party\",\"pass\",\"patch\",\"path\",\"patient\",\"patrol\",\"pattern\",\"pause\",\"pave\",\"payment\",\"peace\",\"peanut\",\"pear\",\"peasant\",\"pelican\",\"pen\",\"penalty\",\"pencil\",\"people\",\"pepper\",\"perfect\",\"permit\",\"person\",\"pet\",\"phone\",\"photo\",\"phrase\",\"physical\",\"piano\",\"picnic\",\"picture\",\"piece\",\"pig\",\"pigeon\",\"pill\",\"pilot\",\"pink\",\"pioneer\",\"pipe\",\"pistol\",\"pitch\",\"pizza\",\"place\",\"planet\",\"plastic\",\"plate\",\"play\",\"please\",\"pledge\",\"pluck\",\"plug\",\"plunge\",\"poem\",\"poet\",\"point\",\"polar\",\"pole\",\"police\",\"pond\",\"pony\",\"pool\",\"popular\",\"portion\",\"position\",\"possible\",\"post\",\"potato\",\"pottery\",\"poverty\",\"powder\",\"power\",\"practice\",\"praise\",\"predict\",\"prefer\",\"prepare\",\"present\",\"pretty\",\"prevent\",\"price\",\"pride\",\"primary\",\"print\",\"priority\",\"prison\",\"private\",\"prize\",\"problem\",\"process\",\"produce\",\"profit\",\"program\",\"project\",\"promote\",\"proof\",\"property\",\"prosper\",\"protect\",\"proud\",\"provide\",\"public\",\"pudding\",\"pull\",\"pulp\",\"pulse\",\"pumpkin\",\"punch\",\"pupil\",\"puppy\",\"purchase\",\"purity\",\"purpose\",\"purse\",\"push\",\"put\",\"puzzle\",\"pyramid\",\"quality\",\"quantum\",\"quarter\",\"question\",\"quick\",\"quit\",\"quiz\",\"quote\",\"rabbit\",\"raccoon\",\"race\",\"rack\",\"radar\",\"radio\",\"rail\",\"rain\",\"raise\",\"rally\",\"ramp\",\"ranch\",\"random\",\"range\",\"rapid\",\"rare\",\"rate\",\"rather\",\"raven\",\"raw\",\"razor\",\"ready\",\"real\",\"reason\",\"rebel\",\"rebuild\",\"recall\",\"receive\",\"recipe\",\"record\",\"recycle\",\"reduce\",\"reflect\",\"reform\",\"refuse\",\"region\",\"regret\",\"regular\",\"reject\",\"relax\",\"release\",\"relief\",\"rely\",\"remain\",\"remember\",\"remind\",\"remove\",\"render\",\"renew\",\"rent\",\"reopen\",\"repair\",\"repeat\",\"replace\",\"report\",\"require\",\"rescue\",\"resemble\",\"resist\",\"resource\",\"response\",\"result\",\"retire\",\"retreat\",\"return\",\"reunion\",\"reveal\",\"review\",\"reward\",\"rhythm\",\"rib\",\"ribbon\",\"rice\",\"rich\",\"ride\",\"ridge\",\"rifle\",\"right\",\"rigid\",\"ring\",\"riot\",\"ripple\",\"risk\",\"ritual\",\"rival\",\"river\",\"road\",\"roast\",\"robot\",\"robust\",\"rocket\",\"romance\",\"roof\",\"rookie\",\"room\",\"rose\",\"rotate\",\"rough\",\"round\",\"route\",\"royal\",\"rubber\",\"rude\",\"rug\",\"rule\",\"run\",\"runway\",\"rural\",\"sad\",\"saddle\",\"sadness\",\"safe\",\"sail\",\"salad\",\"salmon\",\"salon\",\"salt\",\"salute\",\"same\",\"sample\",\"sand\",\"satisfy\",\"satoshi\",\"sauce\",\"sausage\",\"save\",\"say\",\"scale\",\"scan\",\"scare\",\"scatter\",\"scene\",\"scheme\",\"school\",\"science\",\"scissors\",\"scorpion\",\"scout\",\"scrap\",\"screen\",\"script\",\"scrub\",\"sea\",\"search\",\"season\",\"seat\",\"second\",\"secret\",\"section\",\"security\",\"seed\",\"seek\",\"segment\",\"select\",\"sell\",\"seminar\",\"senior\",\"sense\",\"sentence\",\"series\",\"service\",\"session\",\"settle\",\"setup\",\"seven\",\"shadow\",\"shaft\",\"shallow\",\"share\",\"shed\",\"shell\",\"sheriff\",\"shield\",\"shift\",\"shine\",\"ship\",\"shiver\",\"shock\",\"shoe\",\"shoot\",\"shop\",\"short\",\"shoulder\",\"shove\",\"shrimp\",\"shrug\",\"shuffle\",\"shy\",\"sibling\",\"sick\",\"side\",\"siege\",\"sight\",\"sign\",\"silent\",\"silk\",\"silly\",\"silver\",\"similar\",\"simple\",\"since\",\"sing\",\"siren\",\"sister\",\"situate\",\"six\",\"size\",\"skate\",\"sketch\",\"ski\",\"skill\",\"skin\",\"skirt\",\"skull\",\"slab\",\"slam\",\"sleep\",\"slender\",\"slice\",\"slide\",\"slight\",\"slim\",\"slogan\",\"slot\",\"slow\",\"slush\",\"small\",\"smart\",\"smile\",\"smoke\",\"smooth\",\"snack\",\"snake\",\"snap\",\"sniff\",\"snow\",\"soap\",\"soccer\",\"social\",\"sock\",\"soda\",\"soft\",\"solar\",\"soldier\",\"solid\",\"solution\",\"solve\",\"someone\",\"song\",\"soon\",\"sorry\",\"sort\",\"soul\",\"sound\",\"soup\",\"source\",\"south\",\"space\",\"spare\",\"spatial\",\"spawn\",\"speak\",\"special\",\"speed\",\"spell\",\"spend\",\"sphere\",\"spice\",\"spider\",\"spike\",\"spin\",\"spirit\",\"split\",\"spoil\",\"sponsor\",\"spoon\",\"sport\",\"spot\",\"spray\",\"spread\",\"spring\",\"spy\",\"square\",\"squeeze\",\"squirrel\",\"stable\",\"stadium\",\"staff\",\"stage\",\"stairs\",\"stamp\",\"stand\",\"start\",\"state\",\"stay\",\"steak\",\"steel\",\"stem\",\"step\",\"stereo\",\"stick\",\"still\",\"sting\",\"stock\",\"stomach\",\"stone\",\"stool\",\"story\",\"stove\",\"strategy\",\"street\",\"strike\",\"strong\",\"struggle\",\"student\",\"stuff\",\"stumble\",\"style\",\"subject\",\"submit\",\"subway\",\"success\",\"such\",\"sudden\",\"suffer\",\"sugar\",\"suggest\",\"suit\",\"summer\",\"sun\",\"sunny\",\"sunset\",\"super\",\"supply\",\"supreme\",\"sure\",\"surface\",\"surge\",\"surprise\",\"surround\",\"survey\",\"suspect\",\"sustain\",\"swallow\",\"swamp\",\"swap\",\"swarm\",\"swear\",\"sweet\",\"swift\",\"swim\",\"swing\",\"switch\",\"sword\",\"symbol\",\"symptom\",\"syrup\",\"system\",\"table\",\"tackle\",\"tag\",\"tail\",\"talent\",\"talk\",\"tank\",\"tape\",\"target\",\"task\",\"taste\",\"tattoo\",\"taxi\",\"teach\",\"team\",\"tell\",\"ten\",\"tenant\",\"tennis\",\"tent\",\"term\",\"test\",\"text\",\"thank\",\"that\",\"theme\",\"then\",\"theory\",\"there\",\"they\",\"thing\",\"this\",\"thought\",\"three\",\"thrive\",\"throw\",\"thumb\",\"thunder\",\"ticket\",\"tide\",\"tiger\",\"tilt\",\"timber\",\"time\",\"tiny\",\"tip\",\"tired\",\"tissue\",\"title\",\"toast\",\"tobacco\",\"today\",\"toddler\",\"toe\",\"together\",\"toilet\",\"token\",\"tomato\",\"tomorrow\",\"tone\",\"tongue\",\"tonight\",\"tool\",\"tooth\",\"top\",\"topic\",\"topple\",\"torch\",\"tornado\",\"tortoise\",\"toss\",\"total\",\"tourist\",\"toward\",\"tower\",\"town\",\"toy\",\"track\",\"trade\",\"traffic\",\"tragic\",\"train\",\"transfer\",\"trap\",\"trash\",\"travel\",\"tray\",\"treat\",\"tree\",\"trend\",\"trial\",\"tribe\",\"trick\",\"trigger\",\"trim\",\"trip\",\"trophy\",\"trouble\",\"truck\",\"true\",\"truly\",\"trumpet\",\"trust\",\"truth\",\"try\",\"tube\",\"tuition\",\"tumble\",\"tuna\",\"tunnel\",\"turkey\",\"turn\",\"turtle\",\"twelve\",\"twenty\",\"twice\",\"twin\",\"twist\",\"two\",\"type\",\"typical\",\"ugly\",\"umbrella\",\"unable\",\"unaware\",\"uncle\",\"uncover\",\"under\",\"undo\",\"unfair\",\"unfold\",\"unhappy\",\"uniform\",\"unique\",\"unit\",\"universe\",\"unknown\",\"unlock\",\"until\",\"unusual\",\"unveil\",\"update\",\"upgrade\",\"uphold\",\"upon\",\"upper\",\"upset\",\"urban\",\"urge\",\"usage\",\"use\",\"used\",\"useful\",\"useless\",\"usual\",\"utility\",\"vacant\",\"vacuum\",\"vague\",\"valid\",\"valley\",\"valve\",\"van\",\"vanish\",\"vapor\",\"various\",\"vast\",\"vault\",\"vehicle\",\"velvet\",\"vendor\",\"venture\",\"venue\",\"verb\",\"verify\",\"version\",\"very\",\"vessel\",\"veteran\",\"viable\",\"vibrant\",\"vicious\",\"victory\",\"video\",\"view\",\"village\",\"vintage\",\"violin\",\"virtual\",\"virus\",\"visa\",\"visit\",\"visual\",\"vital\",\"vivid\",\"vocal\",\"voice\",\"void\",\"volcano\",\"volume\",\"vote\",\"voyage\",\"wage\",\"wagon\",\"wait\",\"walk\",\"wall\",\"walnut\",\"want\",\"warfare\",\"warm\",\"warrior\",\"wash\",\"wasp\",\"waste\",\"water\",\"wave\",\"way\",\"wealth\",\"weapon\",\"wear\",\"weasel\",\"weather\",\"web\",\"wedding\",\"weekend\",\"weird\",\"welcome\",\"west\",\"wet\",\"whale\",\"what\",\"wheat\",\"wheel\",\"when\",\"where\",\"whip\",\"whisper\",\"wide\",\"width\",\"wife\",\"wild\",\"will\",\"win\",\"window\",\"wine\",\"wing\",\"wink\",\"winner\",\"winter\",\"wire\",\"wisdom\",\"wise\",\"wish\",\"witness\",\"wolf\",\"woman\",\"wonder\",\"wood\",\"wool\",\"word\",\"work\",\"world\",\"worry\",\"worth\",\"wrap\",\"wreck\",\"wrestle\",\"wrist\",\"write\",\"wrong\",\"yard\",\"year\",\"yellow\",\"you\",\"young\",\"youth\",\"zebra\",\"zero\",\"zone\",\"zoo\"]");

var hasRequired_wordlists;

function require_wordlists () {
	if (hasRequired_wordlists) return _wordlists;
	hasRequired_wordlists = 1;
	Object.defineProperty(_wordlists, "__esModule", { value: true });
	// browserify by default only pulls in files that are hard coded in requires
	// In order of last to first in this file, the default wordlist will be chosen
	// based on what is present. (Bundles may remove wordlists they don't need)
	const wordlists = {};
	_wordlists.wordlists = wordlists;
	let _default;
	_wordlists._default = _default;
	try {
	    _wordlists._default = _default = require$$0;
	    wordlists.czech = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$1;
	    wordlists.chinese_simplified = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$2;
	    wordlists.chinese_traditional = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$3;
	    wordlists.korean = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$4;
	    wordlists.french = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$5;
	    wordlists.italian = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$6;
	    wordlists.spanish = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$7;
	    wordlists.japanese = _default;
	    wordlists.JA = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$8;
	    wordlists.portuguese = _default;
	}
	catch (err) { }
	try {
	    _wordlists._default = _default = require$$9;
	    wordlists.english = _default;
	    wordlists.EN = _default;
	}
	catch (err) { }
	return _wordlists;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src;
	hasRequiredSrc = 1;
	Object.defineProperty(src, "__esModule", { value: true });
	const sha256_1 = /*@__PURE__*/ requireSha256$1();
	const sha512_1 = /*@__PURE__*/ requireSha512$1();
	const pbkdf2_1 = /*@__PURE__*/ requirePbkdf2();
	const utils_1 = /*@__PURE__*/ requireUtils();
	const _wordlists_1 = require_wordlists();
	let DEFAULT_WORDLIST = _wordlists_1._default;
	const INVALID_MNEMONIC = 'Invalid mnemonic';
	const INVALID_ENTROPY = 'Invalid entropy';
	const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
	const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
	    'Please pass a 2048 word array explicitly.';
	function normalize(str) {
	    return (str || '').normalize('NFKD');
	}
	function lpad(str, padString, length) {
	    while (str.length < length) {
	        str = padString + str;
	    }
	    return str;
	}
	function binaryToByte(bin) {
	    return parseInt(bin, 2);
	}
	function bytesToBinary(bytes) {
	    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');
	}
	function deriveChecksumBits(entropyBuffer) {
	    const ENT = entropyBuffer.length * 8;
	    const CS = ENT / 32;
	    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
	    return bytesToBinary(Array.from(hash)).slice(0, CS);
	}
	function salt(password) {
	    return 'mnemonic' + (password || '');
	}
	function mnemonicToSeedSync(mnemonic, password) {
	    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
	    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
	    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
	        c: 2048,
	        dkLen: 64,
	    });
	    return Buffer.from(res);
	}
	src.mnemonicToSeedSync = mnemonicToSeedSync;
	function mnemonicToSeed(mnemonic, password) {
	    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));
	    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));
	    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
	        c: 2048,
	        dkLen: 64,
	    }).then((res) => Buffer.from(res));
	}
	src.mnemonicToSeed = mnemonicToSeed;
	function mnemonicToEntropy(mnemonic, wordlist) {
	    wordlist = wordlist || DEFAULT_WORDLIST;
	    if (!wordlist) {
	        throw new Error(WORDLIST_REQUIRED);
	    }
	    const words = normalize(mnemonic).split(' ');
	    if (words.length % 3 !== 0) {
	        throw new Error(INVALID_MNEMONIC);
	    }
	    // convert word indices to 11 bit binary strings
	    const bits = words
	        .map((word) => {
	        const index = wordlist.indexOf(word);
	        if (index === -1) {
	            throw new Error(INVALID_MNEMONIC);
	        }
	        return lpad(index.toString(2), '0', 11);
	    })
	        .join('');
	    // split the binary string into ENT/CS
	    const dividerIndex = Math.floor(bits.length / 33) * 32;
	    const entropyBits = bits.slice(0, dividerIndex);
	    const checksumBits = bits.slice(dividerIndex);
	    // calculate the checksum and compare
	    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
	    if (entropyBytes.length < 16) {
	        throw new Error(INVALID_ENTROPY);
	    }
	    if (entropyBytes.length > 32) {
	        throw new Error(INVALID_ENTROPY);
	    }
	    if (entropyBytes.length % 4 !== 0) {
	        throw new Error(INVALID_ENTROPY);
	    }
	    const entropy = Buffer.from(entropyBytes);
	    const newChecksum = deriveChecksumBits(entropy);
	    if (newChecksum !== checksumBits) {
	        throw new Error(INVALID_CHECKSUM);
	    }
	    return entropy.toString('hex');
	}
	src.mnemonicToEntropy = mnemonicToEntropy;
	function entropyToMnemonic(entropy, wordlist) {
	    if (!Buffer.isBuffer(entropy)) {
	        entropy = Buffer.from(entropy, 'hex');
	    }
	    wordlist = wordlist || DEFAULT_WORDLIST;
	    if (!wordlist) {
	        throw new Error(WORDLIST_REQUIRED);
	    }
	    // 128 <= ENT <= 256
	    if (entropy.length < 16) {
	        throw new TypeError(INVALID_ENTROPY);
	    }
	    if (entropy.length > 32) {
	        throw new TypeError(INVALID_ENTROPY);
	    }
	    if (entropy.length % 4 !== 0) {
	        throw new TypeError(INVALID_ENTROPY);
	    }
	    const entropyBits = bytesToBinary(Array.from(entropy));
	    const checksumBits = deriveChecksumBits(entropy);
	    const bits = entropyBits + checksumBits;
	    const chunks = bits.match(/(.{1,11})/g);
	    const words = chunks.map((binary) => {
	        const index = binaryToByte(binary);
	        return wordlist[index];
	    });
	    return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
	        ? words.join('\u3000')
	        : words.join(' ');
	}
	src.entropyToMnemonic = entropyToMnemonic;
	function generateMnemonic(strength, rng, wordlist) {
	    strength = strength || 128;
	    if (strength % 32 !== 0) {
	        throw new TypeError(INVALID_ENTROPY);
	    }
	    rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));
	    return entropyToMnemonic(rng(strength / 8), wordlist);
	}
	src.generateMnemonic = generateMnemonic;
	function validateMnemonic(mnemonic, wordlist) {
	    try {
	        mnemonicToEntropy(mnemonic, wordlist);
	    }
	    catch (e) {
	        return false;
	    }
	    return true;
	}
	src.validateMnemonic = validateMnemonic;
	function setDefaultWordlist(language) {
	    const result = _wordlists_1.wordlists[language];
	    if (result) {
	        DEFAULT_WORDLIST = result;
	    }
	    else {
	        throw new Error('Could not find wordlist for language "' + language + '"');
	    }
	}
	src.setDefaultWordlist = setDefaultWordlist;
	function getDefaultWordlist() {
	    if (!DEFAULT_WORDLIST) {
	        throw new Error('No Default Wordlist set');
	    }
	    return Object.keys(_wordlists_1.wordlists).filter((lang) => {
	        if (lang === 'JA' || lang === 'EN') {
	            return false;
	        }
	        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
	    })[0];
	}
	src.getDefaultWordlist = getDefaultWordlist;
	var _wordlists_2 = require_wordlists();
	src.wordlists = _wordlists_2.wordlists;
	return src;
}

requireSrc();

var MnemonicStrength;
(function (MnemonicStrength) {
    /** 128 bits of entropy - 12 words */
    MnemonicStrength[MnemonicStrength["MINIMUM"] = 128] = "MINIMUM";
    /** 160 bits of entropy - 15 words */
    MnemonicStrength[MnemonicStrength["LOW"] = 160] = "LOW";
    /** 192 bits of entropy - 18 words */
    MnemonicStrength[MnemonicStrength["MEDIUM"] = 192] = "MEDIUM";
    /** 224 bits of entropy - 21 words */
    MnemonicStrength[MnemonicStrength["HIGH"] = 224] = "HIGH";
    /** 256 bits of entropy - 24 words */
    MnemonicStrength[MnemonicStrength["MAXIMUM"] = 256] = "MAXIMUM";
})(MnemonicStrength || (MnemonicStrength = {}));

/**
 * BIP (Bitcoin Improvement Proposal) derivation path standards
 *
 * These define standardized derivation paths for different address types
 * in hierarchical deterministic (HD) wallets.
 *
 * @see https://github.com/bitcoin/bips
 */
var BIPStandard;
(function (BIPStandard) {
    /**
     * BIP44: Multi-Account Hierarchy for Deterministic Wallets
     *
     * Path: m/44'/coin_type'/account'/change/address_index
     * Original standard for P2PKH (legacy) addresses
     * Widely used by wallets like Unisat for all address types
     *
     * @see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
     */
    BIPStandard[BIPStandard["BIP44"] = 44] = "BIP44";
    /**
     * BIP49: Derivation scheme for P2WPKH-nested-in-P2SH based accounts
     *
     * Path: m/49'/coin_type'/account'/change/address_index
     * For wrapped SegWit addresses (P2SH-P2WPKH starting with '3')
     *
     * @see https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
     */
    BIPStandard[BIPStandard["BIP49"] = 49] = "BIP49";
    /**
     * BIP84: Derivation scheme for P2WPKH based accounts
     *
     * Path: m/84'/coin_type'/account'/change/address_index
     * For native SegWit addresses (P2WPKH starting with 'bc1q')
     * DEFAULT for this library
     *
     * @see https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
     */
    BIPStandard[BIPStandard["BIP84"] = 84] = "BIP84";
    /**
     * BIP86: Derivation scheme for P2TR based accounts
     *
     * Path: m/86'/coin_type'/account'/change/address_index
     * For Taproot addresses (P2TR starting with 'bc1p')
     *
     * @see https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki
     */
    BIPStandard[BIPStandard["BIP86"] = 86] = "BIP86";
})(BIPStandard || (BIPStandard = {}));

cjsExports.BIP32Factory(backend);

var MLDSAPublicKeyMetadata;
(function (MLDSAPublicKeyMetadata) {
    MLDSAPublicKeyMetadata[MLDSAPublicKeyMetadata["MLDSA44"] = 1312] = "MLDSA44";
    MLDSAPublicKeyMetadata[MLDSAPublicKeyMetadata["MLDSA65"] = 1952] = "MLDSA65";
    MLDSAPublicKeyMetadata[MLDSAPublicKeyMetadata["MLDSA87"] = 2592] = "MLDSA87";
})(MLDSAPublicKeyMetadata || (MLDSAPublicKeyMetadata = {}));
function getLevelFromPublicKeyLength(length) {
    switch (length) {
        case MLDSAPublicKeyMetadata.MLDSA44:
            return cjsExports.MLDSASecurityLevel.LEVEL2;
        case MLDSAPublicKeyMetadata.MLDSA65:
            return cjsExports.MLDSASecurityLevel.LEVEL3;
        case MLDSAPublicKeyMetadata.MLDSA87:
            return cjsExports.MLDSASecurityLevel.LEVEL5;
        default:
            throw new Error(`Invalid MLDSA public key length: ${length}`);
    }
}

var ChainId;
(function (ChainId) {
    ChainId[ChainId["Bitcoin"] = 0] = "Bitcoin";
    ChainId[ChainId["Fractal"] = 1] = "Fractal";
})(ChainId || (ChainId = {}));

// Helper functions
function isTaprootInput(input) {
    return (input &&
        !!(input.tapInternalKey ||
            input.tapMerkleRoot ||
            (input.tapLeafScript && input.tapLeafScript.length) ||
            (input.tapBip32Derivation && input.tapBip32Derivation.length) ||
            (input.witnessUtxo &&
                (isP2TR(input.witnessUtxo.script) || isP2MR(input.witnessUtxo.script)))));
}
function getInputRelevantScript(input) {
    if (input.redeemScript) {
        return input.redeemScript;
    }
    if (input.witnessScript) {
        return input.witnessScript;
    }
    if (input.witnessUtxo) {
        return input.witnessUtxo.script;
    }
    if (input.nonWitnessUtxo) ;
    return null;
}
function canSignNonTaprootInput(input, publicKey) {
    if ((input.nonWitnessUtxo &&
        !input.redeemScript &&
        !input.witnessScript &&
        !input.witnessUtxo) ||
        input.redeemScript) {
        return true;
    }
    const script = getInputRelevantScript(input);
    if (script) {
        return pubkeyInScript(publicKey, script);
    }
    return false;
}
/**
 * Checks if a public key is present in a script.
 * @param pubkey The public key to check.
 * @param script The script to search in.
 * @returns A boolean indicating whether the public key is present in the script.
 */
function pubkeyInScript(pubkey, script) {
    return pubkeyPositionInScript(pubkey, script) !== -1;
}

/**
 * Creates a hybrid adapter with untweaked publicKey (for PSBT input matching)
 * but tweaked privateKey (for correct key-path Schnorr signatures).
 * Uses createPrivateKey/createPublicKey for branded type validation.
 */
function toTweakedParallelKeyPair(untweakedSigner, tweakedSigner) {
    return {
        publicKey: ln(untweakedSigner.publicKey),
        getPrivateKey() {
            if (!tweakedSigner.privateKey) {
                throw new Error('Tweaked signer does not have a private key');
            }
            return zt(tweakedSigner.privateKey);
        },
        sign(hash, lowR) {
            return tweakedSigner.sign(hash, lowR);
        },
        signSchnorr(hash) {
            if (!tweakedSigner.signSchnorr) {
                throw new Error('Tweaked signer does not support Schnorr signing');
            }
            return tweakedSigner.signSchnorr(hash);
        },
    };
}

var TransactionType;
(function (TransactionType) {
    TransactionType[TransactionType["GENERIC"] = 0] = "GENERIC";
    TransactionType[TransactionType["FUNDING"] = 1] = "FUNDING";
    TransactionType[TransactionType["DEPLOYMENT"] = 2] = "DEPLOYMENT";
    TransactionType[TransactionType["INTERACTION"] = 3] = "INTERACTION";
    TransactionType[TransactionType["MULTI_SIG"] = 4] = "MULTI_SIG";
    TransactionType[TransactionType["CUSTOM_CODE"] = 5] = "CUSTOM_CODE";
    TransactionType[TransactionType["CANCEL"] = 6] = "CANCEL";
    TransactionType[TransactionType["CONSOLIDATED_SETUP"] = 7] = "CONSOLIDATED_SETUP";
    TransactionType[TransactionType["CONSOLIDATED_REVEAL"] = 8] = "CONSOLIDATED_REVEAL";
})(TransactionType || (TransactionType = {}));

/**
 * Convert witness stack to script witness buffer
 * @param {Uint8Array[]} witness - The witness stack
 * @returns {Uint8Array}
 */
function witnessStackToScriptWitness(witness) {
    let buffer = new Uint8Array(0);
    function concatBuffers(a, b) {
        const result = new Uint8Array(a.length + b.length);
        result.set(a, 0);
        result.set(b, a.length);
        return result;
    }
    function writeSlice(slice) {
        buffer = concatBuffers(buffer, slice);
    }
    function writeVarInt(i) {
        const currentLen = buffer.length;
        const varintLen = encodingLength$1(i);
        const newBuffer = new Uint8Array(currentLen + varintLen);
        newBuffer.set(buffer, 0);
        buffer = newBuffer;
        encode$k(i, buffer, currentLen);
    }
    function writeVarSlice(slice) {
        writeVarInt(slice.length);
        writeSlice(slice);
    }
    function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
    }
    writeVector(witness);
    return buffer;
}

/**
 * The transaction sequence
 */
var TransactionSequence;
(function (TransactionSequence) {
    TransactionSequence[TransactionSequence["REPLACE_BY_FEE"] = 4294967293] = "REPLACE_BY_FEE";
    TransactionSequence[TransactionSequence["FINAL"] = 4294967295] = "FINAL";
})(TransactionSequence || (TransactionSequence = {}));
var CSVModes;
(function (CSVModes) {
    CSVModes[CSVModes["BLOCKS"] = 0] = "BLOCKS";
    CSVModes[CSVModes["TIMESTAMPS"] = 1] = "TIMESTAMPS";
})(CSVModes || (CSVModes = {}));
/**
 * @description PSBT Transaction processor.
 * */
class TweakedTransaction extends Logger {
    logColor = '#00ffe1';
    finalized = false;
    /**
     * @description Was the transaction signed?
     */
    signer;
    /**
     * @description Tweaked signer
     */
    tweakedSigner;
    /**
     * @description The network of the transaction
     */
    network;
    /**
     * @description Was the transaction signed?
     */
    signed = false;
    /**
     * @description The sighash types of the transaction
     * @protected
     */
    sighashTypes;
    /**
     * @description The script data of the transaction
     */
    scriptData = null;
    /**
     * @description The tap data of the transaction
     */
    tapData = null;
    /**
     * @description The inputs of the transaction
     */
    inputs = [];
    /**
     * @description The sequence of the transaction
     * @protected
     */
    sequence = TransactionSequence.REPLACE_BY_FEE;
    /**
     * The tap leaf script
     * @protected
     */
    tapLeafScript = null;
    /**
     * Add a non-witness utxo to the transaction
     * @protected
     */
    nonWitnessUtxo;
    /**
     * Is the transaction being generated inside a browser?
     * @protected
     */
    isBrowser = false;
    /**
     * Track which inputs contain CSV scripts
     * @protected
     */
    csvInputIndices = new Set();
    anchorInputIndices = new Set();
    regenerated = false;
    ignoreSignatureErrors = false;
    noSignatures = false;
    unlockScript;
    txVersion = 2;
    _mldsaSigner = null;
    _hashedPublicKey = null;
    /**
     * Whether address rotation mode is enabled.
     * When true, each UTXO can be signed by a different signer.
     */
    addressRotationEnabled = false;
    /**
     * Map of addresses to their respective signers for address rotation mode.
     */
    signerMap = new Map();
    /**
     * Map of input indices to their signers (resolved from UTXOs or signerMap).
     * Populated during input addition.
     */
    inputSignerMap = new Map();
    /**
     * Cache of tweaked signers per input for address rotation mode.
     */
    tweakedSignerCache = new Map();
    /**
     * Parallel signing configuration using worker threads.
     * When set, key-path taproot inputs are signed in parallel via workers.
     */
    parallelSigningConfig;
    /**
     * Whether to use P2MR (Pay-to-Merkle-Root, BIP 360) instead of P2TR.
     */
    useP2MR = false;
    constructor(data) {
        super();
        this.signer = data.signer;
        this.network = data.network;
        this.noSignatures = data.noSignatures || false;
        if (data.nonWitnessUtxo !== undefined) {
            this.nonWitnessUtxo = data.nonWitnessUtxo;
        }
        if (data.unlockScript !== undefined) {
            this.unlockScript = data.unlockScript;
        }
        this.isBrowser = typeof window !== 'undefined';
        if (data.txVersion) {
            this.txVersion = data.txVersion;
        }
        if (data.mldsaSigner) {
            this._mldsaSigner = data.mldsaSigner;
            this._hashedPublicKey = MessageSigner.sha256(this._mldsaSigner.publicKey);
        }
        // Initialize address rotation
        if (data.addressRotation?.enabled) {
            this.addressRotationEnabled = true;
            this.signerMap = data.addressRotation.signerMap;
        }
        if (data.parallelSigning) {
            this.parallelSigningConfig = data.parallelSigning;
        }
        if (data.useP2MR) {
            this.useP2MR = true;
        }
    }
    /**
     * Get the MLDSA signer
     * @protected
     */
    get mldsaSigner() {
        if (!this._mldsaSigner) {
            throw new Error('MLDSA Signer is not set');
        }
        return this._mldsaSigner;
    }
    /**
     * Get the hashed public key
     * @protected
     */
    get hashedPublicKey() {
        if (!this._hashedPublicKey) {
            throw new Error('Hashed public key is not set');
        }
        return this._hashedPublicKey;
    }
    /**
     * Whether parallel signing can be used for this transaction.
     * Requires parallelSigningConfig and excludes browser, address rotation, and no-signature modes.
     */
    get canUseParallelSigning() {
        return !!this.parallelSigningConfig && !this.addressRotationEnabled && !this.noSignatures;
    }
    /**
     * Read witnesses
     * @protected
     */
    static readScriptWitnessToWitnessStack(buffer) {
        let offset = 0;
        function readSlice(n) {
            const slice = new Uint8Array(buffer.subarray(offset, offset + n));
            offset += n;
            return slice;
        }
        function readVarInt() {
            const varint = decode$j(buffer, offset);
            offset += varint.bytes;
            return varint.numberValue || 0;
        }
        function readVarSlice() {
            const len = readVarInt();
            return readSlice(len);
        }
        function readVector() {
            const count = readVarInt();
            const vector = [];
            for (let i = 0; i < count; i++) {
                vector.push(readVarSlice());
            }
            return vector;
        }
        return readVector();
    }
    /**
     * Pre-estimate the transaction fees for a Taproot transaction
     * @param {bigint} feeRate - The fee rate in satoshis per virtual byte
     * @param {bigint} numInputs - The number of inputs
     * @param {bigint} numOutputs - The number of outputs
     * @param {bigint} numWitnessElements - The number of witness elements (e.g., number of control blocks and witnesses)
     * @param {bigint} witnessElementSize - The average size of each witness element in bytes
     * @param {bigint} emptyWitness - The amount of empty witnesses
     * @param {bigint} [taprootControlWitnessSize=139n] - The size of the control block witness in bytes
     * @param {bigint} [taprootScriptSize=32n] - The size of the taproot script in bytes
     * @returns {bigint} - The estimated transaction fees
     */
    static preEstimateTaprootTransactionFees(feeRate, // satoshis per virtual byte
    numInputs, numOutputs, numWitnessElements, witnessElementSize, emptyWitness, taprootControlWitnessSize = 32n, taprootScriptSize = 139n) {
        const txHeaderSize = 10n;
        const inputBaseSize = 41n;
        const outputSize = 68n;
        const taprootWitnessBaseSize = 1n; // Base witness size per input (without signatures and control blocks)
        // Base transaction size (excluding witness data)
        const baseTxSize = txHeaderSize + inputBaseSize * numInputs + outputSize * numOutputs;
        // Witness data size for Taproot
        const witnessSize = numInputs * taprootWitnessBaseSize +
            numWitnessElements * witnessElementSize +
            taprootControlWitnessSize * numInputs +
            taprootScriptSize * numInputs +
            emptyWitness;
        // Total weight and virtual size
        const weight = baseTxSize * 3n + (baseTxSize + witnessSize);
        const vSize = weight / 4n;
        return vSize * feeRate;
    }
    static signInput(transaction, input, i, signer, sighashTypes) {
        if (sighashTypes && sighashTypes[0])
            input.sighashType = sighashTypes[0];
        transaction.signInput(i, signer, sighashTypes.length ? sighashTypes : undefined);
    }
    /**
     * Calculate the sign hash number
     * @description Calculates the sign hash
     * @protected
     * @returns {number}
     */
    static calculateSignHash(sighashTypes) {
        if (!sighashTypes) {
            throw new Error('Sighash types are required');
        }
        let signHash = 0;
        for (const sighashType of sighashTypes) {
            signHash |= sighashType;
        }
        return signHash || 0;
    }
    [Symbol.dispose]() {
        this.inputs.length = 0;
        this.scriptData = null;
        this.tapData = null;
        this.tapLeafScript = null;
        delete this.tweakedSigner;
        this.csvInputIndices.clear();
        this.anchorInputIndices.clear();
        this.inputSignerMap.clear();
        this.tweakedSignerCache.clear();
        delete this.parallelSigningConfig;
    }
    /**
     * Check if address rotation mode is enabled.
     */
    isAddressRotationEnabled() {
        return this.addressRotationEnabled;
    }
    ignoreSignatureError() {
        this.ignoreSignatureErrors = true;
    }
    /**
     * @description Returns the script address
     * @returns {string}
     */
    getScriptAddress() {
        if (!this.scriptData || !this.scriptData.address) {
            throw new Error('Tap data is required');
        }
        return this.scriptData.address;
    }
    /**
     * @description Returns the transaction
     * @returns {Transaction}
     */
    getTransaction() {
        return this.transaction.extractTransaction(false);
    }
    /**
     * @description Returns the tap address
     * @returns {string}
     * @throws {Error} - If tap data is not set
     */
    getTapAddress() {
        if (!this.tapData || !this.tapData.address) {
            throw new Error('Tap data is required');
        }
        return this.tapData.address;
    }
    /**
     * @description Disables replace by fee on the transaction
     */
    disableRBF() {
        if (this.signed)
            throw new Error('Transaction is already signed');
        this.sequence = TransactionSequence.FINAL;
        for (const input of this.inputs) {
            // This would disable CSV! You need to check if the input has CSV
            if (this.csvInputIndices.has(this.inputs.indexOf(input))) {
                continue;
            }
            input.sequence = TransactionSequence.FINAL;
        }
    }
    /**
     * Get the tweaked hash
     * @private
     *
     * @returns {Uint8Array | undefined} The tweaked hash
     */
    getTweakerHash() {
        return this.tapData?.hash;
    }
    /**
     * Pre-estimate the transaction fees
     * @param {bigint} feeRate - The fee rate
     * @param {bigint} numInputs - The number of inputs
     * @param {bigint} numOutputs - The number of outputs
     * @param {bigint} numSignatures - The number of signatures
     * @param {bigint} numPubkeys - The number of public keys
     * @returns {bigint} - The estimated transaction fees
     */
    preEstimateTransactionFees(feeRate, // satoshis per byte
    numInputs, numOutputs, numSignatures, numPubkeys) {
        const txHeaderSize = 10n;
        const inputBaseSize = 41n;
        const outputSize = 68n;
        const signatureSize = 144n;
        const pubkeySize = 34n;
        // Base transaction size (excluding witness data)
        const baseTxSize = txHeaderSize + inputBaseSize * numInputs + outputSize * numOutputs;
        // Witness data size
        const redeemScriptSize = 1n + numPubkeys * (1n + pubkeySize) + 1n + numSignatures;
        const witnessSize = numSignatures * signatureSize + numPubkeys * pubkeySize + redeemScriptSize;
        // Total weight and virtual size
        const weight = baseTxSize * 3n + (baseTxSize + witnessSize);
        const vSize = weight / 4n;
        return vSize * feeRate;
    }
    /**
     * Get the signer for a specific input index.
     * Returns the input-specific signer if in rotation mode, otherwise the default signer.
     * @param inputIndex - The index of the input
     */
    getSignerForInput(inputIndex) {
        if (this.addressRotationEnabled) {
            const inputSigner = this.inputSignerMap.get(inputIndex);
            if (inputSigner) {
                return inputSigner;
            }
        }
        return this.signer;
    }
    /**
     * Register a signer for a specific input index.
     * Called during UTXO processing to map each input to its signer.
     * @param inputIndex - The index of the input
     * @param utxo - The UTXO being added
     */
    registerInputSigner(inputIndex, utxo) {
        if (!this.addressRotationEnabled) {
            return;
        }
        // Priority 1: UTXO has an explicit signer attached
        if (utxo.signer) {
            this.inputSignerMap.set(inputIndex, utxo.signer);
            return;
        }
        // Priority 2: Look up signer from signerMap by address
        const address = utxo.scriptPubKey?.address;
        if (address && this.signerMap.has(address)) {
            const signer = this.signerMap.get(address);
            if (signer) {
                this.inputSignerMap.set(inputIndex, signer);
                return;
            }
        }
        // Fallback: Use default signer (no entry in inputSignerMap)
    }
    /**
     * Get the x-only public key for a specific input's signer.
     * Used for taproot inputs in address rotation mode.
     * @param inputIndex - The index of the input
     */
    internalPubKeyToXOnlyForInput(inputIndex) {
        const signer = this.getSignerForInput(inputIndex);
        return toXOnly(signer.publicKey);
    }
    /**
     * Get the tweaked signer for a specific input.
     * Caches the result for efficiency.
     * @param inputIndex - The index of the input
     * @param useTweakedHash - Whether to use the tweaked hash
     */
    getTweakedSignerForInput(inputIndex, useTweakedHash = false) {
        if (!this.addressRotationEnabled) {
            // Fall back to original behavior
            if (useTweakedHash) {
                this.tweakSigner();
                return this.tweakedSigner;
            }
            return this.getTweakedSigner(useTweakedHash);
        }
        // Check cache
        const cacheKey = inputIndex * 2 + (useTweakedHash ? 1 : 0);
        if (this.tweakedSignerCache.has(cacheKey)) {
            return this.tweakedSignerCache.get(cacheKey);
        }
        const signer = this.getSignerForInput(inputIndex);
        const tweaked = this.getTweakedSigner(useTweakedHash, signer);
        this.tweakedSignerCache.set(cacheKey, tweaked);
        return tweaked;
    }
    generateTapData() {
        if (this.useP2MR) {
            return {
                network: this.network,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            name: PaymentType.P2TR,
        };
    }
    /**
     * Generates the script address.
     * @protected
     * @returns {TapPayment}
     */
    generateScriptAddress() {
        if (this.useP2MR) {
            return {
                network: this.network,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            name: PaymentType.P2TR,
        };
    }
    /**
     * Returns the signer key.
     * @protected
     * @returns {Signer | UniversalSigner}
     */
    getSignerKey() {
        return this.signer;
    }
    /**
     * Signs an input of the transaction.
     * @param {Psbt} transaction - The transaction to sign
     * @param {PsbtInput} input - The input to sign
     * @param {number} i - The index of the input
     * @param {Signer} signer - The signer to use
     * @param {boolean} [reverse=false] - Should the input be signed in reverse
     * @param {boolean} [errored=false] - Was there an error
     * @protected
     */
    async signInput(transaction, input, i, signer, reverse = false, errored = false) {
        if (this.anchorInputIndices.has(i))
            return;
        const publicKey = signer.publicKey;
        let isTaproot = isTaprootInput(input);
        if (reverse) {
            isTaproot = !isTaproot;
        }
        let signed = false;
        let didError = false;
        if (isTaproot) {
            try {
                await this.attemptSignTaproot(transaction, input, i, signer, publicKey);
                signed = true;
            }
            catch (e) {
                this.error(`Failed to sign Taproot script path input ${i} (reverse: ${reverse}): ${e.message}`);
                didError = true;
            }
        }
        else {
            // Non-Taproot input
            if (!reverse ? canSignNonTaprootInput(input, publicKey) : true) {
                try {
                    await this.signNonTaprootInput(signer, transaction, i);
                    signed = true;
                }
                catch (e) {
                    this.error(`Failed to sign non-Taproot input ${i}: ${e.stack}`);
                    didError = true;
                }
            }
        }
        if (!signed) {
            if (didError && errored) {
                throw new Error(`Failed to sign input ${i} with the provided signer.`);
            }
            try {
                await this.signInput(transaction, input, i, signer, true, didError);
            }
            catch {
                throw new Error(`Cannot sign input ${i} with the provided signer.`);
            }
        }
    }
    splitArray(arr, chunkSize) {
        if (chunkSize <= 0) {
            throw new Error('Chunk size must be greater than 0.');
        }
        const result = [];
        for (let i = 0; i < arr.length; i += chunkSize) {
            result.push(arr.slice(i, i + chunkSize));
        }
        return result;
    }
    /**
     * Signs all the inputs of the transaction.
     * @param {Psbt} transaction - The transaction to sign
     * @protected
     * @returns {Promise<void>}
     */
    async signInputs(transaction) {
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
            return;
        }
        await this.signInputsNonWalletBased(transaction);
    }
    async signInputsNonWalletBased(transaction) {
        if (!this.noSignatures) {
            if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
                let parallelSignedIndices = new Set();
                try {
                    const result = await this.signKeyPathInputsParallel(transaction);
                    if (result.success) {
                        parallelSignedIndices = new Set(result.signatures.keys());
                    }
                }
                catch (e) {
                    this.error(`Parallel signing failed, falling back to sequential: ${e.message}`);
                }
                // Sign remaining inputs (script-path, non-taproot, etc.) sequentially
                await this.signRemainingInputsSequential(transaction, parallelSignedIndices);
            }
            else {
                await this.signInputsSequential(transaction);
            }
        }
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        }
        this.finalized = true;
    }
    /**
     * Signs all inputs sequentially in batches of 20.
     * This is the original signing logic, used as fallback when parallel signing is unavailable.
     */
    async signInputsSequential(transaction) {
        const txs = transaction.data.inputs;
        const batchSize = 20;
        const batches = this.splitArray(txs, batchSize);
        for (let i = 0; i < batches.length; i++) {
            const batch = batches[i];
            const promises = [];
            const offset = i * batchSize;
            for (let j = 0; j < batch.length; j++) {
                const index = offset + j;
                const input = batch[j];
                try {
                    // Use per-input signer in address rotation mode
                    const inputSigner = this.getSignerForInput(index);
                    promises.push(this.signInput(transaction, input, index, inputSigner));
                }
                catch (e) {
                    this.log(`Failed to sign input ${index}: ${e.stack}`);
                }
            }
            await Promise.all(promises);
        }
    }
    /**
     * Signs inputs that were not handled by parallel signing.
     * After parallel key-path signing, script-path taproot inputs, non-taproot inputs,
     * and any inputs that failed parallel signing need sequential signing.
     */
    async signRemainingInputsSequential(transaction, signedIndices) {
        const txs = transaction.data.inputs;
        const unsignedIndices = [];
        for (let i = 0; i < txs.length; i++) {
            if (!signedIndices.has(i)) {
                unsignedIndices.push(i);
            }
        }
        if (unsignedIndices.length === 0)
            return;
        const batchSize = 20;
        const batches = this.splitArray(unsignedIndices, batchSize);
        for (const batch of batches) {
            const promises = [];
            for (const index of batch) {
                const input = txs[index];
                try {
                    const inputSigner = this.getSignerForInput(index);
                    promises.push(this.signInput(transaction, input, index, inputSigner));
                }
                catch (e) {
                    this.log(`Failed to sign input ${index}: ${e.stack}`);
                }
            }
            await Promise.all(promises);
        }
    }
    /**
     * Converts the public key to x-only.
     * @protected
     * @returns {Uint8Array}
     */
    internalPubKeyToXOnly() {
        return toXOnly(this.signer.publicKey);
    }
    /**
     * Internal init.
     * @protected
     */
    internalInit() {
        const scriptParams = this.generateScriptAddress();
        const tapParams = this.generateTapData();
        if (scriptParams.name === PaymentType.P2MR) {
            this.scriptData = p2mr(scriptParams);
        }
        else {
            this.scriptData = p2tr(scriptParams);
        }
        if (tapParams.name === PaymentType.P2MR) {
            this.tapData = p2mr(tapParams);
        }
        else {
            this.tapData = p2tr(tapParams);
        }
    }
    /**
     * Tweak the signer for the interaction
     * @protected
     */
    tweakSigner() {
        if (this.tweakedSigner)
            return;
        // tweaked p2tr signer.
        const tweaked = this.getTweakedSigner(true);
        if (tweaked !== undefined) {
            this.tweakedSigner = tweaked;
        }
    }
    /**
     * Get the tweaked signer
     * @private
     * @returns {UniversalSigner} The tweaked signer
     */
    getTweakedSigner(useTweakedHash = false, signer = this.signer) {
        const settings = {
            network: this.network,
        };
        if (useTweakedHash) {
            const tweakHash = this.getTweakerHash();
            if (tweakHash !== undefined) {
                settings.tweakHash = tweakHash;
            }
        }
        if (!isUniversalSigner(signer)) {
            return;
        }
        return TweakedSigner.tweakSigner(signer, settings);
    }
    /**
     * Signs key-path taproot inputs in parallel using worker threads.
     * @param transaction - The PSBT to sign
     * @param excludeIndices - Input indices to skip (e.g., script-path inputs already signed)
     * @returns The parallel signing result
     */
    async signKeyPathInputsParallel(transaction, excludeIndices) {
        const signer = this.signer;
        // Get the tweaked signer for key-path
        const tweakedSigner = this.getTweakedSigner(true);
        if (!tweakedSigner) {
            throw new Error('Cannot create tweaked signer for parallel signing');
        }
        // Create hybrid adapter: untweaked pubkey (for PSBT matching) + tweaked privkey
        const adapter = toTweakedParallelKeyPair(signer, tweakedSigner);
        // Prepare tasks from PSBT
        const allTasks = prepareSigningTasks(transaction, adapter);
        // Filter out excluded indices
        const tasks = excludeIndices
            ? allTasks.filter((t) => !excludeIndices.has(t.inputIndex))
            : allTasks;
        if (tasks.length === 0) {
            return {
                success: true,
                signatures: new Map(),
                errors: new Map(),
                durationMs: 0,
            };
        }
        // Get or create pool
        let pool;
        let shouldShutdown = false;
        if (this.parallelSigningConfig && 'signBatch' in this.parallelSigningConfig) {
            pool = this.parallelSigningConfig;
        }
        else {
            pool = WorkerSigningPool.getInstance(this.parallelSigningConfig);
            if (!pool.isPreservingWorkers)
                shouldShutdown = true;
        }
        try {
            await pool.initialize();
            const result = await pool.signBatch(tasks, adapter);
            if (result.success) {
                applySignaturesToPsbt(transaction, result, adapter);
            }
            else {
                const errorEntries = [...result.errors.entries()];
                const errorMsg = errorEntries
                    .map(([idx, err]) => `Input ${idx}: ${err}`)
                    .join(', ');
                this.error(`Parallel signing had errors: ${errorMsg}`);
            }
            return result;
        }
        finally {
            if (shouldShutdown)
                await pool.shutdown();
        }
    }
    generateP2SHRedeemScript(customWitnessScript) {
        const p2wsh$1 = p2wsh({
            redeem: { output: customWitnessScript },
            network: this.network,
        });
        // Wrap the P2WSH inside a P2SH (Pay-to-Script-Hash)
        const p2sh$1 = p2sh({
            redeem: p2wsh$1,
            network: this.network,
        });
        return p2sh$1.output;
    }
    generateP2SHRedeemScriptLegacy(inputAddr) {
        const pubKeyHash = hash160(this.signer.publicKey);
        const redeemScript = compile([
            opcodes.OP_DUP,
            opcodes.OP_HASH160,
            pubKeyHash,
            opcodes.OP_EQUALVERIFY,
            opcodes.OP_CHECKSIG,
        ]);
        const redeemScriptHash = hash160(redeemScript);
        const outputScript = compile([
            opcodes.OP_HASH160,
            redeemScriptHash,
            opcodes.OP_EQUAL,
        ]);
        const p2wsh$1 = p2wsh({
            redeem: { output: redeemScript }, // Use the custom redeem script
            network: this.network,
        });
        // Wrap the P2WSH in a P2SH
        const p2sh$1 = p2sh({
            redeem: p2wsh$1, // The P2WSH is wrapped inside the P2SH
            network: this.network,
        });
        const address = fromOutputScript(outputScript, this.network);
        if (address === inputAddr && p2sh$1.redeem && p2sh$1.redeem.output) {
            return {
                redeemScript,
                outputScript: p2sh$1.redeem.output,
            };
        }
        return;
    }
    generateP2SHP2PKHRedeemScript(inputAddr, inputIndex) {
        // Use per-input signer in address rotation mode
        const signer = this.addressRotationEnabled && inputIndex !== undefined
            ? this.getSignerForInput(inputIndex)
            : this.signer;
        const pubkey = signer.publicKey;
        const w = p2wpkh({
            pubkey: pubkey,
            network: this.network,
        });
        const p = p2sh({
            redeem: w,
            network: this.network,
        });
        const address = p.address;
        const redeemScript = p.redeem?.output;
        if (!redeemScript) {
            throw new Error('Failed to generate P2SH-P2WPKH redeem script');
        }
        if (address === inputAddr && p.redeem && p.redeem.output && p.output) {
            return {
                redeemScript: p.redeem.output,
                outputScript: p.output,
            };
        }
        return;
    }
    /**
     * Generate the PSBT input extended, supporting various script types
     * @param {UTXO} utxo The UTXO
     * @param {number} i The index of the input
     * @param {UTXO} _extra Extra UTXO
     * @protected
     * @returns {PsbtInputExtended} The PSBT input extended
     */
    generatePsbtInputExtended(utxo, i, _extra = false) {
        const scriptPub = fromHex$1(utxo.scriptPubKey.hex);
        const input = {
            hash: utxo.transactionId,
            index: utxo.outputIndex,
            sequence: this.sequence,
            witnessUtxo: {
                value: utxo.value,
                script: scriptPub,
            },
        };
        // Handle P2PKH (Legacy)
        if (isP2PKH(scriptPub)) {
            // Legacy input requires nonWitnessUtxo
            if (utxo.nonWitnessUtxo) {
                //delete input.witnessUtxo;
                input.nonWitnessUtxo =
                    utxo.nonWitnessUtxo instanceof Uint8Array
                        ? utxo.nonWitnessUtxo
                        : fromHex$1(utxo.nonWitnessUtxo);
            }
            else {
                throw new Error('Missing nonWitnessUtxo for P2PKH UTXO');
            }
        }
        // Handle P2WPKH (SegWit)
        else if (isP2WPKH(scriptPub) || isUnknownSegwitVersion(scriptPub)) ;
        // Handle P2WSH (SegWit)
        else if (isP2WSHScript(scriptPub)) {
            this.processP2WSHInput(utxo, input, i);
        }
        // Handle P2SH (Can be legacy or wrapping segwit)
        else if (isP2SHScript(scriptPub)) {
            // Redeem script is required for P2SH
            let redeemScriptBuf;
            if (utxo.redeemScript) {
                redeemScriptBuf =
                    utxo.redeemScript instanceof Uint8Array
                        ? utxo.redeemScript
                        : fromHex$1(utxo.redeemScript);
            }
            else {
                // Attempt to generate a redeem script if missing
                if (!utxo.scriptPubKey.address) {
                    throw new Error('Missing redeemScript and no address to regenerate it for P2SH UTXO');
                }
                const legacyScripts = this.generateP2SHP2PKHRedeemScript(utxo.scriptPubKey.address, i);
                if (!legacyScripts) {
                    throw new Error('Missing redeemScript for P2SH UTXO and unable to regenerate');
                }
                redeemScriptBuf = legacyScripts.redeemScript;
            }
            input.redeemScript = redeemScriptBuf;
            // Check if redeemScript is wrapping segwit (like P2SH-P2WPKH or P2SH-P2WSH)
            const payment = p2sh({ redeem: { output: input.redeemScript } });
            if (!payment.redeem) {
                throw new Error('Failed to extract redeem script from P2SH UTXO');
            }
            const redeemOutput = payment.redeem.output;
            if (!redeemOutput) {
                throw new Error('Failed to extract redeem output from P2SH UTXO');
            }
            if (utxo.nonWitnessUtxo) {
                input.nonWitnessUtxo =
                    utxo.nonWitnessUtxo instanceof Uint8Array
                        ? utxo.nonWitnessUtxo
                        : fromHex$1(utxo.nonWitnessUtxo);
            }
            if (isP2WPKH(redeemOutput)) {
                // P2SH-P2WPKH
                // Use witnessUtxo + redeemScript
                Reflect.deleteProperty(input, 'nonWitnessUtxo'); // ensure we do NOT have nonWitnessUtxo
                // witnessScript is not needed
            }
            else if (isP2WSHScript(redeemOutput)) {
                // P2SH-P2WSH
                // Use witnessUtxo + redeemScript + witnessScript
                Reflect.deleteProperty(input, 'nonWitnessUtxo'); // ensure we do NOT have nonWitnessUtxo
                this.processP2WSHInput(utxo, input, i);
            }
            else {
                // Legacy P2SH
                // Use nonWitnessUtxo
                Reflect.deleteProperty(input, 'witnessUtxo'); // ensure we do NOT have witnessUtxo
            }
        }
        // Handle P2TR (Taproot)
        else if (isP2TR(scriptPub)) {
            // Taproot inputs do not require nonWitnessUtxo, witnessUtxo is sufficient.
            // If there's a configured sighash type
            if (this.sighashTypes) {
                const inputSign = TweakedTransaction.calculateSignHash(this.sighashTypes);
                if (inputSign)
                    input.sighashType = inputSign;
            }
            // Taproot internal key - use per-input signer in address rotation mode
            if (this.addressRotationEnabled) {
                input.tapInternalKey = this.internalPubKeyToXOnlyForInput(i);
            }
            else {
                this.tweakSigner();
                input.tapInternalKey = this.internalPubKeyToXOnly();
            }
        }
        // Handle P2MR (Pay-to-Merkle-Root, BIP 360, SegWit v2)
        else if (isP2MR(scriptPub)) {
            // P2MR inputs do not require nonWitnessUtxo, witnessUtxo is sufficient.
            // P2MR has no internal pubkey (no key-path spend).
            if (this.sighashTypes) {
                const inputSign = TweakedTransaction.calculateSignHash(this.sighashTypes);
                if (inputSign)
                    input.sighashType = inputSign;
            }
            // For the transaction's own script-path input (index 0), set tapMerkleRoot
            // from this transaction's tap data. External P2MR UTXOs at other indices
            // do not need tapMerkleRoot set here â€” their tapLeafScript is sufficient.
            if (i === 0 && this.tapData?.hash) {
                input.tapMerkleRoot =
                    this.tapData.hash;
            }
        }
        // Handle P2A (Any SegWit version, future versions)
        else if (isP2A(scriptPub)) {
            this.anchorInputIndices.add(i);
            input.isPayToAnchor = true;
        }
        // Handle P2PK (legacy) or P2MS (bare multisig)
        else if (isP2PK(scriptPub) || isP2MS(scriptPub)) {
            // These are legacy scripts, need nonWitnessUtxo
            if (utxo.nonWitnessUtxo) {
                input.nonWitnessUtxo =
                    utxo.nonWitnessUtxo instanceof Uint8Array
                        ? utxo.nonWitnessUtxo
                        : fromHex$1(utxo.nonWitnessUtxo);
            }
            else {
                throw new Error('Missing nonWitnessUtxo for P2PK or P2MS UTXO');
            }
        }
        else {
            this.error(`Unknown or unsupported script type for output: ${utxo.scriptPubKey.hex}`);
        }
        if (i === 0) {
            // TapLeafScript if available
            if (this.tapLeafScript) {
                input.tapLeafScript = [this.tapLeafScript];
            }
            if (this.nonWitnessUtxo) {
                input.nonWitnessUtxo = this.nonWitnessUtxo;
            }
        }
        return input;
    }
    processP2WSHInput(utxo, input, i) {
        // P2WSH requires a witnessScript
        if (!utxo.witnessScript) {
            // Can't just invent a witnessScript out of thin air. If not provided, it's an error.
            throw new Error('Missing witnessScript for P2WSH UTXO');
        }
        input.witnessScript =
            utxo.witnessScript instanceof Uint8Array
                ? utxo.witnessScript
                : fromHex$1(utxo.witnessScript);
        // No nonWitnessUtxo needed for segwit
        const decompiled = decompile(input.witnessScript);
        if (decompiled && this.isCSVScript(decompiled)) {
            const decompiled = decompile(input.witnessScript);
            if (decompiled && this.isCSVScript(decompiled)) {
                this.csvInputIndices.add(i);
                // Extract CSV value from witness script
                const csvBlocks = this.extractCSVBlocks(decompiled);
                // Use the setCSVSequence method to properly set the sequence
                input.sequence = this.setCSVSequence(csvBlocks, this.sequence);
            }
        }
    }
    secondsToCSVTimeUnits(seconds) {
        return Math.floor(seconds / 512);
    }
    createTimeBasedCSV(seconds) {
        const timeUnits = this.secondsToCSVTimeUnits(seconds);
        if (timeUnits > 0xffff) {
            throw new Error(`Time units ${timeUnits} exceeds maximum of 65,535`);
        }
        return timeUnits | (1 << 22);
    }
    isCSVEnabled(sequence) {
        return (sequence & (1 << 31)) === 0;
    }
    extractCSVValue(sequence) {
        return sequence & 0x0000ffff;
    }
    customFinalizerP2SH = (inputIndex, input, scriptA, isSegwit, isP2SH, isP2WSH, _canRunChecks) => {
        const inputDecoded = this.inputs[inputIndex];
        if (isP2SH && input.partialSig && inputDecoded && inputDecoded.redeemScript) {
            const signatures = input.partialSig.map((sig) => sig.signature) || [];
            const scriptSig = compile([...signatures, inputDecoded.redeemScript]);
            return {
                finalScriptSig: scriptSig,
                finalScriptWitness: undefined,
            };
        }
        if (this.anchorInputIndices.has(inputIndex)) {
            return {
                finalScriptSig: undefined,
                finalScriptWitness: Uint8Array.from([0]),
            };
        }
        if (isP2WSH && isSegwit && input.witnessScript) {
            if (!input.partialSig || input.partialSig.length === 0) {
                throw new Error(`No signatures for P2WSH input #${inputIndex}`);
            }
            const isP2WDA = P2WDADetector.isP2WDAWitnessScript(input.witnessScript);
            if (isP2WDA) {
                return this.finalizeSecondaryP2WDA(inputIndex, input);
            }
            // Check if this is a CSV input
            const isCSVInput = this.csvInputIndices.has(inputIndex);
            if (isCSVInput) {
                // For CSV P2WSH, the witness stack should be: [signature, witnessScript]
                const witnessStack = [
                    input.partialSig[0].signature,
                    input.witnessScript,
                ];
                return {
                    finalScriptSig: undefined,
                    finalScriptWitness: witnessStackToScriptWitness(witnessStack),
                };
            }
            // For non-CSV P2WSH, use default finalization
        }
        return getFinalScripts(inputIndex, input, scriptA, isSegwit, isP2SH, isP2WSH, true, this.unlockScript);
    };
    /**
     * Finalize secondary P2WDA inputs with empty data
     */
    finalizeSecondaryP2WDA(inputIndex, input) {
        if (!input.partialSig || input.partialSig.length === 0) {
            throw new Error(`No signature for P2WDA input #${inputIndex}`);
        }
        if (!input.witnessScript) {
            throw new Error(`No witness script for P2WDA input #${inputIndex}`);
        }
        const witnessStack = P2WDADetector.createSimpleP2WDAWitness(input.partialSig[0].signature, input.witnessScript);
        return {
            finalScriptSig: undefined,
            finalScriptWitness: witnessStackToScriptWitness(witnessStack),
        };
    }
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        // then, we sign all the remaining inputs with the wallet signer.
        await signer.multiSignPsbt([transaction]);
        // Then, we finalize every input.
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        }
        this.finalized = true;
    }
    isCSVScript(decompiled) {
        return decompiled.some((op) => op === opcodes.OP_CHECKSEQUENCEVERIFY);
    }
    setCSVSequence(csvBlocks, currentSequence) {
        if (this.txVersion < 2) {
            throw new Error('CSV requires transaction version 2 or higher');
        }
        if (csvBlocks > 0xffff) {
            throw new Error(`CSV blocks ${csvBlocks} exceeds maximum of 65,535`);
        }
        // Layout of nSequence field (32 bits) when CSV is active (bit 31 = 0):
        // Bit 31: Must be 0 (CSV enable flag)
        // Bits 23-30: Unused by BIP68 (available for custom use)
        // Bit 22: Time flag (0 = blocks, 1 = time)
        // Bits 16-21: Unused by BIP68 (available for custom use)
        // Bits 0-15: CSV lock-time value
        // Extract the time flag if it's set in csvBlocks
        const isTimeBased = (csvBlocks & (1 << 22)) !== 0;
        // Start with the CSV value
        let sequence = csvBlocks & 0x0000ffff;
        // Preserve the time flag if set
        if (isTimeBased) {
            sequence |= 1 << 22;
        }
        if (currentSequence === TransactionSequence.REPLACE_BY_FEE) {
            // Set bit 25 as our explicit RBF flag
            // This is in the unused range (bits 23-30) when CSV is active
            sequence |= 1 << 25;
            // We could use other unused bits for version/features
            // sequence |= (1 << 26); // Could indicate tx flags if we wanted
        }
        // Final safety check: ensure bit 31 is 0 (CSV enabled)
        sequence = sequence & 0x7fffffff;
        return sequence;
    }
    getCSVType(csvValue) {
        // Bit 22 determines if it's time-based (1) or block-based (0)
        return csvValue & (1 << 22) ? CSVModes.TIMESTAMPS : CSVModes.BLOCKS;
    }
    extractCSVBlocks(decompiled) {
        for (let i = 0; i < decompiled.length; i++) {
            if (decompiled[i] === opcodes.OP_CHECKSEQUENCEVERIFY && i > 0) {
                const csvValue = decompiled[i - 1];
                if (csvValue instanceof Uint8Array) {
                    return number.decode(csvValue);
                }
                else if (typeof csvValue === 'number') {
                    // Handle OP_N directly
                    if (csvValue === opcodes.OP_0 || csvValue === opcodes.OP_FALSE) {
                        return 0;
                    }
                    else if (csvValue === opcodes.OP_1NEGATE) {
                        return -1;
                    }
                    else if (csvValue >= opcodes.OP_1 && csvValue <= opcodes.OP_16) {
                        return csvValue - opcodes.OP_1 + 1;
                    }
                    else {
                        // For other numbers, they should have been Buffers
                        // This shouldn't happen in properly decompiled scripts
                        throw new Error(`Unexpected raw number in script: ${csvValue}`);
                    }
                }
            }
        }
        return 0;
    }
    async attemptSignTaproot(transaction, input, i, signer, publicKey) {
        const isScriptSpend = this.isTaprootScriptSpend(input, publicKey);
        if (isScriptSpend) {
            await this.signTaprootInput(signer, transaction, i);
        }
        else {
            let tweakedSigner;
            if (signer !== this.signer) {
                tweakedSigner = this.getTweakedSigner(true, signer);
            }
            else {
                if (!this.tweakedSigner)
                    this.tweakSigner();
                tweakedSigner = this.tweakedSigner;
            }
            if (tweakedSigner) {
                try {
                    await this.signTaprootInput(tweakedSigner, transaction, i);
                }
                catch (e) {
                    tweakedSigner = this.getTweakedSigner(false, this.signer);
                    if (!tweakedSigner) {
                        throw new Error(`Failed to obtain tweaked signer for input ${i}.`, {
                            cause: e,
                        });
                    }
                    await this.signTaprootInput(tweakedSigner, transaction, i);
                }
            }
            else {
                this.error(`Failed to obtain tweaked signer for input ${i}.`);
            }
        }
    }
    isTaprootScriptSpend(input, publicKey) {
        if (input.tapLeafScript && input.tapLeafScript.length > 0) {
            // Check if the signer's public key is involved in any tapLeafScript
            for (const tapLeafScript of input.tapLeafScript) {
                if (pubkeyInScript(publicKey, tapLeafScript.script)) {
                    // The public key is in the script; it's a script spend
                    return true;
                }
            }
        }
        return false;
    }
    async signTaprootInput(signer, transaction, i, tapLeafHash) {
        if ('signTaprootInput' in signer) {
            try {
                await signer.signTaprootInput(transaction, i, tapLeafHash);
            }
            catch {
                throw new Error('Failed to sign Taproot input with provided signer.');
            }
        }
        else {
            transaction.signTaprootInput(i, signer); //tapLeafHash
        }
    }
    async signNonTaprootInput(signer, transaction, i) {
        if ('signInput' in signer) {
            await signer.signInput(transaction, i);
        }
        else {
            transaction.signInput(i, signer);
        }
    }
}

function networkKey(network) {
    return `${network.messagePrefix}|${network.bech32}`;
}
const CHAIN_IDS = new Map([
    [
        networkKey(bitcoin$1),
        new Uint8Array([
            0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xd6, 0x68, 0x9c, 0x08, 0x5a, 0xe1, 0x65, 0x83,
            0x1e, 0x93, 0x4f, 0xf7, 0x63, 0xae, 0x46, 0xa2, 0xa6, 0xc1, 0x72, 0xb3, 0xf1, 0xb6,
            0x0a, 0x8c, 0xe2, 0x6f,
        ]),
    ],
    [
        networkKey(testnet),
        new Uint8Array([
            0x00, 0x00, 0x00, 0x00, 0x09, 0x33, 0xea, 0x01, 0xad, 0x0e, 0xe9, 0x84, 0x20, 0x97,
            0x79, 0xba, 0xae, 0xc3, 0xce, 0xd9, 0x0f, 0xa3, 0xf4, 0x08, 0x71, 0x95, 0x26, 0xf8,
            0xd7, 0x7f, 0x49, 0x43,
        ]),
    ],
    [
        networkKey(opnetTestnet),
        new Uint8Array([
            0, 0, 1, 127, 133, 16, 107, 31, 238, 175, 47, 112, 241, 226, 184, 5, 152, 91, 181, 117,
            248, 143, 155, 11, 165, 117, 61, 47, 60, 241, 50, 115,
        ]),
    ],
    [
        networkKey(regtest),
        new Uint8Array([
            0x0f, 0x91, 0x88, 0xf1, 0x3c, 0xb7, 0xb2, 0xc7, 0x1f, 0x2a, 0x33, 0x5e, 0x3a, 0x4f,
            0xc3, 0x28, 0xbf, 0x5b, 0xeb, 0x43, 0x60, 0x12, 0xaf, 0xca, 0x59, 0x0b, 0x1a, 0x11,
            0x46, 0x6e, 0x22, 0x06,
        ]),
    ],
]);
function getChainId(network) {
    const chainId = CHAIN_IDS.get(networkKey(network));
    if (!chainId)
        throw new Error('Unsupported network for chain ID retrieval');
    return chainId.slice();
}
const BITCOIN_PROTOCOL_ID = new Uint8Array([
    0xe7, 0x84, 0x99, 0x5a, 0x41, 0x2d, 0x77, 0x39, 0x88, 0xc4, 0xb8, 0xe3, 0x33, 0xd7, 0xb3, 0x9d,
    0xfb, 0x3c, 0xab, 0xf1, 0x18, 0xd0, 0xd6, 0x45, 0x41, 0x1a, 0x91, 0x6c, 0xa2, 0x40, 0x79, 0x39,
]);

const MINIMUM_AMOUNT_REWARD = 330n; //540n;
const MINIMUM_AMOUNT_CA = 297n;
const ANCHOR_SCRIPT = fromHex$1('51024e73');
/**
 * Allows to build a transaction like you would on Ethereum.
 * @description The transaction builder class
 * @abstract
 * @class TransactionBuilder
 */
class TransactionBuilder extends TweakedTransaction {
    static MINIMUM_DUST = 330n;
    logColor = '#785def';
    debugFees = false;
    // Cancel script
    LOCK_LEAF_SCRIPT;
    /**
     * @description The overflow fees of the transaction
     * @public
     */
    overflowFees = 0n;
    /**
     * @description Cost in satoshis of the transaction fee
     */
    transactionFee = 0n;
    /**
     * @description The estimated fees of the transaction
     */
    estimatedFees = 0n;
    /**
     * @param {ITransactionParameters} parameters - The transaction parameters
     */
    optionalOutputs;
    /**
     * @description The transaction itself.
     */
    transaction;
    /**
     * @description Inputs to update later on.
     */
    updateInputs = [];
    /**
     * @description The outputs of the transaction
     */
    outputs = [];
    /**
     * @description Output that will be used to pay the fees
     */
    feeOutput = null;
    /**
     * @description The total amount of satoshis in the inputs
     */
    totalInputAmount;
    /**
     * @description The signer of the transaction
     */
    signer;
    /**
     * @description The network where the transaction will be broadcasted
     */
    network;
    /**
     * @description The fee rate of the transaction
     */
    feeRate;
    /**
     * @description The opnet priority fee of the transaction
     */
    priorityFee;
    gasSatFee;
    /**
     * @description The utxos used in the transaction
     */
    utxos;
    /**
     * @description The inputs of the transaction
     * @protected
     */
    optionalInputs;
    /**
     * @description The address where the transaction is sent to
     * @protected
     */
    to;
    /**
     * @description The address where the transaction is sent from
     * @protected
     */
    from;
    /**
     * @description The maximum fee rate of the transaction
     */
    _maximumFeeRate = 100000000;
    /**
     * @description Is the destionation P2PK
     * @protected
     */
    isPubKeyDestination;
    /**
     * @description If the transaction need an anchor output
     * @protected
     */
    anchor;
    note;
    optionalOutputsAdded = false;
    constructor(parameters) {
        super(parameters);
        if (parameters.estimatedFees) {
            this.estimatedFees = parameters.estimatedFees;
        }
        this.signer = parameters.signer;
        this.network = parameters.network;
        this.feeRate = parameters.feeRate;
        this.priorityFee = parameters.priorityFee ?? 0n;
        this.gasSatFee = parameters.gasSatFee ?? 0n;
        this.utxos = parameters.utxos;
        this.optionalInputs = parameters.optionalInputs || [];
        this.to = parameters.to || undefined;
        this.debugFees = parameters.debugFees || false;
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        if (parameters.note) {
            if (typeof parameters.note === 'string') {
                this.note = new TextEncoder().encode(parameters.note);
            }
            else {
                this.note = parameters.note;
            }
        }
        this.anchor = parameters.anchor ?? false;
        this.isPubKeyDestination = this.to
            ? AddressVerificator.isValidPublicKey(this.to, this.network)
            : false;
        this.optionalOutputs = parameters.optionalOutputs;
        this.from = TransactionBuilder.getFrom(parameters.from, this.signer, this.network);
        this.totalInputAmount = this.calculateTotalUTXOAmount();
        const totalVOut = this.calculateTotalVOutAmount();
        if (totalVOut < this.totalInputAmount) {
            throw new Error(`Vout value is less than the value to send`);
        }
        this.transaction = new Psbt({
            network: this.network,
            version: this.txVersion,
        });
    }
    static getFrom(from, keypair, network) {
        return from || EcKeyPair.getTaprootAddress(keypair, network);
    }
    /**
     * @description Converts the witness stack to a script witness
     * @param {Uint8Array[]} witness - The witness stack
     * @protected
     * @returns {Uint8Array}
     */
    static witnessStackToScriptWitness(witness) {
        return witnessStackToScriptWitness(witness);
    }
    [Symbol.dispose]() {
        super[Symbol.dispose]();
        this.updateInputs.length = 0;
        this.outputs.length = 0;
        this.feeOutput = null;
        this.optionalOutputs = undefined;
        this.utxos = [];
        this.optionalInputs = [];
    }
    addOPReturn(buffer) {
        const compileScript = compile([opcodes.OP_RETURN, buffer]);
        this.addOutput({
            value: toSatoshi(0n),
            script: compileScript,
        });
    }
    addAnchor() {
        this.addOutput({
            value: toSatoshi(0n),
            script: ANCHOR_SCRIPT,
        });
    }
    async getFundingTransactionParameters() {
        if (!this.estimatedFees) {
            this.estimatedFees = await this.estimateTransactionFees();
        }
        return {
            utxos: this.utxos,
            to: this.getScriptAddress(),
            signer: this.signer,
            network: this.network,
            feeRate: this.feeRate,
            priorityFee: this.priorityFee ?? 0n,
            gasSatFee: this.gasSatFee ?? 0n,
            from: this.from,
            amount: this.estimatedFees,
            optionalInputs: this.optionalInputs,
            mldsaSigner: null,
            ...(this.optionalOutputs !== undefined
                ? { optionalOutputs: this.optionalOutputs }
                : {}),
        };
    }
    /**
     * Set the destination address of the transaction
     * @param {string} address - The address to set
     */
    setDestinationAddress(address) {
        this.to = address; // this.getScriptAddress()
    }
    /**
     * Set the maximum fee rate of the transaction in satoshis per byte
     * @param {number} feeRate - The fee rate to set
     * @public
     */
    setMaximumFeeRate(feeRate) {
        this._maximumFeeRate = feeRate;
    }
    /**
     * @description Signs the transaction
     * @public
     * @returns {Promise<Transaction>} - The signed transaction in hex format
     * @throws {Error} - If something went wrong
     */
    async signTransaction() {
        if (!this.utxos.length) {
            throw new Error('No UTXOs specified');
        }
        if (this.to &&
            !this.isPubKeyDestination &&
            !EcKeyPair.verifyContractAddress(this.to, this.network)) {
            throw new Error('Invalid contract address. The contract address must be a taproot address.');
        }
        if (this.signed)
            throw new Error('Transaction is already signed');
        this.signed = true;
        await this.buildTransaction();
        const builtTx = await this.internalBuildTransaction(this.transaction);
        if (builtTx) {
            if (this.regenerated) {
                throw new Error('Transaction was regenerated');
            }
            return this.transaction.extractTransaction(true, true);
        }
        throw new Error('Could not sign transaction');
    }
    /**
     * @description Generates the transaction minimal signatures
     * @public
     */
    async generateTransactionMinimalSignatures(checkPartialSigs = false) {
        if (this.to &&
            !this.isPubKeyDestination &&
            !EcKeyPair.verifyContractAddress(this.to, this.network)) {
            throw new Error('Invalid contract address. The contract address must be a taproot address.');
        }
        await this.buildTransaction();
        if (this.transaction.data.inputs.length === 0) {
            const inputs = this.getInputs();
            const outputs = this.getOutputs();
            this.transaction.setMaximumFeeRate(this._maximumFeeRate);
            this.transaction.addInputs(inputs, checkPartialSigs);
            for (let i = 0; i < this.updateInputs.length; i++) {
                this.transaction.updateInput(i, this.updateInputs[i]);
            }
            this.transaction.addOutputs(outputs);
        }
    }
    /**
     * @description Signs the transaction
     * @public
     * @returns {Promise<Psbt>} - The signed transaction in hex format
     * @throws {Error} - If something went wrong
     */
    async signPSBT() {
        if (await this.signTransaction()) {
            return this.transaction;
        }
        throw new Error('Could not sign transaction');
    }
    /**
     * Add an input to the transaction.
     * @param {PsbtInputExtended} input - The input to add
     * @public
     * @returns {void}
     */
    addInput(input) {
        this.inputs.push(input);
    }
    /**
     * Add an output to the transaction.
     * @param {PsbtOutputExtended} output - The output to add
     * @param bypassMinCheck
     * @public
     * @returns {void}
     */
    addOutput(output, bypassMinCheck = false) {
        if (output.value === toSatoshi(0n)) {
            const scriptOutput = output;
            if (!scriptOutput.script || scriptOutput.script.length === 0) {
                throw new Error('Output value is 0 and no script provided');
            }
            if (scriptOutput.script.length < 2) {
                throw new Error('Output script is too short');
            }
            if (scriptOutput.script[0] !== opcodes.OP_RETURN &&
                !equals(scriptOutput.script, ANCHOR_SCRIPT)) {
                throw new Error('Output script must start with OP_RETURN or be an ANCHOR when value is 0');
            }
        }
        else if (!bypassMinCheck && BigInt(output.value) < TransactionBuilder.MINIMUM_DUST) {
            throw new Error(`Output value is less than the minimum dust ${output.value} < ${TransactionBuilder.MINIMUM_DUST}`);
        }
        this.outputs.push(output);
    }
    /**
     * Returns the total value of all outputs added so far (excluding the fee/change output).
     * @public
     * @returns {bigint}
     */
    getTotalOutputValue() {
        return this.outputs.reduce((total, output) => total + BigInt(output.value), 0n);
    }
    /**
     * Receiver address.
     * @public
     * @returns {string} - The receiver address
     */
    toAddress() {
        return this.to;
    }
    /**
     * @description Returns the script address
     * @returns {string} - The script address
     */
    address() {
        return this.tapData?.address;
    }
    /**
     * Estimates the transaction fees with accurate size calculation.
     *
     * @note The P2TR estimation is made for a 2-leaf tree with both a tapScriptSig and a tapInternalKey input, which is a common case for many transactions.
     * This provides a more accurate fee estimation for typical P2TR transactions, but may not be perfectly accurate for all possible script configurations.
     * Adjustments may be needed for more complex scripts or different leaf structures.
     *
     * @public
     * @returns {Promise<bigint>}
     */
    async estimateTransactionFees() {
        await Promise.resolve();
        const fakeTx = new Psbt({ network: this.network });
        const inputs = this.getInputs();
        const outputs = this.getOutputs();
        fakeTx.addInputs(inputs);
        fakeTx.addOutputs(outputs);
        const dummySchnorrSig = new Uint8Array(64);
        const dummyEcdsaSig = new Uint8Array(72);
        const dummyCompressedPubkey = new Uint8Array(33).fill(2);
        const finalizer = (inputIndex, input) => {
            if (input.isPayToAnchor || this.anchorInputIndices.has(inputIndex)) {
                return {
                    finalScriptSig: undefined,
                    finalScriptWitness: Uint8Array.from([0]),
                };
            }
            if (input.witnessScript && P2WDADetector.isP2WDAWitnessScript(input.witnessScript)) {
                // Create dummy witness stack for P2WDA
                const dummyDataSlots = [];
                for (let i = 0; i < 10; i++) {
                    dummyDataSlots.push(new Uint8Array(0));
                }
                const dummyEcdsaSig = new Uint8Array(72);
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        ...dummyDataSlots,
                        dummyEcdsaSig,
                        input.witnessScript,
                    ]),
                };
            }
            if (inputIndex === 0 && this.tapLeafScript) {
                const dummySecret = new Uint8Array(32);
                const dummyScript = this.tapLeafScript.script;
                // A control block for a 2-leaf tree contains one 32-byte hash.
                // P2TR: 33 (version + internal pubkey) + 32 (merkle path) = 65 bytes
                // P2MR: 1 (version) + 32 (merkle path) = 33 bytes (no internal pubkey)
                const controlBlockSize = this.useP2MR ? 1 + 32 : 1 + 32 + 32;
                const dummyControlBlock = new Uint8Array(controlBlockSize);
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummySecret,
                        dummySchnorrSig, // It's a tapScriptSig, which is Schnorr
                        dummySchnorrSig, // Second Schnorr signature
                        dummyScript,
                        dummyControlBlock,
                    ]),
                };
            }
            if (input.witnessUtxo) {
                const script = input.witnessUtxo.script;
                const decompiled = bitcoin.script.decompile(script);
                if (decompiled &&
                    decompiled.length === 5 &&
                    decompiled[0] === opcodes.OP_DUP &&
                    decompiled[1] === opcodes.OP_HASH160 &&
                    decompiled[3] === opcodes.OP_EQUALVERIFY &&
                    decompiled[4] === opcodes.OP_CHECKSIG) {
                    return {
                        finalScriptSig: bitcoin.script.compile([
                            dummyEcdsaSig,
                            dummyCompressedPubkey,
                        ]),
                        finalScriptWitness: undefined,
                    };
                }
            }
            if (input.witnessScript) {
                if (this.csvInputIndices.has(inputIndex)) {
                    // CSV P2WSH needs: [signature, witnessScript]
                    return {
                        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                            dummyEcdsaSig,
                            input.witnessScript,
                        ]),
                    };
                }
                if (input.redeemScript) {
                    // P2SH-P2WSH needs redeemScript in scriptSig and witness data
                    const dummyWitness = [dummyEcdsaSig, input.witnessScript];
                    return {
                        finalScriptSig: input.redeemScript,
                        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(dummyWitness),
                    };
                }
                const decompiled = bitcoin.script.decompile(input.witnessScript);
                if (decompiled && decompiled.length >= 4) {
                    const firstOp = decompiled[0];
                    const lastOp = decompiled[decompiled.length - 1];
                    // Check if it's M-of-N multisig
                    if (typeof firstOp === 'number' &&
                        firstOp >= opcodes.OP_1 &&
                        lastOp === opcodes.OP_CHECKMULTISIG) {
                        const m = firstOp - opcodes.OP_1 + 1;
                        const signatures = [];
                        for (let i = 0; i < m; i++) {
                            signatures.push(dummyEcdsaSig);
                        }
                        return {
                            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                                new Uint8Array(0), // OP_0 due to multisig bug
                                ...signatures,
                                input.witnessScript,
                            ]),
                        };
                    }
                }
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummyEcdsaSig,
                        input.witnessScript,
                    ]),
                };
            }
            else if (input.redeemScript) {
                const decompiled = bitcoin.script.decompile(input.redeemScript);
                if (decompiled &&
                    decompiled.length === 2 &&
                    decompiled[0] === opcodes.OP_0 &&
                    decompiled[1] instanceof Uint8Array &&
                    decompiled[1].length === 20) {
                    // P2SH-P2WPKH
                    return {
                        finalScriptSig: input.redeemScript,
                        finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                            dummyEcdsaSig,
                            dummyCompressedPubkey,
                        ]),
                    };
                }
            }
            if (input.redeemScript && !input.witnessScript && !input.witnessUtxo) {
                // Pure P2SH needs signatures + redeemScript in scriptSig
                return {
                    finalScriptSig: bitcoin.script.compile([dummyEcdsaSig, input.redeemScript]),
                    finalScriptWitness: undefined,
                };
            }
            const inputScript = input.witnessUtxo?.script;
            if (!inputScript)
                return { finalScriptSig: undefined, finalScriptWitness: undefined };
            if (input.tapInternalKey) {
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummySchnorrSig,
                    ]),
                };
            }
            if (inputScript.length === 22 && inputScript[0] === opcodes.OP_0) {
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummyEcdsaSig,
                        dummyCompressedPubkey,
                    ]),
                };
            }
            if (input.redeemScript?.length === 22 && input.redeemScript[0] === opcodes.OP_0) {
                return {
                    finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness([
                        dummyEcdsaSig,
                        dummyCompressedPubkey,
                    ]),
                };
            }
            return getFinalScripts(inputIndex, input, inputScript, true, !!input.redeemScript, !!input.witnessScript);
        };
        try {
            for (let i = 0; i < fakeTx.data.inputs.length; i++) {
                const fullInput = inputs[i];
                if (fullInput) {
                    fakeTx.finalizeInput(i, (idx) => finalizer(idx, fullInput));
                }
            }
        }
        catch (e) {
            this.warn(`Could not finalize dummy tx: ${e.message}`);
        }
        const tx = fakeTx.extractTransaction(true, true);
        const size = tx.virtualSize();
        const fee = this.feeRate * size;
        const finalFee = BigInt(Math.ceil(fee));
        if (this.debugFees) {
            this.log(`Estimating fees: feeRate=${this.feeRate}, accurate_vSize=${size}, fee=${finalFee}n`);
        }
        return finalFee;
    }
    async rebuildFromBase64(base64) {
        this.transaction = Psbt.fromBase64(base64, {
            network: this.network,
            version: this.txVersion,
        });
        this.signed = false;
        this.sighashTypes = [Transaction.SIGHASH_ANYONECANPAY, Transaction.SIGHASH_ALL];
        return await this.signPSBT();
    }
    setPSBT(psbt) {
        this.transaction = psbt;
    }
    /**
     * Returns the inputs of the transaction.
     * @protected
     * @returns {PsbtInputExtended[]}
     */
    getInputs() {
        return this.inputs;
    }
    /**
     * Returns the outputs of the transaction.
     * @protected
     * @returns {PsbtOutputExtended[]}
     */
    getOutputs() {
        const outputs = [...this.outputs];
        if (this.feeOutput)
            outputs.push(this.feeOutput);
        return outputs;
    }
    getOptionalOutputValue() {
        if (!this.optionalOutputs)
            return 0n;
        let total = 0n;
        for (let i = 0; i < this.optionalOutputs.length; i++) {
            total += BigInt(this.optionalOutputs[i].value);
        }
        return total;
    }
    async addRefundOutput(amountSpent, expectRefund = false) {
        if (this.note) {
            this.addOPReturn(this.note);
        }
        if (this.anchor) {
            this.addAnchor();
        }
        // Add a dummy change output to estimate fee with the change-output shape
        this.feeOutput = this.createChangeOutput(TransactionBuilder.MINIMUM_DUST);
        const feeWithChange = await this.estimateTransactionFees();
        const sendBackAmount = this.totalInputAmount - amountSpent - feeWithChange;
        if (this.debugFees) {
            this.log(`Fee with change: ${feeWithChange} sats, inputAmount=${this.totalInputAmount}, amountSpent=${amountSpent}, sendBackAmount=${sendBackAmount}`);
        }
        if (sendBackAmount >= TransactionBuilder.MINIMUM_DUST) {
            // Change output is viable, set it to the real value
            this.feeOutput = this.createChangeOutput(sendBackAmount);
            this.overflowFees = sendBackAmount;
            this.transactionFee = feeWithChange;
        }
        else {
            // Change output not viable, remove it and re-estimate without it
            this.feeOutput = null;
            this.overflowFees = 0n;
            const feeWithoutChange = await this.estimateTransactionFees();
            this.transactionFee = feeWithoutChange;
            if (this.debugFees) {
                this.warn(`Amount to send back (${sendBackAmount} sat) is less than minimum dust. Fee without change: ${feeWithoutChange} sats`);
            }
            if (this.totalInputAmount <= amountSpent) {
                throw new Error(`Insufficient funds: need ${amountSpent + feeWithoutChange} sats but only have ${this.totalInputAmount} sats`);
            }
            if (expectRefund && sendBackAmount < 0n) {
                throw new Error(`Insufficient funds: need at least ${-sendBackAmount} more sats to cover fees.`);
            }
        }
        if (this.debugFees) {
            this.log(`Final fee: ${this.transactionFee} sats, Change output: ${this.feeOutput ? `${this.feeOutput.value} sats` : 'none'}`);
        }
    }
    defineLockScript() {
        return compile([toXOnly(this.signer.publicKey), opcodes.OP_CHECKSIG]);
    }
    /**
     * @description Adds the value to the output
     * @param {number | bigint} value - The value to add
     * @protected
     * @returns {void}
     */
    addValueToToOutput(value) {
        if (BigInt(value) < TransactionBuilder.MINIMUM_DUST) {
            throw new Error(`Value to send is less than the minimum dust ${value} < ${TransactionBuilder.MINIMUM_DUST}`);
        }
        for (let i = 0; i < this.outputs.length; i++) {
            const output = this.outputs[i];
            if ('address' in output && output.address === this.to) {
                this.outputs[i] = {
                    ...output,
                    value: toSatoshi(BigInt(output.value) + BigInt(value)),
                };
                return;
            }
        }
        throw new Error('Output not found');
    }
    generateLegacySignature() {
        this.tweakSigner();
        if (!this.tweakedSigner) {
            throw new Error('Tweaked signer is not defined');
        }
        const tweakedKey = toXOnly(this.tweakedSigner.publicKey);
        const originalKey = this.signer.publicKey;
        if (originalKey.length !== 33) {
            throw new Error('Original public key must be compressed (33 bytes)');
        }
        const chainId = getChainId(this.network);
        const writer = new BinaryWriter();
        // ONLY SUPPORT MLDSA-44 FOR NOW.
        writer.writeU8(cjsExports.MLDSASecurityLevel.LEVEL2);
        writer.writeBytes(this.hashedPublicKey);
        writer.writeBytes(tweakedKey);
        writer.writeBytes(originalKey);
        writer.writeBytes(BITCOIN_PROTOCOL_ID);
        writer.writeBytes(chainId);
        const message = writer.getBuffer();
        const signature = MessageSigner.signMessage(this.tweakedSigner, message);
        const isValid = MessageSigner.verifySignature(tweakedKey, message, signature.signature);
        if (!isValid) {
            throw new Error('Could not verify generated legacy signature for MLDSA link request');
        }
        return new Uint8Array(signature.signature);
    }
    generateMLDSASignature() {
        if (!this.mldsaSigner) {
            throw new Error('MLDSA signer is not defined');
        }
        this.tweakSigner();
        if (!this.tweakedSigner) {
            throw new Error('Tweaked signer is not defined');
        }
        const tweakedKey = toXOnly(this.tweakedSigner.publicKey);
        const originalKey = this.signer.publicKey;
        if (originalKey.length !== 33) {
            throw new Error('Original public key must be compressed (33 bytes)');
        }
        const chainId = getChainId(this.network);
        const level = getLevelFromPublicKeyLength(this.mldsaSigner.publicKey.length);
        if (level !== cjsExports.MLDSASecurityLevel.LEVEL2) {
            throw new Error('Only MLDSA level 2 is supported for link requests');
        }
        const writer = new BinaryWriter();
        writer.writeU8(level);
        writer.writeBytes(this.hashedPublicKey);
        writer.writeBytes(this.mldsaSigner.publicKey);
        writer.writeBytes(tweakedKey);
        writer.writeBytes(originalKey);
        writer.writeBytes(BITCOIN_PROTOCOL_ID);
        writer.writeBytes(chainId);
        const message = writer.getBuffer();
        const signature = MessageSigner.signMLDSAMessage(this.mldsaSigner, message);
        const isValid = MessageSigner.verifyMLDSASignature(this.mldsaSigner, message, signature.signature);
        if (!isValid) {
            throw new Error('Could not verify generated MLDSA signature for link request');
        }
        return new Uint8Array(signature.signature);
    }
    generateMLDSALinkRequest(parameters, features) {
        const mldsaSigner = this.mldsaSigner;
        const legacySignature = this.generateLegacySignature();
        let mldsaSignature = null;
        if (parameters.revealMLDSAPublicKey) {
            mldsaSignature = this.generateMLDSASignature();
        }
        const mldsaRequest = {
            priority: FeaturePriority.MLDSA_LINK_PUBKEY,
            opcode: Features.MLDSA_LINK_PUBKEY,
            data: {
                verifyRequest: !!parameters.revealMLDSAPublicKey,
                publicKey: mldsaSigner.publicKey,
                hashedPublicKey: this.hashedPublicKey,
                level: getLevelFromPublicKeyLength(mldsaSigner.publicKey.length),
                legacySignature: legacySignature,
                mldsaSignature: mldsaSignature,
            },
        };
        features.push(mldsaRequest);
    }
    /**
     * @description Returns the transaction opnet fee
     * @protected
     * @returns {bigint}
     */
    getTransactionOPNetFee() {
        const totalFee = this.priorityFee + this.gasSatFee;
        if (totalFee > TransactionBuilder.MINIMUM_DUST) {
            return totalFee;
        }
        return TransactionBuilder.MINIMUM_DUST;
    }
    /**
     * @description Returns the total amount of satoshis in the inputs
     * @protected
     * @returns {bigint}
     */
    calculateTotalUTXOAmount() {
        let total = 0n;
        for (const utxo of this.utxos) {
            total += utxo.value;
        }
        for (const utxo of this.optionalInputs) {
            total += utxo.value;
        }
        return total;
    }
    /**
     * @description Returns the total amount of satoshis in the outputs
     * @protected
     * @returns {bigint}
     */
    calculateTotalVOutAmount() {
        let total = 0n;
        for (const utxo of this.utxos) {
            total += utxo.value;
        }
        for (const utxo of this.optionalInputs) {
            total += utxo.value;
        }
        return total;
    }
    /**
     * @description Adds optional outputs to transaction and returns their total value in satoshi to calculate refund transaction
     * @protected
     * @returns {bigint}
     */
    addOptionalOutputsAndGetAmount() {
        if (!this.optionalOutputs || this.optionalOutputsAdded)
            return 0n;
        let refundedFromOptionalOutputs = 0n;
        for (let i = 0; i < this.optionalOutputs.length; i++) {
            this.addOutput(this.optionalOutputs[i]);
            refundedFromOptionalOutputs += BigInt(this.optionalOutputs[i].value);
        }
        this.optionalOutputsAdded = true;
        return refundedFromOptionalOutputs;
    }
    /**
     * @description Adds the inputs from the utxos
     * @protected
     * @returns {void}
     */
    addInputsFromUTXO() {
        if (this.utxos.length) {
            //throw new Error('No UTXOs specified');
            if (this.totalInputAmount < TransactionBuilder.MINIMUM_DUST) {
                throw new Error(`Total input amount is ${this.totalInputAmount} sat which is less than the minimum dust ${TransactionBuilder.MINIMUM_DUST} sat.`);
            }
            for (let i = 0; i < this.utxos.length; i++) {
                const utxo = this.utxos[i];
                // Register signer BEFORE generating input (needed for tapInternalKey)
                this.registerInputSigner(i, utxo);
                const input = this.generatePsbtInputExtended(utxo, i);
                this.addInput(input);
            }
        }
        if (this.optionalInputs) {
            for (let i = this.utxos.length; i < this.optionalInputs.length + this.utxos.length; i++) {
                const utxo = this.optionalInputs[i - this.utxos.length];
                // Register signer BEFORE generating input (needed for tapInternalKey)
                this.registerInputSigner(i, utxo);
                const input = this.generatePsbtInputExtended(utxo, i, true);
                this.addInput(input);
            }
        }
    }
    /**
     * Internal init.
     * @protected
     */
    internalInit() {
        this.verifyUTXOValidity();
        super.internalInit();
    }
    /**
     * Add an input update
     * @param {UpdateInput} input - The input to update
     * @protected
     * @returns {void}
     */
    updateInput(input) {
        this.updateInputs.push(input);
    }
    /**
     * Adds the fee to the output.
     * @param amountSpent
     * @param contractAddress
     * @param epochChallenge
     * @param addContractOutput
     * @protected
     */
    addFeeToOutput(amountSpent, contractAddress, epochChallenge, addContractOutput) {
        if (addContractOutput) {
            let amountToCA;
            if (amountSpent > MINIMUM_AMOUNT_REWARD + MINIMUM_AMOUNT_CA) {
                amountToCA = MINIMUM_AMOUNT_CA;
            }
            else {
                amountToCA = amountSpent;
            }
            // ALWAYS THE FIRST INPUT.
            this.addOutput({
                value: toSatoshi(amountToCA),
                address: contractAddress,
            }, true);
            // ALWAYS SECOND.
            if (amountToCA === MINIMUM_AMOUNT_CA &&
                amountSpent - MINIMUM_AMOUNT_CA > MINIMUM_AMOUNT_REWARD) {
                this.addOutput({
                    value: toSatoshi(amountSpent - amountToCA),
                    address: epochChallenge.address,
                }, true);
            }
        }
        else {
            // When SEND_AMOUNT_TO_CA is false, always send to epochChallenge
            // Use the maximum of amountSpent or MINIMUM_AMOUNT_REWARD
            const amountToEpoch = amountSpent < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : amountSpent;
            this.addOutput({
                value: toSatoshi(amountToEpoch),
                address: epochChallenge.address,
            }, true);
        }
    }
    /**
     * Returns the witness of the tap transaction.
     * @protected
     * @returns {Uint8Array}
     */
    getWitness() {
        if (!this.tapData || !this.tapData.witness) {
            throw new Error('Witness is required');
        }
        if (this.tapData.witness.length === 0) {
            throw new Error('Witness is empty');
        }
        return this.tapData.witness[this.tapData.witness.length - 1];
    }
    /**
     * Returns the tap output.
     * @protected
     * @returns {Uint8Array}
     */
    getTapOutput() {
        if (!this.tapData || !this.tapData.output) {
            throw new Error('Tap data is required');
        }
        return this.tapData.output;
    }
    /**
     * Verifies that the utxos are valid.
     * @protected
     */
    verifyUTXOValidity() {
        for (const utxo of this.utxos) {
            if (!utxo.scriptPubKey) {
                throw new Error('Address is required');
            }
        }
        for (const utxo of this.optionalInputs) {
            if (!utxo.scriptPubKey) {
                throw new Error('Address is required');
            }
        }
    }
    /**
     * Builds the transaction.
     * @param {Psbt} transaction - The transaction to build
     * @param checkPartialSigs
     * @protected
     * @returns {Promise<boolean>}
     * @throws {Error} - If something went wrong while building the transaction
     */
    async internalBuildTransaction(transaction, checkPartialSigs = false) {
        if (transaction.data.inputs.length === 0) {
            const inputs = this.getInputs();
            const outputs = this.getOutputs();
            transaction.setMaximumFeeRate(this._maximumFeeRate);
            transaction.addInputs(inputs, checkPartialSigs);
            for (let i = 0; i < this.updateInputs.length; i++) {
                transaction.updateInput(i, this.updateInputs[i]);
            }
            transaction.addOutputs(outputs);
        }
        try {
            await this.signInputs(transaction);
            if (this.finalized) {
                this.transactionFee = BigInt(transaction.getFee());
            }
            return true;
        }
        catch (e) {
            const err = e;
            this.error(`[internalBuildTransaction] Something went wrong while getting building the transaction: ${err.stack}`);
        }
        return false;
    }
    createChangeOutput(amount) {
        if (AddressVerificator.isValidP2TRAddress(this.from, this.network)) {
            return {
                value: toSatoshi(amount),
                address: this.from,
                tapInternalKey: this.internalPubKeyToXOnly(),
            };
        }
        else if (AddressVerificator.isValidPublicKey(this.from, this.network)) {
            const pubKeyScript = compile([
                fromHex$1(this.from.startsWith('0x') ? this.from.slice(2) : this.from),
                opcodes.OP_CHECKSIG,
            ]);
            return {
                value: toSatoshi(amount),
                script: pubKeyScript,
            };
        }
        else {
            return {
                value: toSatoshi(amount),
                address: this.from,
            };
        }
    }
}

/**
 * Class for interaction transactions
 * @class CustomScriptTransaction
 */
class CustomScriptTransaction extends TransactionBuilder {
    type = TransactionType.CUSTOM_CODE;
    /**
     * The contract address
     * @protected
     */
    _scriptAddress;
    /**
     * The tap leaf script
     * @private
     */
    tapLeafScript = null;
    /**
     * The target script redeem
     * @private
     */
    targetScriptRedeem = null;
    /**
     * The left over funds script redeem
     * @private
     */
    leftOverFundsScriptRedeem = null;
    /**
     * The compiled target script
     * @private
     */
    compiledTargetScript;
    /**
     * The script tree
     * @private
     */
    scriptTree;
    /**
     * The deployment bitcoin generator
     * @private
     */
    generator;
    /**
     * The contract seed
     * @private
     */
    scriptSeed;
    /**
     * The contract signer
     * @private
     */
    contractSigner;
    /**
     * The contract salt random bytes
     * @private
     */
    randomBytes;
    /**
     * The witnesses
     * @private
     */
    witnesses;
    annexData;
    constructor(parameters) {
        super(parameters);
        if (!parameters.script)
            throw new Error('Bitcoin script is required');
        if (!parameters.witnesses)
            throw new Error('Witness(es) are required');
        this.witnesses = parameters.witnesses;
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        this.scriptSeed = this.getContractSeed();
        this.contractSigner = EcKeyPair.fromSeedKeyPair(this.scriptSeed, this.network);
        this.generator = new CustomGenerator(this.internalPubKeyToXOnly(), this.network);
        this.compiledTargetScript = this.generator.compile(parameters.script);
        this.scriptTree = this.getScriptTree();
        this.internalInit();
        this._scriptAddress = AddressGenerator.generatePKSH(this.scriptSeed, this.network);
    }
    /**
     * @description Get the contract address (PKSH)
     */
    get scriptAddress() {
        return this._scriptAddress;
    }
    /**
     * @description Get the P2TR address
     */
    get p2trAddress() {
        return this.to || this.getScriptAddress();
    }
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    /**
     * Get the random bytes used for the interaction
     * @returns {Uint8Array} The random bytes
     */
    getRndBytes() {
        return this.randomBytes;
    }
    /**
     * Get the contract signer public key
     * @protected
     */
    contractSignerXOnlyPubKey() {
        return toXOnly(this.contractSigner.publicKey);
    }
    /**
     * Build the transaction
     * @protected
     */
    async buildTransaction() {
        if (!this.to) {
            this.to = this.getScriptAddress();
        }
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!selectedRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!selectedRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: selectedRedeem.redeemVersion,
            script: selectedRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        const amountSpent = this.getTransactionOPNetFee();
        this.addOutput({
            value: toSatoshi(amountSpent),
            address: this.to,
        });
        await this.addRefundOutput(amountSpent + this.addOptionalOutputsAndGetAmount());
    }
    /**
     * Sign the inputs
     * @param {Psbt} transaction The transaction to sign
     * @protected
     */
    async signInputs(transaction) {
        if (!this.contractSigner) {
            await super.signInputs(transaction);
            return;
        }
        // Input 0: sequential (contractSigner + main signer, custom finalizer)
        try {
            transaction.signInput(0, this.contractSigner);
        }
        catch {
            // contractSigner may fail for some script types
        }
        transaction.signInput(0, this.getSignerKey());
        transaction.finalizeInput(0, this.customFinalizer);
        // Inputs 1+: parallel key-path if available, then sequential for remaining
        const signedIndices = new Set([0]);
        if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
            try {
                const result = await this.signKeyPathInputsParallel(transaction, new Set([0]));
                if (result.success) {
                    for (const idx of result.signatures.keys())
                        signedIndices.add(idx);
                }
            }
            catch (e) {
                this.error(`Parallel signing failed: ${e.message}`);
            }
        }
        for (let i = 1; i < transaction.data.inputs.length; i++) {
            if (!signedIndices.has(i)) {
                transaction.signInput(i, this.getSignerKey());
            }
        }
        // Finalize inputs 1+
        for (let i = 1; i < transaction.data.inputs.length; i++) {
            try {
                transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
            }
            catch {
                transaction.finalizeInput(i);
            }
        }
    }
    /**
     * Get the tap output
     * @protected
     */
    generateScriptAddress() {
        if (this.useP2MR) {
            return {
                network: this.network,
                scriptTree: this.scriptTree,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            name: PaymentType.P2TR,
        };
    }
    /**
     * Generate the tap data
     * @protected
     */
    generateTapData() {
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        if (this.useP2MR) {
            return {
                network: this.network,
                scriptTree: this.scriptTree,
                redeem: selectedRedeem,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
            name: PaymentType.P2TR,
        };
    }
    getScriptSolution(input) {
        if (!input.tapScriptSig) {
            throw new Error('Tap script signature is required');
        }
        const witnesses = [...this.witnesses];
        if (input.tapScriptSig) {
            for (const sig of input.tapScriptSig) {
                witnesses.push(sig.signature);
            }
        }
        return witnesses;
    }
    /**
     * Generate the contract seed for the deployment
     * @private
     */
    getContractSeed() {
        return hash256(this.randomBytes);
    }
    /**
     * Finalize the transaction
     * @param _inputIndex
     * @param input
     */
    customFinalizer = (_inputIndex, input) => {
        if (!this.tapLeafScript) {
            throw new Error('Tap leaf script is required');
        }
        const scriptSolution = this.getScriptSolution(input);
        const witness = scriptSolution
            .concat(this.tapLeafScript.script)
            .concat(this.tapLeafScript.controlBlock);
        if (this.annexData && this.annexData.length > 0) {
            let annex;
            if (this.annexData[0] === 0x50) {
                annex = this.annexData;
            }
            else {
                const prefixed = new Uint8Array(this.annexData.length + 1);
                prefixed[0] = 0x50;
                prefixed.set(this.annexData, 1);
                annex = prefixed;
            }
            witness.push(annex);
        }
        return {
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
        };
    };
    /**
     * Generate the redeem scripts
     * @private
     */
    generateRedeemScripts() {
        this.targetScriptRedeem = {
            name: PaymentType.P2TR,
            //pubkeys: this.getPubKeys(),
            output: this.compiledTargetScript,
            redeemVersion: 192,
        };
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            //pubkeys: this.getPubKeys(),
            output: this.getLeafScript(),
            redeemVersion: 192,
        };
    }
    /**
     * Get the second leaf script
     * @private
     */
    getLeafScript() {
        return this.LOCK_LEAF_SCRIPT;
    }
    /**
     * Get the script tree
     * @private
     */
    getScriptTree() {
        this.generateRedeemScripts();
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.getLeafScript(),
                version: 192,
            },
        ];
    }
}

/**
 * Shared interaction transaction
 * @class SharedInteractionTransaction
 */
class SharedInteractionTransaction extends TransactionBuilder {
    static MAXIMUM_CALLDATA_SIZE = 1024 * 1024; // 1MB
    /**
     * Random salt for the interaction
     * @type {Uint8Array}
     */
    randomBytes;
    targetScriptRedeem = null;
    leftOverFundsScriptRedeem = null;
    challenge;
    epochChallenge;
    calldataGenerator;
    /**
     * Calldata for the interaction
     * @protected
     */
    calldata;
    /**
     * Script signer for the interaction
     * @protected
     */
    scriptSigner;
    /**
     * Disable auto refund
     * @protected
     */
    disableAutoRefund;
    constructor(parameters) {
        super(parameters);
        if (!parameters.calldata) {
            throw new Error('Calldata is required');
        }
        if (!parameters.challenge) {
            throw new Error('Challenge solution is required');
        }
        this.challenge = parameters.challenge;
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        this.disableAutoRefund = parameters.disableAutoRefund || false;
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        this.calldata = Compressor.compress(parameters.calldata);
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.scriptSigner = this.generateKeyPairFromSeed();
        this.calldataGenerator = new CalldataGenerator(this.signer.publicKey, this.scriptSignerXOnlyPubKey(), this.network);
    }
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    /**
     * Get the contract secret
     * @returns {Uint8Array} The contract secret
     */
    getContractSecret() {
        return this.contractSecret;
    }
    /**
     * Get the random bytes used for the interaction
     * @returns {Uint8Array} The random bytes
     */
    getRndBytes() {
        return this.randomBytes;
    }
    /**
     * Get the preimage
     */
    getChallenge() {
        return this.challenge;
    }
    /**
     * Get the internal pubkey as an x-only key
     * @protected
     * @returns {Uint8Array} The internal pubkey as an x-only key
     */
    scriptSignerXOnlyPubKey() {
        return toXOnly(this.scriptSigner.publicKey);
    }
    /**
     * Generate a key pair from the seed
     * @protected
     *
     * @returns {UniversalSigner} The key pair
     */
    generateKeyPairFromSeed() {
        return EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
    }
    /**
     * Build the transaction
     * @protected
     *
     * @throws {Error} If the left over funds script redeem is required
     * @throws {Error} If the left over funds script redeem version is required
     * @throws {Error} If the left over funds script redeem output is required
     * @throws {Error} If the to address is required
     */
    async buildTransaction() {
        const selectedRedeem = this.scriptSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!selectedRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!selectedRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: selectedRedeem.redeemVersion,
            script: selectedRedeem.output,
            controlBlock: this.getWitness(),
        };
        if (!this.regenerated) {
            this.addInputsFromUTXO();
        }
        await this.createMineableRewardOutputs();
    }
    /**
     * Sign the inputs
     * @param {Psbt} transaction The transaction to sign
     * @protected
     */
    async signInputs(transaction) {
        if (!this.scriptSigner) {
            await super.signInputs(transaction);
            return;
        }
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
        }
        else {
            await this.signInputsNonWalletBased(transaction);
        }
    }
    generateScriptAddress() {
        if (this.useP2MR) {
            return {
                network: this.network,
                scriptTree: this.scriptTree,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            name: PaymentType.P2TR,
        };
    }
    generateTapData() {
        const selectedRedeem = this.scriptSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        if (this.useP2MR) {
            return {
                network: this.network,
                scriptTree: this.scriptTree,
                redeem: selectedRedeem,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
            name: PaymentType.P2TR,
        };
    }
    /**
     * Generate the script solution
     * @param {PsbtInput} input The input
     * @protected
     *
     * @returns {Uint8Array[]} The script solution
     */
    getScriptSolution(input) {
        if (!input.tapScriptSig) {
            throw new Error('Tap script signature is required');
        }
        return [
            this.contractSecret,
            input.tapScriptSig[0].signature,
            input.tapScriptSig[1].signature,
        ];
    }
    /**
     * Get the script tree
     * @private
     *
     * @returns {Taptree} The script tree
     */
    getScriptTree() {
        if (!this.calldata) {
            throw new Error('Calldata is required');
        }
        this.generateRedeemScripts();
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.LOCK_LEAF_SCRIPT,
                version: 192,
            },
        ];
    }
    /**
     * Transaction finalizer
     * @param {number} _inputIndex The input index
     * @param {PsbtInput} input The input
     */
    customFinalizer = (_inputIndex, input) => {
        if (!this.tapLeafScript) {
            throw new Error('Tap leaf script is required');
        }
        if (!this.contractSecret) {
            throw new Error('Contract secret is required');
        }
        const scriptSolution = this.getScriptSolution(input);
        const witness = scriptSolution
            .concat(this.tapLeafScript.script)
            .concat(this.tapLeafScript.controlBlock);
        return {
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
        };
    };
    // custom for interactions
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        // first, we sign the first input with the script signer.
        await this.signInput(transaction, transaction.data.inputs[0], 0, this.scriptSigner);
        // then, we sign all the remaining inputs with the wallet signer.
        await signer.multiSignPsbt([transaction]);
        // Then, we finalize every input.
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            else {
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    async signInputsNonWalletBased(transaction) {
        // Input 0: always sequential (needs scriptSigner + main signer, custom finalizer)
        await this.signInput(transaction, transaction.data.inputs[0], 0, this.scriptSigner);
        await this.signInput(transaction, transaction.data.inputs[0], 0, this.getSignerKey());
        transaction.finalizeInput(0, this.customFinalizer.bind(this));
        // Inputs 1+: parallel key-path if available, then sequential for remaining
        if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
            let parallelSignedIndices = new Set();
            try {
                const result = await this.signKeyPathInputsParallel(transaction, new Set([0]));
                if (result.success) {
                    parallelSignedIndices = new Set(result.signatures.keys());
                }
            }
            catch (e) {
                this.error(`Parallel signing failed, falling back to sequential: ${e.message}`);
            }
            // Sign remaining inputs 1+ that weren't handled by parallel signing
            for (let i = 1; i < transaction.data.inputs.length; i++) {
                if (!parallelSignedIndices.has(i)) {
                    await this.signInput(transaction, transaction.data.inputs[i], i, this.signer);
                }
            }
        }
        else {
            for (let i = 1; i < transaction.data.inputs.length; i++) {
                await this.signInput(transaction, transaction.data.inputs[i], i, this.signer);
            }
        }
        // Finalize inputs 1+
        for (let i = 1; i < transaction.data.inputs.length; i++) {
            try {
                transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
            }
            catch {
                transaction.finalizeInput(i);
            }
        }
        this.finalized = true;
    }
    async createMineableRewardOutputs() {
        if (!this.to)
            throw new Error('To address is required');
        const opnetFee = this.getTransactionOPNetFee();
        // Add the output to challenge address
        this.addFeeToOutput(opnetFee, this.to, this.epochChallenge, false);
        // Get the actual amount added to outputs (might be MINIMUM_AMOUNT_REWARD if opnetFee is too small)
        const actualOutputAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
        const optionalAmount = this.addOptionalOutputsAndGetAmount();
        if (!this.disableAutoRefund) {
            // Pass the TOTAL amount spent: actual output amount + optional outputs
            await this.addRefundOutput(actualOutputAmount + optionalAmount);
        }
    }
    /**
     * Generate the redeem scripts
     * @private
     *
     * @throws {Error} If the public keys are required
     * @throws {Error} If the leaf script is required
     * @throws {Error} If the leaf script version is required
     * @throws {Error} If the leaf script output is required
     * @throws {Error} If the target script redeem is required
     */
    generateRedeemScripts() {
        this.targetScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.compiledTargetScript,
            redeemVersion: 192,
        };
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.LOCK_LEAF_SCRIPT,
            redeemVersion: 192,
        };
    }
}

class DeploymentTransaction extends TransactionBuilder {
    static MAXIMUM_CONTRACT_SIZE = 128 * 1024;
    type = TransactionType.DEPLOYMENT;
    challenge;
    epochChallenge;
    /**
     * The contract address
     * @protected
     */
    _contractAddress;
    /**
     * The tap leaf script
     * @private
     */
    tapLeafScript = null;
    deploymentVersion = 0x00;
    /**
     * The target script redeem
     * @private
     */
    targetScriptRedeem = null;
    /**
     * The left over funds script redeem
     * @private
     */
    leftOverFundsScriptRedeem = null;
    /**
     * The compiled target script
     * @private
     */
    compiledTargetScript;
    /**
     * The script tree
     * @private
     */
    scriptTree;
    /**
     * The deployment bitcoin generator
     * @private
     */
    deploymentGenerator;
    /**
     * The contract seed
     * @private
     */
    contractSeed;
    /**
     * The contract bytecode
     * @private
     */
    bytecode;
    /**
     * Constructor calldata
     * @private
     */
    calldata;
    /**
     * The contract signer
     * @private
     */
    contractSigner;
    /**
     * The contract public key
     * @private
     */
    _contractPubKey;
    /**
     * The contract salt random bytes
     * @private
     */
    randomBytes;
    _computedAddress;
    constructor(parameters) {
        super(parameters);
        if (!this.hashedPublicKey) {
            throw new Error('MLDSA signer must be defined to deploy a contract.');
        }
        this.bytecode = Compressor.compress(new Uint8Array([...versionBuffer, ...parameters.bytecode]));
        this.verifyBytecode();
        if (parameters.calldata) {
            this.calldata = parameters.calldata;
            this.verifyCalldata();
        }
        if (!parameters.challenge)
            throw new Error('Challenge solution is required');
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.challenge = parameters.challenge;
        this.LOCK_LEAF_SCRIPT = this.defineLockScript();
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        this.contractSeed = this.getContractSeed();
        this.contractSigner = EcKeyPair.fromSeedKeyPair(this.contractSeed, this.network);
        this.deploymentGenerator = new DeploymentGenerator(this.signer.publicKey, this.contractSignerXOnlyPubKey(), this.network);
        if (parameters.compiledTargetScript) {
            if (parameters.compiledTargetScript instanceof Uint8Array) {
                this.compiledTargetScript = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledTargetScript = fromHex$1(parameters.compiledTargetScript);
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledTargetScript = this.deploymentGenerator.compile(this.bytecode, this.randomBytes, this.challenge, this.priorityFee, this.calldata, this.generateFeatures(parameters));
        }
        this.scriptTree = this.getScriptTree();
        this.internalInit();
        this._contractPubKey = '0x' + toHex$1(this.contractSeed);
        this._contractAddress = new Address(this.contractSeed);
    }
    /**
     * Get the contract public key
     */
    get contractPubKey() {
        return this._contractPubKey;
    }
    /**
     * @description Get the contract address (PKSH)
     */
    get contractAddress() {
        return this._contractAddress;
    }
    /**
     * @description Get the P2TR address
     */
    get p2trAddress() {
        return this.to || this.getScriptAddress();
    }
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    /**
     * Get the random bytes used for the interaction
     * @returns {Uint8Array} The random bytes
     */
    getRndBytes() {
        return this.randomBytes;
    }
    /**
     * Get the contract bytecode
     * @returns {Uint8Array} The contract bytecode
     */
    getChallenge() {
        return this.challenge;
    }
    getContractAddress() {
        if (this._computedAddress) {
            return this._computedAddress;
        }
        this._computedAddress = EcKeyPair.p2op(this.contractSeed, this.network, this.deploymentVersion);
        return this._computedAddress;
    }
    /**
     * Get the contract signer public key
     * @protected
     */
    contractSignerXOnlyPubKey() {
        return toXOnly(this.contractSigner.publicKey);
    }
    /**
     * Build the transaction
     * @protected
     */
    async buildTransaction() {
        if (!this.to) {
            this.to = this.getScriptAddress();
        }
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!selectedRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!selectedRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: selectedRedeem.redeemVersion,
            script: selectedRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        const amountSpent = this.getTransactionOPNetFee();
        this.addFeeToOutput(amountSpent, this.getContractAddress(), this.epochChallenge, true);
        await this.addRefundOutput(amountSpent + this.addOptionalOutputsAndGetAmount());
    }
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        // first, we sign the first input with the script signer.
        await this.signInput(transaction, transaction.data.inputs[0], 0, this.contractSigner);
        // then, we sign all the remaining inputs with the wallet signer.
        await signer.multiSignPsbt([transaction]);
        // Then, we finalize every input.
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            else {
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    /**
     * Sign the inputs
     * @param {Psbt} transaction The transaction to sign
     * @protected
     */
    async signInputs(transaction) {
        if (!this.contractSigner) {
            await super.signInputs(transaction);
            return;
        }
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
            return;
        }
        // Input 0: sequential (contractSigner + main signer, custom finalizer)
        transaction.signInput(0, this.contractSigner);
        transaction.signInput(0, this.getSignerKey());
        transaction.finalizeInput(0, this.customFinalizer.bind(this));
        // Inputs 1+: parallel key-path if available, then sequential for remaining
        const signedIndices = new Set([0]);
        if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
            try {
                const result = await this.signKeyPathInputsParallel(transaction, new Set([0]));
                if (result.success) {
                    for (const idx of result.signatures.keys())
                        signedIndices.add(idx);
                }
            }
            catch (e) {
                this.error(`Parallel signing failed: ${e.message}`);
            }
        }
        for (let i = 1; i < transaction.data.inputs.length; i++) {
            if (!signedIndices.has(i)) {
                transaction.signInput(i, this.getSignerKey());
            }
        }
        // Finalize inputs 1+
        for (let i = 1; i < transaction.data.inputs.length; i++) {
            try {
                transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
            }
            catch {
                transaction.finalizeInput(i);
            }
        }
    }
    /**
     * Get the tap output
     * @protected
     */
    generateScriptAddress() {
        if (this.useP2MR) {
            return {
                name: PaymentType.P2MR,
                network: this.network,
                scriptTree: this.scriptTree,
            };
        }
        return {
            name: PaymentType.P2TR,
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
        };
    }
    /**
     * Generate the tap data
     * @protected
     */
    generateTapData() {
        const selectedRedeem = this.contractSigner
            ? this.targetScriptRedeem
            : this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        if (this.useP2MR) {
            return {
                name: PaymentType.P2MR,
                network: this.network,
                scriptTree: this.scriptTree,
                redeem: selectedRedeem,
            };
        }
        return {
            name: PaymentType.P2TR,
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
        };
    }
    generateFeatures(parameters) {
        const features = [];
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.MLDSA_LINK_PUBKEY,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
            throw new Error('To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.');
        }
        if (parameters.linkMLDSAPublicKeyToAddress) {
            this.generateMLDSALinkRequest(parameters, features);
        }
        return features;
    }
    verifyCalldata() {
        if (this.calldata &&
            this.calldata.length > SharedInteractionTransaction.MAXIMUM_CALLDATA_SIZE) {
            throw new Error('Calldata size overflow.');
        }
    }
    verifyBytecode() {
        if (!this.bytecode)
            throw new Error('Bytecode is required');
        if (this.bytecode.length > DeploymentTransaction.MAXIMUM_CONTRACT_SIZE) {
            throw new Error('Contract size overflow.');
        }
    }
    /**
     * Generate the contract seed for the deployment
     * @private
     */
    getContractSeed() {
        if (!this.bytecode) {
            throw new Error('Bytecode is required');
        }
        // Concatenate deployer pubkey, salt, and sha256(bytecode)
        const deployerPubKey = this.internalPubKeyToXOnly();
        const salt = hash256(this.randomBytes);
        const sha256OfBytecode = hash256(this.bytecode);
        const buf = concat$1([deployerPubKey, salt, sha256OfBytecode]);
        return hash256(buf);
    }
    /**
     * Finalize the transaction
     * @param _inputIndex
     * @param input
     */
    customFinalizer = (_inputIndex, input) => {
        if (!this.tapLeafScript) {
            throw new Error('Tap leaf script is required');
        }
        if (!input.tapScriptSig) {
            throw new Error('Tap script signature is required');
        }
        const scriptSolution = [
            this.randomBytes,
            input.tapScriptSig[0].signature,
            input.tapScriptSig[1].signature,
        ];
        const witness = scriptSolution
            .concat(this.tapLeafScript.script)
            .concat(this.tapLeafScript.controlBlock);
        return {
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
        };
    };
    /**
     * Generate the redeem scripts
     * @private
     */
    generateRedeemScripts() {
        this.targetScriptRedeem = {
            name: PaymentType.P2TR,
            //pubkeys: this.getPubKeys(),
            output: this.compiledTargetScript,
            redeemVersion: 192,
        };
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            //pubkeys: this.getPubKeys(),
            output: this.getLeafScript(),
            redeemVersion: 192,
        };
    }
    /**
     * Get the second leaf script
     * @private
     */
    getLeafScript() {
        return this.LOCK_LEAF_SCRIPT;
    }
    /**
     * Get the script tree
     * @private
     */
    getScriptTree() {
        if (!this.bytecode) {
            throw new Error('Contract bytecode is required');
        }
        this.generateRedeemScripts();
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.getLeafScript(),
                version: 192,
            },
        ];
    }
}

class FundingTransaction extends TransactionBuilder {
    type = TransactionType.FUNDING;
    amount;
    splitInputsInto;
    autoAdjustAmount;
    constructor(parameters) {
        const mergedParams = parameters.feeUtxos?.length
            ? { ...parameters, utxos: [...parameters.utxos, ...parameters.feeUtxos] }
            : parameters;
        super(mergedParams);
        this.amount = parameters.amount;
        this.splitInputsInto = parameters.splitInputsInto ?? 1;
        this.autoAdjustAmount = parameters.autoAdjustAmount ?? false;
        this.internalInit();
    }
    async buildTransaction() {
        if (!this.to) {
            throw new Error('Recipient address is required');
        }
        this.addInputsFromUTXO();
        // When autoAdjustAmount is enabled and the amount would leave no room for fees,
        // estimate the fee first and reduce the output amount accordingly.
        if (this.autoAdjustAmount && this.amount >= this.totalInputAmount) {
            // Add a temporary output at full amount to get an accurate fee estimate
            if (this.isPubKeyDestination) {
                const toHexClean = this.to.startsWith('0x') ? this.to.slice(2) : this.to;
                const pubKeyScript = compile([
                    fromHex$1(toHexClean),
                    opcodes.OP_CHECKSIG,
                ]);
                this.addOutput({
                    value: toSatoshi(this.amount),
                    script: pubKeyScript,
                });
            }
            else {
                this.addOutput({
                    value: toSatoshi(this.amount),
                    address: this.to,
                });
            }
            const estimatedFee = await this.estimateTransactionFees();
            // Remove the temporary output
            this.outputs.pop();
            const adjustedAmount = this.totalInputAmount - estimatedFee;
            if (adjustedAmount < TransactionBuilder.MINIMUM_DUST) {
                throw new Error(`Insufficient funds: after deducting fee of ${estimatedFee} sats, remaining amount ${adjustedAmount} sats is below minimum dust`);
            }
            this.amount = adjustedAmount;
        }
        // Add the primary output(s) first
        if (this.splitInputsInto > 1) {
            this.splitInputs(this.amount);
        }
        else if (this.isPubKeyDestination) {
            const toHexClean = this.to.startsWith('0x') ? this.to.slice(2) : this.to;
            const pubKeyScript = compile([
                fromHex$1(toHexClean),
                opcodes.OP_CHECKSIG,
            ]);
            this.addOutput({
                value: toSatoshi(this.amount),
                script: pubKeyScript,
            });
        }
        else {
            this.addOutput({
                value: toSatoshi(this.amount),
                address: this.to,
            });
        }
        // Calculate total amount needed for all outputs (including optional)
        const totalOutputAmount = this.amount + this.addOptionalOutputsAndGetAmount();
        // Add refund output - this will handle fee calculation properly
        await this.addRefundOutput(totalOutputAmount);
    }
    splitInputs(amountSpent) {
        if (!this.to) {
            throw new Error('Recipient address is required');
        }
        const splitAmount = amountSpent / BigInt(this.splitInputsInto);
        for (let i = 0; i < this.splitInputsInto; i++) {
            if (this.isPubKeyDestination) {
                this.addOutput({
                    value: toSatoshi(splitAmount),
                    script: fromHex$1(this.to.slice(2)),
                });
            }
            else {
                this.addOutput({
                    value: toSatoshi(splitAmount),
                    address: this.to,
                });
            }
        }
    }
    getSignerKey() {
        return this.signer;
    }
}

/**
 * Class for interaction transactions
 * @class InteractionTransaction
 */
class InteractionTransaction extends SharedInteractionTransaction {
    type = TransactionType.INTERACTION;
    compiledTargetScript;
    scriptTree;
    tapLeafScript = null;
    /**
     * Contract secret for the interaction
     * @protected
     */
    contractSecret;
    constructor(parameters) {
        super(parameters);
        if (!parameters.contract) {
            throw new Error('parameters.contract is required for interaction transaction.');
        }
        this.contractSecret = fromHex$1(parameters.contract.startsWith('0x') ? parameters.contract.slice(2) : parameters.contract);
        if (this.contractSecret.length !== 32) {
            throw new Error('Invalid contract secret length. Expected 32 bytes.');
        }
        if (parameters.compiledTargetScript) {
            if (parameters.compiledTargetScript instanceof Uint8Array) {
                this.compiledTargetScript = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledTargetScript = fromHex$1(parameters.compiledTargetScript);
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledTargetScript = this.calldataGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
        }
        this.scriptTree = this.getScriptTree();
        this.internalInit();
    }
    generateFeatures(parameters) {
        const features = [];
        if (parameters.loadedStorage) {
            features.push({
                priority: FeaturePriority.ACCESS_LIST,
                opcode: Features.ACCESS_LIST,
                data: parameters.loadedStorage,
            });
        }
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.EPOCH_SUBMISSION,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
            throw new Error('To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.');
        }
        if (parameters.linkMLDSAPublicKeyToAddress) {
            this.generateMLDSALinkRequest(parameters, features);
        }
        return features;
    }
}

/**
 * P2WDA Interaction Transaction
 *
 * This transaction type uses the exact same operation data as regular interactions
 * (via CalldataGenerator), but embeds it in the witness field instead of a taproot script.
 * This achieves 75% cost reduction through the witness discount.
 */
class InteractionTransactionP2WDA extends TransactionBuilder {
    static MAX_WITNESS_FIELDS = 10;
    static MAX_BYTES_PER_WITNESS = 80;
    type = TransactionType.INTERACTION;
    epochChallenge;
    /**
     * Disable auto refund
     * @protected
     */
    disableAutoRefund;
    contractSecret;
    calldata;
    challenge;
    randomBytes;
    p2wdaGenerator;
    scriptSigner;
    p2wdaInputIndices = new Set();
    /**
     * The compiled operation data from CalldataGenerator
     * This is exactly what would go in a taproot script, but we put it in witness instead
     */
    compiledOperationData = null;
    constructor(parameters) {
        super(parameters);
        if (!parameters.to) {
            throw new Error('Contract address (to) is required');
        }
        if (!parameters.contract) {
            throw new Error('Contract secret is required');
        }
        if (!parameters.calldata) {
            throw new Error('Calldata is required');
        }
        if (!parameters.challenge) {
            throw new Error('Challenge solution is required');
        }
        this.disableAutoRefund = parameters.disableAutoRefund || false;
        this.contractSecret = fromHex$1(parameters.contract.startsWith('0x') ? parameters.contract.slice(2) : parameters.contract);
        this.calldata = Compressor.compress(parameters.calldata);
        this.challenge = parameters.challenge;
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        // Create the script signer (same as SharedInteractionTransaction does)
        this.scriptSigner = this.generateKeyPairFromSeed();
        // Create the P2WDA generator instead of CalldataGenerator
        // P2WDA needs a different data format optimized for witness embedding
        this.p2wdaGenerator = new P2WDAGenerator(this.signer.publicKey, this.scriptSignerXOnlyPubKey(), this.network);
        // Validate contract secret
        if (this.contractSecret.length !== 32) {
            throw new Error('Invalid contract secret length. Expected 32 bytes.');
        }
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        // Validate P2WDA inputs
        this.validateP2WDAInputs();
        if (parameters.compiledTargetScript) {
            if (parameters.compiledTargetScript instanceof Uint8Array) {
                this.compiledOperationData = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledOperationData = fromHex$1(parameters.compiledTargetScript);
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledOperationData = this.p2wdaGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
        }
        // Validate size early
        this.validateOperationDataSize();
        this.internalInit();
    }
    /**
     * Get random bytes (for compatibility if needed elsewhere)
     */
    getRndBytes() {
        return this.randomBytes;
    }
    /**
     * Get the challenge (for compatibility if needed elsewhere)
     */
    getChallenge() {
        return this.challenge;
    }
    /**
     * Get contract secret (for compatibility if needed elsewhere)
     */
    getContractSecret() {
        return this.contractSecret;
    }
    /**
     * Build the transaction
     */
    async buildTransaction() {
        if (!this.regenerated) {
            this.addInputsFromUTXO();
        }
        // Add refund
        await this.createMineableRewardOutputs();
    }
    async createMineableRewardOutputs() {
        if (!this.to)
            throw new Error('To address is required');
        const amountSpent = this.getTransactionOPNetFee();
        this.addFeeToOutput(amountSpent, this.to, this.epochChallenge, false);
        const amount = this.addOptionalOutputsAndGetAmount();
        if (!this.disableAutoRefund) {
            await this.addRefundOutput(amountSpent + amount);
        }
    }
    /**
     * Sign inputs with P2WDA-specific handling
     */
    async signInputs(transaction) {
        // Sign all inputs
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            await this.signInput(transaction, transaction.data.inputs[i], i, this.signer);
        }
        // Finalize with appropriate finalizers
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (this.p2wdaInputIndices.has(i)) {
                if (i === 0) {
                    transaction.finalizeInput(i, this.finalizePrimaryP2WDA.bind(this));
                }
                else {
                    transaction.finalizeInput(i, this.finalizeSecondaryP2WDA.bind(this));
                }
            }
            else {
                transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
            }
        }
        this.finalized = true;
    }
    /**
     * Generate features array (same as InteractionTransaction)
     */
    generateFeatures(parameters) {
        const features = [];
        if (parameters.loadedStorage) {
            features.push({
                priority: FeaturePriority.ACCESS_LIST,
                opcode: Features.ACCESS_LIST,
                data: parameters.loadedStorage,
            });
        }
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.EPOCH_SUBMISSION,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        return features;
    }
    /**
     * Generate keypair from seed (same as SharedInteractionTransaction)
     */
    generateKeyPairFromSeed() {
        return EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
    }
    /**
     * Get script signer x-only pubkey (same as SharedInteractionTransaction)
     */
    scriptSignerXOnlyPubKey() {
        return toXOnly(this.scriptSigner.publicKey);
    }
    /**
     * Validate that input 0 is P2WDA
     */
    validateP2WDAInputs() {
        if (this.utxos.length === 0 || !P2WDADetector.isP2WDAUTXO(this.utxos[0])) {
            throw new Error('Input 0 must be a P2WDA UTXO');
        }
        // Track all P2WDA inputs
        for (let i = 0; i < this.utxos.length; i++) {
            if (P2WDADetector.isP2WDAUTXO(this.utxos[i])) {
                this.p2wdaInputIndices.add(i);
            }
        }
        for (let i = 0; i < this.optionalInputs.length; i++) {
            const actualIndex = this.utxos.length + i;
            if (P2WDADetector.isP2WDAUTXO(this.optionalInputs[i])) {
                this.p2wdaInputIndices.add(actualIndex);
            }
        }
    }
    /**
     * Validate the compiled operation data will fit in witness fields
     */
    validateOperationDataSize() {
        if (!this.compiledOperationData) {
            throw new Error('Operation data not compiled');
        }
        // The data that goes in witness: COMPRESS(signature + compiledOperationData)
        // Signature is 64 bytes
        const estimatedSize = this.compiledOperationData.length;
        if (!P2WDAGenerator.validateWitnessSize(estimatedSize)) {
            const signatureSize = 64;
            const totalSize = estimatedSize + signatureSize;
            const compressedEstimate = Math.ceil(totalSize * 0.7);
            const requiredFields = Math.ceil(compressedEstimate / InteractionTransactionP2WDA.MAX_BYTES_PER_WITNESS);
            throw new Error(`Please dont use P2WDA for this operation. Data too large. Raw size: ${estimatedSize} bytes, ` +
                `estimated compressed: ${compressedEstimate} bytes, ` +
                `needs ${requiredFields} witness fields, max is ${InteractionTransactionP2WDA.MAX_WITNESS_FIELDS}`);
        }
    }
    /**
     * Finalize primary P2WDA input with the operation data
     * This is where we create the signature and compress everything
     */
    finalizePrimaryP2WDA(inputIndex, input) {
        if (!input.partialSig || input.partialSig.length === 0) {
            throw new Error(`No signature for P2WDA input #${inputIndex}`);
        }
        if (!input.witnessScript) {
            throw new Error(`No witness script for P2WDA input #${inputIndex}`);
        }
        if (!this.compiledOperationData) {
            throw new Error('Operation data not compiled');
        }
        const txSignature = input.partialSig[0].signature;
        const messageToSign = concat$1([txSignature, this.compiledOperationData]);
        const signedMessage = MessageSigner.signMessage(this.signer, messageToSign);
        const schnorrSignature = signedMessage.signature;
        // Combine and compress: COMPRESS(signature + compiledOperationData)
        const fullData = concat$1([schnorrSignature, this.compiledOperationData]);
        const compressedData = Compressor.compress(fullData);
        // Split into chunks
        const chunks = this.splitIntoWitnessChunks(compressedData);
        if (chunks.length > InteractionTransactionP2WDA.MAX_WITNESS_FIELDS) {
            throw new Error(`Compressed data needs ${chunks.length} witness fields, max is ${InteractionTransactionP2WDA.MAX_WITNESS_FIELDS}`);
        }
        // Build witness stack
        const witnessStack = [txSignature];
        // Add exactly 10 data fields
        // Bitcoin stack is reversed!
        for (let i = 0; i < InteractionTransactionP2WDA.MAX_WITNESS_FIELDS; i++) {
            witnessStack.push(i < chunks.length ? chunks[i] : new Uint8Array(0));
        }
        witnessStack.push(input.witnessScript);
        return {
            finalScriptSig: undefined,
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witnessStack),
        };
    }
    /**
     * Split data into 80-byte chunks
     */
    splitIntoWitnessChunks(data) {
        const chunks = [];
        let offset = 0;
        while (offset < data.length) {
            const size = Math.min(InteractionTransactionP2WDA.MAX_BYTES_PER_WITNESS, data.length - offset);
            chunks.push(data.slice(offset, offset + size));
            offset += size;
        }
        return chunks;
    }
}

class CancelTransaction extends TransactionBuilder {
    type = TransactionType.CANCEL;
    /**
     * The tap leaf script for spending
     */
    tapLeafScript = null;
    compiledTargetScript;
    scriptTree;
    contractSecret;
    leftOverFundsScriptRedeem = null;
    constructor(parameters) {
        super({
            ...parameters,
            gasSatFee: 1n,
            isCancellation: true,
            priorityFee: 1n,
            calldata: new Uint8Array(0),
        });
        this.contractSecret = new Uint8Array(0);
        if (parameters.compiledTargetScript instanceof Uint8Array) {
            this.compiledTargetScript = parameters.compiledTargetScript;
        }
        else {
            this.compiledTargetScript = fromHex$1(parameters.compiledTargetScript);
        }
        // Generate the minimal script tree needed for recovery
        this.scriptTree = this.getMinimalScriptTree();
        this.internalInit();
    }
    async buildTransaction() {
        if (!this.from) {
            throw new Error('From address is required');
        }
        if (!this.leftOverFundsScriptRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.leftOverFundsScriptRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!this.leftOverFundsScriptRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        // Set up the tap leaf script for spending
        this.tapLeafScript = {
            leafVersion: this.leftOverFundsScriptRedeem.redeemVersion,
            script: this.leftOverFundsScriptRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        await this.addRefundOutput(0n, true);
        if (!this.feeOutput) {
            throw new Error('Must add extra UTXOs to cancel this transaction');
        }
    }
    /*protected override async buildTransaction(): Promise<void> {
        if (!this.from) {
            throw new Error('From address is required');
        }

        // For key-path spend, we don't need the tap leaf script
        this.tapLeafScript = null;

        this.addInputsFromUTXO();
        await this.addRefundOutput(0n);
    }*/
    /**
     * Sign the inputs
     * @param {Psbt} transaction The transaction to sign
     * @protected
     */
    /*protected async signInputs(transaction: Psbt): Promise<void> {
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.signInput(0, this.getSignerKey());

                transaction.finalizeInput(0, this.customFinalizer.bind(this));
            } else {
                await super.signInputs(transaction);
            }
        }
    }*/
    /**
     * Generate the script address (for verification purposes)
     */
    generateScriptAddress() {
        if (this.useP2MR) {
            return {
                network: this.network,
                scriptTree: this.scriptTree,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            name: PaymentType.P2TR,
        };
    }
    /**
     * Generate the tap data for spending
     */
    generateTapData() {
        const selectedRedeem = this.leftOverFundsScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        if (this.useP2MR) {
            return {
                network: this.network,
                scriptTree: this.scriptTree,
                redeem: selectedRedeem,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: this.internalPubKeyToXOnly(),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
            name: PaymentType.P2TR,
        };
    }
    /**
     * Custom finalizer for the tap script spend
     */
    customFinalizer = (_inputIndex, input) => {
        if (!this.tapLeafScript) {
            throw new Error('Tap leaf script is required');
        }
        if (!input.tapScriptSig || input.tapScriptSig.length === 0) {
            throw new Error('Tap script signature is required');
        }
        // For the simple lock script, we only need the signature
        const scriptSolution = [input.tapScriptSig[0].signature];
        const witness = scriptSolution
            .concat(this.tapLeafScript.script)
            .concat(this.tapLeafScript.controlBlock);
        return {
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
        };
    };
    async signInputs(transaction) {
        if ('multiSignPsbt' in this.signer) {
            await this.signInputsWalletBased(transaction);
        }
        else {
            await this.signInputsNonWalletBased(transaction);
        }
    }
    async signInputsWalletBased(transaction) {
        const signer = this.signer;
        // then, we sign all the remaining inputs with the wallet signer.
        await signer.multiSignPsbt([transaction]);
        // Then, we finalize every input.
        for (let i = 0; i < transaction.data.inputs.length; i++) {
            if (i === 0) {
                transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            else {
                try {
                    transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
                }
                catch (e) {
                    transaction.finalizeInput(i);
                }
            }
        }
    }
    async signInputsNonWalletBased(transaction) {
        // Input 0: always sequential (script-path with custom finalizer)
        await this.signInput(transaction, transaction.data.inputs[0], 0, this.getSignerKey());
        transaction.finalizeInput(0, this.customFinalizer.bind(this));
        // Inputs 1+: parallel key-path if available, then sequential for remaining
        let parallelSignedIndices = new Set();
        if (this.canUseParallelSigning && isUniversalSigner(this.signer)) {
            try {
                const result = await this.signKeyPathInputsParallel(transaction, new Set([0]));
                if (result.success) {
                    parallelSignedIndices = new Set(result.signatures.keys());
                }
            }
            catch (e) {
                this.error(`Parallel signing failed, falling back to sequential: ${e.message}`);
            }
        }
        for (let i = 1; i < transaction.data.inputs.length; i++) {
            if (!parallelSignedIndices.has(i)) {
                await this.signInput(transaction, transaction.data.inputs[i], i, this.signer);
            }
        }
        // Finalize inputs 1+
        for (let i = 1; i < transaction.data.inputs.length; i++) {
            try {
                transaction.finalizeInput(i, this.customFinalizerP2SH.bind(this));
            }
            catch {
                transaction.finalizeInput(i);
            }
        }
    }
    /**
     * Generate the minimal script tree needed for recovery
     * This only includes the leftover funds script
     */
    getMinimalScriptTree() {
        this.generateLeftoverFundsRedeem();
        if (!this.leftOverFundsScriptRedeem || !this.leftOverFundsScriptRedeem.output) {
            throw new Error('Failed to generate leftover funds redeem script');
        }
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: this.leftOverFundsScriptRedeem.output,
                version: 192,
            },
        ];
    }
    /**
     * Generate the leftover funds redeem script
     */
    generateLeftoverFundsRedeem() {
        // Use the same LOCK_LEAF_SCRIPT from the parent class
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.LOCK_LEAF_SCRIPT,
            redeemVersion: 192,
        };
    }
}

/**
 * Consolidated Interaction Transaction
 *
 * Drop-in replacement for InteractionTransaction that bypasses BIP110/Bitcoin Knots censorship.
 *
 * Uses the same parameters and sends the same data on-chain as InteractionTransaction,
 * but embeds data in hash-committed P2WSH witnesses instead of Tapscript.
 *
 * Data is split into 80-byte chunks (P2WSH stack item limit), with up to 14 chunks
 * batched per P2WSH output (~1,120 bytes per output). Each output's witness script
 * commits to all its chunks via HASH160. When spent, all data chunks are revealed
 * in the witness and verified at consensus level.
 *
 * Policy limits respected:
 * - MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80 bytes per chunk
 * - g_script_size_policy_limit = 1650 bytes total witness size (serialized)
 * - MAX_STANDARD_P2WSH_STACK_ITEMS = 100 items per witness
 *
 * Data integrity is consensus-enforced: if any data is stripped or modified,
 * HASH160(data) != committed_hash and the transaction is INVALID.
 *
 * Capacity: ~1.1KB per P2WSH output, ~220 outputs per reveal tx, ~242KB max.
 *
 * Usage:
 * ```typescript
 * // Same parameters as InteractionTransaction
 * const tx = new ConsolidatedInteractionTransaction({
 *     calldata: myCalldata,
 *     to: contractAddress,
 *     contract: contractSecret,
 *     challenge: myChallenge,
 *     utxos: myUtxos,
 *     signer: mySigner,
 *     network: networks.bitcoin,
 *     feeRate: 10,
 *     priorityFee: 0n,
 *     gasSatFee: 330n,
 * });
 *
 * const result = await tx.build();
 * // Broadcast setup first, then reveal (can use CPFP)
 * broadcast(result.setup.txHex);
 * broadcast(result.reveal.txHex);
 * ```
 */
class ConsolidatedInteractionTransaction extends TransactionBuilder {
    type = TransactionType.INTERACTION;
    /** Random bytes for interaction (same as InteractionTransaction) */
    randomBytes;
    /** The contract address (same as InteractionTransaction.to) */
    contractAddress;
    /** The contract secret - 32 bytes (same as InteractionTransaction) */
    contractSecret;
    /** The compressed calldata (same as InteractionTransaction) */
    calldata;
    /** Challenge solution for epoch (same as InteractionTransaction) */
    challenge;
    /** Epoch challenge P2WSH address (same as InteractionTransaction) */
    epochChallenge;
    /** Script signer for interaction (same as InteractionTransaction) */
    scriptSigner;
    /** Calldata generator - produces same output as InteractionTransaction */
    calldataGenerator;
    /** Hash commitment generator for CHCT */
    hashCommitmentGenerator;
    /** The compiled operation data - SAME as InteractionTransaction's compiledTargetScript */
    compiledTargetScript;
    /** Generated hash-committed P2WSH outputs */
    commitmentOutputs;
    /** Disable auto refund (same as InteractionTransaction) */
    disableAutoRefund;
    /** Maximum chunk size (default: 80 bytes per P2WSH stack item limit) */
    maxChunkSize;
    /** Cached value per output (calculated once, used by setup and reveal) */
    cachedValuePerOutput = null;
    constructor(parameters) {
        super(parameters);
        // Same validation as InteractionTransaction
        if (!parameters.to) {
            throw new Error('Contract address (to) is required');
        }
        if (!parameters.contract) {
            throw new Error('Contract secret (contract) is required');
        }
        if (!parameters.calldata) {
            throw new Error('Calldata is required');
        }
        if (!parameters.challenge) {
            throw new Error('Challenge solution is required');
        }
        this.contractAddress = parameters.to;
        this.contractSecret = fromHex$1(parameters.contract.startsWith('0x') ? parameters.contract.slice(2) : parameters.contract);
        this.disableAutoRefund = parameters.disableAutoRefund || false;
        this.maxChunkSize = parameters.maxChunkSize ?? HashCommitmentGenerator.MAX_CHUNK_SIZE;
        // Validate contract secret (same as InteractionTransaction)
        if (this.contractSecret.length !== 32) {
            throw new Error('Invalid contract secret length. Expected 32 bytes.');
        }
        // Compress calldata (same as SharedInteractionTransaction)
        this.calldata = Compressor.compress(parameters.calldata);
        // Generate random bytes and script signer (same as SharedInteractionTransaction)
        this.randomBytes = parameters.randomBytes || BitcoinUtils.rndBytes();
        this.scriptSigner = EcKeyPair.fromSeedKeyPair(this.randomBytes, this.network);
        // Generate epoch challenge address (same as SharedInteractionTransaction)
        this.challenge = parameters.challenge;
        this.epochChallenge = TimeLockGenerator.generateTimeLockAddress(this.challenge.publicKey.originalPublicKeyBuffer(), this.network);
        // Create calldata generator (same as SharedInteractionTransaction)
        this.calldataGenerator = new CalldataGenerator(this.signer.publicKey, toXOnly(this.scriptSigner.publicKey), this.network);
        // Compile the target script - SAME as InteractionTransaction
        if (parameters.compiledTargetScript) {
            if (parameters.compiledTargetScript instanceof Uint8Array) {
                this.compiledTargetScript = parameters.compiledTargetScript;
            }
            else if (typeof parameters.compiledTargetScript === 'string') {
                this.compiledTargetScript = fromHex$1(parameters.compiledTargetScript);
            }
            else {
                throw new Error('Invalid compiled target script format.');
            }
        }
        else {
            this.compiledTargetScript = this.calldataGenerator.compile(this.calldata, this.contractSecret, this.challenge, this.priorityFee, this.generateFeatures(parameters));
        }
        // Create hash commitment generator
        this.hashCommitmentGenerator = new HashCommitmentGenerator(this.signer.publicKey, this.network);
        // Split compiled data into hash-committed chunks
        this.commitmentOutputs = this.hashCommitmentGenerator.prepareChunks(this.compiledTargetScript, this.maxChunkSize);
        // Validate output count
        this.validateOutputCount();
        const totalChunks = this.commitmentOutputs.reduce((sum, output) => sum + output.dataChunks.length, 0);
        this.log(`ConsolidatedInteractionTransaction: ${this.commitmentOutputs.length} outputs, ` +
            `${totalChunks} chunks from ${this.compiledTargetScript.length} bytes compiled data`);
        this.internalInit();
    }
    /**
     * Get the compiled target script (same as InteractionTransaction).
     */
    exportCompiledTargetScript() {
        return this.compiledTargetScript;
    }
    /**
     * Get the contract secret (same as InteractionTransaction).
     */
    getContractSecret() {
        return this.contractSecret;
    }
    /**
     * Get the random bytes (same as InteractionTransaction).
     */
    getRndBytes() {
        return this.randomBytes;
    }
    /**
     * Get the challenge solution (same as InteractionTransaction).
     */
    getChallenge() {
        return this.challenge;
    }
    /**
     * Get the commitment outputs for the setup transaction.
     */
    getCommitmentOutputs() {
        return this.commitmentOutputs;
    }
    /**
     * Get the number of P2WSH outputs.
     */
    getOutputCount() {
        return this.commitmentOutputs.length;
    }
    /**
     * Get the total number of 80-byte chunks across all outputs.
     */
    getTotalChunkCount() {
        return this.commitmentOutputs.reduce((sum, output) => sum + output.dataChunks.length, 0);
    }
    /**
     * Build both setup and reveal transactions.
     *
     * @returns Complete result with both transactions
     */
    async build() {
        // Build and sign setup transaction using base class flow
        const setupTx = await this.signTransaction();
        const setupTxId = setupTx.getId();
        const setup = {
            txHex: setupTx.toHex(),
            txId: setupTxId,
            outputs: this.commitmentOutputs,
            feesPaid: this.transactionFee,
            chunkCount: this.getTotalChunkCount(),
            totalDataSize: this.compiledTargetScript.length,
        };
        this.log(`Setup transaction: ${setup.txId}`);
        // Build reveal transaction
        const reveal = this.buildRevealTransaction(setupTxId);
        return {
            setup,
            reveal,
            totalFees: setup.feesPaid + reveal.feesPaid,
        };
    }
    /**
     * Build the reveal transaction.
     * Spends the P2WSH commitment outputs, revealing the compiled data in witnesses.
     *
     * Output structure matches InteractionTransaction:
     * - Output to epochChallenge.address (miner reward)
     * - Change output (if any)
     *
     * @param setupTxId The transaction ID of the setup transaction
     */
    buildRevealTransaction(setupTxId) {
        const revealPsbt = new Psbt({ network: this.network });
        // Get the value per output (same as used in setup transaction)
        const valuePerOutput = this.calculateValuePerOutput();
        // Add commitment outputs as inputs (from setup tx)
        for (let i = 0; i < this.commitmentOutputs.length; i++) {
            const commitment = this.commitmentOutputs[i];
            revealPsbt.addInput({
                hash: setupTxId,
                index: i,
                witnessUtxo: {
                    script: commitment.scriptPubKey,
                    value: toSatoshi(valuePerOutput),
                },
                witnessScript: commitment.witnessScript,
            });
        }
        // Calculate input value from commitments
        const inputValue = BigInt(this.commitmentOutputs.length) * valuePerOutput;
        // Calculate OPNet fee (same as InteractionTransaction)
        const opnetFee = this.getTransactionOPNetFee();
        const feeAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
        // Add output to epoch challenge address (same as InteractionTransaction)
        revealPsbt.addOutput({
            address: this.epochChallenge.address,
            value: toSatoshi(feeAmount),
        });
        // Estimate reveal transaction fee
        const estimatedVBytes = this.estimateRevealVBytes();
        const revealFee = BigInt(Math.ceil(estimatedVBytes * this.feeRate));
        // Add change output if there's enough left
        const changeValue = inputValue - feeAmount - revealFee;
        if (changeValue > TransactionBuilder.MINIMUM_DUST) {
            const refundAddress = this.getRefundAddress();
            revealPsbt.addOutput({
                address: refundAddress,
                value: toSatoshi(changeValue),
            });
        }
        // Sign all commitment inputs
        for (let i = 0; i < this.commitmentOutputs.length; i++) {
            revealPsbt.signInput(i, this.signer);
        }
        // Finalize all inputs with hash-commitment finalizer
        for (let i = 0; i < this.commitmentOutputs.length; i++) {
            const commitment = this.commitmentOutputs[i];
            revealPsbt.finalizeInput(i, (_inputIndex, input) => {
                return this.finalizeCommitmentInput(input, commitment);
            });
        }
        const revealTx = revealPsbt.extractTransaction();
        const result = {
            txHex: revealTx.toHex(),
            txId: revealTx.getId(),
            dataSize: this.compiledTargetScript.length,
            feesPaid: revealFee,
            inputCount: this.commitmentOutputs.length,
        };
        this.log(`Reveal transaction: ${result.txId}`);
        return result;
    }
    /**
     * Get the value per commitment output (for external access).
     */
    getValuePerOutput() {
        return this.calculateValuePerOutput();
    }
    /**
     * Build the setup transaction.
     * Creates P2WSH outputs with hash commitments to the compiled data chunks.
     * This is called by signTransaction() in the base class.
     */
    async buildTransaction() {
        // Add funding UTXOs as inputs
        this.addInputsFromUTXO();
        // Calculate value per output (includes reveal fee + OPNet fee)
        const valuePerOutput = this.calculateValuePerOutput();
        // Add each hash-committed P2WSH as an output
        for (const commitment of this.commitmentOutputs) {
            this.addOutput({
                value: toSatoshi(valuePerOutput),
                address: commitment.address,
            });
        }
        // Calculate total spent on commitment outputs
        const totalCommitmentValue = BigInt(this.commitmentOutputs.length) * valuePerOutput;
        // Add optional outputs
        const optionalAmount = this.addOptionalOutputsAndGetAmount();
        // Add refund/change output
        await this.addRefundOutput(totalCommitmentValue + optionalAmount);
    }
    /**
     * Finalize a commitment input.
     *
     * Witness stack: [signature, data_1, data_2, ..., data_N, witnessScript]
     *
     * The witness script verifies each data chunk against its committed hash.
     * If any data is wrong or missing, the transaction is INVALID at consensus level.
     */
    finalizeCommitmentInput(input, commitment) {
        if (!input.partialSig || input.partialSig.length === 0) {
            throw new Error('No signature for commitment input');
        }
        if (!input.witnessScript) {
            throw new Error('No witness script for commitment input');
        }
        // Witness stack for hash-committed P2WSH with multiple chunks
        // Order: [signature, data_1, data_2, ..., data_N, witnessScript]
        const witnessStack = [
            input.partialSig[0].signature, // Signature for OP_CHECKSIG
            ...commitment.dataChunks, // All data chunks for OP_HASH160 verification
            input.witnessScript, // The witness script
        ];
        return {
            finalScriptSig: undefined,
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witnessStack),
        };
    }
    /**
     * Estimate reveal transaction vBytes.
     */
    estimateRevealVBytes() {
        // Calculate actual witness weight based on chunks per output
        let witnessWeight = 0;
        for (const commitment of this.commitmentOutputs) {
            // Per input: 41 bytes base (Ã— 4) + witness data
            // Witness: signature (~72) + chunks (N Ã— 80) + script (N Ã— 23 + 35) + overhead (~20)
            const numChunks = commitment.dataChunks.length;
            const chunkDataWeight = numChunks * 80; // actual data
            const scriptWeight = numChunks * 23 + 35; // witness script
            const sigWeight = 72;
            const overheadWeight = 20;
            witnessWeight += 164 + chunkDataWeight + scriptWeight + sigWeight + overheadWeight;
        }
        const weight = 40 + witnessWeight + 200; // tx overhead + witnesses + outputs
        return Math.ceil(weight / 4);
    }
    /**
     * Calculate the required value per commitment output.
     * This must cover: dust minimum + share of reveal fee + share of OPNet fee
     */
    calculateValuePerOutput() {
        // Return cached value if already calculated
        if (this.cachedValuePerOutput !== null) {
            return this.cachedValuePerOutput;
        }
        const numOutputs = this.commitmentOutputs.length;
        // Calculate OPNet fee
        const opnetFee = this.getTransactionOPNetFee();
        const feeAmount = opnetFee < MINIMUM_AMOUNT_REWARD ? MINIMUM_AMOUNT_REWARD : opnetFee;
        // Calculate reveal fee
        const estimatedVBytes = this.estimateRevealVBytes();
        const revealFee = BigInt(Math.ceil(estimatedVBytes * this.feeRate));
        // Total needed: OPNet fee + reveal fee + dust for change
        const totalNeeded = feeAmount + revealFee + TransactionBuilder.MINIMUM_DUST;
        // Distribute across outputs, ensuring at least MIN_OUTPUT_VALUE per output
        const valuePerOutput = BigInt(Math.ceil(Number(totalNeeded) / numOutputs));
        const minValue = HashCommitmentGenerator.MIN_OUTPUT_VALUE;
        this.cachedValuePerOutput = valuePerOutput > minValue ? valuePerOutput : minValue;
        return this.cachedValuePerOutput;
    }
    /**
     * Get refund address.
     */
    getRefundAddress() {
        if (this.from) {
            return this.from;
        }
        return AddressGenerator.generatePKSH(this.signer.publicKey, this.network);
    }
    /**
     * Generate features (same as InteractionTransaction).
     */
    generateFeatures(parameters) {
        const features = [];
        if (parameters.loadedStorage) {
            features.push({
                priority: FeaturePriority.ACCESS_LIST,
                opcode: Features.ACCESS_LIST,
                data: parameters.loadedStorage,
            });
        }
        const submission = parameters.challenge.getSubmission();
        if (submission) {
            features.push({
                priority: FeaturePriority.EPOCH_SUBMISSION,
                opcode: Features.EPOCH_SUBMISSION,
                data: submission,
            });
        }
        if (parameters.revealMLDSAPublicKey && !parameters.linkMLDSAPublicKeyToAddress) {
            throw new Error('To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true.');
        }
        if (parameters.linkMLDSAPublicKeyToAddress) {
            this.generateMLDSALinkRequest(parameters, features);
        }
        return features;
    }
    /**
     * Validate output count is within standard tx limits.
     */
    validateOutputCount() {
        const maxInputs = HashCommitmentGenerator.calculateMaxInputsPerTx();
        if (this.commitmentOutputs.length > maxInputs) {
            const maxData = HashCommitmentGenerator.calculateMaxDataPerTx();
            throw new Error(`Data too large: ${this.commitmentOutputs.length} P2WSH outputs needed, ` +
                `max ${maxInputs} per standard transaction (~${Math.floor(maxData / 1024)}KB). ` +
                `Compiled data: ${this.compiledTargetScript.length} bytes.`);
        }
    }
}

class TransactionFactory {
    debug = false;
    DUMMY_PUBKEY = new Uint8Array(32).fill(1);
    P2TR_SCRIPT = Uint8Array.from([0x51, 0x20, ...this.DUMMY_PUBKEY]);
    INITIAL_FUNDING_ESTIMATE = 2000n;
    MAX_ITERATIONS = 10;
    /**
     * @description Creates a cancellable transaction.
     * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} params - The cancel transaction parameters
     * @returns {Promise<CancelledTransaction>} - The cancelled transaction result
     */
    async createCancellableTransaction(params) {
        if (!params.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!params.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!params.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        const opWalletCancel = await this.detectCancelOPWallet(params);
        if (opWalletCancel) {
            return opWalletCancel;
        }
        if (!('signer' in params)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const cancel = new CancelTransaction(params);
        const signed = await cancel.signTransaction();
        const rawTx = signed.toHex();
        return {
            transaction: rawTx,
            nextUTXOs: this.getUTXOAsTransaction(signed, params.from, 0),
            inputUtxos: params.utxos,
        };
    }
    /**
     * @description Generate a transaction with a custom script.
     * @param {ICustomTransactionParameters | ICustomTransactionWithoutSigner} interactionParameters - The custom transaction parameters
     * @returns {Promise<[string, string, UTXO[], UTXO[]]>} - The signed transaction tuple [fundingTx, customTx, nextUTXOs, inputUtxos]
     */
    async createCustomScriptTransaction(interactionParameters) {
        if (!interactionParameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!interactionParameters.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const { finalTransaction, estimatedAmount } = await this.iterateFundingAmount({ ...interactionParameters, optionalInputs: inputs }, CustomScriptTransaction, async (tx) => {
            const fee = await tx.estimateTransactionFees();
            const priorityFee = this.getPriorityFee(interactionParameters);
            const optionalValue = tx.getOptionalOutputValue();
            return fee + priorityFee + optionalValue;
        }, 'CustomScript');
        const parameters = await finalTransaction.getFundingTransactionParameters();
        parameters.utxos = interactionParameters.utxos;
        parameters.amount = estimatedAmount;
        const feeEstimationFunding = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!feeEstimationFunding) {
            throw new Error('Could not sign funding transaction.');
        }
        parameters.estimatedFees = feeEstimationFunding.estimatedFees;
        const signedTransaction = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        const newParams = {
            ...interactionParameters,
            utxos: this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.to, 0),
            randomBytes: finalTransaction.getRndBytes(),
            nonWitnessUtxo: signedTransaction.tx.toBuffer(),
            estimatedFees: finalTransaction.estimatedFees,
            compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
            optionalInputs: inputs,
        };
        const customTransaction = new CustomScriptTransaction(newParams);
        const outTx = await customTransaction.signTransaction();
        return [
            signedTransaction.tx.toHex(),
            outTx.toHex(),
            this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.from, 1),
            interactionParameters.utxos,
        ];
    }
    /**
     * @description Generates the required transactions.
     * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
     * @returns {Promise<InteractionResponse>} - The signed transaction
     */
    async signInteraction(interactionParameters) {
        if (!interactionParameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!interactionParameters.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        const opWalletInteraction = await this.detectInteractionOPWallet(interactionParameters);
        if (opWalletInteraction) {
            return opWalletInteraction;
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const useP2WDA = this.hasP2WDAInputs(interactionParameters.utxos);
        if (useP2WDA) {
            return this.signP2WDAInteraction(interactionParameters);
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...interactionParameters, optionalInputs: inputs }, InteractionTransaction, async (tx) => {
            const fee = await tx.estimateTransactionFees();
            const outputsValue = tx.getTotalOutputValue();
            const total = fee + outputsValue;
            if (interactionParameters.subtractExtraUTXOFromAmountRequired &&
                interactionParameters.optionalInputs &&
                interactionParameters.optionalInputs.length > 0) {
                const optionalInputValue = interactionParameters.optionalInputs.reduce((sum, input) => sum + input.value, 0n);
                return total > optionalInputValue ? total - optionalInputValue : 0n;
            }
            return total;
        }, 'Interaction');
        if (!challenge) {
            throw new Error('Failed to get challenge from interaction transaction');
        }
        const parameters = await finalTransaction.getFundingTransactionParameters();
        parameters.utxos = interactionParameters.utxos;
        parameters.amount = estimatedAmount;
        const feeEstimationFunding = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!feeEstimationFunding) {
            throw new Error('Could not sign funding transaction.');
        }
        parameters.estimatedFees = feeEstimationFunding.estimatedFees;
        const signedTransaction = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        const fundingUTXO = this.getUTXOAsTransaction(signedTransaction.tx, finalTransaction.getScriptAddress(), 0);
        const newParams = {
            ...interactionParameters,
            utxos: fundingUTXO,
            randomBytes: finalTransaction.getRndBytes(),
            challenge: challenge,
            compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
            nonWitnessUtxo: signedTransaction.tx.toBuffer(),
            estimatedFees: finalTransaction.estimatedFees,
            optionalInputs: inputs,
        };
        const interactionTx = new InteractionTransaction(newParams);
        const outTx = await interactionTx.signTransaction();
        return {
            interactionAddress: finalTransaction.getScriptAddress(),
            fundingTransaction: signedTransaction.tx.toHex(),
            interactionTransaction: outTx.toHex(),
            estimatedFees: interactionTx.transactionFee,
            nextUTXOs: this.getUTXOAsTransaction(signedTransaction.tx, interactionParameters.from, 1),
            challenge: challenge.toRaw(),
            fundingUTXOs: fundingUTXO,
            fundingInputUtxos: interactionParameters.utxos,
            compiledTargetScript: toHex$1(interactionTx.exportCompiledTargetScript()),
        };
    }
    /**
     * @description Generates a consolidated interaction transaction (CHCT system).
     *
     * Drop-in replacement for signInteraction that bypasses BIP110/Bitcoin Knots censorship.
     * Uses P2WSH with HASH160 commitments instead of Tapscript (which uses OP_IF and gets censored).
     *
     * Returns two transactions:
     * - Setup: Creates P2WSH outputs with hash commitments to data chunks
     * - Reveal: Spends those outputs, revealing data in witnesses
     *
     * Data integrity is consensus-enforced - if data is stripped/modified,
     * HASH160(data) != committed_hash and the transaction is INVALID.
     *
     * @param {IConsolidatedInteractionParameters} interactionParameters - Same parameters as signInteraction
     * @returns {Promise<ConsolidatedInteractionResponse>} - Both setup and reveal transactions
     */
    async signConsolidatedInteraction(interactionParameters) {
        if (!interactionParameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!interactionParameters.utxos[0]) {
            throw new Error('Missing at least one UTXO.');
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('Field "signer" not provided.');
        }
        if (!interactionParameters.challenge) {
            throw new Error('Field "challenge" not provided.');
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const consolidatedTx = new ConsolidatedInteractionTransaction({
            ...interactionParameters,
            optionalInputs: inputs,
        });
        const result = await consolidatedTx.build();
        return {
            setupTransaction: result.setup.txHex,
            revealTransaction: result.reveal.txHex,
            setupTxId: result.setup.txId,
            revealTxId: result.reveal.txId,
            totalFees: result.totalFees,
            chunkCount: result.setup.chunkCount,
            dataSize: result.setup.totalDataSize,
            challenge: consolidatedTx.getChallenge().toRaw(),
            inputUtxos: interactionParameters.utxos,
            compiledTargetScript: toHex$1(consolidatedTx.exportCompiledTargetScript()),
        };
    }
    /**
     * @description Generates the required transactions.
     * @param {IDeploymentParameters} deploymentParameters - The deployment parameters
     * @returns {Promise<DeploymentResult>} - The signed transaction
     */
    async signDeployment(deploymentParameters) {
        const opWalletDeployment = await this.detectDeploymentOPWallet(deploymentParameters);
        if (opWalletDeployment) {
            return opWalletDeployment;
        }
        if (!('signer' in deploymentParameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const inputs = this.parseOptionalInputs(deploymentParameters.optionalInputs);
        const { finalTransaction, estimatedAmount, challenge } = await this.iterateFundingAmount({ ...deploymentParameters, optionalInputs: inputs }, DeploymentTransaction, async (tx) => {
            const fee = await tx.estimateTransactionFees();
            const priorityFee = this.getPriorityFee(deploymentParameters);
            const optionalValue = tx.getOptionalOutputValue();
            return fee + priorityFee + optionalValue;
        }, 'Deployment');
        if (!challenge) {
            throw new Error('Failed to get challenge from deployment transaction');
        }
        const parameters = await finalTransaction.getFundingTransactionParameters();
        parameters.utxos = deploymentParameters.utxos;
        parameters.amount = estimatedAmount;
        const feeEstimationFunding = await this.createFundTransaction({
            ...parameters,
            optionalOutputs: [],
            optionalInputs: [],
        });
        if (!feeEstimationFunding) {
            throw new Error('Could not sign funding transaction.');
        }
        parameters.estimatedFees = feeEstimationFunding.estimatedFees;
        const fundingTransaction = new FundingTransaction({
            ...parameters,
            optionalInputs: [],
            optionalOutputs: [],
        });
        const signedTransaction = await fundingTransaction.signTransaction();
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        const out = signedTransaction.outs[0];
        const newUtxo = {
            transactionId: signedTransaction.getId(),
            outputIndex: 0,
            scriptPubKey: {
                hex: toHex$1(out.script),
                address: finalTransaction.getScriptAddress(),
            },
            value: BigInt(out.value),
        };
        const newParams = {
            ...deploymentParameters,
            utxos: [newUtxo],
            randomBytes: finalTransaction.getRndBytes(),
            compiledTargetScript: finalTransaction.exportCompiledTargetScript(),
            challenge: challenge,
            nonWitnessUtxo: signedTransaction.toBuffer(),
            estimatedFees: finalTransaction.estimatedFees,
            optionalInputs: inputs,
        };
        const deploymentTx = new DeploymentTransaction(newParams);
        const outTx = await deploymentTx.signTransaction();
        const out2 = signedTransaction.outs[1];
        const refundUTXO = {
            transactionId: signedTransaction.getId(),
            outputIndex: 1,
            scriptPubKey: {
                hex: toHex$1(out2.script),
                address: deploymentParameters.from,
            },
            value: BigInt(out2.value),
        };
        return {
            transaction: [signedTransaction.toHex(), outTx.toHex()],
            contractAddress: deploymentTx.getContractAddress(),
            contractPubKey: deploymentTx.contractPubKey,
            utxos: [refundUTXO],
            challenge: challenge.toRaw(),
            inputUtxos: deploymentParameters.utxos,
        };
    }
    /**
     * @description Creates a funding transaction.
     * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
     * @returns {Promise<BitcoinTransferBase>} - The signed transaction
     */
    async createBTCTransfer(parameters) {
        if (!parameters.to) {
            throw new Error('Field "to" not provided.');
        }
        if (!parameters.from) {
            throw new Error('Field "from" not provided.');
        }
        const opWalletInteraction = await this.detectFundingOPWallet(parameters);
        if (opWalletInteraction) {
            return opWalletInteraction;
        }
        if (!('signer' in parameters)) {
            throw new Error('Field "signer" not provided, OP_WALLET not detected.');
        }
        const resp = await this.createFundTransaction(parameters);
        return {
            estimatedFees: resp.estimatedFees,
            tx: resp.tx.toHex(),
            nextUTXOs: this.getAllNewUTXOs(resp.original, resp.tx, parameters.from),
            inputUtxos: parameters.utxos,
        };
    }
    /**
     * Get all new UTXOs of a generated transaction.
     * @param {TransactionBuilder<TransactionType>} original - The original transaction
     * @param {Transaction} tx - The transaction
     * @param {string} to - The address to filter
     * @returns {UTXO[]} - The new UTXOs belonging to the specified address
     */
    getAllNewUTXOs(original, tx, to) {
        const outputs = original.getOutputs();
        const utxos = [];
        for (let i = 0; i < tx.outs.length; i++) {
            const output = outputs[i];
            if ('address' in output) {
                if (output.address !== to)
                    continue;
            }
            else {
                continue;
            }
            utxos.push(...this.getUTXOAsTransaction(tx, to, i));
        }
        return utxos;
    }
    /**
     * Parse optional inputs and normalize nonWitnessUtxo format.
     * @param {UTXO[]} optionalInputs - The optional inputs to parse
     * @returns {UTXO[]} - The parsed inputs with normalized nonWitnessUtxo
     */
    parseOptionalInputs(optionalInputs) {
        return (optionalInputs || []).map((input) => {
            let nonWitness = input.nonWitnessUtxo;
            if (nonWitness &&
                !(nonWitness instanceof Uint8Array) &&
                typeof nonWitness === 'object') {
                nonWitness = Uint8Array.from(Object.values(nonWitness));
            }
            return {
                ...input,
                nonWitnessUtxo: nonWitness,
            };
        });
    }
    /**
     * Detect and use OP_WALLET for funding transactions if available.
     *
     * @param {IFundingTransactionParameters | IFundingTransactionParametersWithoutSigner} fundingParams - The funding transaction parameters
     * @return {Promise<BitcoinTransferBase | null>} - The funding transaction response or null if OP_WALLET not available
     */
    async detectFundingOPWallet(fundingParams) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const result = await opnet.sendBitcoin({
            ...fundingParams,
            // @ts-expect-error signer is stripped by the wallet
            signer: undefined,
        });
        if (!result) {
            throw new Error('Could not sign funding transaction.');
        }
        return {
            ...result,
            inputUtxos: result.inputUtxos ?? fundingParams.utxos,
        };
    }
    /**
     * Detect and use OP_WALLET for cancel transactions if available.
     * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} interactionParameters - The cancel parameters
     * @returns {Promise<CancelledTransaction | null>} - The cancelled transaction or null if OP_WALLET not available
     */
    async detectCancelOPWallet(interactionParameters) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const interaction = await opnet.cancelTransaction({
            ...interactionParameters,
            // @ts-expect-error no, this is ok
            signer: undefined,
        });
        if (!interaction) {
            throw new Error('Could not sign interaction transaction.');
        }
        return {
            ...interaction,
            inputUtxos: interaction.inputUtxos ?? interactionParameters.utxos,
        };
    }
    /**
     * Detect and use OP_WALLET for interaction transactions if available.
     * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
     * @returns {Promise<InteractionResponse | null>} - The interaction response or null if OP_WALLET not available
     */
    async detectInteractionOPWallet(interactionParameters) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const interaction = await opnet.signInteraction({
            ...interactionParameters,
            // @ts-expect-error no, this is ok
            signer: undefined,
        });
        if (!interaction) {
            throw new Error('Could not sign interaction transaction.');
        }
        return {
            ...interaction,
            fundingInputUtxos: interaction.fundingInputUtxos ?? interactionParameters.utxos,
        };
    }
    /**
     * Detect and use OP_WALLET for deployment transactions if available.
     * @param {IDeploymentParameters | IDeploymentParametersWithoutSigner} deploymentParameters - The deployment parameters
     * @returns {Promise<DeploymentResult | null>} - The deployment result or null if OP_WALLET not available
     */
    async detectDeploymentOPWallet(deploymentParameters) {
        if (typeof window === 'undefined') {
            return null;
        }
        const _window = window;
        if (!_window || !_window.opnet || !_window.opnet.web3) {
            return null;
        }
        const opnet = _window.opnet.web3;
        const deployment = await opnet.deployContract({
            ...deploymentParameters,
            // @ts-expect-error no, this is ok
            signer: undefined,
        });
        if (!deployment) {
            throw new Error('Could not sign interaction transaction.');
        }
        return {
            ...deployment,
            inputUtxos: deployment.inputUtxos ?? deploymentParameters.utxos,
        };
    }
    /**
     * Create and sign a funding transaction.
     * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
     * @returns {Promise<FundingTransactionResponse>} - The funding transaction response
     */
    async createFundTransaction(parameters) {
        if (!parameters.to)
            throw new Error('Field "to" not provided.');
        const fundingTransaction = new FundingTransaction(parameters);
        const signedTransaction = await fundingTransaction.signTransaction();
        if (!signedTransaction) {
            throw new Error('Could not sign funding transaction.');
        }
        return {
            tx: signedTransaction,
            original: fundingTransaction,
            estimatedFees: fundingTransaction.estimatedFees,
            nextUTXOs: this.getUTXOAsTransaction(signedTransaction, parameters.to, 0),
            inputUtxos: parameters.utxos,
        };
    }
    /**
     * Check if the UTXOs contain any P2WDA inputs
     *
     * This method examines both main UTXOs and optional inputs to determine
     * if any of them are P2WDA addresses. P2WDA detection is based on the
     * witness script pattern: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
     *
     * @param {UTXO[]} utxos - The main UTXOs to check
     * @returns {boolean} - true if any UTXO is P2WDA, false otherwise
     */
    hasP2WDAInputs(utxos) {
        return utxos.some((utxo) => P2WDADetector.isP2WDAUTXO(utxo));
    }
    /**
     * Sign a P2WDA interaction transaction
     *
     * P2WDA interactions are fundamentally different from standard OP_NET interactions.
     * Instead of using a two-transaction model (funding + interaction), P2WDA embeds
     * the operation data directly in the witness field of a single transaction.
     * This achieves significant cost savings through the witness discount.
     *
     * Key differences:
     * - Single transaction instead of two
     * - Operation data in witness field instead of taproot script
     * - 75% cost reduction for data storage
     * - No separate funding transaction needed
     *
     * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
     * @returns {Promise<InteractionResponse>} - The signed P2WDA interaction response
     */
    async signP2WDAInteraction(interactionParameters) {
        if (!interactionParameters.from) {
            throw new Error('Field "from" not provided.');
        }
        if (!('signer' in interactionParameters)) {
            throw new Error('P2WDA interactions require a signer. OP_WALLET is not supported for P2WDA.');
        }
        const inputs = this.parseOptionalInputs(interactionParameters.optionalInputs);
        const p2wdaTransaction = new InteractionTransactionP2WDA({
            ...interactionParameters,
            optionalInputs: inputs,
        });
        const signedTx = await p2wdaTransaction.signTransaction();
        const txHex = signedTx.toHex();
        return {
            interactionAddress: null,
            fundingTransaction: null,
            interactionTransaction: txHex,
            estimatedFees: p2wdaTransaction.estimatedFees,
            nextUTXOs: this.getUTXOAsTransaction(signedTx, interactionParameters.from, signedTx.outs.length - 1),
            fundingUTXOs: [...interactionParameters.utxos, ...inputs],
            fundingInputUtxos: interactionParameters.utxos,
            challenge: interactionParameters.challenge.toRaw(),
            compiledTargetScript: null,
        };
    }
    /**
     * Get the priority fee from transaction parameters.
     * @param {ITransactionParameters} params - The transaction parameters
     * @returns {bigint} - The priority fee, minimum dust if below threshold
     */
    getPriorityFee(params) {
        const totalFee = params.priorityFee + params.gasSatFee;
        if (totalFee < TransactionBuilder.MINIMUM_DUST) {
            return TransactionBuilder.MINIMUM_DUST;
        }
        return totalFee;
    }
    /**
     * Common iteration logic for finding the correct funding amount.
     *
     * This method iteratively estimates the required funding amount by simulating
     * transactions until the amount converges or max iterations is reached.
     *
     * @param {P extends IInteractionParameters | IDeploymentParameters | ICustomTransactionParameters} params - The transaction parameters
     * @param {new (params: P) => T} TransactionClass - The transaction class constructor
     * @param {(tx: T extends InteractionTransaction | DeploymentTransaction | CustomScriptTransaction) => Promise<bigint>} calculateAmount - Function to calculate required amount
     * @param {string} debugPrefix - Prefix for debug logging
     * @returns {Promise<{finalTransaction: T extends InteractionTransaction | DeploymentTransaction | CustomScriptTransaction, estimatedAmount: bigint, challenge: IChallengeSolution | null}>} - The final transaction and estimated amount
     */
    async iterateFundingAmount(params, TransactionClass, calculateAmount, debugPrefix) {
        const randomBytes = 'randomBytes' in params
            ? (params.randomBytes ?? BitcoinUtils.rndBytes())
            : BitcoinUtils.rndBytes();
        const dummyAddress = Address.dead().p2tr(params.network);
        let estimatedFundingAmount = this.INITIAL_FUNDING_ESTIMATE;
        let previousAmount = 0n;
        let iterations = 0;
        let finalPreTransaction = null;
        let challenge = null;
        while (iterations < this.MAX_ITERATIONS && estimatedFundingAmount !== previousAmount) {
            previousAmount = estimatedFundingAmount;
            const dummyTx = new Transaction();
            dummyTx.addOutput(this.P2TR_SCRIPT, toSatoshi(estimatedFundingAmount));
            const simulatedFundedUtxo = {
                transactionId: toHex$1(new Uint8Array(32)),
                outputIndex: 0,
                scriptPubKey: {
                    hex: toHex$1(this.P2TR_SCRIPT),
                    address: dummyAddress,
                },
                value: estimatedFundingAmount,
                nonWitnessUtxo: dummyTx.toBuffer(),
            };
            let txParams;
            if ('challenge' in params && params.challenge) {
                const withChallenge = {
                    ...params,
                    utxos: [simulatedFundedUtxo],
                    randomBytes: randomBytes,
                    challenge: challenge ?? params.challenge,
                };
                txParams = withChallenge;
            }
            else {
                const withoutChallenge = {
                    ...params,
                    utxos: [simulatedFundedUtxo],
                    randomBytes: randomBytes,
                };
                txParams = withoutChallenge;
            }
            const preTransaction = new TransactionClass(txParams);
            try {
                await preTransaction.generateTransactionMinimalSignatures();
                estimatedFundingAmount = await calculateAmount(preTransaction);
            }
            catch (error) {
                if (error instanceof Error) {
                    const match = error.message.match(/need (\d+) sats but only have (\d+) sats/);
                    if (match) {
                        estimatedFundingAmount = BigInt(match[1]);
                        if (this.debug) {
                            console.log(`${debugPrefix}: Caught insufficient funds, updating to ${estimatedFundingAmount}`);
                        }
                    }
                    else {
                        throw error;
                    }
                }
                else {
                    throw new Error('Unknown error during fee estimation', { cause: error });
                }
            }
            finalPreTransaction = preTransaction;
            if ('getChallenge' in preTransaction &&
                typeof preTransaction.getChallenge === 'function') {
                challenge = preTransaction.getChallenge();
            }
            iterations++;
            if (this.debug) {
                console.log(`${debugPrefix} Iteration ${iterations}: Previous=${previousAmount}, New=${estimatedFundingAmount}`);
            }
        }
        if (!finalPreTransaction) {
            throw new Error(`Failed to converge on ${debugPrefix} funding amount`);
        }
        return {
            finalTransaction: finalPreTransaction,
            estimatedAmount: estimatedFundingAmount,
            challenge,
        };
    }
    /**
     * Convert a transaction output to a UTXO.
     * @param {Transaction} tx - The transaction
     * @param {string} to - The address
     * @param {number} index - The output index
     * @returns {UTXO[]} - The UTXO array (empty if output doesn't exist)
     */
    getUTXOAsTransaction(tx, to, index) {
        if (!tx.outs[index])
            return [];
        const out = tx.outs[index];
        const newUtxo = {
            transactionId: tx.getId(),
            outputIndex: index,
            scriptPubKey: {
                hex: toHex$1(out.script),
                address: to,
            },
            value: BigInt(out.value),
        };
        return [newUtxo];
    }
}

/**
 * Create a multi sign p2tr transaction
 * @class MultiSignTransaction
 */
class MultiSignTransaction extends TransactionBuilder {
    static LOCK_LEAF_SCRIPT = compile([
        opcodes.OP_XOR,
        opcodes.OP_NOP,
        opcodes.OP_CODESEPARATOR,
    ]);
    static signHashTypesArray = [
    //Transaction.SIGHASH_ALL,
    //Transaction.SIGHASH_ANYONECANPAY,
    ];
    static numsPoint = fromHex$1('50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0');
    type = TransactionType.MULTI_SIG;
    targetScriptRedeem = null;
    leftOverFundsScriptRedeem = null;
    compiledTargetScript;
    scriptTree;
    publicKeys;
    minimumSignatures;
    originalInputCount = 0;
    requestedAmount;
    receiver;
    refundVault;
    /**
     * @description Sign hash types
     * @protected
     */
    sighashTypes = MultiSignTransaction.signHashTypesArray;
    constructor(parameters) {
        if (!parameters.refundVault) {
            throw new Error('Refund vault is required');
        }
        if (!parameters.requestedAmount) {
            throw new Error('Requested amount is required');
        }
        if (!parameters.receiver) {
            throw new Error('Receiver is required');
        }
        super({
            ...parameters,
            signer: EcKeyPair.fromPrivateKey(sha256$1(new TextEncoder().encode('aaaaaaaa'))),
            priorityFee: 0n,
            gasSatFee: 0n,
        });
        if (!parameters.pubkeys) {
            throw new Error('Pubkeys are required');
        }
        if (parameters.psbt) {
            this.log(`Using provided PSBT.`);
            this.transaction = parameters.psbt;
            this.originalInputCount = this.transaction.data.inputs.length;
        }
        this.refundVault = parameters.refundVault;
        this.requestedAmount = parameters.requestedAmount;
        this.receiver = parameters.receiver;
        this.publicKeys = parameters.pubkeys;
        this.minimumSignatures = parameters.minimumSignatures;
        this.compiledTargetScript = MultiSignGenerator.compile(parameters.pubkeys, this.minimumSignatures);
        this.scriptTree = this.getScriptTree();
        this.internalInit();
    }
    /**
     * Generate a multisig transaction from a base64 psbt.
     * @param {MultiSignFromBase64Params} params The parameters
     * @returns {MultiSignTransaction} The multisig transaction
     */
    static fromBase64(params) {
        const psbt = Psbt.fromBase64(params.psbt, { network: params.network });
        return new MultiSignTransaction({
            ...params,
            psbt,
        });
    }
    /**
     * Verify if that public key already signed the transaction
     * @param {Psbt} psbt The psbt
     * @param {Uint8Array} signerPubKey The signer public key
     * @returns {boolean} True if the public key signed the transaction
     */
    static verifyIfSigned(psbt, signerPubKey) {
        let alreadySigned = false;
        for (let i = 1; i < psbt.data.inputs.length; i++) {
            const input = psbt.data.inputs[i];
            if (!input.finalScriptWitness) {
                continue;
            }
            const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
            if (decoded.length < 3) {
                continue;
            }
            for (let j = 0; j < decoded.length - 2; j += 3) {
                const pubKey = decoded[j + 2];
                if (equals(pubKey, signerPubKey)) {
                    alreadySigned = true;
                    break;
                }
            }
        }
        return alreadySigned;
    }
    /**
     * Partially sign the transaction
     * @returns {boolean} True if the transaction was signed
     * @public
     */
    static signPartial(psbt, signer, originalInputCount, minimums) {
        let signed = false;
        let final = true;
        for (let i = originalInputCount; i < psbt.data.inputs.length; i++) {
            const input = psbt.data.inputs[i];
            if (!input.tapInternalKey) {
                input.tapInternalKey = toXOnly(MultiSignTransaction.numsPoint);
            }
            const partialSignatures = [];
            if (input.finalScriptWitness) {
                const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
                input.tapLeafScript = [
                    {
                        leafVersion: 192,
                        script: decoded[decoded.length - 2],
                        controlBlock: decoded[decoded.length - 1],
                    },
                ];
                // we must insert all the partial signatures, decoded.length - 2
                for (let j = 0; j < decoded.length - 2; j += 3) {
                    partialSignatures.push({
                        signature: decoded[j],
                        leafHash: decoded[j + 1],
                        pubkey: decoded[j + 2],
                    });
                }
                input.tapScriptSig = (input.tapScriptSig || []).concat(partialSignatures);
            }
            Reflect.deleteProperty(input, 'finalScriptWitness');
            const signHashTypes = MultiSignTransaction.signHashTypesArray
                ? [MultiSignTransaction.calculateSignHash(MultiSignTransaction.signHashTypesArray)]
                : [];
            try {
                MultiSignTransaction.signInput(psbt, input, i, signer, signHashTypes);
                signed = true;
            }
            catch (e) {
                console.log(e);
            }
            if (signed) {
                if (!input.tapScriptSig)
                    throw new Error('No new signatures for input');
                if (input.tapScriptSig.length !== minimums[i - originalInputCount]) {
                    final = false;
                }
            }
        }
        return {
            signed,
            final: !signed ? false : final,
        };
    }
    /**
     * Partially finalize a P2TR MS transaction
     * @param {number} inputIndex The input index
     * @param {PsbtInput} input The input
     * @param {Uint8Array[]} partialSignatures The partial signatures
     * @param {Uint8Array[]} orderedPubKeys The ordered public keys
     * @param {boolean} isFinal If the transaction is final
     */
    static partialFinalizer = (inputIndex, input, partialSignatures, orderedPubKeys, isFinal) => {
        if (!input.tapLeafScript ||
            !input.tapLeafScript[0]?.script ||
            !input.tapLeafScript[0]?.controlBlock) {
            throw new Error('Tap leaf script is required');
        }
        if (!input.tapScriptSig) {
            throw new Error(`No new signatures for input ${inputIndex}.`);
        }
        let scriptSolution = [];
        if (!isFinal) {
            scriptSolution = input.tapScriptSig
                .map((sig) => {
                return [sig.signature, sig.leafHash, sig.pubkey];
            })
                .flat();
        }
        else {
            /** We must order the signatures and the pub keys. */
            for (const pubKey of orderedPubKeys) {
                let found = false;
                for (const sig of input.tapScriptSig) {
                    if (equals(sig.pubkey, toXOnly(pubKey))) {
                        scriptSolution.push(sig.signature);
                        found = true;
                    }
                }
                if (!found) {
                    scriptSolution.push(new Uint8Array(0));
                }
            }
            scriptSolution = scriptSolution.reverse();
        }
        if (partialSignatures.length > 0) {
            scriptSolution = scriptSolution.concat(partialSignatures);
        }
        const tapLeaf = input.tapLeafScript[0];
        const witness = scriptSolution.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
        return {
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
        };
    };
    /**
     * Dedupe signatures
     * @param {TapScriptSig[]} original The original signatures
     * @param {TapScriptSig[]} partial The partial signatures
     * @returns {TapScriptSig[]} The deduped signatures
     */
    static dedupeSignatures(original, partial) {
        const signatures = new Map();
        for (const sig of original) {
            signatures.set(toHex$1(sig.pubkey), sig);
        }
        for (const sig of partial) {
            if (!signatures.has(toHex$1(sig.pubkey))) {
                signatures.set(toHex$1(sig.pubkey), sig);
            }
        }
        return Array.from(signatures.values());
    }
    /**
     * Attempt to finalize the inputs
     * @param {Psbt} psbt The psbt
     * @param {number} startIndex The start index
     * @param {Uint8Array[]} orderedPubKeys The ordered public keys
     * @param {boolean} isFinal If the transaction is final
     * @returns {boolean} True if the inputs were finalized
     */
    static attemptFinalizeInputs(psbt, startIndex, orderedPubKeys, isFinal) {
        let finalizedInputs = 0;
        for (let i = startIndex; i < psbt.data.inputs.length; i++) {
            try {
                const input = psbt.data.inputs[i];
                if (!input.tapInternalKey) {
                    input.tapInternalKey = toXOnly(MultiSignTransaction.numsPoint);
                }
                const partialSignatures = [];
                if (input.finalScriptWitness) {
                    const decoded = TransactionBuilder.readScriptWitnessToWitnessStack(input.finalScriptWitness);
                    // we must insert all the partial signatures, decoded.length - 2
                    for (let j = 0; j < decoded.length - 2; j += 3) {
                        partialSignatures.push({
                            signature: decoded[j],
                            leafHash: decoded[j + 1],
                            pubkey: decoded[j + 2],
                        });
                    }
                    input.tapLeafScript = [
                        {
                            leafVersion: 192,
                            script: decoded[decoded.length - 2],
                            controlBlock: decoded[decoded.length - 1],
                        },
                    ];
                    input.tapScriptSig = MultiSignTransaction.dedupeSignatures(input.tapScriptSig || [], partialSignatures);
                }
                Reflect.deleteProperty(input, 'finalScriptWitness');
                psbt.finalizeInput(i, (inputIndex, input) => {
                    return MultiSignTransaction.partialFinalizer(inputIndex, input, [], orderedPubKeys[i - startIndex], isFinal);
                });
                finalizedInputs++;
            }
            catch (e) { }
        }
        return finalizedInputs === psbt.data.inputs.length - startIndex;
    }
    /**
     * Finalize the psbt multisig transaction
     */
    finalizeTransactionInputs() {
        let finalized = false;
        try {
            for (let i = this.originalInputCount; i < this.transaction.data.inputs.length; i++) {
                this.transaction.finalizeInput(i, this.customFinalizer.bind(this));
            }
            finalized = true;
        }
        catch (e) {
            this.error(`Error finalizing transaction inputs: ${e.stack}`);
        }
        return finalized;
    }
    /**
     * @description Signs the transaction
     * @public
     * @returns {Promise<Psbt>} - The signed transaction in hex format
     * @throws {Error} - If something went wrong
     */
    async signPSBT() {
        if (await this.signTransaction()) {
            return this.transaction;
        }
        throw new Error('Could not sign transaction');
    }
    /**
     * Build the transaction
     * @protected
     *
     * @throws {Error} If the left over funds script redeem is required
     * @throws {Error} If the left over funds script redeem version is required
     * @throws {Error} If the left over funds script redeem output is required
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async buildTransaction() {
        const selectedRedeem = this.targetScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!selectedRedeem.redeemVersion) {
            throw new Error('Left over funds script redeem version is required');
        }
        if (!selectedRedeem.output) {
            throw new Error('Left over funds script redeem output is required');
        }
        this.tapLeafScript = {
            leafVersion: selectedRedeem.redeemVersion,
            script: selectedRedeem.output,
            controlBlock: this.getWitness(),
        };
        this.addInputsFromUTXO();
        const outputLeftAmount = this.calculateOutputLeftAmountFromVaults(this.utxos);
        if (outputLeftAmount < 0) {
            throw new Error(`Output value left is negative ${outputLeftAmount}.`);
        }
        this.addOutput({
            address: this.refundVault,
            value: toSatoshi(outputLeftAmount),
        });
        this.addOutput({
            address: this.receiver,
            value: toSatoshi(this.requestedAmount),
        });
    }
    /**
     * Builds the transaction.
     * @param {Psbt} transaction - The transaction to build
     * @param checkPartialSigs
     * @protected
     * @returns {Promise<boolean>}
     * @throws {Error} - If something went wrong while building the transaction
     */
    async internalBuildTransaction(transaction, checkPartialSigs = false) {
        const inputs = this.getInputs();
        const outputs = this.getOutputs();
        transaction.setMaximumFeeRate(this._maximumFeeRate);
        transaction.addInputs(inputs, checkPartialSigs);
        for (let i = 0; i < this.updateInputs.length; i++) {
            transaction.updateInput(i, this.updateInputs[i]);
        }
        transaction.addOutputs(outputs);
        try {
            await this.signInputs(transaction);
            return this.finalizeTransactionInputs();
        }
        catch (e) {
            const err = e;
            this.error(`[internalBuildTransaction] Something went wrong while getting building the transaction: ${err.stack}`);
        }
        return false;
    }
    /**
     * Sign the inputs
     * @protected
     */
    async signInputs(_transaction) { }
    generateScriptAddress() {
        if (this.useP2MR) {
            return {
                network: this.network,
                scriptTree: this.scriptTree,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: toXOnly(MultiSignTransaction.numsPoint),
            network: this.network,
            scriptTree: this.scriptTree,
            name: PaymentType.P2TR,
        };
    }
    generateTapData() {
        const selectedRedeem = this.targetScriptRedeem;
        if (!selectedRedeem) {
            throw new Error('Left over funds script redeem is required');
        }
        if (!this.scriptTree) {
            throw new Error('Script tree is required');
        }
        if (this.useP2MR) {
            return {
                network: this.network,
                scriptTree: this.scriptTree,
                redeem: selectedRedeem,
                name: PaymentType.P2MR,
            };
        }
        return {
            internalPubkey: toXOnly(MultiSignTransaction.numsPoint),
            network: this.network,
            scriptTree: this.scriptTree,
            redeem: selectedRedeem,
            name: PaymentType.P2TR,
        };
    }
    /**
     * Generate the script solution
     * @param {PsbtInput} input The input
     * @protected
     *
     * @returns {Uint8Array[]} The script solution
     */
    getScriptSolution(input) {
        if (!input.tapScriptSig) {
            return [];
        }
        return input.tapScriptSig.map((sig) => {
            return sig.signature;
        });
    }
    /**
     * Get the script tree
     * @private
     *
     * @returns {Taptree} The script tree
     */
    getScriptTree() {
        this.generateRedeemScripts();
        return [
            {
                output: this.compiledTargetScript,
                version: 192,
            },
            {
                output: MultiSignTransaction.LOCK_LEAF_SCRIPT,
                version: 192,
            },
        ];
    }
    getTotalOutputAmount(utxos) {
        let total = 0n;
        for (const utxo of utxos) {
            total += utxo.value;
        }
        return total;
    }
    /**
     * @description Calculate the amount left to refund to the first vault.
     * @private
     * @returns {bigint} The amount left
     */
    calculateOutputLeftAmountFromVaults(utxos) {
        const total = this.getTotalOutputAmount(utxos);
        return total - this.requestedAmount;
    }
    /**
     * Transaction finalizer
     * @param {number} _inputIndex The input index
     * @param {PsbtInput} input The input
     */
    customFinalizer = (_inputIndex, input) => {
        if (!this.tapLeafScript) {
            throw new Error('Tap leaf script is required');
        }
        const scriptSolution = this.getScriptSolution(input);
        const witness = scriptSolution
            .concat(this.tapLeafScript.script)
            .concat(this.tapLeafScript.controlBlock);
        return {
            finalScriptWitness: TransactionBuilder.witnessStackToScriptWitness(witness),
        };
    };
    /**
     * Generate the redeem scripts
     * @private
     *
     * @throws {Error} If the public keys are required
     * @throws {Error} If the leaf script is required
     * @throws {Error} If the leaf script version is required
     * @throws {Error} If the leaf script output is required
     * @throws {Error} If the target script redeem is required
     */
    generateRedeemScripts() {
        this.targetScriptRedeem = {
            name: PaymentType.P2TR,
            output: this.compiledTargetScript,
            redeemVersion: 192,
        };
        this.leftOverFundsScriptRedeem = {
            name: PaymentType.P2TR,
            output: MultiSignTransaction.LOCK_LEAF_SCRIPT,
            redeemVersion: 192,
        };
    }
}

/**
 * @description Target consensus updates.
 *
 * @description For one year, there will be a new consensus update every 3 months.
 * @description After one year, there will be a new consensus update every 6 months.
 * @description After two years, there will be a new consensus update every year.
 */
var Consensus;
(function (Consensus) {
    Consensus[Consensus["Roswell"] = 0] = "Roswell";
    Consensus[Consensus["Rachel"] = 1] = "Rachel";
    Consensus[Consensus["Kecksburg"] = 2] = "Kecksburg";
    Consensus[Consensus["Phoenix"] = 3] = "Phoenix";
    Consensus[Consensus["Aurora"] = 4] = "Aurora";
    Consensus[Consensus["Rendlesham"] = 5] = "Rendlesham";
    Consensus[Consensus["Lazar"] = 6] = "Lazar";
    Consensus[Consensus["ShagHarbor"] = 7] = "ShagHarbor";
    Consensus[Consensus["Exeter"] = 8] = "Exeter";
    Consensus[Consensus["Stephenville"] = 9] = "Stephenville";
    Consensus[Consensus["Valensole"] = 10] = "Valensole";
    Consensus[Consensus["Socorro"] = 11] = "Socorro";
    Consensus[Consensus["Pascagoula"] = 12] = "Pascagoula";
    Consensus[Consensus["Tehran"] = 13] = "Tehran";
    Consensus[Consensus["Westall"] = 14] = "Westall";
    Consensus[Consensus["Hopkinsville"] = 15] = "Hopkinsville";
    Consensus[Consensus["Belgium"] = 16] = "Belgium";
    Consensus[Consensus["Breeze"] = 17] = "Breeze";
    Consensus[Consensus["Flatwoods"] = 18] = "Flatwoods";
    Consensus[Consensus["Maury"] = 20] = "Maury";
    Consensus[Consensus["Varginha"] = 21] = "Varginha";
    Consensus[Consensus["Trindade"] = 22] = "Trindade";
    Consensus[Consensus["Levelland"] = 23] = "Levelland";
    Consensus[Consensus["Wanaque"] = 24] = "Wanaque";
    Consensus[Consensus["Coyame"] = 25] = "Coyame";
    Consensus[Consensus["Delphos"] = 26] = "Delphos";
})(Consensus || (Consensus = {}));

const RoswellConsensus = {
    CONSENSUS: Consensus.Roswell};

({
    [Consensus.Roswell]: RoswellConsensus,
});
Consensus.Roswell;

function stringToBuffer(str) {
    return fromHex$1(str.startsWith('0x') ? str.slice(2) : str);
}

class EpochValidator {
    static BLOCKS_PER_EPOCH = 5n;
    /**
     * Calculate SHA-1 hash
     */
    static sha1(data) {
        return sha1$1(data);
    }
    /**
     * Calculate mining preimage
     */
    static calculatePreimage(checksumRoot, publicKey, salt) {
        // Ensure all are 32 bytes
        if (checksumRoot.length !== 32 || publicKey.length !== 32 || salt.length !== 32) {
            throw new Error('All inputs must be 32 bytes');
        }
        const preimage = new Uint8Array(32);
        for (let i = 0; i < 32; i++) {
            preimage[i] =
                checksumRoot[i] ^ publicKey[i] ^ salt[i];
        }
        return preimage;
    }
    /**
     * Count matching bits between two hashes
     */
    static countMatchingBits(hash1, hash2) {
        let matchingBits = 0;
        if (hash1.length !== hash2.length) {
            throw new Error('Hashes must be of the same length');
        }
        const minLength = Math.min(hash1.length, hash2.length);
        for (let i = 0; i < minLength; i++) {
            const byte1 = hash1[i];
            const byte2 = hash2[i];
            if (byte1 === byte2) {
                matchingBits += 8;
            }
            else {
                // Check individual bits
                for (let bit = 7; bit >= 0; bit--) {
                    if (((byte1 >> bit) & 1) === ((byte2 >> bit) & 1)) {
                        matchingBits++;
                    }
                    else {
                        return matchingBits;
                    }
                }
            }
        }
        return matchingBits;
    }
    /**
     * Verify an epoch solution using IPreimage
     */
    static verifySolution(challenge, log = false) {
        try {
            const verification = challenge.verification;
            const calculatedPreimage = this.calculatePreimage(verification.targetChecksum, challenge.publicKey.toBuffer(), challenge.salt);
            const computedSolution = this.sha1(calculatedPreimage);
            if (!equals(computedSolution, challenge.solution)) {
                return false;
            }
            const matchingBits = this.countMatchingBits(computedSolution, verification.targetHash);
            if (matchingBits !== challenge.difficulty) {
                return false;
            }
            const expectedStartBlock = challenge.epochNumber * this.BLOCKS_PER_EPOCH;
            const expectedEndBlock = expectedStartBlock + this.BLOCKS_PER_EPOCH - 1n;
            return !(verification.startBlock !== expectedStartBlock ||
                verification.endBlock !== expectedEndBlock);
        }
        catch (error) {
            if (log)
                console.error('Verification error:', error);
            return false;
        }
    }
    /**
     * Get the mining target block for an epoch
     */
    static getMiningTargetBlock(epochNumber) {
        if (epochNumber === 0n) {
            return null; // Epoch 0 cannot be mined
        }
        // Last block of previous epoch
        return epochNumber * this.BLOCKS_PER_EPOCH - 1n;
    }
    /**
     * Validate epoch winner from raw data
     */
    static validateEpochWinner(epochData) {
        try {
            const epochNumber = BigInt(epochData.epochNumber);
            const publicKey = Address.fromString(epochData.mldsaPublicKey, epochData.legacyPublicKey);
            const solution = stringToBuffer(epochData.solution);
            const salt = stringToBuffer(epochData.salt);
            const difficulty = epochData.difficulty;
            const verification = {
                epochHash: stringToBuffer(epochData.verification.epochHash),
                epochRoot: stringToBuffer(epochData.verification.epochRoot),
                targetHash: stringToBuffer(epochData.verification.targetHash),
                targetChecksum: stringToBuffer(epochData.verification.targetChecksum),
                startBlock: BigInt(epochData.verification.startBlock),
                endBlock: BigInt(epochData.verification.endBlock),
                proofs: Object.freeze(epochData.verification.proofs.map((p) => stringToBuffer(p))),
            };
            const calculatedPreimage = this.calculatePreimage(verification.targetChecksum, publicKey.toBuffer(), salt);
            const computedSolution = this.sha1(calculatedPreimage);
            if (!equals(computedSolution, solution)) {
                return false;
            }
            const matchingBits = this.countMatchingBits(computedSolution, verification.targetHash);
            if (matchingBits !== difficulty) {
                return false;
            }
            const expectedStartBlock = epochNumber * this.BLOCKS_PER_EPOCH;
            const expectedEndBlock = expectedStartBlock + this.BLOCKS_PER_EPOCH - 1n;
            return !(verification.startBlock !== expectedStartBlock ||
                verification.endBlock !== expectedEndBlock);
        }
        catch {
            return false;
        }
    }
    /**
     * Validate epoch winner from Preimage instance
     */
    static validateChallengeSolution(challenge) {
        return this.verifySolution(challenge);
    }
    /**
     * Calculate solution hash from preimage components
     * @param targetChecksum The target checksum (32 bytes)
     * @param publicKey The public key buffer (32 bytes)
     * @param salt The salt buffer (32 bytes)
     * @returns The SHA-1 hash of the preimage
     */
    static calculateSolution(targetChecksum, publicKey, salt) {
        const preimage = this.calculatePreimage(targetChecksum, publicKey, salt);
        return this.sha1(preimage);
    }
    /**
     * Check if a solution meets the minimum difficulty requirement
     */
    static checkDifficulty(solution, targetHash, minDifficulty) {
        const difficulty = this.countMatchingBits(solution, targetHash);
        return {
            valid: difficulty >= minDifficulty,
            difficulty,
        };
    }
}

class ChallengeVerification {
    epochHash;
    epochRoot;
    targetHash;
    targetChecksum;
    startBlock;
    endBlock;
    proofs;
    constructor(data) {
        this.epochHash = stringToBuffer(data.epochHash);
        this.epochRoot = stringToBuffer(data.epochRoot);
        this.targetHash = stringToBuffer(data.targetHash);
        this.targetChecksum = stringToBuffer(data.targetChecksum);
        this.startBlock = BigInt(data.startBlock);
        this.endBlock = BigInt(data.endBlock);
        this.proofs = Object.freeze(data.proofs.map((proof) => stringToBuffer(proof)));
    }
}
class ChallengeSubmission {
    epochNumber;
    publicKey;
    solution;
    graffiti;
    signature;
    constructor(data, epochNumber) {
        this.epochNumber = epochNumber;
        this.publicKey = Address.fromString(data.mldsaPublicKey, data.legacyPublicKey);
        this.solution = stringToBuffer(data.solution);
        this.graffiti = data.graffiti ? stringToBuffer(data.graffiti) : undefined;
        this.signature = stringToBuffer(data.signature);
    }
    verifySignature() {
        const signatureDataWriter = new BinaryWriter();
        signatureDataWriter.writeAddress(this.publicKey);
        signatureDataWriter.writeU64(this.epochNumber);
        signatureDataWriter.writeBytes(this.solution);
        if (this.graffiti) {
            signatureDataWriter.writeBytes(this.graffiti);
        }
        const buffer = signatureDataWriter.getBuffer();
        return MessageSigner.verifySignature(this.publicKey.tweakedPublicKeyToBuffer(), buffer, this.signature);
    }
}
class ChallengeSolution {
    epochNumber;
    publicKey;
    solution;
    salt;
    graffiti;
    difficulty;
    verification;
    submission;
    constructor(data) {
        this.epochNumber = BigInt(data.epochNumber);
        this.publicKey = Address.fromString(data.mldsaPublicKey, data.legacyPublicKey);
        this.solution = stringToBuffer(data.solution);
        this.salt = stringToBuffer(data.salt);
        this.graffiti = stringToBuffer(data.graffiti);
        this.difficulty = data.difficulty;
        this.verification = new ChallengeVerification(data.verification);
        this.submission = data.submission
            ? new ChallengeSubmission(data.submission, this.epochNumber + 2n)
            : data.submission;
    }
    /**
     * Static method to validate from raw data directly
     */
    static validateRaw(data) {
        return EpochValidator.validateEpochWinner(data);
    }
    verifySubmissionSignature() {
        if (!this.submission) {
            throw new Error('No submission provided in request.');
        }
        return this.submission.verifySignature();
    }
    getSubmission() {
        if (!this.submission) {
            return;
        }
        if (!this.verifySubmissionSignature()) {
            throw new Error('Invalid submission signature.');
        }
        return this.submission;
    }
    /**
     * Verify this challenge
     * @returns {boolean} True if the challenge is valid
     */
    verify() {
        return EpochValidator.validateChallengeSolution(this);
    }
    /**
     * Get the preimage challenge
     * @returns {Uint8Array} The solution/challenge as a Uint8Array
     */
    toBuffer() {
        return this.solution;
    }
    /**
     * Get the solution as a hex string
     * @returns {string} The solution as a hex string with 0x prefix
     */
    toHex() {
        return '0x' + toHex$1(this.solution);
    }
    /**
     * Convert to raw format for serialization
     */
    toRaw() {
        return {
            epochNumber: this.epochNumber.toString(),
            mldsaPublicKey: this.publicKey.toHex(),
            legacyPublicKey: this.publicKey.tweakedToHex(),
            solution: this.toHex(),
            salt: '0x' + toHex$1(this.salt),
            graffiti: '0x' + toHex$1(this.graffiti),
            difficulty: this.difficulty,
            verification: {
                epochHash: '0x' + toHex$1(this.verification.epochHash),
                epochRoot: '0x' + toHex$1(this.verification.epochRoot),
                targetHash: '0x' + toHex$1(this.verification.targetHash),
                targetChecksum: '0x' + toHex$1(this.verification.targetChecksum),
                startBlock: this.verification.startBlock.toString(),
                endBlock: this.verification.endBlock.toString(),
                proofs: this.verification.proofs.map((p) => '0x' + toHex$1(p)),
            },
        };
    }
    /**
     * Calculate the expected solution hash for this challenge
     * @returns {Uint8Array} The calculated solution hash
     */
    calculateSolution() {
        return EpochValidator.calculateSolution(this.verification.targetChecksum, this.publicKey.toBuffer(), this.salt);
    }
    /**
     * Check if the challenge meets a specific difficulty requirement
     * @param {number} minDifficulty The minimum difficulty required
     * @returns {Promise<{valid: boolean; difficulty: number}>} Validation result
     */
    checkDifficulty(minDifficulty) {
        return EpochValidator.checkDifficulty(this.solution, this.verification.targetHash, minDifficulty);
    }
    /**
     * Get the mining target block for this epoch
     * @returns {bigint | null} The target block number or null if epoch 0
     */
    getMiningTargetBlock() {
        return EpochValidator.getMiningTargetBlock(this.epochNumber);
    }
}

var PSBTTypes;
(function (PSBTTypes) {
    PSBTTypes[PSBTTypes["UNWRAP"] = 0] = "UNWRAP";
})(PSBTTypes || (PSBTTypes = {}));

class P2TR_MS {
    /**
     * Generate a multi-sig address
     * @param {Uint8Array[]} pubKeys - The public keys to use
     * @param {number} minimumSignatureRequired - The minimum number of signatures required
     * @param {Network} network - The network to use
     * @returns {string} - The generated address
     * @throws {Error} - If the address cannot be generated
     */
    static generateMultiSigAddress(pubKeys, minimumSignatureRequired, network = bitcoin$1) {
        const publicKeys = EcKeyPair.verifyPubKeys(pubKeys, network);
        if (publicKeys.length !== pubKeys.length)
            throw new Error(`Contains invalid public keys`);
        // fake params
        const multiSignParams = {
            network: network,
            utxos: [],
            pubkeys: pubKeys,
            minimumSignatures: minimumSignatureRequired,
            feeRate: 100,
            receiver: 'a',
            requestedAmount: 1n,
            refundVault: 'a',
            mldsaSigner: null,
        };
        const address = new MultiSignTransaction(multiSignParams).getScriptAddress();
        if (!address) {
            throw new Error('Failed to generate address');
        }
        return address;
    }
}

class P2MR_MS {
    /**
     * Generate a multi-sig P2MR address
     * @param {Uint8Array[]} pubKeys - The public keys to use
     * @param {number} minimumSignatureRequired - The minimum number of signatures required
     * @param {Network} network - The network to use
     * @returns {string} - The generated address
     * @throws {Error} - If the address cannot be generated
     */
    static generateMultiSigAddress(pubKeys, minimumSignatureRequired, network = bitcoin$1) {
        const publicKeys = EcKeyPair.verifyPubKeys(pubKeys, network);
        if (publicKeys.length !== pubKeys.length)
            throw new Error(`Contains invalid public keys`);
        // fake params
        const multiSignParams = {
            network: network,
            utxos: [],
            pubkeys: publicKeys,
            minimumSignatures: minimumSignatureRequired,
            feeRate: 100,
            receiver: 'a',
            requestedAmount: 1n,
            refundVault: 'a',
            mldsaSigner: null,
            useP2MR: true,
        };
        const address = new MultiSignTransaction(multiSignParams).getScriptAddress();
        if (!address) {
            throw new Error('Failed to generate address');
        }
        return address;
    }
}

var sha_js = {exports: {}};

var inherits = {exports: {}};

function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser = { exports: {} };
var process = browser.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);

var util = {};

var types = {};

var shams$1;
var hasRequiredShams$1;

function requireShams$1 () {
	if (hasRequiredShams$1) return shams$1;
	hasRequiredShams$1 = 1;

	/** @type {import('./shams')} */
	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	shams$1 = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			// eslint-disable-next-line no-extra-parens
			var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};
	return shams$1;
}

var shams;
var hasRequiredShams;

function requireShams () {
	if (hasRequiredShams) return shams;
	hasRequiredShams = 1;

	var hasSymbols = requireShams$1();

	/** @type {import('.')} */
	shams = function hasToStringTagShams() {
		return hasSymbols() && !!Symbol.toStringTag;
	};
	return shams;
}

var esObjectAtoms;
var hasRequiredEsObjectAtoms;

function requireEsObjectAtoms () {
	if (hasRequiredEsObjectAtoms) return esObjectAtoms;
	hasRequiredEsObjectAtoms = 1;

	/** @type {import('.')} */
	esObjectAtoms = Object;
	return esObjectAtoms;
}

var esErrors;
var hasRequiredEsErrors;

function requireEsErrors () {
	if (hasRequiredEsErrors) return esErrors;
	hasRequiredEsErrors = 1;

	/** @type {import('.')} */
	esErrors = Error;
	return esErrors;
}

var _eval;
var hasRequired_eval;

function require_eval () {
	if (hasRequired_eval) return _eval;
	hasRequired_eval = 1;

	/** @type {import('./eval')} */
	_eval = EvalError;
	return _eval;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	/** @type {import('./range')} */
	range = RangeError;
	return range;
}

var ref;
var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;

	/** @type {import('./ref')} */
	ref = ReferenceError;
	return ref;
}

var syntax;
var hasRequiredSyntax;

function requireSyntax () {
	if (hasRequiredSyntax) return syntax;
	hasRequiredSyntax = 1;

	/** @type {import('./syntax')} */
	syntax = SyntaxError;
	return syntax;
}

var type;
var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;

	/** @type {import('./type')} */
	type = TypeError;
	return type;
}

var uri;
var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;

	/** @type {import('./uri')} */
	uri = URIError;
	return uri;
}

var abs;
var hasRequiredAbs;

function requireAbs () {
	if (hasRequiredAbs) return abs;
	hasRequiredAbs = 1;

	/** @type {import('./abs')} */
	abs = Math.abs;
	return abs;
}

var floor;
var hasRequiredFloor;

function requireFloor () {
	if (hasRequiredFloor) return floor;
	hasRequiredFloor = 1;

	/** @type {import('./floor')} */
	floor = Math.floor;
	return floor;
}

var max;
var hasRequiredMax;

function requireMax () {
	if (hasRequiredMax) return max;
	hasRequiredMax = 1;

	/** @type {import('./max')} */
	max = Math.max;
	return max;
}

var min;
var hasRequiredMin;

function requireMin () {
	if (hasRequiredMin) return min;
	hasRequiredMin = 1;

	/** @type {import('./min')} */
	min = Math.min;
	return min;
}

var pow;
var hasRequiredPow;

function requirePow () {
	if (hasRequiredPow) return pow;
	hasRequiredPow = 1;

	/** @type {import('./pow')} */
	pow = Math.pow;
	return pow;
}

var round;
var hasRequiredRound;

function requireRound () {
	if (hasRequiredRound) return round;
	hasRequiredRound = 1;

	/** @type {import('./round')} */
	round = Math.round;
	return round;
}

var _isNaN;
var hasRequired_isNaN;

function require_isNaN () {
	if (hasRequired_isNaN) return _isNaN;
	hasRequired_isNaN = 1;

	/** @type {import('./isNaN')} */
	_isNaN = Number.isNaN || function isNaN(a) {
		return a !== a;
	};
	return _isNaN;
}

var sign;
var hasRequiredSign;

function requireSign () {
	if (hasRequiredSign) return sign;
	hasRequiredSign = 1;

	var $isNaN = /*@__PURE__*/ require_isNaN();

	/** @type {import('./sign')} */
	sign = function sign(number) {
		if ($isNaN(number) || number === 0) {
			return number;
		}
		return number < 0 ? -1 : 1;
	};
	return sign;
}

var gOPD;
var hasRequiredGOPD;

function requireGOPD () {
	if (hasRequiredGOPD) return gOPD;
	hasRequiredGOPD = 1;

	/** @type {import('./gOPD')} */
	gOPD = Object.getOwnPropertyDescriptor;
	return gOPD;
}

var gopd;
var hasRequiredGopd;

function requireGopd () {
	if (hasRequiredGopd) return gopd;
	hasRequiredGopd = 1;

	/** @type {import('.')} */
	var $gOPD = /*@__PURE__*/ requireGOPD();

	if ($gOPD) {
		try {
			$gOPD([], 'length');
		} catch (e) {
			// IE 8 has a broken gOPD
			$gOPD = null;
		}
	}

	gopd = $gOPD;
	return gopd;
}

var esDefineProperty;
var hasRequiredEsDefineProperty;

function requireEsDefineProperty () {
	if (hasRequiredEsDefineProperty) return esDefineProperty;
	hasRequiredEsDefineProperty = 1;

	/** @type {import('.')} */
	var $defineProperty = Object.defineProperty || false;
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
		} catch (e) {
			// IE 8 has a broken defineProperty
			$defineProperty = false;
		}
	}

	esDefineProperty = $defineProperty;
	return esDefineProperty;
}

var hasSymbols;
var hasRequiredHasSymbols;

function requireHasSymbols () {
	if (hasRequiredHasSymbols) return hasSymbols;
	hasRequiredHasSymbols = 1;

	var origSymbol = typeof Symbol !== 'undefined' && Symbol;
	var hasSymbolSham = requireShams$1();

	/** @type {import('.')} */
	hasSymbols = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }

		return hasSymbolSham();
	};
	return hasSymbols;
}

var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;

function requireReflect_getPrototypeOf () {
	if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
	hasRequiredReflect_getPrototypeOf = 1;

	/** @type {import('./Reflect.getPrototypeOf')} */
	Reflect_getPrototypeOf = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;
	return Reflect_getPrototypeOf;
}

var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;

function requireObject_getPrototypeOf () {
	if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
	hasRequiredObject_getPrototypeOf = 1;

	var $Object = /*@__PURE__*/ requireEsObjectAtoms();

	/** @type {import('./Object.getPrototypeOf')} */
	Object_getPrototypeOf = $Object.getPrototypeOf || null;
	return Object_getPrototypeOf;
}

var implementation;
var hasRequiredImplementation;

function requireImplementation () {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = '[object Function]';

	var concatty = function concatty(a, b) {
	    var arr = [];

	    for (var i = 0; i < a.length; i += 1) {
	        arr[i] = a[i];
	    }
	    for (var j = 0; j < b.length; j += 1) {
	        arr[j + a.length] = b[j];
	    }

	    return arr;
	};

	var slicy = function slicy(arrLike, offset) {
	    var arr = [];
	    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
	        arr[j] = arrLike[i];
	    }
	    return arr;
	};

	var joiny = function (arr, joiner) {
	    var str = '';
	    for (var i = 0; i < arr.length; i += 1) {
	        str += arr[i];
	        if (i + 1 < arr.length) {
	            str += joiner;
	        }
	    }
	    return str;
	};

	implementation = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slicy(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                concatty(args, arguments)
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        }
	        return target.apply(
	            that,
	            concatty(args, arguments)
	        );

	    };

	    var boundLength = max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs[i] = '$' + i;
	    }

	    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};
	return implementation;
}

var functionBind;
var hasRequiredFunctionBind;

function requireFunctionBind () {
	if (hasRequiredFunctionBind) return functionBind;
	hasRequiredFunctionBind = 1;

	var implementation = requireImplementation();

	functionBind = Function.prototype.bind || implementation;
	return functionBind;
}

var functionCall;
var hasRequiredFunctionCall;

function requireFunctionCall () {
	if (hasRequiredFunctionCall) return functionCall;
	hasRequiredFunctionCall = 1;

	/** @type {import('./functionCall')} */
	functionCall = Function.prototype.call;
	return functionCall;
}

var functionApply;
var hasRequiredFunctionApply;

function requireFunctionApply () {
	if (hasRequiredFunctionApply) return functionApply;
	hasRequiredFunctionApply = 1;

	/** @type {import('./functionApply')} */
	functionApply = Function.prototype.apply;
	return functionApply;
}

var reflectApply;
var hasRequiredReflectApply;

function requireReflectApply () {
	if (hasRequiredReflectApply) return reflectApply;
	hasRequiredReflectApply = 1;

	/** @type {import('./reflectApply')} */
	reflectApply = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
	return reflectApply;
}

var actualApply;
var hasRequiredActualApply;

function requireActualApply () {
	if (hasRequiredActualApply) return actualApply;
	hasRequiredActualApply = 1;

	var bind = requireFunctionBind();

	var $apply = requireFunctionApply();
	var $call = requireFunctionCall();
	var $reflectApply = requireReflectApply();

	/** @type {import('./actualApply')} */
	actualApply = $reflectApply || bind.call($call, $apply);
	return actualApply;
}

var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;

function requireCallBindApplyHelpers () {
	if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
	hasRequiredCallBindApplyHelpers = 1;

	var bind = requireFunctionBind();
	var $TypeError = /*@__PURE__*/ requireType();

	var $call = requireFunctionCall();
	var $actualApply = requireActualApply();

	/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
	callBindApplyHelpers = function callBindBasic(args) {
		if (args.length < 1 || typeof args[0] !== 'function') {
			throw new $TypeError('a function is required');
		}
		return $actualApply(bind, $call, args);
	};
	return callBindApplyHelpers;
}

var get;
var hasRequiredGet;

function requireGet () {
	if (hasRequiredGet) return get;
	hasRequiredGet = 1;

	var callBind = requireCallBindApplyHelpers();
	var gOPD = /*@__PURE__*/ requireGopd();

	var hasProtoAccessor;
	try {
		// eslint-disable-next-line no-extra-parens, no-proto
		hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
			throw e;
		}
	}

	// eslint-disable-next-line no-extra-parens
	var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

	var $Object = Object;
	var $getPrototypeOf = $Object.getPrototypeOf;

	/** @type {import('./get')} */
	get = desc && typeof desc.get === 'function'
		? callBind([desc.get])
		: typeof $getPrototypeOf === 'function'
			? /** @type {import('./get')} */ function getDunder(value) {
				// eslint-disable-next-line eqeqeq
				return $getPrototypeOf(value == null ? value : $Object(value));
			}
			: false;
	return get;
}

var getProto;
var hasRequiredGetProto;

function requireGetProto () {
	if (hasRequiredGetProto) return getProto;
	hasRequiredGetProto = 1;

	var reflectGetProto = requireReflect_getPrototypeOf();
	var originalGetProto = requireObject_getPrototypeOf();

	var getDunderProto = /*@__PURE__*/ requireGet();

	/** @type {import('.')} */
	getProto = reflectGetProto
		? function getProto(O) {
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return reflectGetProto(O);
		}
		: originalGetProto
			? function getProto(O) {
				if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
					throw new TypeError('getProto: not an object');
				}
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return originalGetProto(O);
			}
			: getDunderProto
				? function getProto(O) {
					// @ts-expect-error TS can't narrow inside a closure, for some reason
					return getDunderProto(O);
				}
				: null;
	return getProto;
}

var hasown;
var hasRequiredHasown;

function requireHasown () {
	if (hasRequiredHasown) return hasown;
	hasRequiredHasown = 1;

	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = requireFunctionBind();

	/** @type {import('.')} */
	hasown = bind.call(call, $hasOwn);
	return hasown;
}

var getIntrinsic;
var hasRequiredGetIntrinsic;

function requireGetIntrinsic () {
	if (hasRequiredGetIntrinsic) return getIntrinsic;
	hasRequiredGetIntrinsic = 1;

	var undefined$1;

	var $Object = /*@__PURE__*/ requireEsObjectAtoms();

	var $Error = /*@__PURE__*/ requireEsErrors();
	var $EvalError = /*@__PURE__*/ require_eval();
	var $RangeError = /*@__PURE__*/ requireRange();
	var $ReferenceError = /*@__PURE__*/ requireRef();
	var $SyntaxError = /*@__PURE__*/ requireSyntax();
	var $TypeError = /*@__PURE__*/ requireType();
	var $URIError = /*@__PURE__*/ requireUri();

	var abs = /*@__PURE__*/ requireAbs();
	var floor = /*@__PURE__*/ requireFloor();
	var max = /*@__PURE__*/ requireMax();
	var min = /*@__PURE__*/ requireMin();
	var pow = /*@__PURE__*/ requirePow();
	var round = /*@__PURE__*/ requireRound();
	var sign = /*@__PURE__*/ requireSign();

	var $Function = Function;

	// eslint-disable-next-line consistent-return
	var getEvalledConstructor = function (expressionSyntax) {
		try {
			return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
		} catch (e) {}
	};

	var $gOPD = /*@__PURE__*/ requireGopd();
	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var throwTypeError = function () {
		throw new $TypeError();
	};
	var ThrowTypeError = $gOPD
		? (function () {
			try {
				// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
				arguments.callee; // IE 8 does not throw here
				return throwTypeError;
			} catch (calleeThrows) {
				try {
					// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
					return $gOPD(arguments, 'callee').get;
				} catch (gOPDthrows) {
					return throwTypeError;
				}
			}
		}())
		: throwTypeError;

	var hasSymbols = requireHasSymbols()();

	var getProto = requireGetProto();
	var $ObjectGPO = requireObject_getPrototypeOf();
	var $ReflectGPO = requireReflect_getPrototypeOf();

	var $apply = requireFunctionApply();
	var $call = requireFunctionCall();

	var needsEval = {};

	var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);

	var INTRINSICS = {
		__proto__: null,
		'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
		'%Array%': Array,
		'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
		'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
		'%AsyncFromSyncIteratorPrototype%': undefined$1,
		'%AsyncFunction%': needsEval,
		'%AsyncGenerator%': needsEval,
		'%AsyncGeneratorFunction%': needsEval,
		'%AsyncIteratorPrototype%': needsEval,
		'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
		'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
		'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
		'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
		'%Boolean%': Boolean,
		'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
		'%Date%': Date,
		'%decodeURI%': decodeURI,
		'%decodeURIComponent%': decodeURIComponent,
		'%encodeURI%': encodeURI,
		'%encodeURIComponent%': encodeURIComponent,
		'%Error%': $Error,
		'%eval%': eval, // eslint-disable-line no-eval
		'%EvalError%': $EvalError,
		'%Float16Array%': typeof Float16Array === 'undefined' ? undefined$1 : Float16Array,
		'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
		'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
		'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
		'%Function%': $Function,
		'%GeneratorFunction%': needsEval,
		'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
		'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
		'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
		'%isFinite%': isFinite,
		'%isNaN%': isNaN,
		'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
		'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
		'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
		'%Math%': Math,
		'%Number%': Number,
		'%Object%': $Object,
		'%Object.getOwnPropertyDescriptor%': $gOPD,
		'%parseFloat%': parseFloat,
		'%parseInt%': parseInt,
		'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
		'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
		'%RangeError%': $RangeError,
		'%ReferenceError%': $ReferenceError,
		'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
		'%RegExp%': RegExp,
		'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
		'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
		'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
		'%String%': String,
		'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
		'%Symbol%': hasSymbols ? Symbol : undefined$1,
		'%SyntaxError%': $SyntaxError,
		'%ThrowTypeError%': ThrowTypeError,
		'%TypedArray%': TypedArray,
		'%TypeError%': $TypeError,
		'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
		'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
		'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
		'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
		'%URIError%': $URIError,
		'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
		'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
		'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,

		'%Function.prototype.call%': $call,
		'%Function.prototype.apply%': $apply,
		'%Object.defineProperty%': $defineProperty,
		'%Object.getPrototypeOf%': $ObjectGPO,
		'%Math.abs%': abs,
		'%Math.floor%': floor,
		'%Math.max%': max,
		'%Math.min%': min,
		'%Math.pow%': pow,
		'%Math.round%': round,
		'%Math.sign%': sign,
		'%Reflect.getPrototypeOf%': $ReflectGPO
	};

	if (getProto) {
		try {
			null.error; // eslint-disable-line no-unused-expressions
		} catch (e) {
			// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
			var errorProto = getProto(getProto(e));
			INTRINSICS['%Error.prototype%'] = errorProto;
		}
	}

	var doEval = function doEval(name) {
		var value;
		if (name === '%AsyncFunction%') {
			value = getEvalledConstructor('async function () {}');
		} else if (name === '%GeneratorFunction%') {
			value = getEvalledConstructor('function* () {}');
		} else if (name === '%AsyncGeneratorFunction%') {
			value = getEvalledConstructor('async function* () {}');
		} else if (name === '%AsyncGenerator%') {
			var fn = doEval('%AsyncGeneratorFunction%');
			if (fn) {
				value = fn.prototype;
			}
		} else if (name === '%AsyncIteratorPrototype%') {
			var gen = doEval('%AsyncGenerator%');
			if (gen && getProto) {
				value = getProto(gen.prototype);
			}
		}

		INTRINSICS[name] = value;

		return value;
	};

	var LEGACY_ALIASES = {
		__proto__: null,
		'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
		'%ArrayPrototype%': ['Array', 'prototype'],
		'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
		'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
		'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
		'%ArrayProto_values%': ['Array', 'prototype', 'values'],
		'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
		'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
		'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
		'%BooleanPrototype%': ['Boolean', 'prototype'],
		'%DataViewPrototype%': ['DataView', 'prototype'],
		'%DatePrototype%': ['Date', 'prototype'],
		'%ErrorPrototype%': ['Error', 'prototype'],
		'%EvalErrorPrototype%': ['EvalError', 'prototype'],
		'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
		'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
		'%FunctionPrototype%': ['Function', 'prototype'],
		'%Generator%': ['GeneratorFunction', 'prototype'],
		'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
		'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
		'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
		'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
		'%JSONParse%': ['JSON', 'parse'],
		'%JSONStringify%': ['JSON', 'stringify'],
		'%MapPrototype%': ['Map', 'prototype'],
		'%NumberPrototype%': ['Number', 'prototype'],
		'%ObjectPrototype%': ['Object', 'prototype'],
		'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
		'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
		'%PromisePrototype%': ['Promise', 'prototype'],
		'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
		'%Promise_all%': ['Promise', 'all'],
		'%Promise_reject%': ['Promise', 'reject'],
		'%Promise_resolve%': ['Promise', 'resolve'],
		'%RangeErrorPrototype%': ['RangeError', 'prototype'],
		'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
		'%RegExpPrototype%': ['RegExp', 'prototype'],
		'%SetPrototype%': ['Set', 'prototype'],
		'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
		'%StringPrototype%': ['String', 'prototype'],
		'%SymbolPrototype%': ['Symbol', 'prototype'],
		'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
		'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
		'%TypeErrorPrototype%': ['TypeError', 'prototype'],
		'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
		'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
		'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
		'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
		'%URIErrorPrototype%': ['URIError', 'prototype'],
		'%WeakMapPrototype%': ['WeakMap', 'prototype'],
		'%WeakSetPrototype%': ['WeakSet', 'prototype']
	};

	var bind = requireFunctionBind();
	var hasOwn = /*@__PURE__*/ requireHasown();
	var $concat = bind.call($call, Array.prototype.concat);
	var $spliceApply = bind.call($apply, Array.prototype.splice);
	var $replace = bind.call($call, String.prototype.replace);
	var $strSlice = bind.call($call, String.prototype.slice);
	var $exec = bind.call($call, RegExp.prototype.exec);

	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === '%' && last !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
		} else if (last === '%' && first !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
		}
		var result = [];
		$replace(string, rePropName, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
		});
		return result;
	};
	/* end adaptation */

	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = '%' + alias[0] + '%';
		}

		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) {
				value = doEval(intrinsicName);
			}
			if (typeof value === 'undefined' && !allowMissing) {
				throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
			}

			return {
				alias: alias,
				name: intrinsicName,
				value: value
			};
		}

		throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
	};

	getIntrinsic = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== 'string' || name.length === 0) {
			throw new $TypeError('intrinsic name must be a non-empty string');
		}
		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
			throw new $TypeError('"allowMissing" argument must be a boolean');
		}

		if ($exec(/^%?[^%]*%?$/, name) === null) {
			throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
		}
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

		var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;

		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}

		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if (
				(
					(first === '"' || first === "'" || first === '`')
					|| (last === '"' || last === "'" || last === '`')
				)
				&& first !== last
			) {
				throw new $SyntaxError('property names with quotes must have matching quotes');
			}
			if (part === 'constructor' || !isOwn) {
				skipFurtherCaching = true;
			}

			intrinsicBaseName += '.' + part;
			intrinsicRealName = '%' + intrinsicBaseName + '%';

			if (hasOwn(INTRINSICS, intrinsicRealName)) {
				value = INTRINSICS[intrinsicRealName];
			} else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) {
						throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
					}
					return void undefined$1;
				}
				if ($gOPD && (i + 1) >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;

					// By convention, when a data property is converted to an accessor
					// property to emulate a data property that does not suffer from
					// the override mistake, that accessor's getter is marked with
					// an `originalValue` property. Here, when we detect this, we
					// uphold the illusion by pretending to see that original data
					// property, i.e., returning the value rather than the getter
					// itself.
					if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
						value = desc.get;
					} else {
						value = value[part];
					}
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}

				if (isOwn && !skipFurtherCaching) {
					INTRINSICS[intrinsicRealName] = value;
				}
			}
		}
		return value;
	};
	return getIntrinsic;
}

var callBound;
var hasRequiredCallBound;

function requireCallBound () {
	if (hasRequiredCallBound) return callBound;
	hasRequiredCallBound = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	var callBindBasic = requireCallBindApplyHelpers();

	/** @type {(thisArg: string, searchString: string, position?: number) => number} */
	var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

	/** @type {import('.')} */
	callBound = function callBoundIntrinsic(name, allowMissing) {
		/* eslint no-extra-parens: 0 */

		var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
		if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
			return callBindBasic(/** @type {const} */ ([intrinsic]));
		}
		return intrinsic;
	};
	return callBound;
}

var isArguments;
var hasRequiredIsArguments;

function requireIsArguments () {
	if (hasRequiredIsArguments) return isArguments;
	hasRequiredIsArguments = 1;

	var hasToStringTag = requireShams()();
	var callBound = /*@__PURE__*/ requireCallBound();

	var $toString = callBound('Object.prototype.toString');

	/** @type {import('.')} */
	var isStandardArguments = function isArguments(value) {
		if (
			hasToStringTag
			&& value
			&& typeof value === 'object'
			&& Symbol.toStringTag in value
		) {
			return false;
		}
		return $toString(value) === '[object Arguments]';
	};

	/** @type {import('.')} */
	var isLegacyArguments = function isArguments(value) {
		if (isStandardArguments(value)) {
			return true;
		}
		return value !== null
			&& typeof value === 'object'
			&& 'length' in value
			&& typeof value.length === 'number'
			&& value.length >= 0
			&& $toString(value) !== '[object Array]'
			&& 'callee' in value
			&& $toString(value.callee) === '[object Function]';
	};

	var supportsStandardArguments = (function () {
		return isStandardArguments(arguments);
	}());

	// @ts-expect-error TODO make this not error
	isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

	/** @type {import('.')} */
	isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
	return isArguments;
}

var isRegex;
var hasRequiredIsRegex;

function requireIsRegex () {
	if (hasRequiredIsRegex) return isRegex;
	hasRequiredIsRegex = 1;

	var callBound = /*@__PURE__*/ requireCallBound();
	var hasToStringTag = requireShams()();
	var hasOwn = /*@__PURE__*/ requireHasown();
	var gOPD = /*@__PURE__*/ requireGopd();

	/** @type {import('.')} */
	var fn;

	if (hasToStringTag) {
		/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */
		var $exec = callBound('RegExp.prototype.exec');
		/** @type {object} */
		var isRegexMarker = {};

		var throwRegexMarker = function () {
			throw isRegexMarker;
		};
		/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */
		var badStringifier = {
			toString: throwRegexMarker,
			valueOf: throwRegexMarker
		};

		if (typeof Symbol.toPrimitive === 'symbol') {
			badStringifier[Symbol.toPrimitive] = throwRegexMarker;
		}

		/** @type {import('.')} */
		// @ts-expect-error TS can't figure out that the $exec call always throws
		// eslint-disable-next-line consistent-return
		fn = function isRegex(value) {
			if (!value || typeof value !== 'object') {
				return false;
			}

			// eslint-disable-next-line no-extra-parens
			var descriptor = /** @type {NonNullable<typeof gOPD>} */ (gOPD)(/** @type {{ lastIndex?: unknown }} */ (value), 'lastIndex');
			var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');
			if (!hasLastIndexDataProperty) {
				return false;
			}

			try {
				// eslint-disable-next-line no-extra-parens
				$exec(value, /** @type {string} */ (/** @type {unknown} */ (badStringifier)));
			} catch (e) {
				return e === isRegexMarker;
			}
		};
	} else {
		/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */
		var $toString = callBound('Object.prototype.toString');
		/** @const @type {'[object RegExp]'} */
		var regexClass = '[object RegExp]';

		/** @type {import('.')} */
		fn = function isRegex(value) {
			// In older browsers, typeof regex incorrectly returns 'function'
			if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
				return false;
			}

			return $toString(value) === regexClass;
		};
	}

	isRegex = fn;
	return isRegex;
}

var safeRegexTest;
var hasRequiredSafeRegexTest;

function requireSafeRegexTest () {
	if (hasRequiredSafeRegexTest) return safeRegexTest;
	hasRequiredSafeRegexTest = 1;

	var callBound = /*@__PURE__*/ requireCallBound();
	var isRegex = requireIsRegex();

	var $exec = callBound('RegExp.prototype.exec');
	var $TypeError = /*@__PURE__*/ requireType();

	/** @type {import('.')} */
	safeRegexTest = function regexTester(regex) {
		if (!isRegex(regex)) {
			throw new $TypeError('`regex` must be a RegExp');
		}
		return function test(s) {
			return $exec(regex, s) !== null;
		};
	};
	return safeRegexTest;
}

var generatorFunction;
var hasRequiredGeneratorFunction;

function requireGeneratorFunction () {
	if (hasRequiredGeneratorFunction) return generatorFunction;
	hasRequiredGeneratorFunction = 1;

	// eslint-disable-next-line no-extra-parens, no-empty-function
	const cached = /** @type {GeneratorFunctionConstructor} */ (function* () {}.constructor);

	/** @type {import('.')} */
	generatorFunction = () => cached;
	return generatorFunction;
}

var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;

function requireIsGeneratorFunction () {
	if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
	hasRequiredIsGeneratorFunction = 1;

	var callBound = /*@__PURE__*/ requireCallBound();
	var safeRegexTest = /*@__PURE__*/ requireSafeRegexTest();
	var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
	var hasToStringTag = requireShams()();
	var getProto = requireGetProto();

	var toStr = callBound('Object.prototype.toString');
	var fnToStr = callBound('Function.prototype.toString');

	var getGeneratorFunction = /*@__PURE__*/ requireGeneratorFunction();

	/** @type {import('.')} */
	isGeneratorFunction = function isGeneratorFunction(fn) {
		if (typeof fn !== 'function') {
			return false;
		}
		if (isFnRegex(fnToStr(fn))) {
			return true;
		}
		if (!hasToStringTag) {
			var str = toStr(fn);
			return str === '[object GeneratorFunction]';
		}
		if (!getProto) {
			return false;
		}
		var GeneratorFunction = getGeneratorFunction();
		return GeneratorFunction && getProto(fn) === GeneratorFunction.prototype;
	};
	return isGeneratorFunction;
}

var isCallable;
var hasRequiredIsCallable;

function requireIsCallable () {
	if (hasRequiredIsCallable) return isCallable;
	hasRequiredIsCallable = 1;
	var fnToStr = Function.prototype.toString;
	var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
	var badArrayLike;
	var isCallableMarker;
	if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
	  try {
	    badArrayLike = Object.defineProperty({}, "length", {
	      get: function() {
	        throw isCallableMarker;
	      }
	    });
	    isCallableMarker = {};
	    reflectApply(function() {
	      throw 42;
	    }, null, badArrayLike);
	  } catch (_) {
	    if (_ !== isCallableMarker) {
	      reflectApply = null;
	    }
	  }
	} else {
	  reflectApply = null;
	}
	var constructorRegex = /^\s*class\b/;
	var isES6ClassFn = function isES6ClassFunction(value) {
	  try {
	    var fnStr = fnToStr.call(value);
	    return constructorRegex.test(fnStr);
	  } catch (e) {
	    return false;
	  }
	};
	var tryFunctionObject = function tryFunctionToStr(value) {
	  try {
	    if (isES6ClassFn(value)) {
	      return false;
	    }
	    fnToStr.call(value);
	    return true;
	  } catch (e) {
	    return false;
	  }
	};
	var toStr = Object.prototype.toString;
	var objectClass = "[object Object]";
	var fnClass = "[object Function]";
	var genClass = "[object GeneratorFunction]";
	var ddaClass = "[object HTMLAllCollection]";
	var ddaClass2 = "[object HTML document.all class]";
	var ddaClass3 = "[object HTMLCollection]";
	var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
	var isIE68 = !(0 in [,]);
	var isDDA = function isDocumentDotAll() {
	  return false;
	};
	if (typeof document === "object") {
	  var all = document.all;
	  if (toStr.call(all) === toStr.call(document.all)) {
	    isDDA = function isDocumentDotAll2(value) {
	      if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
	        try {
	          var str = toStr.call(value);
	          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
	        } catch (e) {
	        }
	      }
	      return false;
	    };
	  }
	}
	isCallable = reflectApply ? function isCallable(value) {
	  if (isDDA(value)) {
	    return true;
	  }
	  if (!value) {
	    return false;
	  }
	  if (typeof value !== "function" && typeof value !== "object") {
	    return false;
	  }
	  try {
	    reflectApply(value, null, badArrayLike);
	  } catch (e) {
	    if (e !== isCallableMarker) {
	      return false;
	    }
	  }
	  return !isES6ClassFn(value) && tryFunctionObject(value);
	} : function isCallable2(value) {
	  if (isDDA(value)) {
	    return true;
	  }
	  if (!value) {
	    return false;
	  }
	  if (typeof value !== "function" && typeof value !== "object") {
	    return false;
	  }
	  if (hasToStringTag) {
	    return tryFunctionObject(value);
	  }
	  if (isES6ClassFn(value)) {
	    return false;
	  }
	  var strClass = toStr.call(value);
	  if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
	    return false;
	  }
	  return tryFunctionObject(value);
	};
	return isCallable;
}

var forEach;
var hasRequiredForEach;

function requireForEach () {
	if (hasRequiredForEach) return forEach;
	hasRequiredForEach = 1;

	var isCallable = requireIsCallable();

	var toStr = Object.prototype.toString;
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */
	var forEachArray = function forEachArray(array, iterator, receiver) {
	    for (var i = 0, len = array.length; i < len; i++) {
	        if (hasOwnProperty.call(array, i)) {
	            if (receiver == null) {
	                iterator(array[i], i, array);
	            } else {
	                iterator.call(receiver, array[i], i, array);
	            }
	        }
	    }
	};

	/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */
	var forEachString = function forEachString(string, iterator, receiver) {
	    for (var i = 0, len = string.length; i < len; i++) {
	        // no such thing as a sparse string.
	        if (receiver == null) {
	            iterator(string.charAt(i), i, string);
	        } else {
	            iterator.call(receiver, string.charAt(i), i, string);
	        }
	    }
	};

	/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */
	var forEachObject = function forEachObject(object, iterator, receiver) {
	    for (var k in object) {
	        if (hasOwnProperty.call(object, k)) {
	            if (receiver == null) {
	                iterator(object[k], k, object);
	            } else {
	                iterator.call(receiver, object[k], k, object);
	            }
	        }
	    }
	};

	/** @type {(x: unknown) => x is readonly unknown[]} */
	function isArray(x) {
	    return toStr.call(x) === '[object Array]';
	}

	/** @type {import('.')._internal} */
	forEach = function forEach(list, iterator, thisArg) {
	    if (!isCallable(iterator)) {
	        throw new TypeError('iterator must be a function');
	    }

	    var receiver;
	    if (arguments.length >= 3) {
	        receiver = thisArg;
	    }

	    if (isArray(list)) {
	        forEachArray(list, iterator, receiver);
	    } else if (typeof list === 'string') {
	        forEachString(list, iterator, receiver);
	    } else {
	        forEachObject(list, iterator, receiver);
	    }
	};
	return forEach;
}

var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;

function requirePossibleTypedArrayNames () {
	if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
	hasRequiredPossibleTypedArrayNames = 1;

	/** @type {import('.')} */
	possibleTypedArrayNames = [
		'Float16Array',
		'Float32Array',
		'Float64Array',
		'Int8Array',
		'Int16Array',
		'Int32Array',
		'Uint8Array',
		'Uint8ClampedArray',
		'Uint16Array',
		'Uint32Array',
		'BigInt64Array',
		'BigUint64Array'
	];
	return possibleTypedArrayNames;
}

var availableTypedArrays;
var hasRequiredAvailableTypedArrays;

function requireAvailableTypedArrays () {
	if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
	hasRequiredAvailableTypedArrays = 1;
	var possibleNames = /*@__PURE__*/ requirePossibleTypedArrayNames();
	var g = typeof globalThis === "undefined" ? globalThis : globalThis;
	availableTypedArrays = function availableTypedArrays() {
	  var out = [];
	  for (var i = 0; i < possibleNames.length; i++) {
	    if (typeof g[possibleNames[i]] === "function") {
	      out[out.length] = possibleNames[i];
	    }
	  }
	  return out;
	};
	return availableTypedArrays;
}

var callBind = {exports: {}};

var defineDataProperty;
var hasRequiredDefineDataProperty;

function requireDefineDataProperty () {
	if (hasRequiredDefineDataProperty) return defineDataProperty;
	hasRequiredDefineDataProperty = 1;

	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var $SyntaxError = /*@__PURE__*/ requireSyntax();
	var $TypeError = /*@__PURE__*/ requireType();

	var gopd = /*@__PURE__*/ requireGopd();

	/** @type {import('.')} */
	defineDataProperty = function defineDataProperty(
		obj,
		property,
		value
	) {
		if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
			throw new $TypeError('`obj` must be an object or a function`');
		}
		if (typeof property !== 'string' && typeof property !== 'symbol') {
			throw new $TypeError('`property` must be a string or a symbol`');
		}
		if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
			throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
			throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
			throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
			throw new $TypeError('`loose`, if provided, must be a boolean');
		}

		var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
		var nonWritable = arguments.length > 4 ? arguments[4] : null;
		var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
		var loose = arguments.length > 6 ? arguments[6] : false;

		/* @type {false | TypedPropertyDescriptor<unknown>} */
		var desc = !!gopd && gopd(obj, property);

		if ($defineProperty) {
			$defineProperty(obj, property, {
				configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
				enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
				value: value,
				writable: nonWritable === null && desc ? desc.writable : !nonWritable
			});
		} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
			// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
			obj[property] = value; // eslint-disable-line no-param-reassign
		} else {
			throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
		}
	};
	return defineDataProperty;
}

var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;

function requireHasPropertyDescriptors () {
	if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
	hasRequiredHasPropertyDescriptors = 1;

	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var hasPropertyDescriptors = function hasPropertyDescriptors() {
		return !!$defineProperty;
	};

	hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
		// node v0.6 has a bug where array lengths can be Set but not Defined
		if (!$defineProperty) {
			return null;
		}
		try {
			return $defineProperty([], 'length', { value: 1 }).length !== 1;
		} catch (e) {
			// In Firefox 4-22, defining length on an array throws an exception.
			return true;
		}
	};

	hasPropertyDescriptors_1 = hasPropertyDescriptors;
	return hasPropertyDescriptors_1;
}

var setFunctionLength;
var hasRequiredSetFunctionLength;

function requireSetFunctionLength () {
	if (hasRequiredSetFunctionLength) return setFunctionLength;
	hasRequiredSetFunctionLength = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
	var define = /*@__PURE__*/ requireDefineDataProperty();
	var hasDescriptors = /*@__PURE__*/ requireHasPropertyDescriptors()();
	var gOPD = /*@__PURE__*/ requireGopd();

	var $TypeError = /*@__PURE__*/ requireType();
	var $floor = GetIntrinsic('%Math.floor%');

	/** @type {import('.')} */
	setFunctionLength = function setFunctionLength(fn, length) {
		if (typeof fn !== 'function') {
			throw new $TypeError('`fn` is not a function');
		}
		if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
			throw new $TypeError('`length` must be a positive 32-bit integer');
		}

		var loose = arguments.length > 2 && !!arguments[2];

		var functionLengthIsConfigurable = true;
		var functionLengthIsWritable = true;
		if ('length' in fn && gOPD) {
			var desc = gOPD(fn, 'length');
			if (desc && !desc.configurable) {
				functionLengthIsConfigurable = false;
			}
			if (desc && !desc.writable) {
				functionLengthIsWritable = false;
			}
		}

		if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
			if (hasDescriptors) {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
			} else {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
			}
		}
		return fn;
	};
	return setFunctionLength;
}

var applyBind;
var hasRequiredApplyBind;

function requireApplyBind () {
	if (hasRequiredApplyBind) return applyBind;
	hasRequiredApplyBind = 1;

	var bind = requireFunctionBind();
	var $apply = requireFunctionApply();
	var actualApply = requireActualApply();

	/** @type {import('./applyBind')} */
	applyBind = function applyBind() {
		return actualApply(bind, $apply, arguments);
	};
	return applyBind;
}

var hasRequiredCallBind;

function requireCallBind () {
	if (hasRequiredCallBind) return callBind.exports;
	hasRequiredCallBind = 1;
	(function (module) {

		var setFunctionLength = /*@__PURE__*/ requireSetFunctionLength();

		var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

		var callBindBasic = requireCallBindApplyHelpers();
		var applyBind = requireApplyBind();

		module.exports = function callBind(originalFunction) {
			var func = callBindBasic(arguments);
			var adjustedLength = originalFunction.length - (arguments.length - 1);
			return setFunctionLength(
				func,
				1 + (adjustedLength > 0 ? adjustedLength : 0),
				true
			);
		};

		if ($defineProperty) {
			$defineProperty(module.exports, 'apply', { value: applyBind });
		} else {
			module.exports.apply = applyBind;
		} 
	} (callBind));
	return callBind.exports;
}

var whichTypedArray;
var hasRequiredWhichTypedArray;

function requireWhichTypedArray () {
	if (hasRequiredWhichTypedArray) return whichTypedArray;
	hasRequiredWhichTypedArray = 1;
	var forEach = requireForEach();
	var availableTypedArrays = /*@__PURE__*/ requireAvailableTypedArrays();
	var callBind = requireCallBind();
	var callBound = /*@__PURE__*/ requireCallBound();
	var gOPD = /*@__PURE__*/ requireGopd();
	var getProto = requireGetProto();
	var $toString = callBound("Object.prototype.toString");
	var hasToStringTag = requireShams()();
	var g = typeof globalThis === "undefined" ? globalThis : globalThis;
	var typedArrays = availableTypedArrays();
	var $slice = callBound("String.prototype.slice");
	var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
	  for (var i = 0; i < array.length; i += 1) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	};
	var cache = { __proto__: null };
	if (hasToStringTag && gOPD && getProto) {
	  forEach(typedArrays, function(typedArray) {
	    var arr = new g[typedArray]();
	    if (Symbol.toStringTag in arr && getProto) {
	      var proto = getProto(arr);
	      var descriptor = gOPD(proto, Symbol.toStringTag);
	      if (!descriptor && proto) {
	        var superProto = getProto(proto);
	        descriptor = gOPD(superProto, Symbol.toStringTag);
	      }
	      if (descriptor && descriptor.get) {
	        var bound = callBind(descriptor.get);
	        cache[
	          /** @type {`$${import('.').TypedArrayName}`} */
	          "$" + typedArray
	        ] = bound;
	      }
	    }
	  });
	} else {
	  forEach(typedArrays, function(typedArray) {
	    var arr = new g[typedArray]();
	    var fn = arr.slice || arr.set;
	    if (fn) {
	      var bound = (
	        /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
	        // @ts-expect-error TODO FIXME
	        callBind(fn)
	      );
	      cache[
	        /** @type {`$${import('.').TypedArrayName}`} */
	        "$" + typedArray
	      ] = bound;
	    }
	  });
	}
	var tryTypedArrays = function tryAllTypedArrays(value) {
	  var found = false;
	  forEach(
	    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
	    cache,
	    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
	    function(getter, typedArray) {
	      if (!found) {
	        try {
	          if ("$" + getter(value) === typedArray) {
	            found = /** @type {import('.').TypedArrayName} */
	            $slice(typedArray, 1);
	          }
	        } catch (e) {
	        }
	      }
	    }
	  );
	  return found;
	};
	var trySlices = function tryAllSlices(value) {
	  var found = false;
	  forEach(
	    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
	    cache,
	    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
	    function(getter, name) {
	      if (!found) {
	        try {
	          getter(value);
	          found = /** @type {import('.').TypedArrayName} */
	          $slice(name, 1);
	        } catch (e) {
	        }
	      }
	    }
	  );
	  return found;
	};
	whichTypedArray = function whichTypedArray(value) {
	  if (!value || typeof value !== "object") {
	    return false;
	  }
	  if (!hasToStringTag) {
	    var tag = $slice($toString(value), 8, -1);
	    if ($indexOf(typedArrays, tag) > -1) {
	      return tag;
	    }
	    if (tag !== "Object") {
	      return false;
	    }
	    return trySlices(value);
	  }
	  if (!gOPD) {
	    return null;
	  }
	  return tryTypedArrays(value);
	};
	return whichTypedArray;
}

var isTypedArray;
var hasRequiredIsTypedArray;

function requireIsTypedArray () {
	if (hasRequiredIsTypedArray) return isTypedArray;
	hasRequiredIsTypedArray = 1;

	var whichTypedArray = /*@__PURE__*/ requireWhichTypedArray();

	/** @type {import('.')} */
	isTypedArray = function isTypedArray(value) {
		return !!whichTypedArray(value);
	};
	return isTypedArray;
}

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	(function (exports$1) {

		var isArgumentsObject = /*@__PURE__*/ requireIsArguments();
		var isGeneratorFunction = requireIsGeneratorFunction();
		var whichTypedArray = /*@__PURE__*/ requireWhichTypedArray();
		var isTypedArray = /*@__PURE__*/ requireIsTypedArray();

		function uncurryThis(f) {
		  return f.call.bind(f);
		}

		var BigIntSupported = typeof BigInt !== 'undefined';
		var SymbolSupported = typeof Symbol !== 'undefined';

		var ObjectToString = uncurryThis(Object.prototype.toString);

		var numberValue = uncurryThis(Number.prototype.valueOf);
		var stringValue = uncurryThis(String.prototype.valueOf);
		var booleanValue = uncurryThis(Boolean.prototype.valueOf);

		if (BigIntSupported) {
		  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
		}

		if (SymbolSupported) {
		  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
		}

		function checkBoxedPrimitive(value, prototypeValueOf) {
		  if (typeof value !== 'object') {
		    return false;
		  }
		  try {
		    prototypeValueOf(value);
		    return true;
		  } catch(e) {
		    return false;
		  }
		}

		exports$1.isArgumentsObject = isArgumentsObject;
		exports$1.isGeneratorFunction = isGeneratorFunction;
		exports$1.isTypedArray = isTypedArray;

		// Taken from here and modified for better browser support
		// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
		function isPromise(input) {
			return (
				(
					typeof Promise !== 'undefined' &&
					input instanceof Promise
				) ||
				(
					input !== null &&
					typeof input === 'object' &&
					typeof input.then === 'function' &&
					typeof input.catch === 'function'
				)
			);
		}
		exports$1.isPromise = isPromise;

		function isArrayBufferView(value) {
		  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
		    return ArrayBuffer.isView(value);
		  }

		  return (
		    isTypedArray(value) ||
		    isDataView(value)
		  );
		}
		exports$1.isArrayBufferView = isArrayBufferView;


		function isUint8Array(value) {
		  return whichTypedArray(value) === 'Uint8Array';
		}
		exports$1.isUint8Array = isUint8Array;

		function isUint8ClampedArray(value) {
		  return whichTypedArray(value) === 'Uint8ClampedArray';
		}
		exports$1.isUint8ClampedArray = isUint8ClampedArray;

		function isUint16Array(value) {
		  return whichTypedArray(value) === 'Uint16Array';
		}
		exports$1.isUint16Array = isUint16Array;

		function isUint32Array(value) {
		  return whichTypedArray(value) === 'Uint32Array';
		}
		exports$1.isUint32Array = isUint32Array;

		function isInt8Array(value) {
		  return whichTypedArray(value) === 'Int8Array';
		}
		exports$1.isInt8Array = isInt8Array;

		function isInt16Array(value) {
		  return whichTypedArray(value) === 'Int16Array';
		}
		exports$1.isInt16Array = isInt16Array;

		function isInt32Array(value) {
		  return whichTypedArray(value) === 'Int32Array';
		}
		exports$1.isInt32Array = isInt32Array;

		function isFloat32Array(value) {
		  return whichTypedArray(value) === 'Float32Array';
		}
		exports$1.isFloat32Array = isFloat32Array;

		function isFloat64Array(value) {
		  return whichTypedArray(value) === 'Float64Array';
		}
		exports$1.isFloat64Array = isFloat64Array;

		function isBigInt64Array(value) {
		  return whichTypedArray(value) === 'BigInt64Array';
		}
		exports$1.isBigInt64Array = isBigInt64Array;

		function isBigUint64Array(value) {
		  return whichTypedArray(value) === 'BigUint64Array';
		}
		exports$1.isBigUint64Array = isBigUint64Array;

		function isMapToString(value) {
		  return ObjectToString(value) === '[object Map]';
		}
		isMapToString.working = (
		  typeof Map !== 'undefined' &&
		  isMapToString(new Map())
		);

		function isMap(value) {
		  if (typeof Map === 'undefined') {
		    return false;
		  }

		  return isMapToString.working
		    ? isMapToString(value)
		    : value instanceof Map;
		}
		exports$1.isMap = isMap;

		function isSetToString(value) {
		  return ObjectToString(value) === '[object Set]';
		}
		isSetToString.working = (
		  typeof Set !== 'undefined' &&
		  isSetToString(new Set())
		);
		function isSet(value) {
		  if (typeof Set === 'undefined') {
		    return false;
		  }

		  return isSetToString.working
		    ? isSetToString(value)
		    : value instanceof Set;
		}
		exports$1.isSet = isSet;

		function isWeakMapToString(value) {
		  return ObjectToString(value) === '[object WeakMap]';
		}
		isWeakMapToString.working = (
		  typeof WeakMap !== 'undefined' &&
		  isWeakMapToString(new WeakMap())
		);
		function isWeakMap(value) {
		  if (typeof WeakMap === 'undefined') {
		    return false;
		  }

		  return isWeakMapToString.working
		    ? isWeakMapToString(value)
		    : value instanceof WeakMap;
		}
		exports$1.isWeakMap = isWeakMap;

		function isWeakSetToString(value) {
		  return ObjectToString(value) === '[object WeakSet]';
		}
		isWeakSetToString.working = (
		  typeof WeakSet !== 'undefined' &&
		  isWeakSetToString(new WeakSet())
		);
		function isWeakSet(value) {
		  return isWeakSetToString(value);
		}
		exports$1.isWeakSet = isWeakSet;

		function isArrayBufferToString(value) {
		  return ObjectToString(value) === '[object ArrayBuffer]';
		}
		isArrayBufferToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  isArrayBufferToString(new ArrayBuffer())
		);
		function isArrayBuffer(value) {
		  if (typeof ArrayBuffer === 'undefined') {
		    return false;
		  }

		  return isArrayBufferToString.working
		    ? isArrayBufferToString(value)
		    : value instanceof ArrayBuffer;
		}
		exports$1.isArrayBuffer = isArrayBuffer;

		function isDataViewToString(value) {
		  return ObjectToString(value) === '[object DataView]';
		}
		isDataViewToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  typeof DataView !== 'undefined' &&
		  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
		);
		function isDataView(value) {
		  if (typeof DataView === 'undefined') {
		    return false;
		  }

		  return isDataViewToString.working
		    ? isDataViewToString(value)
		    : value instanceof DataView;
		}
		exports$1.isDataView = isDataView;

		// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
		var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
		function isSharedArrayBufferToString(value) {
		  return ObjectToString(value) === '[object SharedArrayBuffer]';
		}
		function isSharedArrayBuffer(value) {
		  if (typeof SharedArrayBufferCopy === 'undefined') {
		    return false;
		  }

		  if (typeof isSharedArrayBufferToString.working === 'undefined') {
		    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
		  }

		  return isSharedArrayBufferToString.working
		    ? isSharedArrayBufferToString(value)
		    : value instanceof SharedArrayBufferCopy;
		}
		exports$1.isSharedArrayBuffer = isSharedArrayBuffer;

		function isAsyncFunction(value) {
		  return ObjectToString(value) === '[object AsyncFunction]';
		}
		exports$1.isAsyncFunction = isAsyncFunction;

		function isMapIterator(value) {
		  return ObjectToString(value) === '[object Map Iterator]';
		}
		exports$1.isMapIterator = isMapIterator;

		function isSetIterator(value) {
		  return ObjectToString(value) === '[object Set Iterator]';
		}
		exports$1.isSetIterator = isSetIterator;

		function isGeneratorObject(value) {
		  return ObjectToString(value) === '[object Generator]';
		}
		exports$1.isGeneratorObject = isGeneratorObject;

		function isWebAssemblyCompiledModule(value) {
		  return ObjectToString(value) === '[object WebAssembly.Module]';
		}
		exports$1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

		function isNumberObject(value) {
		  return checkBoxedPrimitive(value, numberValue);
		}
		exports$1.isNumberObject = isNumberObject;

		function isStringObject(value) {
		  return checkBoxedPrimitive(value, stringValue);
		}
		exports$1.isStringObject = isStringObject;

		function isBooleanObject(value) {
		  return checkBoxedPrimitive(value, booleanValue);
		}
		exports$1.isBooleanObject = isBooleanObject;

		function isBigIntObject(value) {
		  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
		}
		exports$1.isBigIntObject = isBigIntObject;

		function isSymbolObject(value) {
		  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
		}
		exports$1.isSymbolObject = isSymbolObject;

		function isBoxedPrimitive(value) {
		  return (
		    isNumberObject(value) ||
		    isStringObject(value) ||
		    isBooleanObject(value) ||
		    isBigIntObject(value) ||
		    isSymbolObject(value)
		  );
		}
		exports$1.isBoxedPrimitive = isBoxedPrimitive;

		function isAnyArrayBuffer(value) {
		  return typeof Uint8Array !== 'undefined' && (
		    isArrayBuffer(value) ||
		    isSharedArrayBuffer(value)
		  );
		}
		exports$1.isAnyArrayBuffer = isAnyArrayBuffer;

		['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
		  Object.defineProperty(exports$1, method, {
		    enumerable: false,
		    value: function() {
		      throw new Error(method + ' is not supported in userland');
		    }
		  });
		}); 
	} (types));
	return types;
}

var isBuffer;
var hasRequiredIsBuffer;

function requireIsBuffer () {
	if (hasRequiredIsBuffer) return isBuffer;
	hasRequiredIsBuffer = 1;
	isBuffer = function isBuffer(arg) {
	  return arg instanceof Buffer;
	};
	return isBuffer;
}

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports$1) {
		// Copyright Joyent, Inc. and other Node contributors.
		//
		// Permission is hereby granted, free of charge, to any person obtaining a
		// copy of this software and associated documentation files (the
		// "Software"), to deal in the Software without restriction, including
		// without limitation the rights to use, copy, modify, merge, publish,
		// distribute, sublicense, and/or sell copies of the Software, and to permit
		// persons to whom the Software is furnished to do so, subject to the
		// following conditions:
		//
		// The above copyright notice and this permission notice shall be included
		// in all copies or substantial portions of the Software.
		//
		// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
		// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
		// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
		// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
		// USE OR OTHER DEALINGS IN THE SOFTWARE.

		var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
		  function getOwnPropertyDescriptors(obj) {
		    var keys = Object.keys(obj);
		    var descriptors = {};
		    for (var i = 0; i < keys.length; i++) {
		      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
		    }
		    return descriptors;
		  };

		var formatRegExp = /%[sdj%]/g;
		exports$1.format = function(f) {
		  if (!isString(f)) {
		    var objects = [];
		    for (var i = 0; i < arguments.length; i++) {
		      objects.push(inspect(arguments[i]));
		    }
		    return objects.join(' ');
		  }

		  var i = 1;
		  var args = arguments;
		  var len = args.length;
		  var str = String(f).replace(formatRegExp, function(x) {
		    if (x === '%%') return '%';
		    if (i >= len) return x;
		    switch (x) {
		      case '%s': return String(args[i++]);
		      case '%d': return Number(args[i++]);
		      case '%j':
		        try {
		          return JSON.stringify(args[i++]);
		        } catch (_) {
		          return '[Circular]';
		        }
		      default:
		        return x;
		    }
		  });
		  for (var x = args[i]; i < len; x = args[++i]) {
		    if (isNull(x) || !isObject(x)) {
		      str += ' ' + x;
		    } else {
		      str += ' ' + inspect(x);
		    }
		  }
		  return str;
		};


		// Mark that a method should not be used.
		// Returns a modified function which warns once by default.
		// If --no-deprecation is set, then it is a no-op.
		exports$1.deprecate = function(fn, msg) {
		  if (typeof process$1 !== 'undefined' && process$1.noDeprecation === true) {
		    return fn;
		  }

		  // Allow for deprecating things in the process of starting up.
		  if (typeof process$1 === 'undefined') {
		    return function() {
		      return exports$1.deprecate(fn, msg).apply(this, arguments);
		    };
		  }

		  var warned = false;
		  function deprecated() {
		    if (!warned) {
		      if (process$1.throwDeprecation) {
		        throw new Error(msg);
		      } else if (process$1.traceDeprecation) {
		        console.trace(msg);
		      } else {
		        console.error(msg);
		      }
		      warned = true;
		    }
		    return fn.apply(this, arguments);
		  }

		  return deprecated;
		};


		var debugs = {};
		var debugEnvRegex = /^$/;

		if (process$1.env.NODE_DEBUG) {
		  var debugEnv = process$1.env.NODE_DEBUG;
		  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
		    .replace(/\*/g, '.*')
		    .replace(/,/g, '$|^')
		    .toUpperCase();
		  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
		}
		exports$1.debuglog = function(set) {
		  set = set.toUpperCase();
		  if (!debugs[set]) {
		    if (debugEnvRegex.test(set)) {
		      var pid = process$1.pid;
		      debugs[set] = function() {
		        var msg = exports$1.format.apply(exports$1, arguments);
		        console.error('%s %d: %s', set, pid, msg);
		      };
		    } else {
		      debugs[set] = function() {};
		    }
		  }
		  return debugs[set];
		};


		/**
		 * Echos the value of a value. Trys to print the value out
		 * in the best way possible given the different types.
		 *
		 * @param {Object} obj The object to print out.
		 * @param {Object} opts Optional options object that alters the output.
		 */
		/* legacy: obj, showHidden, depth, colors*/
		function inspect(obj, opts) {
		  // default options
		  var ctx = {
		    seen: [],
		    stylize: stylizeNoColor
		  };
		  // legacy...
		  if (arguments.length >= 3) ctx.depth = arguments[2];
		  if (arguments.length >= 4) ctx.colors = arguments[3];
		  if (isBoolean(opts)) {
		    // legacy...
		    ctx.showHidden = opts;
		  } else if (opts) {
		    // got an "options" object
		    exports$1._extend(ctx, opts);
		  }
		  // set default options
		  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
		  if (isUndefined(ctx.depth)) ctx.depth = 2;
		  if (isUndefined(ctx.colors)) ctx.colors = false;
		  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
		  if (ctx.colors) ctx.stylize = stylizeWithColor;
		  return formatValue(ctx, obj, ctx.depth);
		}
		exports$1.inspect = inspect;


		// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
		inspect.colors = {
		  'bold' : [1, 22],
		  'italic' : [3, 23],
		  'underline' : [4, 24],
		  'inverse' : [7, 27],
		  'white' : [37, 39],
		  'grey' : [90, 39],
		  'black' : [30, 39],
		  'blue' : [34, 39],
		  'cyan' : [36, 39],
		  'green' : [32, 39],
		  'magenta' : [35, 39],
		  'red' : [31, 39],
		  'yellow' : [33, 39]
		};

		// Don't use 'blue' not visible on cmd.exe
		inspect.styles = {
		  'special': 'cyan',
		  'number': 'yellow',
		  'boolean': 'yellow',
		  'undefined': 'grey',
		  'null': 'bold',
		  'string': 'green',
		  'date': 'magenta',
		  // "name": intentionally not styling
		  'regexp': 'red'
		};


		function stylizeWithColor(str, styleType) {
		  var style = inspect.styles[styleType];

		  if (style) {
		    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
		           '\u001b[' + inspect.colors[style][1] + 'm';
		  } else {
		    return str;
		  }
		}


		function stylizeNoColor(str, styleType) {
		  return str;
		}


		function arrayToHash(array) {
		  var hash = {};

		  array.forEach(function(val, idx) {
		    hash[val] = true;
		  });

		  return hash;
		}


		function formatValue(ctx, value, recurseTimes) {
		  // Provide a hook for user-specified inspect functions.
		  // Check that value is an object with an inspect function on it
		  if (ctx.customInspect &&
		      value &&
		      isFunction(value.inspect) &&
		      // Filter out the util module, it's inspect function is special
		      value.inspect !== exports$1.inspect &&
		      // Also filter out any prototype objects using the circular check.
		      !(value.constructor && value.constructor.prototype === value)) {
		    var ret = value.inspect(recurseTimes, ctx);
		    if (!isString(ret)) {
		      ret = formatValue(ctx, ret, recurseTimes);
		    }
		    return ret;
		  }

		  // Primitive types cannot have properties
		  var primitive = formatPrimitive(ctx, value);
		  if (primitive) {
		    return primitive;
		  }

		  // Look up the keys of the object.
		  var keys = Object.keys(value);
		  var visibleKeys = arrayToHash(keys);

		  if (ctx.showHidden) {
		    keys = Object.getOwnPropertyNames(value);
		  }

		  // IE doesn't make error fields non-enumerable
		  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
		  if (isError(value)
		      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
		    return formatError(value);
		  }

		  // Some type of object without properties can be shortcutted.
		  if (keys.length === 0) {
		    if (isFunction(value)) {
		      var name = value.name ? ': ' + value.name : '';
		      return ctx.stylize('[Function' + name + ']', 'special');
		    }
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    }
		    if (isDate(value)) {
		      return ctx.stylize(Date.prototype.toString.call(value), 'date');
		    }
		    if (isError(value)) {
		      return formatError(value);
		    }
		  }

		  var base = '', array = false, braces = ['{', '}'];

		  // Make Array say that they are Array
		  if (isArray(value)) {
		    array = true;
		    braces = ['[', ']'];
		  }

		  // Make functions say that they are functions
		  if (isFunction(value)) {
		    var n = value.name ? ': ' + value.name : '';
		    base = ' [Function' + n + ']';
		  }

		  // Make RegExps say that they are RegExps
		  if (isRegExp(value)) {
		    base = ' ' + RegExp.prototype.toString.call(value);
		  }

		  // Make dates with properties first say the date
		  if (isDate(value)) {
		    base = ' ' + Date.prototype.toUTCString.call(value);
		  }

		  // Make error with message first say the error
		  if (isError(value)) {
		    base = ' ' + formatError(value);
		  }

		  if (keys.length === 0 && (!array || value.length == 0)) {
		    return braces[0] + base + braces[1];
		  }

		  if (recurseTimes < 0) {
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
		    } else {
		      return ctx.stylize('[Object]', 'special');
		    }
		  }

		  ctx.seen.push(value);

		  var output;
		  if (array) {
		    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
		  } else {
		    output = keys.map(function(key) {
		      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
		    });
		  }

		  ctx.seen.pop();

		  return reduceToSingleString(output, base, braces);
		}


		function formatPrimitive(ctx, value) {
		  if (isUndefined(value))
		    return ctx.stylize('undefined', 'undefined');
		  if (isString(value)) {
		    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
		                                             .replace(/'/g, "\\'")
		                                             .replace(/\\"/g, '"') + '\'';
		    return ctx.stylize(simple, 'string');
		  }
		  if (isNumber(value))
		    return ctx.stylize('' + value, 'number');
		  if (isBoolean(value))
		    return ctx.stylize('' + value, 'boolean');
		  // For some reason typeof null is "object", so special case here.
		  if (isNull(value))
		    return ctx.stylize('null', 'null');
		}


		function formatError(value) {
		  return '[' + Error.prototype.toString.call(value) + ']';
		}


		function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
		  var output = [];
		  for (var i = 0, l = value.length; i < l; ++i) {
		    if (hasOwnProperty(value, String(i))) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          String(i), true));
		    } else {
		      output.push('');
		    }
		  }
		  keys.forEach(function(key) {
		    if (!key.match(/^\d+$/)) {
		      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
		          key, true));
		    }
		  });
		  return output;
		}


		function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
		  var name, str, desc;
		  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
		  if (desc.get) {
		    if (desc.set) {
		      str = ctx.stylize('[Getter/Setter]', 'special');
		    } else {
		      str = ctx.stylize('[Getter]', 'special');
		    }
		  } else {
		    if (desc.set) {
		      str = ctx.stylize('[Setter]', 'special');
		    }
		  }
		  if (!hasOwnProperty(visibleKeys, key)) {
		    name = '[' + key + ']';
		  }
		  if (!str) {
		    if (ctx.seen.indexOf(desc.value) < 0) {
		      if (isNull(recurseTimes)) {
		        str = formatValue(ctx, desc.value, null);
		      } else {
		        str = formatValue(ctx, desc.value, recurseTimes - 1);
		      }
		      if (str.indexOf('\n') > -1) {
		        if (array) {
		          str = str.split('\n').map(function(line) {
		            return '  ' + line;
		          }).join('\n').slice(2);
		        } else {
		          str = '\n' + str.split('\n').map(function(line) {
		            return '   ' + line;
		          }).join('\n');
		        }
		      }
		    } else {
		      str = ctx.stylize('[Circular]', 'special');
		    }
		  }
		  if (isUndefined(name)) {
		    if (array && key.match(/^\d+$/)) {
		      return str;
		    }
		    name = JSON.stringify('' + key);
		    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
		      name = name.slice(1, -1);
		      name = ctx.stylize(name, 'name');
		    } else {
		      name = name.replace(/'/g, "\\'")
		                 .replace(/\\"/g, '"')
		                 .replace(/(^"|"$)/g, "'");
		      name = ctx.stylize(name, 'string');
		    }
		  }

		  return name + ': ' + str;
		}


		function reduceToSingleString(output, base, braces) {
		  var length = output.reduce(function(prev, cur) {
		    if (cur.indexOf('\n') >= 0) ;
		    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
		  }, 0);

		  if (length > 60) {
		    return braces[0] +
		           (base === '' ? '' : base + '\n ') +
		           ' ' +
		           output.join(',\n  ') +
		           ' ' +
		           braces[1];
		  }

		  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
		}


		// NOTE: These type checking functions intentionally don't use `instanceof`
		// because it is fragile and can be easily faked with `Object.create()`.
		exports$1.types = requireTypes();

		function isArray(ar) {
		  return Array.isArray(ar);
		}
		exports$1.isArray = isArray;

		function isBoolean(arg) {
		  return typeof arg === 'boolean';
		}
		exports$1.isBoolean = isBoolean;

		function isNull(arg) {
		  return arg === null;
		}
		exports$1.isNull = isNull;

		function isNullOrUndefined(arg) {
		  return arg == null;
		}
		exports$1.isNullOrUndefined = isNullOrUndefined;

		function isNumber(arg) {
		  return typeof arg === 'number';
		}
		exports$1.isNumber = isNumber;

		function isString(arg) {
		  return typeof arg === 'string';
		}
		exports$1.isString = isString;

		function isSymbol(arg) {
		  return typeof arg === 'symbol';
		}
		exports$1.isSymbol = isSymbol;

		function isUndefined(arg) {
		  return arg === void 0;
		}
		exports$1.isUndefined = isUndefined;

		function isRegExp(re) {
		  return isObject(re) && objectToString(re) === '[object RegExp]';
		}
		exports$1.isRegExp = isRegExp;
		exports$1.types.isRegExp = isRegExp;

		function isObject(arg) {
		  return typeof arg === 'object' && arg !== null;
		}
		exports$1.isObject = isObject;

		function isDate(d) {
		  return isObject(d) && objectToString(d) === '[object Date]';
		}
		exports$1.isDate = isDate;
		exports$1.types.isDate = isDate;

		function isError(e) {
		  return isObject(e) &&
		      (objectToString(e) === '[object Error]' || e instanceof Error);
		}
		exports$1.isError = isError;
		exports$1.types.isNativeError = isError;

		function isFunction(arg) {
		  return typeof arg === 'function';
		}
		exports$1.isFunction = isFunction;

		function isPrimitive(arg) {
		  return arg === null ||
		         typeof arg === 'boolean' ||
		         typeof arg === 'number' ||
		         typeof arg === 'string' ||
		         typeof arg === 'symbol' ||  // ES6 symbol
		         typeof arg === 'undefined';
		}
		exports$1.isPrimitive = isPrimitive;

		exports$1.isBuffer = requireIsBuffer();

		function objectToString(o) {
		  return Object.prototype.toString.call(o);
		}


		function pad(n) {
		  return n < 10 ? '0' + n.toString(10) : n.toString(10);
		}


		var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
		              'Oct', 'Nov', 'Dec'];

		// 26 Feb 16:19:34
		function timestamp() {
		  var d = new Date();
		  var time = [pad(d.getHours()),
		              pad(d.getMinutes()),
		              pad(d.getSeconds())].join(':');
		  return [d.getDate(), months[d.getMonth()], time].join(' ');
		}


		// log is just a thin wrapper to console.log that prepends a timestamp
		exports$1.log = function() {
		  console.log('%s - %s', timestamp(), exports$1.format.apply(exports$1, arguments));
		};


		/**
		 * Inherit the prototype methods from one constructor into another.
		 *
		 * The Function.prototype.inherits from lang.js rewritten as a standalone
		 * function (not on Function.prototype). NOTE: If this file is to be loaded
		 * during bootstrapping this function needs to be rewritten using some native
		 * functions as prototype setup using normal JavaScript does not work as
		 * expected during bootstrapping (see mirror.js in r114903).
		 *
		 * @param {function} ctor Constructor function which needs to inherit the
		 *     prototype.
		 * @param {function} superCtor Constructor function to inherit prototype from.
		 */
		exports$1.inherits = requireInherits();

		exports$1._extend = function(origin, add) {
		  // Don't do anything if add isn't an object
		  if (!add || !isObject(add)) return origin;

		  var keys = Object.keys(add);
		  var i = keys.length;
		  while (i--) {
		    origin[keys[i]] = add[keys[i]];
		  }
		  return origin;
		};

		function hasOwnProperty(obj, prop) {
		  return Object.prototype.hasOwnProperty.call(obj, prop);
		}

		var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

		exports$1.promisify = function promisify(original) {
		  if (typeof original !== 'function')
		    throw new TypeError('The "original" argument must be of type Function');

		  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
		    var fn = original[kCustomPromisifiedSymbol];
		    if (typeof fn !== 'function') {
		      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
		    }
		    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		      value: fn, enumerable: false, writable: false, configurable: true
		    });
		    return fn;
		  }

		  function fn() {
		    var promiseResolve, promiseReject;
		    var promise = new Promise(function (resolve, reject) {
		      promiseResolve = resolve;
		      promiseReject = reject;
		    });

		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }
		    args.push(function (err, value) {
		      if (err) {
		        promiseReject(err);
		      } else {
		        promiseResolve(value);
		      }
		    });

		    try {
		      original.apply(this, args);
		    } catch (err) {
		      promiseReject(err);
		    }

		    return promise;
		  }

		  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

		  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		    value: fn, enumerable: false, writable: false, configurable: true
		  });
		  return Object.defineProperties(
		    fn,
		    getOwnPropertyDescriptors(original)
		  );
		};

		exports$1.promisify.custom = kCustomPromisifiedSymbol;

		function callbackifyOnRejected(reason, cb) {
		  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
		  // Because `null` is a special error value in callbacks which means "no error
		  // occurred", we error-wrap so the callback consumer can distinguish between
		  // "the promise rejected with null" or "the promise fulfilled with undefined".
		  if (!reason) {
		    var newReason = new Error('Promise was rejected with a falsy value');
		    newReason.reason = reason;
		    reason = newReason;
		  }
		  return cb(reason);
		}

		function callbackify(original) {
		  if (typeof original !== 'function') {
		    throw new TypeError('The "original" argument must be of type Function');
		  }

		  // We DO NOT return the promise as it gives the user a false sense that
		  // the promise is actually somehow related to the callback's execution
		  // and that the callback throwing will reject the promise.
		  function callbackified() {
		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }

		    var maybeCb = args.pop();
		    if (typeof maybeCb !== 'function') {
		      throw new TypeError('The last argument must be of type Function');
		    }
		    var self = this;
		    var cb = function() {
		      return maybeCb.apply(self, arguments);
		    };
		    // In true node style we process the callback on `nextTick` with all the
		    // implications (stack, `uncaughtException`, `async_hooks`)
		    original.apply(this, args)
		      .then(function(ret) { process$1.nextTick(cb.bind(null, null, ret)); },
		            function(rej) { process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
		  }

		  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
		  Object.defineProperties(callbackified,
		                          getOwnPropertyDescriptors(original));
		  return callbackified;
		}
		exports$1.callbackify = callbackify; 
	} (util));
	return util;
}

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = requireUtil();
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

var safeBuffer = {exports: {}};

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function (exports$1) {
		Object.defineProperties(exports$1, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
		var buffer = {};
		var base64Js = {};
		base64Js.byteLength = byteLength;
		base64Js.toByteArray = toByteArray;
		base64Js.fromByteArray = fromByteArray;
		var lookup = [];
		var revLookup = [];
		var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
		var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		for (var i = 0, len = code.length; i < len; ++i) {
		  lookup[i] = code[i];
		  revLookup[code.charCodeAt(i)] = i;
		}
		revLookup["-".charCodeAt(0)] = 62;
		revLookup["_".charCodeAt(0)] = 63;
		function getLens(b64) {
		  var len2 = b64.length;
		  if (len2 % 4 > 0) {
		    throw new Error("Invalid string. Length must be a multiple of 4");
		  }
		  var validLen = b64.indexOf("=");
		  if (validLen === -1) validLen = len2;
		  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
		  return [validLen, placeHoldersLen];
		}
		function byteLength(b64) {
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];
		  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
		}
		function _byteLength(b64, validLen, placeHoldersLen) {
		  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
		}
		function toByteArray(b64) {
		  var tmp;
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];
		  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		  var curByte = 0;
		  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		  var i2;
		  for (i2 = 0; i2 < len2; i2 += 4) {
		    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
		    arr[curByte++] = tmp >> 16 & 255;
		    arr[curByte++] = tmp >> 8 & 255;
		    arr[curByte++] = tmp & 255;
		  }
		  if (placeHoldersLen === 2) {
		    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
		    arr[curByte++] = tmp & 255;
		  }
		  if (placeHoldersLen === 1) {
		    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
		    arr[curByte++] = tmp >> 8 & 255;
		    arr[curByte++] = tmp & 255;
		  }
		  return arr;
		}
		function tripletToBase64(num) {
		  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
		}
		function encodeChunk(uint8, start, end) {
		  var tmp;
		  var output = [];
		  for (var i2 = start; i2 < end; i2 += 3) {
		    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
		    output.push(tripletToBase64(tmp));
		  }
		  return output.join("");
		}
		function fromByteArray(uint8) {
		  var tmp;
		  var len2 = uint8.length;
		  var extraBytes = len2 % 3;
		  var parts = [];
		  var maxChunkLength = 16383;
		  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
		    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
		  }
		  if (extraBytes === 1) {
		    tmp = uint8[len2 - 1];
		    parts.push(
		      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
		    );
		  } else if (extraBytes === 2) {
		    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
		    parts.push(
		      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
		    );
		  }
		  return parts.join("");
		}
		var ieee754 = {};
		/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
		ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
		  var e, m;
		  var eLen = nBytes * 8 - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var nBits = -7;
		  var i2 = isLE ? nBytes - 1 : 0;
		  var d = isLE ? -1 : 1;
		  var s = buffer2[offset + i2];
		  i2 += d;
		  e = s & (1 << -nBits) - 1;
		  s >>= -nBits;
		  nBits += eLen;
		  for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
		  }
		  m = e & (1 << -nBits) - 1;
		  e >>= -nBits;
		  nBits += mLen;
		  for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
		  }
		  if (e === 0) {
		    e = 1 - eBias;
		  } else if (e === eMax) {
		    return m ? NaN : (s ? -1 : 1) * Infinity;
		  } else {
		    m = m + Math.pow(2, mLen);
		    e = e - eBias;
		  }
		  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
		};
		ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
		  var e, m, c;
		  var eLen = nBytes * 8 - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
		  var i2 = isLE ? 0 : nBytes - 1;
		  var d = isLE ? 1 : -1;
		  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
		  value = Math.abs(value);
		  if (isNaN(value) || value === Infinity) {
		    m = isNaN(value) ? 1 : 0;
		    e = eMax;
		  } else {
		    e = Math.floor(Math.log(value) / Math.LN2);
		    if (value * (c = Math.pow(2, -e)) < 1) {
		      e--;
		      c *= 2;
		    }
		    if (e + eBias >= 1) {
		      value += rt / c;
		    } else {
		      value += rt * Math.pow(2, 1 - eBias);
		    }
		    if (value * c >= 2) {
		      e++;
		      c /= 2;
		    }
		    if (e + eBias >= eMax) {
		      m = 0;
		      e = eMax;
		    } else if (e + eBias >= 1) {
		      m = (value * c - 1) * Math.pow(2, mLen);
		      e = e + eBias;
		    } else {
		      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
		      e = 0;
		    }
		  }
		  for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
		  }
		  e = e << mLen | m;
		  eLen += mLen;
		  for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
		  }
		  buffer2[offset + i2 - d] |= s * 128;
		};
		/*!
		 * The buffer module from node.js, for the browser.
		 *
		 * @author   Feross Aboukhadijeh <https://feross.org>
		 * @license  MIT
		 */
		(function(exports2) {
		  const base64 = base64Js;
		  const ieee754$1 = ieee754;
		  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
		  exports2.Buffer = Buffer2;
		  exports2.SlowBuffer = SlowBuffer;
		  exports2.INSPECT_MAX_BYTES = 50;
		  const K_MAX_LENGTH = 2147483647;
		  exports2.kMaxLength = K_MAX_LENGTH;
		  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
		  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
		  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
		    console.error(
		      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
		    );
		  }
		  function typedArraySupport() {
		    try {
		      const arr = new GlobalUint8Array(1);
		      const proto = { foo: function() {
		        return 42;
		      } };
		      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
		      Object.setPrototypeOf(arr, proto);
		      return arr.foo() === 42;
		    } catch (e) {
		      return false;
		    }
		  }
		  Object.defineProperty(Buffer2.prototype, "parent", {
		    enumerable: true,
		    get: function() {
		      if (!Buffer2.isBuffer(this)) return void 0;
		      return this.buffer;
		    }
		  });
		  Object.defineProperty(Buffer2.prototype, "offset", {
		    enumerable: true,
		    get: function() {
		      if (!Buffer2.isBuffer(this)) return void 0;
		      return this.byteOffset;
		    }
		  });
		  function createBuffer(length) {
		    if (length > K_MAX_LENGTH) {
		      throw new RangeError('The value "' + length + '" is invalid for option "size"');
		    }
		    const buf = new GlobalUint8Array(length);
		    Object.setPrototypeOf(buf, Buffer2.prototype);
		    return buf;
		  }
		  function Buffer2(arg, encodingOrOffset, length) {
		    if (typeof arg === "number") {
		      if (typeof encodingOrOffset === "string") {
		        throw new TypeError(
		          'The "string" argument must be of type string. Received type number'
		        );
		      }
		      return allocUnsafe(arg);
		    }
		    return from(arg, encodingOrOffset, length);
		  }
		  Buffer2.poolSize = 8192;
		  function from(value, encodingOrOffset, length) {
		    if (typeof value === "string") {
		      return fromString(value, encodingOrOffset);
		    }
		    if (GlobalArrayBuffer.isView(value)) {
		      return fromArrayView(value);
		    }
		    if (value == null) {
		      throw new TypeError(
		        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
		      );
		    }
		    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
		      return fromArrayBuffer(value, encodingOrOffset, length);
		    }
		    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
		      return fromArrayBuffer(value, encodingOrOffset, length);
		    }
		    if (typeof value === "number") {
		      throw new TypeError(
		        'The "value" argument must not be of type number. Received type number'
		      );
		    }
		    const valueOf = value.valueOf && value.valueOf();
		    if (valueOf != null && valueOf !== value) {
		      return Buffer2.from(valueOf, encodingOrOffset, length);
		    }
		    const b = fromObject(value);
		    if (b) return b;
		    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
		      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
		    }
		    throw new TypeError(
		      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
		    );
		  }
		  Buffer2.from = function(value, encodingOrOffset, length) {
		    return from(value, encodingOrOffset, length);
		  };
		  Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
		  Object.setPrototypeOf(Buffer2, GlobalUint8Array);
		  function assertSize(size) {
		    if (typeof size !== "number") {
		      throw new TypeError('"size" argument must be of type number');
		    } else if (size < 0) {
		      throw new RangeError('The value "' + size + '" is invalid for option "size"');
		    }
		  }
		  function alloc(size, fill, encoding) {
		    assertSize(size);
		    if (size <= 0) {
		      return createBuffer(size);
		    }
		    if (fill !== void 0) {
		      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
		    }
		    return createBuffer(size);
		  }
		  Buffer2.alloc = function(size, fill, encoding) {
		    return alloc(size, fill, encoding);
		  };
		  function allocUnsafe(size) {
		    assertSize(size);
		    return createBuffer(size < 0 ? 0 : checked(size) | 0);
		  }
		  Buffer2.allocUnsafe = function(size) {
		    return allocUnsafe(size);
		  };
		  Buffer2.allocUnsafeSlow = function(size) {
		    return allocUnsafe(size);
		  };
		  function fromString(string, encoding) {
		    if (typeof encoding !== "string" || encoding === "") {
		      encoding = "utf8";
		    }
		    if (!Buffer2.isEncoding(encoding)) {
		      throw new TypeError("Unknown encoding: " + encoding);
		    }
		    const length = byteLength2(string, encoding) | 0;
		    let buf = createBuffer(length);
		    const actual = buf.write(string, encoding);
		    if (actual !== length) {
		      buf = buf.slice(0, actual);
		    }
		    return buf;
		  }
		  function fromArrayLike(array) {
		    const length = array.length < 0 ? 0 : checked(array.length) | 0;
		    const buf = createBuffer(length);
		    for (let i2 = 0; i2 < length; i2 += 1) {
		      buf[i2] = array[i2] & 255;
		    }
		    return buf;
		  }
		  function fromArrayView(arrayView) {
		    if (isInstance(arrayView, GlobalUint8Array)) {
		      const copy = new GlobalUint8Array(arrayView);
		      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
		    }
		    return fromArrayLike(arrayView);
		  }
		  function fromArrayBuffer(array, byteOffset, length) {
		    if (byteOffset < 0 || array.byteLength < byteOffset) {
		      throw new RangeError('"offset" is outside of buffer bounds');
		    }
		    if (array.byteLength < byteOffset + (length || 0)) {
		      throw new RangeError('"length" is outside of buffer bounds');
		    }
		    let buf;
		    if (byteOffset === void 0 && length === void 0) {
		      buf = new GlobalUint8Array(array);
		    } else if (length === void 0) {
		      buf = new GlobalUint8Array(array, byteOffset);
		    } else {
		      buf = new GlobalUint8Array(array, byteOffset, length);
		    }
		    Object.setPrototypeOf(buf, Buffer2.prototype);
		    return buf;
		  }
		  function fromObject(obj) {
		    if (Buffer2.isBuffer(obj)) {
		      const len2 = checked(obj.length) | 0;
		      const buf = createBuffer(len2);
		      if (buf.length === 0) {
		        return buf;
		      }
		      obj.copy(buf, 0, 0, len2);
		      return buf;
		    }
		    if (obj.length !== void 0) {
		      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
		        return createBuffer(0);
		      }
		      return fromArrayLike(obj);
		    }
		    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
		      return fromArrayLike(obj.data);
		    }
		  }
		  function checked(length) {
		    if (length >= K_MAX_LENGTH) {
		      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
		    }
		    return length | 0;
		  }
		  function SlowBuffer(length) {
		    if (+length != length) {
		      length = 0;
		    }
		    return Buffer2.alloc(+length);
		  }
		  Buffer2.isBuffer = function isBuffer(b) {
		    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
		  };
		  Buffer2.compare = function compare(a, b) {
		    if (isInstance(a, GlobalUint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
		    if (isInstance(b, GlobalUint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
		    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
		      throw new TypeError(
		        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
		      );
		    }
		    if (a === b) return 0;
		    let x = a.length;
		    let y = b.length;
		    for (let i2 = 0, len2 = Math.min(x, y); i2 < len2; ++i2) {
		      if (a[i2] !== b[i2]) {
		        x = a[i2];
		        y = b[i2];
		        break;
		      }
		    }
		    if (x < y) return -1;
		    if (y < x) return 1;
		    return 0;
		  };
		  Buffer2.isEncoding = function isEncoding(encoding) {
		    switch (String(encoding).toLowerCase()) {
		      case "hex":
		      case "utf8":
		      case "utf-8":
		      case "ascii":
		      case "latin1":
		      case "binary":
		      case "base64":
		      case "ucs2":
		      case "ucs-2":
		      case "utf16le":
		      case "utf-16le":
		        return true;
		      default:
		        return false;
		    }
		  };
		  Buffer2.concat = function concat(list, length) {
		    if (!Array.isArray(list)) {
		      throw new TypeError('"list" argument must be an Array of Buffers');
		    }
		    if (list.length === 0) {
		      return Buffer2.alloc(0);
		    }
		    let i2;
		    if (length === void 0) {
		      length = 0;
		      for (i2 = 0; i2 < list.length; ++i2) {
		        length += list[i2].length;
		      }
		    }
		    const buffer2 = Buffer2.allocUnsafe(length);
		    let pos = 0;
		    for (i2 = 0; i2 < list.length; ++i2) {
		      let buf = list[i2];
		      if (isInstance(buf, GlobalUint8Array)) {
		        if (pos + buf.length > buffer2.length) {
		          if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
		          buf.copy(buffer2, pos);
		        } else {
		          GlobalUint8Array.prototype.set.call(
		            buffer2,
		            buf,
		            pos
		          );
		        }
		      } else if (!Buffer2.isBuffer(buf)) {
		        throw new TypeError('"list" argument must be an Array of Buffers');
		      } else {
		        buf.copy(buffer2, pos);
		      }
		      pos += buf.length;
		    }
		    return buffer2;
		  };
		  function byteLength2(string, encoding) {
		    if (Buffer2.isBuffer(string)) {
		      return string.length;
		    }
		    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
		      return string.byteLength;
		    }
		    if (typeof string !== "string") {
		      throw new TypeError(
		        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
		      );
		    }
		    const len2 = string.length;
		    const mustMatch = arguments.length > 2 && arguments[2] === true;
		    if (!mustMatch && len2 === 0) return 0;
		    let loweredCase = false;
		    for (; ; ) {
		      switch (encoding) {
		        case "ascii":
		        case "latin1":
		        case "binary":
		          return len2;
		        case "utf8":
		        case "utf-8":
		          return utf8ToBytes(string).length;
		        case "ucs2":
		        case "ucs-2":
		        case "utf16le":
		        case "utf-16le":
		          return len2 * 2;
		        case "hex":
		          return len2 >>> 1;
		        case "base64":
		          return base64ToBytes(string).length;
		        default:
		          if (loweredCase) {
		            return mustMatch ? -1 : utf8ToBytes(string).length;
		          }
		          encoding = ("" + encoding).toLowerCase();
		          loweredCase = true;
		      }
		    }
		  }
		  Buffer2.byteLength = byteLength2;
		  function slowToString(encoding, start, end) {
		    let loweredCase = false;
		    if (start === void 0 || start < 0) {
		      start = 0;
		    }
		    if (start > this.length) {
		      return "";
		    }
		    if (end === void 0 || end > this.length) {
		      end = this.length;
		    }
		    if (end <= 0) {
		      return "";
		    }
		    end >>>= 0;
		    start >>>= 0;
		    if (end <= start) {
		      return "";
		    }
		    if (!encoding) encoding = "utf8";
		    while (true) {
		      switch (encoding) {
		        case "hex":
		          return hexSlice(this, start, end);
		        case "utf8":
		        case "utf-8":
		          return utf8Slice(this, start, end);
		        case "ascii":
		          return asciiSlice(this, start, end);
		        case "latin1":
		        case "binary":
		          return latin1Slice(this, start, end);
		        case "base64":
		          return base64Slice(this, start, end);
		        case "ucs2":
		        case "ucs-2":
		        case "utf16le":
		        case "utf-16le":
		          return utf16leSlice(this, start, end);
		        default:
		          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
		          encoding = (encoding + "").toLowerCase();
		          loweredCase = true;
		      }
		    }
		  }
		  Buffer2.prototype._isBuffer = true;
		  function swap(b, n, m) {
		    const i2 = b[n];
		    b[n] = b[m];
		    b[m] = i2;
		  }
		  Buffer2.prototype.swap16 = function swap16() {
		    const len2 = this.length;
		    if (len2 % 2 !== 0) {
		      throw new RangeError("Buffer size must be a multiple of 16-bits");
		    }
		    for (let i2 = 0; i2 < len2; i2 += 2) {
		      swap(this, i2, i2 + 1);
		    }
		    return this;
		  };
		  Buffer2.prototype.swap32 = function swap32() {
		    const len2 = this.length;
		    if (len2 % 4 !== 0) {
		      throw new RangeError("Buffer size must be a multiple of 32-bits");
		    }
		    for (let i2 = 0; i2 < len2; i2 += 4) {
		      swap(this, i2, i2 + 3);
		      swap(this, i2 + 1, i2 + 2);
		    }
		    return this;
		  };
		  Buffer2.prototype.swap64 = function swap64() {
		    const len2 = this.length;
		    if (len2 % 8 !== 0) {
		      throw new RangeError("Buffer size must be a multiple of 64-bits");
		    }
		    for (let i2 = 0; i2 < len2; i2 += 8) {
		      swap(this, i2, i2 + 7);
		      swap(this, i2 + 1, i2 + 6);
		      swap(this, i2 + 2, i2 + 5);
		      swap(this, i2 + 3, i2 + 4);
		    }
		    return this;
		  };
		  Buffer2.prototype.toString = function toString() {
		    const length = this.length;
		    if (length === 0) return "";
		    if (arguments.length === 0) return utf8Slice(this, 0, length);
		    return slowToString.apply(this, arguments);
		  };
		  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
		  Buffer2.prototype.equals = function equals(b) {
		    if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
		    if (this === b) return true;
		    return Buffer2.compare(this, b) === 0;
		  };
		  Buffer2.prototype.inspect = function inspect() {
		    let str = "";
		    const max = exports2.INSPECT_MAX_BYTES;
		    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
		    if (this.length > max) str += " ... ";
		    return "<Buffer " + str + ">";
		  };
		  if (customInspectSymbol) {
		    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
		  }
		  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
		    if (isInstance(target, GlobalUint8Array)) {
		      target = Buffer2.from(target, target.offset, target.byteLength);
		    }
		    if (!Buffer2.isBuffer(target)) {
		      throw new TypeError(
		        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
		      );
		    }
		    if (start === void 0) {
		      start = 0;
		    }
		    if (end === void 0) {
		      end = target ? target.length : 0;
		    }
		    if (thisStart === void 0) {
		      thisStart = 0;
		    }
		    if (thisEnd === void 0) {
		      thisEnd = this.length;
		    }
		    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		      throw new RangeError("out of range index");
		    }
		    if (thisStart >= thisEnd && start >= end) {
		      return 0;
		    }
		    if (thisStart >= thisEnd) {
		      return -1;
		    }
		    if (start >= end) {
		      return 1;
		    }
		    start >>>= 0;
		    end >>>= 0;
		    thisStart >>>= 0;
		    thisEnd >>>= 0;
		    if (this === target) return 0;
		    let x = thisEnd - thisStart;
		    let y = end - start;
		    const len2 = Math.min(x, y);
		    const thisCopy = this.slice(thisStart, thisEnd);
		    const targetCopy = target.slice(start, end);
		    for (let i2 = 0; i2 < len2; ++i2) {
		      if (thisCopy[i2] !== targetCopy[i2]) {
		        x = thisCopy[i2];
		        y = targetCopy[i2];
		        break;
		      }
		    }
		    if (x < y) return -1;
		    if (y < x) return 1;
		    return 0;
		  };
		  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
		    if (buffer2.length === 0) return -1;
		    if (typeof byteOffset === "string") {
		      encoding = byteOffset;
		      byteOffset = 0;
		    } else if (byteOffset > 2147483647) {
		      byteOffset = 2147483647;
		    } else if (byteOffset < -2147483648) {
		      byteOffset = -2147483648;
		    }
		    byteOffset = +byteOffset;
		    if (numberIsNaN(byteOffset)) {
		      byteOffset = dir ? 0 : buffer2.length - 1;
		    }
		    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
		    if (byteOffset >= buffer2.length) {
		      if (dir) return -1;
		      else byteOffset = buffer2.length - 1;
		    } else if (byteOffset < 0) {
		      if (dir) byteOffset = 0;
		      else return -1;
		    }
		    if (typeof val === "string") {
		      val = Buffer2.from(val, encoding);
		    }
		    if (Buffer2.isBuffer(val)) {
		      if (val.length === 0) {
		        return -1;
		      }
		      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
		    } else if (typeof val === "number") {
		      val = val & 255;
		      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
		        if (dir) {
		          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
		        } else {
		          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
		        }
		      }
		      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
		    }
		    throw new TypeError("val must be string, number or Buffer");
		  }
		  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
		    let indexSize = 1;
		    let arrLength = arr.length;
		    let valLength = val.length;
		    if (encoding !== void 0) {
		      encoding = String(encoding).toLowerCase();
		      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
		        if (arr.length < 2 || val.length < 2) {
		          return -1;
		        }
		        indexSize = 2;
		        arrLength /= 2;
		        valLength /= 2;
		        byteOffset /= 2;
		      }
		    }
		    function read(buf, i3) {
		      if (indexSize === 1) {
		        return buf[i3];
		      } else {
		        return buf.readUInt16BE(i3 * indexSize);
		      }
		    }
		    let i2;
		    if (dir) {
		      let foundIndex = -1;
		      for (i2 = byteOffset; i2 < arrLength; i2++) {
		        if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
		          if (foundIndex === -1) foundIndex = i2;
		          if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
		        } else {
		          if (foundIndex !== -1) i2 -= i2 - foundIndex;
		          foundIndex = -1;
		        }
		      }
		    } else {
		      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
		      for (i2 = byteOffset; i2 >= 0; i2--) {
		        let found = true;
		        for (let j = 0; j < valLength; j++) {
		          if (read(arr, i2 + j) !== read(val, j)) {
		            found = false;
		            break;
		          }
		        }
		        if (found) return i2;
		      }
		    }
		    return -1;
		  }
		  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
		    return this.indexOf(val, byteOffset, encoding) !== -1;
		  };
		  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
		    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
		  };
		  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
		    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
		  };
		  function hexWrite(buf, string, offset, length) {
		    offset = Number(offset) || 0;
		    const remaining = buf.length - offset;
		    if (!length) {
		      length = remaining;
		    } else {
		      length = Number(length);
		      if (length > remaining) {
		        length = remaining;
		      }
		    }
		    const strLen = string.length;
		    if (length > strLen / 2) {
		      length = strLen / 2;
		    }
		    let i2;
		    for (i2 = 0; i2 < length; ++i2) {
		      const parsed = parseInt(string.substr(i2 * 2, 2), 16);
		      if (numberIsNaN(parsed)) return i2;
		      buf[offset + i2] = parsed;
		    }
		    return i2;
		  }
		  function utf8Write(buf, string, offset, length) {
		    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
		  }
		  function asciiWrite(buf, string, offset, length) {
		    return blitBuffer(asciiToBytes(string), buf, offset, length);
		  }
		  function base64Write(buf, string, offset, length) {
		    return blitBuffer(base64ToBytes(string), buf, offset, length);
		  }
		  function ucs2Write(buf, string, offset, length) {
		    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
		  }
		  Buffer2.prototype.write = function write(string, offset, length, encoding) {
		    if (offset === void 0) {
		      encoding = "utf8";
		      length = this.length;
		      offset = 0;
		    } else if (length === void 0 && typeof offset === "string") {
		      encoding = offset;
		      length = this.length;
		      offset = 0;
		    } else if (isFinite(offset)) {
		      offset = offset >>> 0;
		      if (isFinite(length)) {
		        length = length >>> 0;
		        if (encoding === void 0) encoding = "utf8";
		      } else {
		        encoding = length;
		        length = void 0;
		      }
		    } else {
		      throw new Error(
		        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
		      );
		    }
		    const remaining = this.length - offset;
		    if (length === void 0 || length > remaining) length = remaining;
		    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
		      throw new RangeError("Attempt to write outside buffer bounds");
		    }
		    if (!encoding) encoding = "utf8";
		    let loweredCase = false;
		    for (; ; ) {
		      switch (encoding) {
		        case "hex":
		          return hexWrite(this, string, offset, length);
		        case "utf8":
		        case "utf-8":
		          return utf8Write(this, string, offset, length);
		        case "ascii":
		        case "latin1":
		        case "binary":
		          return asciiWrite(this, string, offset, length);
		        case "base64":
		          return base64Write(this, string, offset, length);
		        case "ucs2":
		        case "ucs-2":
		        case "utf16le":
		        case "utf-16le":
		          return ucs2Write(this, string, offset, length);
		        default:
		          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
		          encoding = ("" + encoding).toLowerCase();
		          loweredCase = true;
		      }
		    }
		  };
		  Buffer2.prototype.toJSON = function toJSON() {
		    return {
		      type: "Buffer",
		      data: Array.prototype.slice.call(this._arr || this, 0)
		    };
		  };
		  function base64Slice(buf, start, end) {
		    if (start === 0 && end === buf.length) {
		      return base64.fromByteArray(buf);
		    } else {
		      return base64.fromByteArray(buf.slice(start, end));
		    }
		  }
		  function utf8Slice(buf, start, end) {
		    end = Math.min(buf.length, end);
		    const res = [];
		    let i2 = start;
		    while (i2 < end) {
		      const firstByte = buf[i2];
		      let codePoint = null;
		      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
		      if (i2 + bytesPerSequence <= end) {
		        let secondByte, thirdByte, fourthByte, tempCodePoint;
		        switch (bytesPerSequence) {
		          case 1:
		            if (firstByte < 128) {
		              codePoint = firstByte;
		            }
		            break;
		          case 2:
		            secondByte = buf[i2 + 1];
		            if ((secondByte & 192) === 128) {
		              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
		              if (tempCodePoint > 127) {
		                codePoint = tempCodePoint;
		              }
		            }
		            break;
		          case 3:
		            secondByte = buf[i2 + 1];
		            thirdByte = buf[i2 + 2];
		            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
		              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
		              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
		                codePoint = tempCodePoint;
		              }
		            }
		            break;
		          case 4:
		            secondByte = buf[i2 + 1];
		            thirdByte = buf[i2 + 2];
		            fourthByte = buf[i2 + 3];
		            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
		              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
		              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
		                codePoint = tempCodePoint;
		              }
		            }
		        }
		      }
		      if (codePoint === null) {
		        codePoint = 65533;
		        bytesPerSequence = 1;
		      } else if (codePoint > 65535) {
		        codePoint -= 65536;
		        res.push(codePoint >>> 10 & 1023 | 55296);
		        codePoint = 56320 | codePoint & 1023;
		      }
		      res.push(codePoint);
		      i2 += bytesPerSequence;
		    }
		    return decodeCodePointsArray(res);
		  }
		  const MAX_ARGUMENTS_LENGTH = 4096;
		  function decodeCodePointsArray(codePoints) {
		    const len2 = codePoints.length;
		    if (len2 <= MAX_ARGUMENTS_LENGTH) {
		      return String.fromCharCode.apply(String, codePoints);
		    }
		    let res = "";
		    let i2 = 0;
		    while (i2 < len2) {
		      res += String.fromCharCode.apply(
		        String,
		        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
		      );
		    }
		    return res;
		  }
		  function asciiSlice(buf, start, end) {
		    let ret = "";
		    end = Math.min(buf.length, end);
		    for (let i2 = start; i2 < end; ++i2) {
		      ret += String.fromCharCode(buf[i2] & 127);
		    }
		    return ret;
		  }
		  function latin1Slice(buf, start, end) {
		    let ret = "";
		    end = Math.min(buf.length, end);
		    for (let i2 = start; i2 < end; ++i2) {
		      ret += String.fromCharCode(buf[i2]);
		    }
		    return ret;
		  }
		  function hexSlice(buf, start, end) {
		    const len2 = buf.length;
		    if (!start || start < 0) start = 0;
		    if (!end || end < 0 || end > len2) end = len2;
		    let out = "";
		    for (let i2 = start; i2 < end; ++i2) {
		      out += hexSliceLookupTable[buf[i2]];
		    }
		    return out;
		  }
		  function utf16leSlice(buf, start, end) {
		    const bytes = buf.slice(start, end);
		    let res = "";
		    for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
		      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
		    }
		    return res;
		  }
		  Buffer2.prototype.slice = function slice(start, end) {
		    const len2 = this.length;
		    start = ~~start;
		    end = end === void 0 ? len2 : ~~end;
		    if (start < 0) {
		      start += len2;
		      if (start < 0) start = 0;
		    } else if (start > len2) {
		      start = len2;
		    }
		    if (end < 0) {
		      end += len2;
		      if (end < 0) end = 0;
		    } else if (end > len2) {
		      end = len2;
		    }
		    if (end < start) end = start;
		    const newBuf = this.subarray(start, end);
		    Object.setPrototypeOf(newBuf, Buffer2.prototype);
		    return newBuf;
		  };
		  function checkOffset(offset, ext, length) {
		    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
		    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
		  }
		  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) checkOffset(offset, byteLength3, this.length);
		    let val = this[offset];
		    let mul = 1;
		    let i2 = 0;
		    while (++i2 < byteLength3 && (mul *= 256)) {
		      val += this[offset + i2] * mul;
		    }
		    return val;
		  };
		  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) {
		      checkOffset(offset, byteLength3, this.length);
		    }
		    let val = this[offset + --byteLength3];
		    let mul = 1;
		    while (byteLength3 > 0 && (mul *= 256)) {
		      val += this[offset + --byteLength3] * mul;
		    }
		    return val;
		  };
		  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 1, this.length);
		    return this[offset];
		  };
		  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 2, this.length);
		    return this[offset] | this[offset + 1] << 8;
		  };
		  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 2, this.length);
		    return this[offset] << 8 | this[offset + 1];
		  };
		  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
		  };
		  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
		  };
		  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
		    offset = offset >>> 0;
		    validateNumber(offset, "offset");
		    const first = this[offset];
		    const last = this[offset + 7];
		    if (first === void 0 || last === void 0) {
		      boundsError(offset, this.length - 8);
		    }
		    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
		    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
		    return BigInt(lo) + (BigInt(hi) << BigInt(32));
		  });
		  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
		    offset = offset >>> 0;
		    validateNumber(offset, "offset");
		    const first = this[offset];
		    const last = this[offset + 7];
		    if (first === void 0 || last === void 0) {
		      boundsError(offset, this.length - 8);
		    }
		    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
		    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
		    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
		  });
		  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) checkOffset(offset, byteLength3, this.length);
		    let val = this[offset];
		    let mul = 1;
		    let i2 = 0;
		    while (++i2 < byteLength3 && (mul *= 256)) {
		      val += this[offset + i2] * mul;
		    }
		    mul *= 128;
		    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
		    return val;
		  };
		  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) checkOffset(offset, byteLength3, this.length);
		    let i2 = byteLength3;
		    let mul = 1;
		    let val = this[offset + --i2];
		    while (i2 > 0 && (mul *= 256)) {
		      val += this[offset + --i2] * mul;
		    }
		    mul *= 128;
		    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
		    return val;
		  };
		  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 1, this.length);
		    if (!(this[offset] & 128)) return this[offset];
		    return (255 - this[offset] + 1) * -1;
		  };
		  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 2, this.length);
		    const val = this[offset] | this[offset + 1] << 8;
		    return val & 32768 ? val | 4294901760 : val;
		  };
		  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 2, this.length);
		    const val = this[offset + 1] | this[offset] << 8;
		    return val & 32768 ? val | 4294901760 : val;
		  };
		  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
		  };
		  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
		  };
		  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
		    offset = offset >>> 0;
		    validateNumber(offset, "offset");
		    const first = this[offset];
		    const last = this[offset + 7];
		    if (first === void 0 || last === void 0) {
		      boundsError(offset, this.length - 8);
		    }
		    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
		    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
		  });
		  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
		    offset = offset >>> 0;
		    validateNumber(offset, "offset");
		    const first = this[offset];
		    const last = this[offset + 7];
		    if (first === void 0 || last === void 0) {
		      boundsError(offset, this.length - 8);
		    }
		    const val = (first << 24) + // Overflow
		    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
		    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
		  });
		  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return ieee754$1.read(this, offset, true, 23, 4);
		  };
		  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 4, this.length);
		    return ieee754$1.read(this, offset, false, 23, 4);
		  };
		  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 8, this.length);
		    return ieee754$1.read(this, offset, true, 52, 8);
		  };
		  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
		    offset = offset >>> 0;
		    if (!noAssert) checkOffset(offset, 8, this.length);
		    return ieee754$1.read(this, offset, false, 52, 8);
		  };
		  function checkInt(buf, value, offset, ext, max, min) {
		    if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
		    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
		    if (offset + ext > buf.length) throw new RangeError("Index out of range");
		  }
		  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) {
		      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
		      checkInt(this, value, offset, byteLength3, maxBytes, 0);
		    }
		    let mul = 1;
		    let i2 = 0;
		    this[offset] = value & 255;
		    while (++i2 < byteLength3 && (mul *= 256)) {
		      this[offset + i2] = value / mul & 255;
		    }
		    return offset + byteLength3;
		  };
		  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    byteLength3 = byteLength3 >>> 0;
		    if (!noAssert) {
		      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
		      checkInt(this, value, offset, byteLength3, maxBytes, 0);
		    }
		    let i2 = byteLength3 - 1;
		    let mul = 1;
		    this[offset + i2] = value & 255;
		    while (--i2 >= 0 && (mul *= 256)) {
		      this[offset + i2] = value / mul & 255;
		    }
		    return offset + byteLength3;
		  };
		  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
		    this[offset] = value & 255;
		    return offset + 1;
		  };
		  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
		    this[offset] = value & 255;
		    this[offset + 1] = value >>> 8;
		    return offset + 2;
		  };
		  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
		    this[offset] = value >>> 8;
		    this[offset + 1] = value & 255;
		    return offset + 2;
		  };
		  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
		    this[offset + 3] = value >>> 24;
		    this[offset + 2] = value >>> 16;
		    this[offset + 1] = value >>> 8;
		    this[offset] = value & 255;
		    return offset + 4;
		  };
		  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
		    this[offset] = value >>> 24;
		    this[offset + 1] = value >>> 16;
		    this[offset + 2] = value >>> 8;
		    this[offset + 3] = value & 255;
		    return offset + 4;
		  };
		  function wrtBigUInt64LE(buf, value, offset, min, max) {
		    checkIntBI(value, min, max, buf, offset, 7);
		    let lo = Number(value & BigInt(4294967295));
		    buf[offset++] = lo;
		    lo = lo >> 8;
		    buf[offset++] = lo;
		    lo = lo >> 8;
		    buf[offset++] = lo;
		    lo = lo >> 8;
		    buf[offset++] = lo;
		    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
		    buf[offset++] = hi;
		    hi = hi >> 8;
		    buf[offset++] = hi;
		    hi = hi >> 8;
		    buf[offset++] = hi;
		    hi = hi >> 8;
		    buf[offset++] = hi;
		    return offset;
		  }
		  function wrtBigUInt64BE(buf, value, offset, min, max) {
		    checkIntBI(value, min, max, buf, offset, 7);
		    let lo = Number(value & BigInt(4294967295));
		    buf[offset + 7] = lo;
		    lo = lo >> 8;
		    buf[offset + 6] = lo;
		    lo = lo >> 8;
		    buf[offset + 5] = lo;
		    lo = lo >> 8;
		    buf[offset + 4] = lo;
		    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
		    buf[offset + 3] = hi;
		    hi = hi >> 8;
		    buf[offset + 2] = hi;
		    hi = hi >> 8;
		    buf[offset + 1] = hi;
		    hi = hi >> 8;
		    buf[offset] = hi;
		    return offset + 8;
		  }
		  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
		    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
		  });
		  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
		    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
		  });
		  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) {
		      const limit = Math.pow(2, 8 * byteLength3 - 1);
		      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
		    }
		    let i2 = 0;
		    let mul = 1;
		    let sub = 0;
		    this[offset] = value & 255;
		    while (++i2 < byteLength3 && (mul *= 256)) {
		      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
		        sub = 1;
		      }
		      this[offset + i2] = (value / mul >> 0) - sub & 255;
		    }
		    return offset + byteLength3;
		  };
		  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) {
		      const limit = Math.pow(2, 8 * byteLength3 - 1);
		      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
		    }
		    let i2 = byteLength3 - 1;
		    let mul = 1;
		    let sub = 0;
		    this[offset + i2] = value & 255;
		    while (--i2 >= 0 && (mul *= 256)) {
		      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
		        sub = 1;
		      }
		      this[offset + i2] = (value / mul >> 0) - sub & 255;
		    }
		    return offset + byteLength3;
		  };
		  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
		    if (value < 0) value = 255 + value + 1;
		    this[offset] = value & 255;
		    return offset + 1;
		  };
		  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
		    this[offset] = value & 255;
		    this[offset + 1] = value >>> 8;
		    return offset + 2;
		  };
		  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
		    this[offset] = value >>> 8;
		    this[offset + 1] = value & 255;
		    return offset + 2;
		  };
		  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
		    this[offset] = value & 255;
		    this[offset + 1] = value >>> 8;
		    this[offset + 2] = value >>> 16;
		    this[offset + 3] = value >>> 24;
		    return offset + 4;
		  };
		  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
		    if (value < 0) value = 4294967295 + value + 1;
		    this[offset] = value >>> 24;
		    this[offset + 1] = value >>> 16;
		    this[offset + 2] = value >>> 8;
		    this[offset + 3] = value & 255;
		    return offset + 4;
		  };
		  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
		    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
		  });
		  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
		    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
		  });
		  function checkIEEE754(buf, value, offset, ext, max, min) {
		    if (offset + ext > buf.length) throw new RangeError("Index out of range");
		    if (offset < 0) throw new RangeError("Index out of range");
		  }
		  function writeFloat(buf, value, offset, littleEndian, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) {
		      checkIEEE754(buf, value, offset, 4);
		    }
		    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
		    return offset + 4;
		  }
		  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
		    return writeFloat(this, value, offset, true, noAssert);
		  };
		  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
		    return writeFloat(this, value, offset, false, noAssert);
		  };
		  function writeDouble(buf, value, offset, littleEndian, noAssert) {
		    value = +value;
		    offset = offset >>> 0;
		    if (!noAssert) {
		      checkIEEE754(buf, value, offset, 8);
		    }
		    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
		    return offset + 8;
		  }
		  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
		    return writeDouble(this, value, offset, true, noAssert);
		  };
		  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
		    return writeDouble(this, value, offset, false, noAssert);
		  };
		  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
		    if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
		    if (!start) start = 0;
		    if (!end && end !== 0) end = this.length;
		    if (targetStart >= target.length) targetStart = target.length;
		    if (!targetStart) targetStart = 0;
		    if (end > 0 && end < start) end = start;
		    if (end === start) return 0;
		    if (target.length === 0 || this.length === 0) return 0;
		    if (targetStart < 0) {
		      throw new RangeError("targetStart out of bounds");
		    }
		    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
		    if (end < 0) throw new RangeError("sourceEnd out of bounds");
		    if (end > this.length) end = this.length;
		    if (target.length - targetStart < end - start) {
		      end = target.length - targetStart + start;
		    }
		    const len2 = end - start;
		    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
		      this.copyWithin(targetStart, start, end);
		    } else {
		      GlobalUint8Array.prototype.set.call(
		        target,
		        this.subarray(start, end),
		        targetStart
		      );
		    }
		    return len2;
		  };
		  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
		    if (typeof val === "string") {
		      if (typeof start === "string") {
		        encoding = start;
		        start = 0;
		        end = this.length;
		      } else if (typeof end === "string") {
		        encoding = end;
		        end = this.length;
		      }
		      if (encoding !== void 0 && typeof encoding !== "string") {
		        throw new TypeError("encoding must be a string");
		      }
		      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
		        throw new TypeError("Unknown encoding: " + encoding);
		      }
		      if (val.length === 1) {
		        const code2 = val.charCodeAt(0);
		        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
		          val = code2;
		        }
		      }
		    } else if (typeof val === "number") {
		      val = val & 255;
		    } else if (typeof val === "boolean") {
		      val = Number(val);
		    }
		    if (start < 0 || this.length < start || this.length < end) {
		      throw new RangeError("Out of range index");
		    }
		    if (end <= start) {
		      return this;
		    }
		    start = start >>> 0;
		    end = end === void 0 ? this.length : end >>> 0;
		    if (!val) val = 0;
		    let i2;
		    if (typeof val === "number") {
		      for (i2 = start; i2 < end; ++i2) {
		        this[i2] = val;
		      }
		    } else {
		      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
		      const len2 = bytes.length;
		      if (len2 === 0) {
		        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
		      }
		      for (i2 = 0; i2 < end - start; ++i2) {
		        this[i2 + start] = bytes[i2 % len2];
		      }
		    }
		    return this;
		  };
		  const errors = {};
		  function E(sym, getMessage, Base) {
		    errors[sym] = class NodeError extends Base {
		      constructor() {
		        super();
		        Object.defineProperty(this, "message", {
		          value: getMessage.apply(this, arguments),
		          writable: true,
		          configurable: true
		        });
		        this.name = `${this.name} [${sym}]`;
		        this.stack;
		        delete this.name;
		      }
		      get code() {
		        return sym;
		      }
		      set code(value) {
		        Object.defineProperty(this, "code", {
		          configurable: true,
		          enumerable: true,
		          value,
		          writable: true
		        });
		      }
		      toString() {
		        return `${this.name} [${sym}]: ${this.message}`;
		      }
		    };
		  }
		  E(
		    "ERR_BUFFER_OUT_OF_BOUNDS",
		    function(name) {
		      if (name) {
		        return `${name} is outside of buffer bounds`;
		      }
		      return "Attempt to access memory outside buffer bounds";
		    },
		    RangeError
		  );
		  E(
		    "ERR_INVALID_ARG_TYPE",
		    function(name, actual) {
		      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
		    },
		    TypeError
		  );
		  E(
		    "ERR_OUT_OF_RANGE",
		    function(str, range, input) {
		      let msg = `The value of "${str}" is out of range.`;
		      let received = input;
		      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
		        received = addNumericalSeparator(String(input));
		      } else if (typeof input === "bigint") {
		        received = String(input);
		        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
		          received = addNumericalSeparator(received);
		        }
		        received += "n";
		      }
		      msg += ` It must be ${range}. Received ${received}`;
		      return msg;
		    },
		    RangeError
		  );
		  function addNumericalSeparator(val) {
		    let res = "";
		    let i2 = val.length;
		    const start = val[0] === "-" ? 1 : 0;
		    for (; i2 >= start + 4; i2 -= 3) {
		      res = `_${val.slice(i2 - 3, i2)}${res}`;
		    }
		    return `${val.slice(0, i2)}${res}`;
		  }
		  function checkBounds(buf, offset, byteLength3) {
		    validateNumber(offset, "offset");
		    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
		      boundsError(offset, buf.length - (byteLength3 + 1));
		    }
		  }
		  function checkIntBI(value, min, max, buf, offset, byteLength3) {
		    if (value > max || value < min) {
		      const n = typeof min === "bigint" ? "n" : "";
		      let range;
		      {
		        if (min === 0 || min === BigInt(0)) {
		          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
		        } else {
		          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
		        }
		      }
		      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
		    }
		    checkBounds(buf, offset, byteLength3);
		  }
		  function validateNumber(value, name) {
		    if (typeof value !== "number") {
		      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
		    }
		  }
		  function boundsError(value, length, type) {
		    if (Math.floor(value) !== value) {
		      validateNumber(value, type);
		      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
		    }
		    if (length < 0) {
		      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
		    }
		    throw new errors.ERR_OUT_OF_RANGE(
		      "offset",
		      `>= ${0} and <= ${length}`,
		      value
		    );
		  }
		  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
		  function base64clean(str) {
		    str = str.split("=")[0];
		    str = str.trim().replace(INVALID_BASE64_RE, "");
		    if (str.length < 2) return "";
		    while (str.length % 4 !== 0) {
		      str = str + "=";
		    }
		    return str;
		  }
		  function utf8ToBytes(string, units) {
		    units = units || Infinity;
		    let codePoint;
		    const length = string.length;
		    let leadSurrogate = null;
		    const bytes = [];
		    for (let i2 = 0; i2 < length; ++i2) {
		      codePoint = string.charCodeAt(i2);
		      if (codePoint > 55295 && codePoint < 57344) {
		        if (!leadSurrogate) {
		          if (codePoint > 56319) {
		            if ((units -= 3) > -1) bytes.push(239, 191, 189);
		            continue;
		          } else if (i2 + 1 === length) {
		            if ((units -= 3) > -1) bytes.push(239, 191, 189);
		            continue;
		          }
		          leadSurrogate = codePoint;
		          continue;
		        }
		        if (codePoint < 56320) {
		          if ((units -= 3) > -1) bytes.push(239, 191, 189);
		          leadSurrogate = codePoint;
		          continue;
		        }
		        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
		      } else if (leadSurrogate) {
		        if ((units -= 3) > -1) bytes.push(239, 191, 189);
		      }
		      leadSurrogate = null;
		      if (codePoint < 128) {
		        if ((units -= 1) < 0) break;
		        bytes.push(codePoint);
		      } else if (codePoint < 2048) {
		        if ((units -= 2) < 0) break;
		        bytes.push(
		          codePoint >> 6 | 192,
		          codePoint & 63 | 128
		        );
		      } else if (codePoint < 65536) {
		        if ((units -= 3) < 0) break;
		        bytes.push(
		          codePoint >> 12 | 224,
		          codePoint >> 6 & 63 | 128,
		          codePoint & 63 | 128
		        );
		      } else if (codePoint < 1114112) {
		        if ((units -= 4) < 0) break;
		        bytes.push(
		          codePoint >> 18 | 240,
		          codePoint >> 12 & 63 | 128,
		          codePoint >> 6 & 63 | 128,
		          codePoint & 63 | 128
		        );
		      } else {
		        throw new Error("Invalid code point");
		      }
		    }
		    return bytes;
		  }
		  function asciiToBytes(str) {
		    const byteArray = [];
		    for (let i2 = 0; i2 < str.length; ++i2) {
		      byteArray.push(str.charCodeAt(i2) & 255);
		    }
		    return byteArray;
		  }
		  function utf16leToBytes(str, units) {
		    let c, hi, lo;
		    const byteArray = [];
		    for (let i2 = 0; i2 < str.length; ++i2) {
		      if ((units -= 2) < 0) break;
		      c = str.charCodeAt(i2);
		      hi = c >> 8;
		      lo = c % 256;
		      byteArray.push(lo);
		      byteArray.push(hi);
		    }
		    return byteArray;
		  }
		  function base64ToBytes(str) {
		    return base64.toByteArray(base64clean(str));
		  }
		  function blitBuffer(src, dst, offset, length) {
		    let i2;
		    for (i2 = 0; i2 < length; ++i2) {
		      if (i2 + offset >= dst.length || i2 >= src.length) break;
		      dst[i2 + offset] = src[i2];
		    }
		    return i2;
		  }
		  function isInstance(obj, type) {
		    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
		  }
		  function numberIsNaN(obj) {
		    return obj !== obj;
		  }
		  const hexSliceLookupTable = (function() {
		    const alphabet = "0123456789abcdef";
		    const table = new Array(256);
		    for (let i2 = 0; i2 < 16; ++i2) {
		      const i16 = i2 * 16;
		      for (let j = 0; j < 16; ++j) {
		        table[i16 + j] = alphabet[i2] + alphabet[j];
		      }
		    }
		    return table;
		  })();
		  function defineBigIntMethod(fn) {
		    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
		  }
		  function BufferBigIntNotDefined() {
		    throw new Error("BigInt not supported");
		  }
		})(buffer);
		const Buffer = buffer.Buffer;
		exports$1.Blob = buffer.Blob;
		exports$1.BlobOptions = buffer.BlobOptions;
		exports$1.Buffer = buffer.Buffer;
		exports$1.File = buffer.File;
		exports$1.FileOptions = buffer.FileOptions;
		exports$1.INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;
		exports$1.SlowBuffer = buffer.SlowBuffer;
		exports$1.TranscodeEncoding = buffer.TranscodeEncoding;
		exports$1.atob = buffer.atob;
		exports$1.btoa = buffer.btoa;
		exports$1.constants = buffer.constants;
		exports$1.default = Buffer;
		exports$1.isAscii = buffer.isAscii;
		exports$1.isUtf8 = buffer.isUtf8;
		exports$1.kMaxLength = buffer.kMaxLength;
		exports$1.kStringMaxLength = buffer.kStringMaxLength;
		exports$1.resolveObjectURL = buffer.resolveObjectURL;
		exports$1.transcode = buffer.transcode; 
	} (dist));
	return dist;
}

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports$1) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = requireDist();
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports$1);
		  exports$1.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var isarray;
var hasRequiredIsarray;

function requireIsarray () {
	if (hasRequiredIsarray) return isarray;
	hasRequiredIsarray = 1;
	var toString = {}.toString;

	isarray = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};
	return isarray;
}

var typedArrayBuffer;
var hasRequiredTypedArrayBuffer;

function requireTypedArrayBuffer () {
	if (hasRequiredTypedArrayBuffer) return typedArrayBuffer;
	hasRequiredTypedArrayBuffer = 1;

	var $TypeError = /*@__PURE__*/ requireType();

	var callBound = /*@__PURE__*/ requireCallBound();

	/** @type {undefined | ((thisArg: import('.').TypedArray) => Buffer<ArrayBufferLike>)} */
	var $typedArrayBuffer = callBound('TypedArray.prototype.buffer', true);

	var isTypedArray = /*@__PURE__*/ requireIsTypedArray();

	/** @type {import('.')} */
	// node <= 0.10, < 0.11.4 has a nonconfigurable own property instead of a prototype getter
	typedArrayBuffer = $typedArrayBuffer || function typedArrayBuffer(x) {
		if (!isTypedArray(x)) {
			throw new $TypeError('Not a Typed Array');
		}
		return x.buffer;
	};
	return typedArrayBuffer;
}

var toBuffer;
var hasRequiredToBuffer;

function requireToBuffer () {
	if (hasRequiredToBuffer) return toBuffer;
	hasRequiredToBuffer = 1;

	var Buffer = requireSafeBuffer().Buffer;
	var isArray = requireIsarray();
	var typedArrayBuffer = /*@__PURE__*/ requireTypedArrayBuffer();

	var isView = ArrayBuffer.isView || function isView(obj) {
		try {
			typedArrayBuffer(obj);
			return true;
		} catch (e) {
			return false;
		}
	};

	var useUint8Array = typeof Uint8Array !== 'undefined';
	var useArrayBuffer = typeof ArrayBuffer !== 'undefined'
		&& typeof Uint8Array !== 'undefined';
	var useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);

	toBuffer = function toBuffer(data, encoding) {
		if (Buffer.isBuffer(data)) {
			if (data.constructor && !('isBuffer' in data)) {
				// probably a SlowBuffer
				return Buffer.from(data);
			}
			return data;
		}

		if (typeof data === 'string') {
			return Buffer.from(data, encoding);
		}

		/*
		 * Wrap any TypedArray instances and DataViews
		 * Makes sense only on engines with full TypedArray support -- let Buffer detect that
		 */
		if (useArrayBuffer && isView(data)) {
			// Bug in Node.js <6.3.1, which treats this as out-of-bounds
			if (data.byteLength === 0) {
				return Buffer.alloc(0);
			}

			// When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer
			if (useFromArrayBuffer) {
				var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
				/*
				 * Recheck result size, as offset/length doesn't work on Node.js <5.10
				 * We just go to Uint8Array case if this fails
				 */
				if (res.byteLength === data.byteLength) {
					return res;
				}
			}

			// Convert to Uint8Array bytes and then to Buffer
			var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
			var result = Buffer.from(uint8);

			/*
			 * Let's recheck that conversion succeeded
			 * We have .length but not .byteLength when useFromArrayBuffer is false
			 */
			if (result.length === data.byteLength) {
				return result;
			}
		}

		/*
		 * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over
		 * Doesn't make sense with other TypedArray instances
		 */
		if (useUint8Array && data instanceof Uint8Array) {
			return Buffer.from(data);
		}

		var isArr = isArray(data);
		if (isArr) {
			for (var i = 0; i < data.length; i += 1) {
				var x = data[i];
				if (
					typeof x !== 'number'
					|| x < 0
					|| x > 255
					|| ~~x !== x // NaN and integer check
				) {
					throw new RangeError('Array items must be numbers in the range 0-255.');
				}
			}
		}

		/*
		 * Old Buffer polyfill on an engine that doesn't have TypedArray support
		 * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed
		 * Convert to our current Buffer implementation
		 */
		if (
			isArr || (
				Buffer.isBuffer(data)
				&& data.constructor
				&& typeof data.constructor.isBuffer === 'function'
				&& data.constructor.isBuffer(data)
			)
		) {
			return Buffer.from(data);
		}

		throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
	};
	return toBuffer;
}

var hash;
var hasRequiredHash;

function requireHash () {
	if (hasRequiredHash) return hash;
	hasRequiredHash = 1;

	var Buffer = requireSafeBuffer().Buffer;
	var toBuffer = /*@__PURE__*/ requireToBuffer();

	// prototype class for hash functions
	function Hash(blockSize, finalSize) {
		this._block = Buffer.alloc(blockSize);
		this._finalSize = finalSize;
		this._blockSize = blockSize;
		this._len = 0;
	}

	Hash.prototype.update = function (data, enc) {
		/* eslint no-param-reassign: 0 */
		data = toBuffer(data, enc || 'utf8');

		var block = this._block;
		var blockSize = this._blockSize;
		var length = data.length;
		var accum = this._len;

		for (var offset = 0; offset < length;) {
			var assigned = accum % blockSize;
			var remainder = Math.min(length - offset, blockSize - assigned);

			for (var i = 0; i < remainder; i++) {
				block[assigned + i] = data[offset + i];
			}

			accum += remainder;
			offset += remainder;

			if ((accum % blockSize) === 0) {
				this._update(block);
			}
		}

		this._len += length;
		return this;
	};

	Hash.prototype.digest = function (enc) {
		var rem = this._len % this._blockSize;

		this._block[rem] = 0x80;

		/*
		 * zero (rem + 1) trailing bits, where (rem + 1) is the smallest
		 * non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
		 */
		this._block.fill(0, rem + 1);

		if (rem >= this._finalSize) {
			this._update(this._block);
			this._block.fill(0);
		}

		var bits = this._len * 8;

		// uint32
		if (bits <= 0xffffffff) {
			this._block.writeUInt32BE(bits, this._blockSize - 4);

			// uint64
		} else {
			var lowBits = (bits & 0xffffffff) >>> 0;
			var highBits = (bits - lowBits) / 0x100000000;

			this._block.writeUInt32BE(highBits, this._blockSize - 8);
			this._block.writeUInt32BE(lowBits, this._blockSize - 4);
		}

		this._update(this._block);
		var hash = this._hash();

		return enc ? hash.toString(enc) : hash;
	};

	Hash.prototype._update = function () {
		throw new Error('_update must be implemented by subclass');
	};

	hash = Hash;
	return hash;
}

var sha;
var hasRequiredSha;

function requireSha () {
	if (hasRequiredSha) return sha;
	hasRequiredSha = 1;

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
	 * in FIPS PUB 180-1
	 * This source code is derived from sha1.js of the same repository.
	 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
	 * operation was added.
	 */

	var inherits = requireInherits();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var K = [
		0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W = new Array(80);

	function Sha() {
		this.init();
		this._w = W;

		Hash.call(this, 64, 56);
	}

	inherits(Sha, Hash);

	Sha.prototype.init = function () {
		this._a = 0x67452301;
		this._b = 0xefcdab89;
		this._c = 0x98badcfe;
		this._d = 0x10325476;
		this._e = 0xc3d2e1f0;

		return this;
	};

	function rotl5(num) {
		return (num << 5) | (num >>> 27);
	}

	function rotl30(num) {
		return (num << 30) | (num >>> 2);
	}

	function ft(s, b, c, d) {
		if (s === 0) {
			return (b & c) | (~b & d);
		}
		if (s === 2) {
			return (b & c) | (b & d) | (c & d);
		}
		return b ^ c ^ d;
	}

	Sha.prototype._update = function (M) {
		var w = this._w;

		var a = this._a | 0;
		var b = this._b | 0;
		var c = this._c | 0;
		var d = this._d | 0;
		var e = this._e | 0;

		for (var i = 0; i < 16; ++i) {
			w[i] = M.readInt32BE(i * 4);
		}
		for (; i < 80; ++i) {
			w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
		}

		for (var j = 0; j < 80; ++j) {
			var s = ~~(j / 20);
			var t = (rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s]) | 0;

			e = d;
			d = c;
			c = rotl30(b);
			b = a;
			a = t;
		}

		this._a = (a + this._a) | 0;
		this._b = (b + this._b) | 0;
		this._c = (c + this._c) | 0;
		this._d = (d + this._d) | 0;
		this._e = (e + this._e) | 0;
	};

	Sha.prototype._hash = function () {
		var H = Buffer.allocUnsafe(20);

		H.writeInt32BE(this._a | 0, 0);
		H.writeInt32BE(this._b | 0, 4);
		H.writeInt32BE(this._c | 0, 8);
		H.writeInt32BE(this._d | 0, 12);
		H.writeInt32BE(this._e | 0, 16);

		return H;
	};

	sha = Sha;
	return sha;
}

var sha1;
var hasRequiredSha1;

function requireSha1 () {
	if (hasRequiredSha1) return sha1;
	hasRequiredSha1 = 1;

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = requireInherits();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var K = [
		0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W = new Array(80);

	function Sha1() {
		this.init();
		this._w = W;

		Hash.call(this, 64, 56);
	}

	inherits(Sha1, Hash);

	Sha1.prototype.init = function () {
		this._a = 0x67452301;
		this._b = 0xefcdab89;
		this._c = 0x98badcfe;
		this._d = 0x10325476;
		this._e = 0xc3d2e1f0;

		return this;
	};

	function rotl1(num) {
		return (num << 1) | (num >>> 31);
	}

	function rotl5(num) {
		return (num << 5) | (num >>> 27);
	}

	function rotl30(num) {
		return (num << 30) | (num >>> 2);
	}

	function ft(s, b, c, d) {
		if (s === 0) {
			return (b & c) | (~b & d);
		}
		if (s === 2) {
			return (b & c) | (b & d) | (c & d);
		}
		return b ^ c ^ d;
	}

	Sha1.prototype._update = function (M) {
		var w = this._w;

		var a = this._a | 0;
		var b = this._b | 0;
		var c = this._c | 0;
		var d = this._d | 0;
		var e = this._e | 0;

		for (var i = 0; i < 16; ++i) {
			w[i] = M.readInt32BE(i * 4);
		}
		for (; i < 80; ++i) {
			w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
		}

		for (var j = 0; j < 80; ++j) {
			var s = ~~(j / 20);
			var t = (rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s]) | 0;

			e = d;
			d = c;
			c = rotl30(b);
			b = a;
			a = t;
		}

		this._a = (a + this._a) | 0;
		this._b = (b + this._b) | 0;
		this._c = (c + this._c) | 0;
		this._d = (d + this._d) | 0;
		this._e = (e + this._e) | 0;
	};

	Sha1.prototype._hash = function () {
		var H = Buffer.allocUnsafe(20);

		H.writeInt32BE(this._a | 0, 0);
		H.writeInt32BE(this._b | 0, 4);
		H.writeInt32BE(this._c | 0, 8);
		H.writeInt32BE(this._d | 0, 12);
		H.writeInt32BE(this._e | 0, 16);

		return H;
	};

	sha1 = Sha1;
	return sha1;
}

var sha256;
var hasRequiredSha256;

function requireSha256 () {
	if (hasRequiredSha256) return sha256;
	hasRequiredSha256 = 1;

	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = requireInherits();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var K = [
		0x428A2F98,
		0x71374491,
		0xB5C0FBCF,
		0xE9B5DBA5,
		0x3956C25B,
		0x59F111F1,
		0x923F82A4,
		0xAB1C5ED5,
		0xD807AA98,
		0x12835B01,
		0x243185BE,
		0x550C7DC3,
		0x72BE5D74,
		0x80DEB1FE,
		0x9BDC06A7,
		0xC19BF174,
		0xE49B69C1,
		0xEFBE4786,
		0x0FC19DC6,
		0x240CA1CC,
		0x2DE92C6F,
		0x4A7484AA,
		0x5CB0A9DC,
		0x76F988DA,
		0x983E5152,
		0xA831C66D,
		0xB00327C8,
		0xBF597FC7,
		0xC6E00BF3,
		0xD5A79147,
		0x06CA6351,
		0x14292967,
		0x27B70A85,
		0x2E1B2138,
		0x4D2C6DFC,
		0x53380D13,
		0x650A7354,
		0x766A0ABB,
		0x81C2C92E,
		0x92722C85,
		0xA2BFE8A1,
		0xA81A664B,
		0xC24B8B70,
		0xC76C51A3,
		0xD192E819,
		0xD6990624,
		0xF40E3585,
		0x106AA070,
		0x19A4C116,
		0x1E376C08,
		0x2748774C,
		0x34B0BCB5,
		0x391C0CB3,
		0x4ED8AA4A,
		0x5B9CCA4F,
		0x682E6FF3,
		0x748F82EE,
		0x78A5636F,
		0x84C87814,
		0x8CC70208,
		0x90BEFFFA,
		0xA4506CEB,
		0xBEF9A3F7,
		0xC67178F2
	];

	var W = new Array(64);

	function Sha256() {
		this.init();

		this._w = W; // new Array(64)

		Hash.call(this, 64, 56);
	}

	inherits(Sha256, Hash);

	Sha256.prototype.init = function () {
		this._a = 0x6a09e667;
		this._b = 0xbb67ae85;
		this._c = 0x3c6ef372;
		this._d = 0xa54ff53a;
		this._e = 0x510e527f;
		this._f = 0x9b05688c;
		this._g = 0x1f83d9ab;
		this._h = 0x5be0cd19;

		return this;
	};

	function ch(x, y, z) {
		return z ^ (x & (y ^ z));
	}

	function maj(x, y, z) {
		return (x & y) | (z & (x | y));
	}

	function sigma0(x) {
		return ((x >>> 2) | (x << 30)) ^ ((x >>> 13) | (x << 19)) ^ ((x >>> 22) | (x << 10));
	}

	function sigma1(x) {
		return ((x >>> 6) | (x << 26)) ^ ((x >>> 11) | (x << 21)) ^ ((x >>> 25) | (x << 7));
	}

	function gamma0(x) {
		return ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);
	}

	function gamma1(x) {
		return ((x >>> 17) | (x << 15)) ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);
	}

	Sha256.prototype._update = function (M) {
		var w = this._w;

		var a = this._a | 0;
		var b = this._b | 0;
		var c = this._c | 0;
		var d = this._d | 0;
		var e = this._e | 0;
		var f = this._f | 0;
		var g = this._g | 0;
		var h = this._h | 0;

		for (var i = 0; i < 16; ++i) {
			w[i] = M.readInt32BE(i * 4);
		}
		for (; i < 64; ++i) {
			w[i] = (gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16]) | 0;
		}

		for (var j = 0; j < 64; ++j) {
			var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + w[j]) | 0;
			var T2 = (sigma0(a) + maj(a, b, c)) | 0;

			h = g;
			g = f;
			f = e;
			e = (d + T1) | 0;
			d = c;
			c = b;
			b = a;
			a = (T1 + T2) | 0;
		}

		this._a = (a + this._a) | 0;
		this._b = (b + this._b) | 0;
		this._c = (c + this._c) | 0;
		this._d = (d + this._d) | 0;
		this._e = (e + this._e) | 0;
		this._f = (f + this._f) | 0;
		this._g = (g + this._g) | 0;
		this._h = (h + this._h) | 0;
	};

	Sha256.prototype._hash = function () {
		var H = Buffer.allocUnsafe(32);

		H.writeInt32BE(this._a, 0);
		H.writeInt32BE(this._b, 4);
		H.writeInt32BE(this._c, 8);
		H.writeInt32BE(this._d, 12);
		H.writeInt32BE(this._e, 16);
		H.writeInt32BE(this._f, 20);
		H.writeInt32BE(this._g, 24);
		H.writeInt32BE(this._h, 28);

		return H;
	};

	sha256 = Sha256;
	return sha256;
}

var sha224;
var hasRequiredSha224;

function requireSha224 () {
	if (hasRequiredSha224) return sha224;
	hasRequiredSha224 = 1;

	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = requireInherits();
	var Sha256 = requireSha256();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var W = new Array(64);

	function Sha224() {
		this.init();

		this._w = W; // new Array(64)

		Hash.call(this, 64, 56);
	}

	inherits(Sha224, Sha256);

	Sha224.prototype.init = function () {
		this._a = 0xc1059ed8;
		this._b = 0x367cd507;
		this._c = 0x3070dd17;
		this._d = 0xf70e5939;
		this._e = 0xffc00b31;
		this._f = 0x68581511;
		this._g = 0x64f98fa7;
		this._h = 0xbefa4fa4;

		return this;
	};

	Sha224.prototype._hash = function () {
		var H = Buffer.allocUnsafe(28);

		H.writeInt32BE(this._a, 0);
		H.writeInt32BE(this._b, 4);
		H.writeInt32BE(this._c, 8);
		H.writeInt32BE(this._d, 12);
		H.writeInt32BE(this._e, 16);
		H.writeInt32BE(this._f, 20);
		H.writeInt32BE(this._g, 24);

		return H;
	};

	sha224 = Sha224;
	return sha224;
}

var sha512;
var hasRequiredSha512;

function requireSha512 () {
	if (hasRequiredSha512) return sha512;
	hasRequiredSha512 = 1;

	var inherits = requireInherits();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var K = [
		0x428a2f98,
		0xd728ae22,
		0x71374491,
		0x23ef65cd,
		0xb5c0fbcf,
		0xec4d3b2f,
		0xe9b5dba5,
		0x8189dbbc,
		0x3956c25b,
		0xf348b538,
		0x59f111f1,
		0xb605d019,
		0x923f82a4,
		0xaf194f9b,
		0xab1c5ed5,
		0xda6d8118,
		0xd807aa98,
		0xa3030242,
		0x12835b01,
		0x45706fbe,
		0x243185be,
		0x4ee4b28c,
		0x550c7dc3,
		0xd5ffb4e2,
		0x72be5d74,
		0xf27b896f,
		0x80deb1fe,
		0x3b1696b1,
		0x9bdc06a7,
		0x25c71235,
		0xc19bf174,
		0xcf692694,
		0xe49b69c1,
		0x9ef14ad2,
		0xefbe4786,
		0x384f25e3,
		0x0fc19dc6,
		0x8b8cd5b5,
		0x240ca1cc,
		0x77ac9c65,
		0x2de92c6f,
		0x592b0275,
		0x4a7484aa,
		0x6ea6e483,
		0x5cb0a9dc,
		0xbd41fbd4,
		0x76f988da,
		0x831153b5,
		0x983e5152,
		0xee66dfab,
		0xa831c66d,
		0x2db43210,
		0xb00327c8,
		0x98fb213f,
		0xbf597fc7,
		0xbeef0ee4,
		0xc6e00bf3,
		0x3da88fc2,
		0xd5a79147,
		0x930aa725,
		0x06ca6351,
		0xe003826f,
		0x14292967,
		0x0a0e6e70,
		0x27b70a85,
		0x46d22ffc,
		0x2e1b2138,
		0x5c26c926,
		0x4d2c6dfc,
		0x5ac42aed,
		0x53380d13,
		0x9d95b3df,
		0x650a7354,
		0x8baf63de,
		0x766a0abb,
		0x3c77b2a8,
		0x81c2c92e,
		0x47edaee6,
		0x92722c85,
		0x1482353b,
		0xa2bfe8a1,
		0x4cf10364,
		0xa81a664b,
		0xbc423001,
		0xc24b8b70,
		0xd0f89791,
		0xc76c51a3,
		0x0654be30,
		0xd192e819,
		0xd6ef5218,
		0xd6990624,
		0x5565a910,
		0xf40e3585,
		0x5771202a,
		0x106aa070,
		0x32bbd1b8,
		0x19a4c116,
		0xb8d2d0c8,
		0x1e376c08,
		0x5141ab53,
		0x2748774c,
		0xdf8eeb99,
		0x34b0bcb5,
		0xe19b48a8,
		0x391c0cb3,
		0xc5c95a63,
		0x4ed8aa4a,
		0xe3418acb,
		0x5b9cca4f,
		0x7763e373,
		0x682e6ff3,
		0xd6b2b8a3,
		0x748f82ee,
		0x5defb2fc,
		0x78a5636f,
		0x43172f60,
		0x84c87814,
		0xa1f0ab72,
		0x8cc70208,
		0x1a6439ec,
		0x90befffa,
		0x23631e28,
		0xa4506ceb,
		0xde82bde9,
		0xbef9a3f7,
		0xb2c67915,
		0xc67178f2,
		0xe372532b,
		0xca273ece,
		0xea26619c,
		0xd186b8c7,
		0x21c0c207,
		0xeada7dd6,
		0xcde0eb1e,
		0xf57d4f7f,
		0xee6ed178,
		0x06f067aa,
		0x72176fba,
		0x0a637dc5,
		0xa2c898a6,
		0x113f9804,
		0xbef90dae,
		0x1b710b35,
		0x131c471b,
		0x28db77f5,
		0x23047d84,
		0x32caab7b,
		0x40c72493,
		0x3c9ebe0a,
		0x15c9bebc,
		0x431d67c4,
		0x9c100d4c,
		0x4cc5d4be,
		0xcb3e42b6,
		0x597f299c,
		0xfc657e2a,
		0x5fcb6fab,
		0x3ad6faec,
		0x6c44198c,
		0x4a475817
	];

	var W = new Array(160);

	function Sha512() {
		this.init();
		this._w = W;

		Hash.call(this, 128, 112);
	}

	inherits(Sha512, Hash);

	Sha512.prototype.init = function () {
		this._ah = 0x6a09e667;
		this._bh = 0xbb67ae85;
		this._ch = 0x3c6ef372;
		this._dh = 0xa54ff53a;
		this._eh = 0x510e527f;
		this._fh = 0x9b05688c;
		this._gh = 0x1f83d9ab;
		this._hh = 0x5be0cd19;

		this._al = 0xf3bcc908;
		this._bl = 0x84caa73b;
		this._cl = 0xfe94f82b;
		this._dl = 0x5f1d36f1;
		this._el = 0xade682d1;
		this._fl = 0x2b3e6c1f;
		this._gl = 0xfb41bd6b;
		this._hl = 0x137e2179;

		return this;
	};

	function Ch(x, y, z) {
		return z ^ (x & (y ^ z));
	}

	function maj(x, y, z) {
		return (x & y) | (z & (x | y));
	}

	function sigma0(x, xl) {
		return ((x >>> 28) | (xl << 4)) ^ ((xl >>> 2) | (x << 30)) ^ ((xl >>> 7) | (x << 25));
	}

	function sigma1(x, xl) {
		return ((x >>> 14) | (xl << 18)) ^ ((x >>> 18) | (xl << 14)) ^ ((xl >>> 9) | (x << 23));
	}

	function Gamma0(x, xl) {
		return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ (x >>> 7);
	}

	function Gamma0l(x, xl) {
		return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ ((x >>> 7) | (xl << 25));
	}

	function Gamma1(x, xl) {
		return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ (x >>> 6);
	}

	function Gamma1l(x, xl) {
		return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ ((x >>> 6) | (xl << 26));
	}

	function getCarry(a, b) {
		return (a >>> 0) < (b >>> 0) ? 1 : 0;
	}

	Sha512.prototype._update = function (M) {
		var w = this._w;

		var ah = this._ah | 0;
		var bh = this._bh | 0;
		var ch = this._ch | 0;
		var dh = this._dh | 0;
		var eh = this._eh | 0;
		var fh = this._fh | 0;
		var gh = this._gh | 0;
		var hh = this._hh | 0;

		var al = this._al | 0;
		var bl = this._bl | 0;
		var cl = this._cl | 0;
		var dl = this._dl | 0;
		var el = this._el | 0;
		var fl = this._fl | 0;
		var gl = this._gl | 0;
		var hl = this._hl | 0;

		for (var i = 0; i < 32; i += 2) {
			w[i] = M.readInt32BE(i * 4);
			w[i + 1] = M.readInt32BE((i * 4) + 4);
		}
		for (; i < 160; i += 2) {
			var xh = w[i - (15 * 2)];
			var xl = w[i - (15 * 2) + 1];
			var gamma0 = Gamma0(xh, xl);
			var gamma0l = Gamma0l(xl, xh);

			xh = w[i - (2 * 2)];
			xl = w[i - (2 * 2) + 1];
			var gamma1 = Gamma1(xh, xl);
			var gamma1l = Gamma1l(xl, xh);

			// w[i] = gamma0 + w[i - 7] + gamma1 + w[i - 16]
			var Wi7h = w[i - (7 * 2)];
			var Wi7l = w[i - (7 * 2) + 1];

			var Wi16h = w[i - (16 * 2)];
			var Wi16l = w[i - (16 * 2) + 1];

			var Wil = (gamma0l + Wi7l) | 0;
			var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
			Wil = (Wil + gamma1l) | 0;
			Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
			Wil = (Wil + Wi16l) | 0;
			Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

			w[i] = Wih;
			w[i + 1] = Wil;
		}

		for (var j = 0; j < 160; j += 2) {
			Wih = w[j];
			Wil = w[j + 1];

			var majh = maj(ah, bh, ch);
			var majl = maj(al, bl, cl);

			var sigma0h = sigma0(ah, al);
			var sigma0l = sigma0(al, ah);
			var sigma1h = sigma1(eh, el);
			var sigma1l = sigma1(el, eh);

			// t1 = h + sigma1 + ch + K[j] + w[j]
			var Kih = K[j];
			var Kil = K[j + 1];

			var chh = Ch(eh, fh, gh);
			var chl = Ch(el, fl, gl);

			var t1l = (hl + sigma1l) | 0;
			var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
			t1l = (t1l + chl) | 0;
			t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
			t1l = (t1l + Kil) | 0;
			t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
			t1l = (t1l + Wil) | 0;
			t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

			// t2 = sigma0 + maj
			var t2l = (sigma0l + majl) | 0;
			var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

			hh = gh;
			hl = gl;
			gh = fh;
			gl = fl;
			fh = eh;
			fl = el;
			el = (dl + t1l) | 0;
			eh = (dh + t1h + getCarry(el, dl)) | 0;
			dh = ch;
			dl = cl;
			ch = bh;
			cl = bl;
			bh = ah;
			bl = al;
			al = (t1l + t2l) | 0;
			ah = (t1h + t2h + getCarry(al, t1l)) | 0;
		}

		this._al = (this._al + al) | 0;
		this._bl = (this._bl + bl) | 0;
		this._cl = (this._cl + cl) | 0;
		this._dl = (this._dl + dl) | 0;
		this._el = (this._el + el) | 0;
		this._fl = (this._fl + fl) | 0;
		this._gl = (this._gl + gl) | 0;
		this._hl = (this._hl + hl) | 0;

		this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
		this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
		this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
		this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
		this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
		this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
		this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
		this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
	};

	Sha512.prototype._hash = function () {
		var H = Buffer.allocUnsafe(64);

		function writeInt64BE(h, l, offset) {
			H.writeInt32BE(h, offset);
			H.writeInt32BE(l, offset + 4);
		}

		writeInt64BE(this._ah, this._al, 0);
		writeInt64BE(this._bh, this._bl, 8);
		writeInt64BE(this._ch, this._cl, 16);
		writeInt64BE(this._dh, this._dl, 24);
		writeInt64BE(this._eh, this._el, 32);
		writeInt64BE(this._fh, this._fl, 40);
		writeInt64BE(this._gh, this._gl, 48);
		writeInt64BE(this._hh, this._hl, 56);

		return H;
	};

	sha512 = Sha512;
	return sha512;
}

var sha384;
var hasRequiredSha384;

function requireSha384 () {
	if (hasRequiredSha384) return sha384;
	hasRequiredSha384 = 1;

	var inherits = requireInherits();
	var SHA512 = requireSha512();
	var Hash = requireHash();
	var Buffer = requireSafeBuffer().Buffer;

	var W = new Array(160);

	function Sha384() {
		this.init();
		this._w = W;

		Hash.call(this, 128, 112);
	}

	inherits(Sha384, SHA512);

	Sha384.prototype.init = function () {
		this._ah = 0xcbbb9d5d;
		this._bh = 0x629a292a;
		this._ch = 0x9159015a;
		this._dh = 0x152fecd8;
		this._eh = 0x67332667;
		this._fh = 0x8eb44a87;
		this._gh = 0xdb0c2e0d;
		this._hh = 0x47b5481d;

		this._al = 0xc1059ed8;
		this._bl = 0x367cd507;
		this._cl = 0x3070dd17;
		this._dl = 0xf70e5939;
		this._el = 0xffc00b31;
		this._fl = 0x68581511;
		this._gl = 0x64f98fa7;
		this._hl = 0xbefa4fa4;

		return this;
	};

	Sha384.prototype._hash = function () {
		var H = Buffer.allocUnsafe(48);

		function writeInt64BE(h, l, offset) {
			H.writeInt32BE(h, offset);
			H.writeInt32BE(l, offset + 4);
		}

		writeInt64BE(this._ah, this._al, 0);
		writeInt64BE(this._bh, this._bl, 8);
		writeInt64BE(this._ch, this._cl, 16);
		writeInt64BE(this._dh, this._dl, 24);
		writeInt64BE(this._eh, this._el, 32);
		writeInt64BE(this._fh, this._fl, 40);

		return H;
	};

	sha384 = Sha384;
	return sha384;
}

var hasRequiredSha_js;

function requireSha_js () {
	if (hasRequiredSha_js) return sha_js.exports;
	hasRequiredSha_js = 1;
	(function (module) {

		module.exports = function SHA(algorithm) {
			var alg = algorithm.toLowerCase();

			var Algorithm = module.exports[alg];
			if (!Algorithm) {
				throw new Error(alg + ' is not supported (we accept pull requests)');
			}

			return new Algorithm();
		};

		module.exports.sha = requireSha();
		module.exports.sha1 = requireSha1();
		module.exports.sha224 = requireSha224();
		module.exports.sha256 = requireSha256();
		module.exports.sha384 = requireSha384();
		module.exports.sha512 = requireSha512(); 
	} (sha_js));
	return sha_js.exports;
}

var sha_jsExports = requireSha_js();
const shajs = /*@__PURE__*/getDefaultExportFromCjs$1(sha_jsExports);

var ABIDataTypes;
(function (ABIDataTypes) {
    // Unsigned integers
    ABIDataTypes["UINT8"] = "UINT8";
    ABIDataTypes["UINT16"] = "UINT16";
    ABIDataTypes["UINT32"] = "UINT32";
    ABIDataTypes["UINT64"] = "UINT64";
    ABIDataTypes["UINT128"] = "UINT128";
    ABIDataTypes["UINT256"] = "UINT256";
    // Signed integers
    ABIDataTypes["INT8"] = "INT8";
    ABIDataTypes["INT16"] = "INT16";
    ABIDataTypes["INT32"] = "INT32";
    ABIDataTypes["INT64"] = "INT64";
    ABIDataTypes["INT128"] = "INT128";
    // Basic types
    ABIDataTypes["BOOL"] = "BOOL";
    ABIDataTypes["ADDRESS"] = "ADDRESS";
    ABIDataTypes["EXTENDED_ADDRESS"] = "EXTENDED_ADDRESS";
    ABIDataTypes["STRING"] = "STRING";
    ABIDataTypes["BYTES4"] = "BYTES4";
    ABIDataTypes["BYTES32"] = "BYTES32";
    ABIDataTypes["BYTES"] = "BYTES";
    // Tuples/Maps
    ABIDataTypes["ADDRESS_UINT256_TUPLE"] = "ADDRESS_UINT256_TUPLE";
    ABIDataTypes["EXTENDED_ADDRESS_UINT256_TUPLE"] = "EXTENDED_ADDRESS_UINT256_TUPLE";
    // Signatures
    ABIDataTypes["SCHNORR_SIGNATURE"] = "SCHNORR_SIGNATURE";
    // Arrays
    ABIDataTypes["ARRAY_OF_ADDRESSES"] = "ARRAY_OF_ADDRESSES";
    ABIDataTypes["ARRAY_OF_EXTENDED_ADDRESSES"] = "ARRAY_OF_EXTENDED_ADDRESSES";
    ABIDataTypes["ARRAY_OF_UINT256"] = "ARRAY_OF_UINT256";
    ABIDataTypes["ARRAY_OF_UINT128"] = "ARRAY_OF_UINT128";
    ABIDataTypes["ARRAY_OF_UINT64"] = "ARRAY_OF_UINT64";
    ABIDataTypes["ARRAY_OF_UINT32"] = "ARRAY_OF_UINT32";
    ABIDataTypes["ARRAY_OF_UINT16"] = "ARRAY_OF_UINT16";
    ABIDataTypes["ARRAY_OF_UINT8"] = "ARRAY_OF_UINT8";
    ABIDataTypes["ARRAY_OF_STRING"] = "ARRAY_OF_STRING";
    ABIDataTypes["ARRAY_OF_BYTES"] = "ARRAY_OF_BYTES";
    ABIDataTypes["ARRAY_OF_BUFFERS"] = "ARRAY_OF_BUFFERS";
})(ABIDataTypes || (ABIDataTypes = {}));

/**
 * Canonical string â†’ ABIDataTypes mapping.
 * Only includes canonical ABI-style names (not AssemblyScript aliases).
 */
({
    address: ABIDataTypes.ADDRESS,
    extendedAddress: ABIDataTypes.EXTENDED_ADDRESS,
    bool: ABIDataTypes.BOOL,
    bytes: ABIDataTypes.BYTES,
    uint256: ABIDataTypes.UINT256,
    uint128: ABIDataTypes.UINT128,
    uint64: ABIDataTypes.UINT64,
    uint32: ABIDataTypes.UINT32,
    uint16: ABIDataTypes.UINT16,
    uint8: ABIDataTypes.UINT8,
    int128: ABIDataTypes.INT128,
    int64: ABIDataTypes.INT64,
    int32: ABIDataTypes.INT32,
    int16: ABIDataTypes.INT16,
    int8: ABIDataTypes.INT8,
    string: ABIDataTypes.STRING,
    bytes4: ABIDataTypes.BYTES4,
    bytes32: ABIDataTypes.BYTES32,
    schnorrSignature: ABIDataTypes.SCHNORR_SIGNATURE,
    'tuple(address,uint256)[]': ABIDataTypes.ADDRESS_UINT256_TUPLE,
    'tuple(extendedAddress,uint256)[]': ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE,
    'address[]': ABIDataTypes.ARRAY_OF_ADDRESSES,
    'extendedAddress[]': ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES,
    'uint256[]': ABIDataTypes.ARRAY_OF_UINT256,
    'uint128[]': ABIDataTypes.ARRAY_OF_UINT128,
    'uint64[]': ABIDataTypes.ARRAY_OF_UINT64,
    'uint32[]': ABIDataTypes.ARRAY_OF_UINT32,
    'uint16[]': ABIDataTypes.ARRAY_OF_UINT16,
    'uint8[]': ABIDataTypes.ARRAY_OF_UINT8,
    'bytes[]': ABIDataTypes.ARRAY_OF_BYTES,
    'buffer[]': ABIDataTypes.ARRAY_OF_BUFFERS,
    'string[]': ABIDataTypes.ARRAY_OF_STRING,
    boolean: ABIDataTypes.BOOL,
});
/**
 * Canonical reverse mapping: ABIDataTypes â†’ canonical string.
 */
const AbiTypeToStr = {
    [ABIDataTypes.ADDRESS]: 'address',
    [ABIDataTypes.EXTENDED_ADDRESS]: 'extendedAddress',
    [ABIDataTypes.BOOL]: 'bool',
    [ABIDataTypes.BYTES]: 'bytes',
    [ABIDataTypes.BYTES32]: 'bytes32',
    [ABIDataTypes.BYTES4]: 'bytes4',
    [ABIDataTypes.UINT256]: 'uint256',
    [ABIDataTypes.UINT128]: 'uint128',
    [ABIDataTypes.UINT64]: 'uint64',
    [ABIDataTypes.UINT32]: 'uint32',
    [ABIDataTypes.UINT16]: 'uint16',
    [ABIDataTypes.UINT8]: 'uint8',
    [ABIDataTypes.INT128]: 'int128',
    [ABIDataTypes.INT64]: 'int64',
    [ABIDataTypes.INT32]: 'int32',
    [ABIDataTypes.INT16]: 'int16',
    [ABIDataTypes.INT8]: 'int8',
    [ABIDataTypes.STRING]: 'string',
    [ABIDataTypes.ADDRESS_UINT256_TUPLE]: 'tuple(address,uint256)[]',
    [ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE]: 'tuple(extendedAddress,uint256)[]',
    [ABIDataTypes.SCHNORR_SIGNATURE]: 'schnorrSignature',
    [ABIDataTypes.ARRAY_OF_ADDRESSES]: 'address[]',
    [ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES]: 'extendedAddress[]',
    [ABIDataTypes.ARRAY_OF_UINT256]: 'uint256[]',
    [ABIDataTypes.ARRAY_OF_UINT128]: 'uint128[]',
    [ABIDataTypes.ARRAY_OF_UINT64]: 'uint64[]',
    [ABIDataTypes.ARRAY_OF_UINT32]: 'uint32[]',
    [ABIDataTypes.ARRAY_OF_UINT16]: 'uint16[]',
    [ABIDataTypes.ARRAY_OF_UINT8]: 'uint8[]',
    [ABIDataTypes.ARRAY_OF_BYTES]: 'bytes[]',
    [ABIDataTypes.ARRAY_OF_STRING]: 'string[]',
    [ABIDataTypes.ARRAY_OF_BUFFERS]: 'buffer[]',
};

/**
 * Type guard: returns true if the ABI type is a tuple (ordered array of types).
 */
function isAbiTuple(type) {
    return Array.isArray(type);
}
/**
 * Type guard: returns true if the ABI type is a struct (named fields).
 */
function isAbiStruct(type) {
    return typeof type === 'object' && type !== null && !Array.isArray(type);
}
/**
 * Type guard: returns true if the ABI type is a simple ABIDataTypes enum value.
 */
function isSimpleAbiType(type) {
    return typeof type === 'string';
}
/**
 * Converts a structured AbiType into a canonical selector string.
 * - Simple: ABIDataTypes.ADDRESS â†’ "address"
 * - Struct: { a: ADDRESS, b: UINT256 } â†’ "tuple(address,uint256)" (inline, no [])
 * - Single-element tuple: [UINT256] â†’ "uint256[]"
 * - Multi-element tuple: [ADDRESS, UINT256] â†’ "tuple(address,uint256)[]"
 */
function abiTypeToSelectorString(type) {
    if (isSimpleAbiType(type)) {
        const str = AbiTypeToStr[type];
        if (!str) {
            throw new Error(`Unknown ABI type: ${type}`);
        }
        return str;
    }
    // Struct: inline tuple (no [] suffix)
    if (isAbiStruct(type)) {
        const inner = Object.values(type)
            .map((t) => abiTypeToSelectorString(t))
            .join(',');
        return `tuple(${inner})`;
    }
    // Single-element tuple: unwrap to "type[]"
    const firstType = type[0];
    if (type.length === 1 && firstType !== undefined) {
        return `${abiTypeToSelectorString(firstType)}[]`;
    }
    // Multi-element tuple: "tuple(types...)[]"
    const inner = type.map((t) => abiTypeToSelectorString(t)).join(',');
    return `tuple(${inner})[]`;
}

class ABICoder {
    decodeData(data, types) {
        const byteReader = new BinaryReader(data);
        const result = [];
        for (const type of types) {
            result.push(this.decodeSingleValue(byteReader, type));
        }
        return result;
    }
    encodeSelector(selectorIdentifier) {
        // first 4 bytes of sha256 hash of the function signature
        const hash = this.sha256(selectorIdentifier);
        const selector = hash.subarray(0, 4); // 4 bytes
        return Array.from(selector, (b) => b.toString(16).padStart(2, '0')).join('');
    }
    numericSelectorToHex(selector) {
        return selector.toString(16);
    }
    /**
     * Decodes a single value from the reader based on the ABI type.
     * Supports ABIDataTypes enum values, tuple arrays, and struct objects.
     */
    decodeSingleValue(reader, type) {
        if (isAbiTuple(type)) {
            // Single-element tuple: unwrap to flat array
            const firstType = type[0];
            if (type.length === 1 && firstType !== undefined) {
                return this.decodeArray(reader, firstType);
            }
            return this.decodeTuple(reader, type);
        }
        if (isAbiStruct(type)) {
            return this.decodeStruct(reader, type);
        }
        switch (type) {
            case ABIDataTypes.UINT8:
                return reader.readU8();
            case ABIDataTypes.UINT16:
                return reader.readU16();
            case ABIDataTypes.UINT32:
                return reader.readU32();
            case ABIDataTypes.BYTES4:
                return reader.readBytes(4);
            case ABIDataTypes.BYTES32:
                return reader.readBytes(32);
            case ABIDataTypes.BOOL:
                return reader.readBoolean();
            case ABIDataTypes.ADDRESS:
                return reader.readAddress();
            case ABIDataTypes.STRING:
                return reader.readStringWithLength();
            case ABIDataTypes.UINT128:
                return reader.readU128();
            case ABIDataTypes.UINT256:
                return reader.readU256();
            case ABIDataTypes.INT8:
                return reader.readI8();
            case ABIDataTypes.INT16:
                return reader.readI16();
            case ABIDataTypes.INT32:
                return reader.readI32();
            case ABIDataTypes.INT64:
                return reader.readI64();
            case ABIDataTypes.INT128:
                return reader.readI128();
            case ABIDataTypes.EXTENDED_ADDRESS:
                return reader.readExtendedAddress();
            case ABIDataTypes.ADDRESS_UINT256_TUPLE:
                return reader.readAddressValueTuple();
            case ABIDataTypes.EXTENDED_ADDRESS_UINT256_TUPLE:
                return reader.readExtendedAddressMapU256();
            case ABIDataTypes.SCHNORR_SIGNATURE:
                return reader.readSchnorrSignature();
            case ABIDataTypes.BYTES:
                return reader.readBytesWithLength();
            case ABIDataTypes.UINT64:
                return reader.readU64();
            case ABIDataTypes.ARRAY_OF_ADDRESSES:
                return reader.readAddressArray();
            case ABIDataTypes.ARRAY_OF_EXTENDED_ADDRESSES:
                return reader.readExtendedAddressArray();
            case ABIDataTypes.ARRAY_OF_UINT256:
                return reader.readU256Array();
            case ABIDataTypes.ARRAY_OF_UINT128:
                return reader.readU128Array();
            case ABIDataTypes.ARRAY_OF_UINT64:
                return reader.readU64Array();
            case ABIDataTypes.ARRAY_OF_UINT32:
                return reader.readU32Array();
            case ABIDataTypes.ARRAY_OF_UINT16:
                return reader.readU16Array();
            case ABIDataTypes.ARRAY_OF_UINT8:
                return reader.readU8Array();
            case ABIDataTypes.ARRAY_OF_STRING:
                return reader.readStringArray();
            case ABIDataTypes.ARRAY_OF_BYTES:
                return reader.readBytesArray();
            case ABIDataTypes.ARRAY_OF_BUFFERS:
                return reader.readArrayOfBuffer();
            default:
                throw new Error(`Unsupported ABI type: ${type}`);
        }
    }
    /** Decodes a single-element tuple as a flat typed array (u16 count + values). */
    decodeArray(reader, elementType) {
        const count = reader.readU16();
        const result = [];
        for (let i = 0; i < count; i++) {
            result.push(this.decodeSingleValue(reader, elementType));
        }
        return result;
    }
    /** Decodes a multi-element tuple as array of tuple entries (u16 count + entries). */
    decodeTuple(reader, types) {
        const count = reader.readU16();
        const result = [];
        for (let i = 0; i < count; i++) {
            const entry = [];
            for (const fieldType of types) {
                entry.push(this.decodeSingleValue(reader, fieldType));
            }
            result.push(entry);
        }
        return result;
    }
    /** Decodes a struct as a single object with named fields (inline, no count prefix). */
    decodeStruct(reader, struct) {
        const entry = {};
        for (const [name, fieldType] of Object.entries(struct)) {
            entry[name] = this.decodeSingleValue(reader, fieldType);
        }
        return entry;
    }
    sha256(buffer) {
        return new Uint8Array(new shajs.sha256().update(buffer).digest());
    }
}

class NetEvent {
    type;
    data;
    constructor(type, data) {
        this.type = type;
        this.data = data;
    }
}

var XverseNetwork;
(function (XverseNetwork) {
    XverseNetwork["mainnet"] = "mainnet";
    XverseNetwork["testnet"] = "testnet";
    XverseNetwork["signet"] = "Signet";
})(XverseNetwork || (XverseNetwork = {}));
var SigningProtocol;
(function (SigningProtocol) {
    SigningProtocol["ECDSA"] = "ECDSA";
    SigningProtocol["BIP322"] = "BIP322";
})(SigningProtocol || (SigningProtocol = {}));

/*
How it works:
`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.
*/

class Node {
	value;
	next;

	constructor(value) {
		this.value = value;
	}
}

class Queue {
	#head;
	#tail;
	#size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node(value);

		if (this.#head) {
			this.#tail.next = node;
			this.#tail = node;
		} else {
			this.#head = node;
			this.#tail = node;
		}

		this.#size++;
	}

	dequeue() {
		const current = this.#head;
		if (!current) {
			return;
		}

		this.#head = this.#head.next;
		this.#size--;

		// Clean up tail reference when queue becomes empty
		if (!this.#head) {
			this.#tail = undefined;
		}

		return current.value;
	}

	peek() {
		if (!this.#head) {
			return;
		}

		return this.#head.value;

		// TODO: Node.js 18.
		// return this.#head?.value;
	}

	clear() {
		this.#head = undefined;
		this.#tail = undefined;
		this.#size = 0;
	}

	get size() {
		return this.#size;
	}

	* [Symbol.iterator]() {
		let current = this.#head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}

	* drain() {
		while (this.#head) {
			yield this.dequeue();
		}
	}
}

function pLimit(concurrency) {
	let rejectOnClear = false;

	if (typeof concurrency === 'object') {
		({concurrency, rejectOnClear = false} = concurrency);
	}

	validateConcurrency(concurrency);

	if (typeof rejectOnClear !== 'boolean') {
		throw new TypeError('Expected `rejectOnClear` to be a boolean');
	}

	const queue = new Queue();
	let activeCount = 0;

	const resumeNext = () => {
		// Process the next queued function if we're under the concurrency limit
		if (activeCount < concurrency && queue.size > 0) {
			activeCount++;
			queue.dequeue().run();
		}
	};

	const next = () => {
		activeCount--;
		resumeNext();
	};

	const run = async (function_, resolve, arguments_) => {
		// Execute the function and capture the result promise
		const result = (async () => function_(...arguments_))();

		// Resolve immediately with the promise (don't wait for completion)
		resolve(result);

		// Wait for the function to complete (success or failure)
		// We catch errors here to prevent unhandled rejections,
		// but the original promise rejection is preserved for the caller
		try {
			await result;
		} catch {}

		// Decrement active count and process next queued function
		next();
	};

	const enqueue = (function_, resolve, reject, arguments_) => {
		const queueItem = {reject};

		// Queue the internal resolve function instead of the run function
		// to preserve the asynchronous execution context.
		new Promise(internalResolve => { // eslint-disable-line promise/param-names
			queueItem.run = internalResolve;
			queue.enqueue(queueItem);
		}).then(run.bind(undefined, function_, resolve, arguments_)); // eslint-disable-line promise/prefer-await-to-then

		// Start processing immediately if we haven't reached the concurrency limit
		if (activeCount < concurrency) {
			resumeNext();
		}
	};

	const generator = (function_, ...arguments_) => new Promise((resolve, reject) => {
		enqueue(function_, resolve, reject, arguments_);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount,
		},
		pendingCount: {
			get: () => queue.size,
		},
		clearQueue: {
			value() {
				if (!rejectOnClear) {
					queue.clear();
					return;
				}

				const abortError = AbortSignal.abort().reason;

				while (queue.size > 0) {
					queue.dequeue().reject(abortError);
				}
			},
		},
		concurrency: {
			get: () => concurrency,

			set(newConcurrency) {
				validateConcurrency(newConcurrency);
				concurrency = newConcurrency;

				queueMicrotask(() => {
					// eslint-disable-next-line no-unmodified-loop-condition
					while (activeCount < concurrency && queue.size > 0) {
						resumeNext();
					}
				});
			},
		},
		map: {
			async value(iterable, function_) {
				const promises = Array.from(iterable, (value, index) => this(function_, value, index));
				return Promise.all(promises);
			},
		},
	});

	return generator;
}

function validateConcurrency(concurrency) {
	if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}
}

/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var wasm = null;
try {
  wasm = new WebAssembly.Instance(
    new WebAssembly.Module(
      new Uint8Array([
        // \0asm
        0,
        97,
        115,
        109,
        // version 1
        1,
        0,
        0,
        0,
        // section "type"
        1,
        13,
        2,
        // 0, () => i32
        96,
        0,
        1,
        127,
        // 1, (i32, i32, i32, i32) => i32
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        // section "function"
        3,
        7,
        6,
        // 0, type 0
        0,
        // 1, type 1
        1,
        // 2, type 1
        1,
        // 3, type 1
        1,
        // 4, type 1
        1,
        // 5, type 1
        1,
        // section "global"
        6,
        6,
        1,
        // 0, "high", mutable i32
        127,
        1,
        65,
        0,
        11,
        // section "export"
        7,
        50,
        6,
        // 0, "mul"
        3,
        109,
        117,
        108,
        0,
        1,
        // 1, "div_s"
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        // 2, "div_u"
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        // 3, "rem_s"
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        // 4, "rem_u"
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        // 5, "get_high"
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        // section "code"
        10,
        191,
        1,
        6,
        // 0, "get_high"
        4,
        0,
        35,
        0,
        11,
        // 1, "mul"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 2, "div_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 3, "div_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 4, "rem_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 5, "rem_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])
    ),
    {}
  ).exports;
} catch {
}
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}
Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache) UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache) INT_CACHE[value] = obj;
    return obj;
  }
}
Long.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value)) return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0) return UZERO;
    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  }
  if (value < 0) return fromNumber(-value, unsigned).neg();
  return fromBits(
    value % TWO_PWR_32_DBL | 0,
    value / TWO_PWR_32_DBL | 0,
    unsigned
  );
}
Long.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0) throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  var p;
  if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number") return fromNumber(val, unsigned);
  if (typeof val === "string") return fromString(val, unsigned);
  return fromBits(
    val.low,
    val.high,
    typeof unsigned === "boolean" ? unsigned : val.unsigned
  );
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero()) return digits + result;
    else {
      while (digits.length < 6) digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isSafeInteger = function isSafeInteger() {
  var top11Bits = this.high >> 21;
  if (!top11Bits) return true;
  if (this.unsigned) return false;
  return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
    /* validates */
    other
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
    /* validates */
    other
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
    /* validates */
    other
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.eq(other)) return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) return -1;
  if (!thisNeg && otherNeg) return 1;
  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend)) addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero()) return this;
  if (!isLong(multiplier)) multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
    else return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (divisor.isZero()) throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE)) return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative()) return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned) divisor = divisor.toUnsigned();
    if (divisor.gt(this)) return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero()) approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function and(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low << numBits,
      this.high << numBits | this.low >>> 32 - numBits,
      this.unsigned
    );
  else return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >> numBits,
      this.unsigned
    );
  else
    return fromBits(
      this.high >> numBits - 32,
      this.high >= 0 ? 0 : -1,
      this.unsigned
    );
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >>> numBits,
      this.unsigned
    );
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(
      this.low << numBits | this.high >>> b,
      this.high << numBits | this.low >>> b,
      this.unsigned
    );
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(
    this.high << numBits | this.low >>> b,
    this.low << numBits | this.high >>> b,
    this.unsigned
  );
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = 32 - numBits;
    return fromBits(
      this.high << b | this.low >>> numBits,
      this.low << b | this.high >>> numBits,
      this.unsigned
    );
  }
  numBits -= 32;
  b = 32 - numBits;
  return fromBits(
    this.low << b | this.high >>> numBits,
    this.high << b | this.low >>> numBits,
    this.unsigned
  );
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned) return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned) return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(
    bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
    bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
    unsigned
  );
};
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(
    bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
    bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
    unsigned
  );
};
if (typeof BigInt === "function") {
  Long.fromBigInt = function fromBigInt(value, unsigned) {
    var lowBits = Number(BigInt.asIntN(32, value));
    var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
    return fromBits(lowBits, highBits, unsigned);
  };
  Long.fromValue = function fromValueWithBigInt(value, unsigned) {
    if (typeof value === "bigint") return Long.fromBigInt(value, unsigned);
    return fromValue(value, unsigned);
  };
  LongPrototype.toBigInt = function toBigInt() {
    var lowBigInt = BigInt(this.low >>> 0);
    var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
    return highBigInt << BigInt(32) | lowBigInt;
  };
}

/*
 *      bignumber.js v9.3.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


var
  isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
  mathceil = Math.ceil,
  mathfloor = Math.floor,

  bignumberError = '[BigNumber Error] ',
  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

  BASE = 1e14,
  LOG_BASE = 14,
  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
  SQRT_BASE = 1e7,

  // EDITABLE
  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
  // the arguments to toExponential, toFixed, toFormat, and toPrecision.
  MAX = 1E9;                                   // 0 to MAX_INT32


/*
 * Create and return a BigNumber constructor.
 */
function clone(configObject) {
  var div, convertBase, parseNumeric,
    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
    ONE = new BigNumber(1),


    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


    // The default values below must be integers within the inclusive ranges stated.
    // The values can also be changed at run-time using BigNumber.set.

    // The maximum number of decimal places for operations involving division.
    DECIMAL_PLACES = 20,                     // 0 to MAX

    // The rounding mode used when rounding to the above decimal places, and when using
    // toExponential, toFixed, toFormat and toPrecision, and round (default value).
    // UP         0 Away from zero.
    // DOWN       1 Towards zero.
    // CEIL       2 Towards +Infinity.
    // FLOOR      3 Towards -Infinity.
    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    ROUNDING_MODE = 4,                       // 0 to 8

    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

    // The exponent value at and beneath which toString returns exponential notation.
    // Number type: -7
    TO_EXP_NEG = -7,                         // 0 to -MAX

    // The exponent value at and above which toString returns exponential notation.
    // Number type: 21
    TO_EXP_POS = 21,                         // 0 to MAX

    // RANGE : [MIN_EXP, MAX_EXP]

    // The minimum exponent value, beneath which underflow to zero occurs.
    // Number type: -324  (5e-324)
    MIN_EXP = -1e7,                          // -1 to -MAX

    // The maximum exponent value, above which overflow to Infinity occurs.
    // Number type:  308  (1.7976931348623157e+308)
    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
    MAX_EXP = 1e7,                           // 1 to MAX

    // Whether to use cryptographically-secure random number generation, if available.
    CRYPTO = false,                          // true or false

    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP        0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN      1 The remainder has the same sign as the dividend.
    //             This modulo mode is commonly known as 'truncated division' and is
    //             equivalent to (a % n) in JavaScript.
    // FLOOR     3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
    //             The remainder is always positive.
    //
    // The truncated division, floored division, Euclidian division and IEEE 754 remainder
    // modes are commonly used for the modulus operation.
    // Although the other rounding modes can also be used, they may not give useful results.
    MODULO_MODE = 1,                         // 0 to 9

    // The maximum number of significant digits of the result of the exponentiatedBy operation.
    // If POW_PRECISION is 0, there will be unlimited significant digits.
    POW_PRECISION = 0,                       // 0 to MAX

    // The format specification used by the BigNumber.prototype.toFormat method.
    FORMAT = {
      prefix: '',
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ',',
      decimalSeparator: '.',
      fractionGroupSize: 0,
      fractionGroupSeparator: '\xA0',        // non-breaking space
      suffix: ''
    },

    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
    // '-', '.', whitespace, or repeated character.
    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
    alphabetHasNormalDecimalDigits = true;


  //------------------------------------------------------------------------------------------


  // CONSTRUCTOR


  /*
   * The BigNumber constructor and exported function.
   * Create and return a new instance of a BigNumber object.
   *
   * v {number|string|BigNumber} A numeric value.
   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
   */
  function BigNumber(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str,
      x = this;

    // Enable constructor call without `new`.
    if (!(x instanceof BigNumber)) return new BigNumber(v, b);

    if (b == null) {

      if (v && v._isBigNumber === true) {
        x.s = v.s;

        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }

        return;
      }

      if ((isNum = typeof v == 'number') && v * 0 == 0) {

        // Use `1 / n` to handle minus zero also.
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;

        // Fast path for integers, where n < 2147483648 (2**31).
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++);

          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }

          return;
        }

        str = String(v);
      } else {

        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

      // Exponential form?
      if ((i = str.search(/e/i)) > 0) {

        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {

        // Integer.
        e = str.length;
      }

    } else {

      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
      intCheck(b, 2, ALPHABET.length, 'Base');

      // Allow exponential notation to be used with base 10 argument, while
      // also rounding to DECIMAL_PLACES as with other bases.
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }

      str = String(v);

      if (isNum = typeof v == 'number') {

        // Avoid potential interpretation of Infinity and NaN as base 44+ values.
        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
          throw Error
           (tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }

      alphabet = ALPHABET.slice(0, b);
      e = i = 0;

      // Check that str is a valid base b number.
      // Don't use RegExp, so alphabet can contain special characters.
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == '.') {

            // If '.' is not the first character and it has not be found before.
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {

            // Allow e.g. hexadecimal 'FF' as well as 'ff'.
            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }

          return parseNumeric(x, String(v), isNum, b);
        }
      }

      // Prevent later check for length on converted number.
      isNum = false;
      str = convertBase(str, b, 10, x.s);

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
      else e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48; i++);

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(--len) === 48;);

    if (str = str.slice(i, ++len)) {
      len -= i;

      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
      if (isNum && BigNumber.DEBUG &&
        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
          throw Error
           (tooManyDigits + (x.s * v));
      }

       // Overflow?
      if ((e = e - i - 1) > MAX_EXP) {

        // Infinity.
        x.c = x.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];

        // Transform base

        // e is the base 10 exponent.
        // i is where to slice str to get the first element of the coefficient array.
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;  // i < 1

        if (i < len) {
          if (i) x.c.push(+str.slice(0, i));

          for (len -= LOG_BASE; i < len;) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }

          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }

        for (; i--; str += '0');
        x.c.push(+str);
      }
    } else {

      // Zero.
      x.c = [x.e = 0];
    }
  }


  // CONSTRUCTOR PROPERTIES


  BigNumber.clone = clone;

  BigNumber.ROUND_UP = 0;
  BigNumber.ROUND_DOWN = 1;
  BigNumber.ROUND_CEIL = 2;
  BigNumber.ROUND_FLOOR = 3;
  BigNumber.ROUND_HALF_UP = 4;
  BigNumber.ROUND_HALF_DOWN = 5;
  BigNumber.ROUND_HALF_EVEN = 6;
  BigNumber.ROUND_HALF_CEIL = 7;
  BigNumber.ROUND_HALF_FLOOR = 8;
  BigNumber.EUCLID = 9;


  /*
   * Configure infrequently-changing library-wide settings.
   *
   * Accept an object with the following optional properties (if the value of a property is
   * a number, it must be an integer within the inclusive range stated):
   *
   *   DECIMAL_PLACES   {number}           0 to MAX
   *   ROUNDING_MODE    {number}           0 to 8
   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
   *   CRYPTO           {boolean}          true or false
   *   MODULO_MODE      {number}           0 to 9
   *   POW_PRECISION       {number}           0 to MAX
   *   ALPHABET         {string}           A string of two or more unique characters which does
   *                                       not contain '.'.
   *   FORMAT           {object}           An object with some of the following properties:
   *     prefix                 {string}
   *     groupSize              {number}
   *     secondaryGroupSize     {number}
   *     groupSeparator         {string}
   *     decimalSeparator       {string}
   *     fractionGroupSize      {number}
   *     fractionGroupSeparator {string}
   *     suffix                 {string}
   *
   * (The values assigned to the above FORMAT object properties are not checked for validity.)
   *
   * E.g.
   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
   *
   * Ignore properties/parameters set to null or undefined, except for ALPHABET.
   *
   * Return an object with the properties current values.
   */
  BigNumber.config = BigNumber.set = function (obj) {
    var p, v;

    if (obj != null) {

      if (typeof obj == 'object') {

        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }

        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }

        // EXPONENTIAL_AT {number|number[]}
        // Integer, -MAX to MAX inclusive or
        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }

        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
        if (obj.hasOwnProperty(p = 'RANGE')) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error
               (bignumberError + p + ' cannot be zero: ' + v);
            }
          }
        }

        // CRYPTO {boolean} true or false.
        // '[BigNumber Error] CRYPTO not true or false: {v}'
        // '[BigNumber Error] crypto unavailable'
        if (obj.hasOwnProperty(p = 'CRYPTO')) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != 'undefined' && crypto &&
               (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error
                 (bignumberError + 'crypto unavailable');
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error
             (bignumberError + p + ' not true or false: ' + v);
          }
        }

        // MODULO_MODE {number} Integer, 0 to 9 inclusive.
        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }

        // POW_PRECISION {number} Integer, 0 to MAX inclusive.
        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }

        // FORMAT {object}
        // '[BigNumber Error] FORMAT not an object: {v}'
        if (obj.hasOwnProperty(p = 'FORMAT')) {
          v = obj[p];
          if (typeof v == 'object') FORMAT = v;
          else throw Error
           (bignumberError + p + ' not an object: ' + v);
        }

        // ALPHABET {string}
        // '[BigNumber Error] ALPHABET invalid: {v}'
        if (obj.hasOwnProperty(p = 'ALPHABET')) {
          v = obj[p];

          // Disallow if less than two characters,
          // or if it contains '+', '-', '.', whitespace, or a repeated character.
          if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
            ALPHABET = v;
          } else {
            throw Error
             (bignumberError + p + ' invalid: ' + v);
          }
        }

      } else {

        // '[BigNumber Error] Object expected: {v}'
        throw Error
         (bignumberError + 'Object expected: ' + obj);
      }
    }

    return {
      DECIMAL_PLACES: DECIMAL_PLACES,
      ROUNDING_MODE: ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO: CRYPTO,
      MODULO_MODE: MODULO_MODE,
      POW_PRECISION: POW_PRECISION,
      FORMAT: FORMAT,
      ALPHABET: ALPHABET
    };
  };


  /*
   * Return true if v is a BigNumber instance, otherwise return false.
   *
   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
   *
   * v {any}
   *
   * '[BigNumber Error] Invalid BigNumber: {v}'
   */
  BigNumber.isBigNumber = function (v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber.DEBUG) return true;

    var i, n,
      c = v.c,
      e = v.e,
      s = v.s;

    out: if ({}.toString.call(c) == '[object Array]') {

      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

        // If the first element is zero, the BigNumber value must be zero.
        if (c[0] === 0) {
          if (e === 0 && c.length === 1) return true;
          break out;
        }

        // Calculate number of digits that c[0] should have, based on the exponent.
        i = (e + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;

        // Calculate number of digits of c[0].
        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
        if (String(c[0]).length == i) {

          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          }

          // Last element cannot be zero, unless it is the only element.
          if (n !== 0) return true;
        }
      }

    // Infinity/NaN
    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
      return true;
    }

    throw Error
      (bignumberError + 'Invalid BigNumber: ' + v);
  };


  /*
   * Return a new BigNumber whose value is the maximum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.maximum = BigNumber.max = function () {
    return maxOrMin(arguments, -1);
  };


  /*
   * Return a new BigNumber whose value is the minimum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.minimum = BigNumber.min = function () {
    return maxOrMin(arguments, 1);
  };


  /*
   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
   * zeros are produced).
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
   * '[BigNumber Error] crypto unavailable'
   */
  BigNumber.random = (function () {
    var pow2_53 = 0x20000000000000;

    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
    // Check if Math.random() produces more than 32 bits of randomness.
    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
     ? function () { return mathfloor(Math.random() * pow2_53); }
     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
       (Math.random() * 0x800000 | 0); };

    return function (dp) {
      var a, b, e, k, v,
        i = 0,
        c = [],
        rand = new BigNumber(ONE);

      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);

      k = mathceil(dp / LOG_BASE);

      if (CRYPTO) {

        // Browsers supporting crypto.getRandomValues.
        if (crypto.getRandomValues) {

          a = crypto.getRandomValues(new Uint32Array(k *= 2));

          for (; i < k;) {

            // 53 bits:
            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
            //                                     11111 11111111 11111111
            // 0x20000 is 2^21.
            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

            // Rejection sampling:
            // 0 <= v < 9007199254740992
            // Probability that v >= 9e15, is
            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {

              // 0 <= v <= 8999999999999999
              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;

        // Node.js supporting crypto.randomBytes.
        } else if (crypto.randomBytes) {

          // buffer
          a = crypto.randomBytes(k *= 7);

          for (; i < k;) {

            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
            // 0x100000000 is 2^32, 0x1000000 is 2^24
            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
            // 0 <= v < 9007199254740992
            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {

              // 0 <= (v % 1e14) <= 99999999999999
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error
           (bignumberError + 'crypto unavailable');
        }
      }

      // Use Math.random.
      if (!CRYPTO) {

        for (; i < k;) {
          v = random53bitInt();
          if (v < 9e15) c[i++] = v % 1e14;
        }
      }

      k = c[--i];
      dp %= LOG_BASE;

      // Convert trailing digits to zeros according to dp.
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }

      // Remove trailing elements which are zero.
      for (; c[i] === 0; c.pop(), i--);

      // Zero?
      if (i < 0) {
        c = [e = 0];
      } else {

        // Remove leading elements which are zero and adjust exponent accordingly.
        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

        // Count the digits of the first element of c to determine leading zeros, and...
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

        // adjust the exponent accordingly.
        if (i < LOG_BASE) e -= LOG_BASE - i;
      }

      rand.e = e;
      rand.c = c;
      return rand;
    };
  })();


   /*
   * Return a BigNumber whose value is the sum of the arguments.
   *
   * arguments {number|string|BigNumber}
   */
  BigNumber.sum = function () {
    var i = 1,
      args = arguments,
      sum = new BigNumber(args[0]);
    for (; i < args.length;) sum = sum.plus(args[i++]);
    return sum;
  };


  // PRIVATE FUNCTIONS


  // Called by BigNumber and BigNumber.prototype.toString.
  convertBase = (function () {
    var decimal = '0123456789';

    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. toBaseOut('255', 10, 16) returns [15, 15].
     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j,
        arr = [0],
        arrL,
        i = 0,
        len = str.length;

      for (; i < len;) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

        arr[0] += alphabet.indexOf(str.charAt(i++));

        for (j = 0; j < arr.length; j++) {

          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }

      return arr.reverse();
    }

    // Convert a numeric string of baseIn to a numeric string of baseOut.
    // If the caller is toString, we are converting from base 10 to baseOut.
    // If the caller is BigNumber, we are converting from baseIn to base 10.
    return function (str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y,
        i = str.indexOf('.'),
        dp = DECIMAL_PLACES,
        rm = ROUNDING_MODE;

      // Non-integer.
      if (i >= 0) {
        k = POW_PRECISION;

        // Unlimited precision.
        POW_PRECISION = 0;
        str = str.replace('.', '');
        y = new BigNumber(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;

        // Convert str as if an integer, then restore the fraction part by dividing the
        // result by its base raised to a power.

        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
         10, baseOut, decimal);
        y.e = y.c.length;
      }

      // Convert the number as integer.

      xc = toBaseOut(str, baseIn, baseOut, callerIsToString
       ? (alphabet = ALPHABET, decimal)
       : (alphabet = decimal, ALPHABET));

      // xc now represents str as an integer and converted to baseOut. e is the exponent.
      e = k = xc.length;

      // Remove trailing zeros.
      for (; xc[--k] == 0; xc.pop());

      // Zero?
      if (!xc[0]) return alphabet.charAt(0);

      // Does str represent an integer? If so, no need for the division.
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;

        // The sign is needed for correct rounding.
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }

      // xc now represents str converted to baseOut.

      // The index of the rounding digit.
      d = e + dp + 1;

      // The rounding digit: the digit to the right of the digit that may be rounded up.
      i = xc[d];

      // Look at the rounding digits and mode to determine whether to round up.

      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;

      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
             rm == (x.s < 0 ? 8 : 7));

      // If the index of the rounding digit is not greater than zero, or xc represents
      // zero, then the result of the base conversion is zero or, if rounding up, a value
      // such as 0.00001.
      if (d < 1 || !xc[0]) {

        // 1^-dp or 0
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {

        // Truncate xc to the required number of decimal places.
        xc.length = d;

        // Round up?
        if (r) {

          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (--baseOut; ++xc[--d] > baseOut;) {
            xc[d] = 0;

            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }

        // Determine trailing zeros.
        for (k = xc.length; !xc[--k];);

        // E.g. [4, 11, 15] becomes 4bf.
        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

        // Add leading zeros, decimal point and trailing zeros as required.
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }

      // The caller will add the sign.
      return str;
    };
  })();


  // Perform division in the specified base. Called by div and convertBase.
  div = (function () {

    // Assume non-zero x and k.
    function multiply(x, k, base) {
      var m, temp, xlo, xhi,
        carry = 0,
        i = x.length,
        klo = k % SQRT_BASE,
        khi = k / SQRT_BASE | 0;

      for (x = x.slice(); i--;) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }

      if (carry) x = [carry].concat(x);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, cmp;

      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {

        for (i = cmp = 0; i < aL; i++) {

          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return cmp;
    }

    function subtract(a, b, aL, base) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1; a.splice(0, 1));
    }

    // x: dividend, y: divisor.
    return function (x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
        yL, yz,
        s = x.s == y.s ? 1 : -1,
        xc = x.c,
        yc = y.c;

      // Either NaN, Infinity or 0?
      if (!xc || !xc[0] || !yc || !yc[0]) {

        return new BigNumber(

         // Return NaN if either NaN, or both Infinity or 0.
         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

          // Return Â±0 if x is Â±0 or y is Â±Infinity, or return Â±Infinity as y is Â±0.
          xc && xc[0] == 0 || !yc ? s * 0 : s / 0
       );
      }

      q = new BigNumber(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;

      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }

      // Result exponent may be one less then the current value of e.
      // The coefficients of the BigNumbers from convertBase may have trailing zeros.
      for (i = 0; yc[i] == (xc[i] || 0); i++);

      if (yc[i] > (xc[i] || 0)) e--;

      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;

        // Normalise xc and yc so highest order digit of yc is >= base / 2.

        n = mathfloor(base / (yc[0] + 1));

        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }

        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;

        // Add zeros to make remainder as long as divisor.
        for (; remL < yL; rem[remL++] = 0);
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2) yc0++;
        // Not necessary, but to prevent trial digit n > base, when using base 3.
        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

        do {
          n = 0;

          // Compare divisor and remainder.
          cmp = compare(yc, rem, yL, remL);

          // If divisor < remainder.
          if (cmp < 0) {

            // Calculate trial digit, n.

            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

            // n is how many times the divisor goes into the current remainder.
            n = mathfloor(rem0 / yc0);

            //  Algorithm:
            //  product = divisor multiplied by trial digit (n).
            //  Compare product and remainder.
            //  If product is greater than remainder:
            //    Subtract divisor from product, decrement trial digit.
            //  Subtract product from remainder.
            //  If product was less than remainder at the last compare:
            //    Compare new remainder and divisor.
            //    If remainder is greater than divisor:
            //      Subtract divisor from remainder, increment trial digit.

            if (n > 1) {

              // n may be > base only when base is 3.
              if (n >= base) n = base - 1;

              // product = divisor * trial digit.
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;

              // Compare product and remainder.
              // If product > remainder then trial digit n too high.
              // n is 1 too high about 5% of the time, and is not known to have
              // ever been more than 1 too high.
              while (compare(prod, rem, prodL, remL) == 1) {
                n--;

                // Subtract divisor from product.
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {

              // n is 0 or 1, cmp is -1.
              // If n is 0, there is no need to compare yc and rem again below,
              // so change cmp to 1 to avoid it.
              // If n is 1, leave cmp as -1, so yc and rem are compared again.
              if (n == 0) {

                // divisor < remainder, so n must be at least 1.
                cmp = n = 1;
              }

              // product = divisor
              prod = yc.slice();
              prodL = prod.length;
            }

            if (prodL < remL) prod = [0].concat(prod);

            // Subtract product from remainder.
            subtract(rem, prod, remL, base);
            remL = rem.length;

             // If product was < remainder.
            if (cmp == -1) {

              // Compare divisor and new remainder.
              // If divisor < new remainder, subtract divisor from remainder.
              // Trial digit n too low.
              // n is 1 too low about 5% of the time, and very rarely 2 too low.
              while (compare(yc, rem, yL, remL) < 1) {
                n++;

                // Subtract divisor from remainder.
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          } // else cmp === 1 and n will be 0

          // Add the next digit, n, to the result array.
          qc[i++] = n;

          // Update the remainder.
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);

        more = rem[0] != null;

        // Leading zero?
        if (!qc[0]) qc.splice(0, 1);
      }

      if (base == BASE) {

        // To calculate q.e, first get the number of digits of qc[0].
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

      // Caller is convertBase.
      } else {
        q.e = e;
        q.r = +more;
      }

      return q;
    };
  })();


  /*
   * Return a string representing the value of BigNumber n in fixed-point or exponential
   * notation rounded to the specified decimal places or significant digits.
   *
   * n: a BigNumber.
   * i: the index of the last digit required (i.e. the digit that may be rounded up).
   * rm: the rounding mode.
   * id: 1 (toExponential) or 2 (toPrecision).
   */
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;

    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);

    if (!n.c) return n.toString();

    c0 = n.c[0];
    ne = n.e;

    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
       ? toExponential(str, ne)
       : toFixedPoint(str, ne, '0');
    } else {
      n = round(new BigNumber(n), i, rm);

      // n.e may have changed if the value was rounded up.
      e = n.e;

      str = coeffToString(n.c);
      len = str.length;

      // toPrecision returns exponential notation if the number of significant digits
      // specified is less than the number of digits necessary to represent the integer
      // part of the value in fixed-point notation.

      // Exponential notation.
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

        // Append zeros?
        for (; len < i; str += '0', len++);
        str = toExponential(str, e);

      // Fixed-point notation.
      } else {
        i -= ne + (id === 2 && e > ne);
        str = toFixedPoint(str, e, '0');

        // Append zeros?
        if (e + 1 > len) {
          if (--i > 0) for (str += '.'; i--; str += '0');
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len) str += '.';
            for (; i--; str += '0');
          }
        }
      }
    }

    return n.s < 0 && c0 ? '-' + str : str;
  }


  // Handle BigNumber.max and BigNumber.min.
  // If any number is NaN, return NaN.
  function maxOrMin(args, n) {
    var k, y,
      i = 1,
      x = new BigNumber(args[0]);

    for (; i < args.length; i++) {
      y = new BigNumber(args[i]);
      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
        x = y;
      }
    }

    return x;
  }


  /*
   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
   * Called by minus, plus and times.
   */
  function normalise(n, c, e) {
    var i = 1,
      j = c.length;

     // Remove trailing zeros.
    for (; !c[--j]; c.pop());

    // Calculate the base 10 exponent. First get the number of digits of c[0].
    for (j = c[0]; j >= 10; j /= 10, i++);

    // Overflow?
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

      // Infinity.
      n.c = n.e = null;

    // Underflow?
    } else if (e < MIN_EXP) {

      // Zero.
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }

    return n;
  }


  // Handle values that fail the validity test in BigNumber.
  parseNumeric = (function () {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
      dotAfter = /^([^.]+)\.$/,
      dotBefore = /^\.([^.]+)$/,
      isInfinityOrNaN = /^-?(Infinity|NaN)$/,
      whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

    return function (x, str, isNum, b) {
      var base,
        s = isNum ? str : str.replace(whitespaceOrPlus, '');

      // No exception on Â±Infinity or NaN.
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {

          // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
          s = s.replace(basePrefix, function (m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
            return !b || b == base ? p1 : m;
          });

          if (b) {
            base = b;

            // E.g. '1.' to '1', '.1' to '0.1'
            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
          }

          if (str != s) return new BigNumber(s, base);
        }

        // '[BigNumber Error] Not a number: {n}'
        // '[BigNumber Error] Not a base {b} number: {n}'
        if (BigNumber.DEBUG) {
          throw Error
            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
        }

        // NaN
        x.s = null;
      }

      x.c = x.e = null;
    }
  })();


  /*
   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
   * If r is truthy, it is known that there are more digits after the rounding digit.
   */
  function round(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd,
      xc = x.c,
      pows10 = POWS_TEN;

    // if x is not Infinity or NaN...
    if (xc) {

      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
      // n is a base 1e14 number, the value of the element of array x.c containing rd.
      // ni is the index of n within x.c.
      // d is the number of digits of n.
      // i is the index of rd within n including leading zeros.
      // j is the actual index of rd within n (if < 0, rd is a leading zero).
      out: {

        // Get the number of digits of the first element of xc.
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
        i = sd - d;

        // If the rounding digit is in the first element of xc...
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];

          // Get the rounding digit at index j of n.
          rd = mathfloor(n / pows10[d - j - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);

          if (ni >= xc.length) {

            if (r) {

              // Needed by sqrt.
              for (; xc.length <= ni; xc.push(0));
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];

            // Get the number of digits of n.
            for (d = 1; k >= 10; k /= 10, d++);

            // Get the index of rd within n.
            i %= LOG_BASE;

            // Get the index of rd within n, adjusted for leading zeros.
            // The number of leading zeros of n is given by LOG_BASE - d.
            j = i - LOG_BASE + d;

            // Get the rounding digit at index j of n.
            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
          }
        }

        r = r || sd < 0 ||

        // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

        r = rm < 4
         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
           rm == (x.s < 0 ? 8 : 7));

        if (sd < 1 || !xc[0]) {
          xc.length = 0;

          if (r) {

            // Convert sd to decimal places.
            sd -= x.e + 1;

            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {

            // Zero.
            xc[0] = x.e = 0;
          }

          return x;
        }

        // Remove excess digits.
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];

          // E.g. 56700 becomes 56000 if 7 is the rounding digit.
          // j > 0 means i > number of leading zeros of n.
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }

        // Round up?
        if (r) {

          for (; ;) {

            // If the digit to be rounded up is in the first element of xc...
            if (ni == 0) {

              // i will be the length of xc[0] before k is added.
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++);

              // if i != k the length has increased.
              if (i != k) {
                x.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }

              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }

        // Remove trailing zeros.
        for (i = xc.length; xc[--i] === 0; xc.pop());
      }

      // Overflow? Infinity.
      if (x.e > MAX_EXP) {
        x.c = x.e = null;

      // Underflow? Zero.
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }

    return x;
  }


  function valueOf(n) {
    var str,
      e = n.e;

    if (e === null) return n.toString();

    str = coeffToString(n.c);

    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
      ? toExponential(str, e)
      : toFixedPoint(str, e, '0');

    return n.s < 0 ? '-' + str : str;
  }


  // PROTOTYPE/INSTANCE METHODS


  /*
   * Return a new BigNumber whose value is the absolute value of this BigNumber.
   */
  P.absoluteValue = P.abs = function () {
    var x = new BigNumber(this);
    if (x.s < 0) x.s = 1;
    return x;
  };


  /*
   * Return
   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
   *   0 if they have the same value,
   *   or null if the value of either is NaN.
   */
  P.comparedTo = function (y, b) {
    return compare(this, new BigNumber(y, b));
  };


  /*
   * If dp is undefined or null or true or false, return the number of decimal places of the
   * value of this BigNumber, or null if the value of this BigNumber is Â±Infinity or NaN.
   *
   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.decimalPlaces = P.dp = function (dp, rm) {
    var c, n, v,
      x = this;

    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      return round(new BigNumber(x), dp + x.e + 1, rm);
    }

    if (!(c = x.c)) return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last number.
    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
    if (n < 0) n = 0;

    return n;
  };


  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */
  P.dividedBy = P.div = function (y, b) {
    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };


  /*
   * Return a new BigNumber whose value is the integer part of dividing the value of this
   * BigNumber by the value of BigNumber(y, b).
   */
  P.dividedToIntegerBy = P.idiv = function (y, b) {
    return div(this, new BigNumber(y, b), 0, 1);
  };


  /*
   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
   *
   * If m is present, return the result modulo m.
   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
   *
   * The modular power operation works efficiently when x, n, and m are integers, otherwise it
   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
   *
   * n {number|string|BigNumber} The exponent. An integer.
   * [m] {number|string|BigNumber} The modulus.
   *
   * '[BigNumber Error] Exponent not an integer: {n}'
   */
  P.exponentiatedBy = P.pow = function (n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
      x = this;

    n = new BigNumber(n);

    // Allow NaN and Â±Infinity, but not other non-integers.
    if (n.c && !n.isInteger()) {
      throw Error
        (bignumberError + 'Exponent not an integer: ' + valueOf(n));
    }

    if (m != null) m = new BigNumber(m);

    // Exponent of MAX_SAFE_INTEGER is 15.
    nIsBig = n.e > 14;

    // If x is NaN, Â±Infinity, Â±0 or Â±1, or n is Â±Infinity, NaN or Â±0.
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

      // The sign of the result of pow when x is negative depends on the evenness of n.
      // If +n overflows to Â±Infinity, the evenness of n would be not be known.
      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }

    nIsNeg = n.s < 0;

    if (m) {

      // x % m returns NaN if abs(m) is zero, or m is NaN.
      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

      isModExp = !nIsNeg && x.isInteger() && m.isInteger();

      if (isModExp) x = x.mod(m);

    // Overflow to Â±Infinity: >=2**1e10 or >=1.0000024**1e15.
    // Underflow to Â±0: <=0.79**1e10 or <=0.9999975**1e15.
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
      // [1, 240000000]
      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
      // [80000000000000]  [99999750000000]
      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

      // If x is negative and n is odd, k = -0, else k = 0.
      k = x.s < 0 && isOdd(n) ? -0 : 0;

      // If x >= 1, k = Â±Infinity.
      if (x.e > -1) k = 1 / k;

      // If n is negative return Â±0, else return Â±Infinity.
      return new BigNumber(nIsNeg ? 1 / k : k);

    } else if (POW_PRECISION) {

      // Truncating each coefficient array to a length of k after each multiplication
      // equates to truncating significant digits to POW_PRECISION + [28, 41],
      // i.e. there will be a minimum of 28 guard digits retained.
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }

    if (nIsBig) {
      half = new BigNumber(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }

    y = new BigNumber(ONE);

    // Performs 54 loop iterations for n of 9007199254740991.
    for (; ;) {

      if (nIsOdd) {
        y = y.times(x);
        if (!y.c) break;

        if (k) {
          if (y.c.length > k) y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
        }
      }

      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);

        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }

      x = x.times(x);

      if (k) {
        if (x.c && x.c.length > k) x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
      }
    }

    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);

    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
   */
  P.integerValue = function (rm) {
    var n = new BigNumber(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };


  /*
   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isEqualTo = P.eq = function (y, b) {
    return compare(this, new BigNumber(y, b)) === 0;
  };


  /*
   * Return true if the value of this BigNumber is a finite number, otherwise return false.
   */
  P.isFinite = function () {
    return !!this.c;
  };


  /*
   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isGreaterThan = P.gt = function (y, b) {
    return compare(this, new BigNumber(y, b)) > 0;
  };


  /*
   * Return true if the value of this BigNumber is greater than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */
  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

  };


  /*
   * Return true if the value of this BigNumber is an integer, otherwise return false.
   */
  P.isInteger = function () {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };


  /*
   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
   * otherwise return false.
   */
  P.isLessThan = P.lt = function (y, b) {
    return compare(this, new BigNumber(y, b)) < 0;
  };


  /*
   * Return true if the value of this BigNumber is less than or equal to the value of
   * BigNumber(y, b), otherwise return false.
   */
  P.isLessThanOrEqualTo = P.lte = function (y, b) {
    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
  };


  /*
   * Return true if the value of this BigNumber is NaN, otherwise return false.
   */
  P.isNaN = function () {
    return !this.s;
  };


  /*
   * Return true if the value of this BigNumber is negative, otherwise return false.
   */
  P.isNegative = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this BigNumber is positive, otherwise return false.
   */
  P.isPositive = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
   */
  P.isZero = function () {
    return !!this.c && this.c[0] == 0;
  };


  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new BigNumber whose value is the value of this BigNumber minus the value of
   * BigNumber(y, b).
   */
  P.minus = function (y, b) {
    var i, j, t, xLTy,
      x = this,
      a = x.s;

    y = new BigNumber(y, b);
    b = y.s;

    // Either NaN?
    if (!a || !b) return new BigNumber(NaN);

    // Signs differ?
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }

    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;

    if (!xe || !ye) {

      // Either Infinity?
      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

      // Either zero?
      if (!xc[0] || !yc[0]) {

        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
         ROUNDING_MODE == 3 ? -0 : 0);
      }
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Determine which is the bigger number.
    if (a = xe - ye) {

      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }

      t.reverse();

      // Prepend zeros to equalise exponents.
      for (b = a; b--; t.push(0));
      t.reverse();
    } else {

      // Exponents equal. Check digit by digit.
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

      for (a = b = 0; b < j; b++) {

        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }

    // x < y? Point xc to the array of the bigger number.
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }

    b = (j = yc.length) - (i = xc.length);

    // Append zeros to xc if shorter.
    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
    if (b > 0) for (; b--; xc[i++] = 0);
    b = BASE - 1;

    // Subtract yc from xc.
    for (; j > a;) {

      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b);
        --xc[i];
        xc[j] += BASE;
      }

      xc[j] -= yc[j];
    }

    // Remove leading zeros and adjust exponent accordingly.
    for (; xc[0] == 0; xc.splice(0, 1), --ye);

    // Zero?
    if (!xc[0]) {

      // Following IEEE 754 (2008) 6.3,
      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }

    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
    // for finite x and y.
    return normalise(y, xc, ye);
  };


  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
   * BigNumber(y, b). The result depends on the value of MODULO_MODE.
   */
  P.modulo = P.mod = function (y, b) {
    var q, s,
      x = this;

    y = new BigNumber(y, b);

    // Return NaN if x is Infinity or NaN, or y is NaN or zero.
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber(NaN);

    // Return x if y is Infinity or x is zero.
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber(x);
    }

    if (MODULO_MODE == 9) {

      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // r = x - qy    where  0 <= r < abs(y)
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }

    y = x.minus(q.times(y));

    // To match JavaScript %, ensure sign of zero is sign of dividend.
    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

    return y;
  };


  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
   * of BigNumber(y, b).
   */
  P.multipliedBy = P.times = function (y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
      base, sqrtBase,
      x = this,
      xc = x.c,
      yc = (y = new BigNumber(y, b)).c;

    // Either NaN, Â±Infinity or Â±0?
    if (!xc || !yc || !xc[0] || !yc[0]) {

      // Return NaN if either is NaN, or one is 0 and the other is Infinity.
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;

        // Return Â±Infinity if either is Â±Infinity.
        if (!xc || !yc) {
          y.c = y.e = null;

        // Return Â±0 if either is Â±0.
        } else {
          y.c = [0];
          y.e = 0;
        }
      }

      return y;
    }

    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;

    // Ensure xc points to longer array and xcL to its length.
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }

    // Initialise the result array with zeros.
    for (i = xcL + ycL, zc = []; i--; zc.push(0));

    base = BASE;
    sqrtBase = SQRT_BASE;

    for (i = ycL; --i >= 0;) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;

      for (k = xcL, j = i + k; j > i;) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }

      zc[j] = c;
    }

    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }

    return normalise(y, zc, e);
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber negated,
   * i.e. multiplied by -1.
   */
  P.negated = function () {
    var x = new BigNumber(this);
    x.s = -x.s || null;
    return x;
  };


  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new BigNumber whose value is the value of this BigNumber plus the value of
   * BigNumber(y, b).
   */
  P.plus = function (y, b) {
    var t,
      x = this,
      a = x.s;

    y = new BigNumber(y, b);
    b = y.s;

    // Either NaN?
    if (!a || !b) return new BigNumber(NaN);

    // Signs differ?
     if (a != b) {
      y.s = -b;
      return x.minus(y);
    }

    var xe = x.e / LOG_BASE,
      ye = y.e / LOG_BASE,
      xc = x.c,
      yc = y.c;

    if (!xe || !ye) {

      // Return Â±Infinity if either Â±Infinity.
      if (!xc || !yc) return new BigNumber(a / 0);

      // Either zero?
      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
    }

    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();

    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }

      t.reverse();
      for (; a--; t.push(0));
      t.reverse();
    }

    a = xc.length;
    b = yc.length;

    // Point xc to the longer array, and b to the shorter length.
    if (a - b < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b = a;
    }

    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
    for (a = 0; b;) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }

    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }

    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    // ye = MAX_EXP + 1 possible
    return normalise(y, xc, ye);
  };


  /*
   * If sd is undefined or null or true or false, return the number of significant digits of
   * the value of this BigNumber, or null if the value of this BigNumber is Â±Infinity or NaN.
   * If sd is true include integer-part trailing zeros in the count.
   *
   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
   * ROUNDING_MODE if rm is omitted.
   *
   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
   *                     boolean: whether to count integer-part trailing zeros: true or false.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */
  P.precision = P.sd = function (sd, rm) {
    var c, n, v,
      x = this;

    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      return round(new BigNumber(x), sd, rm);
    }

    if (!(c = x.c)) return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;

    if (v = c[v]) {

      // Subtract the number of trailing zeros of the last element.
      for (; v % 10 == 0; v /= 10, n--);

      // Add the number of digits of the first element.
      for (v = c[0]; v >= 10; v /= 10, n++);
    }

    if (sd && x.e + 1 > n) n = x.e + 1;

    return n;
  };


  /*
   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
   *
   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
   */
  P.shiftedBy = function (k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times('1e' + k);
  };


  /*
   *  sqrt(-n) =  N
   *  sqrt(N) =  N
   *  sqrt(-I) =  N
   *  sqrt(I) =  I
   *  sqrt(0) =  0
   *  sqrt(-0) = -0
   *
   * Return a new BigNumber whose value is the square root of the value of this BigNumber,
   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
   */
  P.squareRoot = P.sqrt = function () {
    var m, n, r, rep, t,
      x = this,
      c = x.c,
      s = x.s,
      e = x.e,
      dp = DECIMAL_PLACES + 4,
      half = new BigNumber('0.5');

    // Negative/NaN/Infinity/zero?
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }

    // Initial estimate.
    s = Math.sqrt(+valueOf(x));

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new BigNumber(n);
    } else {
      r = new BigNumber(s + '');
    }

    // Check for zero.
    // r could be zero if MIN_EXP is changed after the this value was created.
    // This would cause a division by zero (x/t) and hence Infinity below, which would cause
    // coeffToString to throw.
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3) s = 0;

      // Newton-Raphson iteration.
      for (; ;) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));

        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

          // The exponent of r may here be one less than the final result exponent,
          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
          // are indexed correctly.
          if (r.e < e) --s;
          n = n.slice(s - 3, s + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
          // iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the
            // exact result as the nines may infinitely repeat.
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);

              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }

            dp += 4;
            s += 4;
            rep = 1;
          } else {

            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
            // result. If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }

            break;
          }
        }
      }
    }

    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };


  /*
   * Return a string representing the value of this BigNumber in exponential notation and
   * rounded using ROUNDING_MODE to dp fixed decimal places.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.toExponential = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };


  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounding
   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
   *
   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
   * but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   */
  P.toFixed = function (dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };


  /*
   * Return a string representing the value of this BigNumber in fixed-point notation rounded
   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
   * of the format or FORMAT object (see BigNumber.set).
   *
   * The formatting object may contain some or all of the properties shown below.
   *
   * FORMAT = {
   *   prefix: '',
   *   groupSize: 3,
   *   secondaryGroupSize: 0,
   *   groupSeparator: ',',
   *   decimalSeparator: '.',
   *   fractionGroupSize: 0,
   *   fractionGroupSeparator: '\xA0',      // non-breaking space
   *   suffix: ''
   * };
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   * [format] {object} Formatting options. See FORMAT pbject above.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
   * '[BigNumber Error] Argument not an object: {format}'
   */
  P.toFormat = function (dp, rm, format) {
    var str,
      x = this;

    if (format == null) {
      if (dp != null && rm && typeof rm == 'object') {
        format = rm;
        rm = null;
      } else if (dp && typeof dp == 'object') {
        format = dp;
        dp = rm = null;
      } else {
        format = FORMAT;
      }
    } else if (typeof format != 'object') {
      throw Error
        (bignumberError + 'Argument not an object: ' + format);
    }

    str = x.toFixed(dp, rm);

    if (x.c) {
      var i,
        arr = str.split('.'),
        g1 = +format.groupSize,
        g2 = +format.secondaryGroupSize,
        groupSeparator = format.groupSeparator || '',
        intPart = arr[0],
        fractionPart = arr[1],
        isNeg = x.s < 0,
        intDigits = isNeg ? intPart.slice(1) : intPart,
        len = intDigits.length;

      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }

      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = '-' + intPart;
      }

      str = fractionPart
       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
        ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
         '$&' + (format.fractionGroupSeparator || ''))
        : fractionPart)
       : intPart;
    }

    return (format.prefix || '') + str + (format.suffix || '');
  };


  /*
   * Return an array of two BigNumbers representing the value of this BigNumber as a simple
   * fraction with an integer numerator and an integer denominator.
   * The denominator will be a positive non-zero value less than or equal to the specified
   * maximum denominator. If a maximum denominator is not specified, the denominator will be
   * the lowest value necessary to represent the number exactly.
   *
   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
   *
   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
   */
  P.toFraction = function (md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
      x = this,
      xc = x.c;

    if (md != null) {
      n = new BigNumber(md);

      // Throw if md is less than one or is not an integer, unless it is Infinity.
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error
          (bignumberError + 'Argument ' +
            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
      }
    }

    if (!xc) return new BigNumber(x);

    d = new BigNumber(ONE);
    n1 = d0 = new BigNumber(ONE);
    d1 = n0 = new BigNumber(ONE);
    s = coeffToString(xc);

    // Determine initial denominator.
    // d is a power of 10 and the minimum max denominator that specifies the value exactly.
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber(s);

    // n0 = d1 = 0
    n0.c[0] = 0;

    for (; ;)  {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }

    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;

    // Determine which fraction is closer to x, n0/d0 or n1/d1
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

    MAX_EXP = exp;

    return r;
  };


  /*
   * Return the value of this BigNumber converted to a number primitive.
   */
  P.toNumber = function () {
    return +valueOf(this);
  };


  /*
   * Return a string representing the value of this BigNumber rounded to sd significant digits
   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
   * necessary to represent the integer part of the value in fixed-point notation, then use
   * exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
   */
  P.toPrecision = function (sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };


  /*
   * Return a string representing the value of this BigNumber in base b, or base 10 if b is
   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
   * TO_EXP_NEG, return exponential notation.
   *
   * [b] {number} Integer, 2 to ALPHABET.length inclusive.
   *
   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
   */
  P.toString = function (b) {
    var str,
      n = this,
      s = n.s,
      e = n.e;

    // Infinity or NaN?
    if (e === null) {
      if (s) {
        str = 'Infinity';
        if (s < 0) str = '-' + str;
      } else {
        str = 'NaN';
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS
         ? toExponential(coeffToString(n.c), e)
         : toFixedPoint(coeffToString(n.c), e, '0');
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, '0');
      } else {
        intCheck(b, 2, ALPHABET.length, 'Base');
        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
      }

      if (s < 0 && n.c[0]) str = '-' + str;
    }

    return str;
  };


  /*
   * Return as toString, but do not accept a base argument, and include the minus sign for
   * negative zero.
   */
  P.valueOf = P.toJSON = function () {
    return valueOf(this);
  };


  P._isBigNumber = true;

  P[Symbol.toStringTag] = 'BigNumber';

  // Node.js v10.12.0+
  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;

  if (configObject != null) BigNumber.set(configObject);

  return BigNumber;
}


// PRIVATE HELPER FUNCTIONS

// These functions don't need access to variables,
// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}


// Return a coefficient array as a string of base 10 digits.
function coeffToString(a) {
  var s, z,
    i = 1,
    j = a.length,
    r = a[0] + '';

  for (; i < j;) {
    s = a[i++] + '';
    z = LOG_BASE - s.length;
    for (; z--; s = '0' + s);
    r += s;
  }

  // Determine trailing zeros.
  for (j = r.length; r.charCodeAt(--j) === 48;);

  return r.slice(0, j + 1 || 1);
}


// Compare the value of BigNumbers x and y.
function compare(x, y) {
  var a, b,
    xc = x.c,
    yc = y.c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either NaN?
  if (!i || !j) return null;

  a = xc && !xc[0];
  b = yc && !yc[0];

  // Either zero?
  if (a || b) return a ? b ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  a = i < 0;
  b = k == l;

  // Either Infinity?
  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

  // Compare exponents.
  if (!b) return k > l ^ a ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

  // Compare lengths.
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}


/*
 * Check that n is a primitive number, an integer, and in range, otherwise throw.
 */
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error
     (bignumberError + (name || 'Argument') + (typeof n == 'number'
       ? n < min || n > max ? ' out of range: ' : ' not an integer: '
       : ' not a primitive number: ') + String(n));
  }
}


// Assumes finite n.
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}


function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
   (e < 0 ? 'e' : 'e+') + e;
}


function toFixedPoint(str, e, z) {
  var len, zs;

  // Negative exponent?
  if (e < 0) {

    // Prepend zeros.
    for (zs = z + '.'; ++e; zs += z);
    str = zs + str;

  // Positive exponent
  } else {
    len = str.length;

    // Append zeros.
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z);
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + '.' + str.slice(e);
    }
  }

  return str;
}


// EXPORT


var BigNumber = clone();

export { Address as A, BinaryWriter as B, ChallengeSolution as C, P2TR_MS as D, Logger as L, NetEvent as N, P2MR_MS as P, TransactionFactory as T, getDefaultExportFromCjs$1 as a, fromBase64$1 as b, BinaryReader as c, decompile as d, AddressTypes as e, fromHex$1 as f, getAugmentedNamespace as g, AddressVerificator as h, testnet as i, bitcoin$1 as j, BufferHelper as k, AddressMap as l, toBase64$1 as m, process$1 as n, opnetTestnet as o, pLimit as p, Long as q, regtest as r, abiTypeToSelectorString as s, toHex$1 as t, ABICoder as u, isAbiTuple as v, isAbiStruct as w, ABIDataTypes as x, BigNumber as y, fromBech32 as z };
