export const isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
export const isReactNative = typeof navigator !== 'undefined' &&
    navigator.product === 'ReactNative';
export const isBrowser = !isNode && !isReactNative && typeof window !== 'undefined' && typeof Worker !== 'undefined';
export function detectRuntime() {
    if (isReactNative)
        return 'react-native';
    if (isNode)
        return 'node';
    if (isBrowser)
        return 'browser';
    return 'unknown';
}
export async function createWorker(workerScript) {
    if (isNode) {
        return createNodeWorker(workerScript);
    }
    return createBrowserWorker(workerScript);
}
async function createNodeWorker(workerScript) {
    const { Worker } = await import('worker_threads');
    const worker = new Worker(workerScript, { eval: true });
    worker.on('error', (err) => {
        console.error('[WorkerCreator] Worker error:', err);
    });
    let messageCallback = null;
    worker.on('message', (msg) => {
        if (messageCallback)
            messageCallback(msg);
    });
    worker.unref();
    return {
        postMessage: (msg, transferables) => {
            if (transferables && transferables.length > 0) {
                worker.postMessage(msg, transferables);
            }
            else {
                worker.postMessage(msg);
            }
        },
        onMessage: (callback) => {
            messageCallback = callback;
        },
        terminate: async () => {
            await worker.terminate();
        },
    };
}
function createBrowserWorker(workerScript) {
    const blob = new Blob([workerScript], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    const worker = new Worker(url);
    worker.onerror = (err) => {
        console.error('[WorkerCreator] Worker error:', err);
    };
    return {
        postMessage: (msg, transferables) => {
            if (transferables && transferables.length > 0) {
                worker.postMessage(msg, transferables);
            }
            else {
                worker.postMessage(msg);
            }
        },
        onMessage: (callback) => {
            worker.onmessage = (e) => callback(e.data);
        },
        terminate: () => {
            worker.terminate();
            URL.revokeObjectURL(url);
        },
    };
}
