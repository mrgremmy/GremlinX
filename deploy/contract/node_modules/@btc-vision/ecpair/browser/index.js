function en(e) {
  const t = e.length;
  if (t % 2 !== 0) throw new TypeError("fromHexInternal: odd-length hex string");
  const r = new Uint8Array(t / 2);
  for (let n = 0; n < t; n += 2) {
    const i = de(e.charCodeAt(n)), o = de(e.charCodeAt(n + 1));
    if (i === -1 || o === -1) throw new TypeError("fromHexInternal: invalid hex character");
    r[n >> 1] = i << 4 | o;
  }
  return r;
}
function de(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function Lt(e) {
  for (let t = 0; t < e.length; t++)
    if (e[t] !== 0) return !1;
  return !0;
}
function pr(e, t) {
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; n++) {
    const i = e[n], o = t[n];
    if (i < o) return -1;
    if (i > o) return 1;
  }
  return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
}
function M(e, t) {
  if (e.length !== t.length) return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== t[r]) return !1;
  return !0;
}
function wt(e) {
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += e[r].toString(16).padStart(2, "0");
  return t;
}
function nn(...e) {
  let t = 0;
  for (const i of e) t += i.length;
  const r = new Uint8Array(t);
  let n = 0;
  for (const i of e)
    r.set(i, n), n += i.length;
  return r;
}
const Jt = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n, mr = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn, Be = 21n * 10n ** 14n;
function Se(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
function Er(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function xr(e) {
  return e instanceof Uint8Array && e.length === 20;
}
function vr(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 || Lt(e) ? !1 : Se(e) < Jt;
}
function rn(e) {
  if (!(e instanceof Uint8Array)) return !1;
  const t = e[0];
  return e.length === 33 && (t === 2 || t === 3) || e.length === 65 && (t === 4 || t === 6 || t === 7);
}
function Br(e) {
  return !(e instanceof Uint8Array) || e.length !== 32 ? !1 : !Lt(e);
}
function on(e) {
  return e instanceof Uint8Array && e.length >= 8 && e.length <= 73;
}
function sn(e) {
  return e instanceof Uint8Array && e.length === 64;
}
function Sr(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function fn(e) {
  return typeof e == "bigint" && e >= 0n && e <= Be;
}
function Ae(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertBytes32: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertBytes32: expected 32 bytes, got ${e.length} bytes`);
}
function cn(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPrivateKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertPrivateKey: expected 32 bytes, got ${e.length} bytes`);
  if (Lt(e))
    throw new TypeError("assertPrivateKey: key is zero");
  if (Se(e) >= Jt)
    throw new TypeError("assertPrivateKey: key not in range [1, n)");
}
function an(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertPublicKey: expected Uint8Array");
  if (!rn(e))
    throw new TypeError(
      `assertPublicKey: invalid SEC1 public key (length=${e.length}, prefix=0x${(e[0] ?? 0).toString(16).padStart(2, "0")})`
    );
}
function dn(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertXOnlyPublicKey: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertXOnlyPublicKey: expected 32 bytes, got ${e.length} bytes`);
  if (Lt(e))
    throw new TypeError("assertXOnlyPublicKey: key is zero");
}
function un(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("assertMessageHash: expected Uint8Array");
  if (e.length !== 32)
    throw new TypeError(`assertMessageHash: expected 32 bytes, got ${e.length} bytes`);
}
function Ar(e) {
  return Ae(e), e;
}
function Or(e) {
  if (!(e instanceof Uint8Array) || e.length !== 20)
    throw new TypeError("createBytes20: expected 20 bytes Uint8Array");
  return e;
}
function zt(e) {
  return cn(e), e;
}
function ln(e) {
  return an(e), e;
}
function hn(e) {
  return dn(e), e;
}
function Rr(e) {
  if (!on(e))
    throw new TypeError(`createSignature: expected 8-73 bytes, got ${e.length} bytes`);
  return e;
}
function Ir(e) {
  if (!sn(e))
    throw new TypeError(`createSchnorrSignature: expected 64 bytes, got ${e.length} bytes`);
  return e;
}
function Ur(e) {
  return un(e), e;
}
function Pr(e) {
  if (!fn(e))
    throw new TypeError(`createSatoshi: value out of range [0, ${Be}]`);
  return e;
}
const lt = {
  /** Can produce ECDSA signatures (requires a private key). */
  EcdsaSign: 1,
  /** Can verify ECDSA signatures. */
  EcdsaVerify: 2,
  /** Can produce BIP-340 Schnorr signatures (requires a private key and backend support). */
  SchnorrSign: 4,
  /** Can verify BIP-340 Schnorr signatures (requires backend support). */
  SchnorrVerify: 8,
  /** Can export the raw private key bytes. */
  PrivateKeyExport: 16,
  /** Can derive a tweaked child key via Taproot-style tweaking. */
  PublicKeyTweak: 32,
  /** Supports BIP-32 hierarchical deterministic derivation. */
  HdDerivation: 64
};
function te(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function dt(e, t = "") {
  if (!Number.isSafeInteger(e) || e < 0) {
    const r = t && `"${t}" `;
    throw new Error(`${r}expected integer >= 0, got ${e}`);
  }
}
function _(e, t, r = "") {
  const n = te(e), i = e?.length, o = t !== void 0;
  if (!n || o && i !== t) {
    const s = r && `"${r}" `, f = o ? ` of length ${t}` : "", c = n ? `length=${i}` : `type=${typeof e}`;
    throw new Error(s + "expected Uint8Array" + f + ", got " + c);
  }
  return e;
}
function Oe(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  dt(e.outputLen), dt(e.blockLen);
}
function It(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function bn(e, t) {
  _(e, void 0, "digestInto() output");
  const r = t.outputLen;
  if (e.length < r)
    throw new Error('"digestInto() output" expected to be of length >=' + r);
}
function Ut(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
function $t(e) {
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
function G(e, t) {
  return e << 32 - t | e >>> t;
}
const Re = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", yn = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ht(e) {
  if (_(e), Re)
    return e.toHex();
  let t = "";
  for (let r = 0; r < e.length; r++)
    t += yn[e[r]];
  return t;
}
const Q = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function ue(e) {
  if (e >= Q._0 && e <= Q._9)
    return e - Q._0;
  if (e >= Q.A && e <= Q.F)
    return e - (Q.A - 10);
  if (e >= Q.a && e <= Q.f)
    return e - (Q.a - 10);
}
function Pt(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  if (Re)
    return Uint8Array.fromHex(e);
  const t = e.length, r = t / 2;
  if (t % 2)
    throw new Error("hex string expected, got unpadded hex of length " + t);
  const n = new Uint8Array(r);
  for (let i = 0, o = 0; i < r; i++, o += 2) {
    const s = ue(e.charCodeAt(o)), f = ue(e.charCodeAt(o + 1));
    if (s === void 0 || f === void 0) {
      const c = e[o] + e[o + 1];
      throw new Error('hex string expected, got non-hex character "' + c + '" at index ' + o);
    }
    n[i] = s * 16 + f;
  }
  return n;
}
function W(...e) {
  let t = 0;
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    _(i), t += i.length;
  }
  const r = new Uint8Array(t);
  for (let n = 0, i = 0; n < e.length; n++) {
    const o = e[n];
    r.set(o, i), i += o.length;
  }
  return r;
}
function gn(e, t = {}) {
  const r = (i, o) => e(o).update(i).digest(), n = e(void 0);
  return r.outputLen = n.outputLen, r.blockLen = n.blockLen, r.create = (i) => e(i), Object.assign(r, t), Object.freeze(r);
}
function Kt(e = 32) {
  const t = typeof globalThis == "object" ? globalThis.crypto : null;
  if (typeof t?.getRandomValues != "function")
    throw new Error("crypto.getRandomValues must be defined");
  return t.getRandomValues(new Uint8Array(e));
}
const wn = (e) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, e])
});
function pn(e, t, r) {
  return e & t ^ ~e & r;
}
function mn(e, t, r) {
  return e & t ^ e & r ^ t & r;
}
class En {
  blockLen;
  outputLen;
  padOffset;
  isLE;
  // For partial updates less than block size
  buffer;
  view;
  finished = !1;
  length = 0;
  pos = 0;
  destroyed = !1;
  constructor(t, r, n, i) {
    this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = $t(this.buffer);
  }
  update(t) {
    It(this), _(t);
    const { view: r, buffer: n, blockLen: i } = this, o = t.length;
    for (let s = 0; s < o; ) {
      const f = Math.min(i - this.pos, o - s);
      if (f === i) {
        const c = $t(t);
        for (; i <= o - s; s += i)
          this.process(c, s);
        continue;
      }
      n.set(t.subarray(s, s + f), this.pos), this.pos += f, s += f, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    It(this), bn(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: o } = this;
    let { pos: s } = this;
    r[s++] = 128, Ut(this.buffer.subarray(s)), this.padOffset > i - s && (this.process(n, 0), s = 0);
    for (let b = s; b < i; b++)
      r[b] = 0;
    n.setBigUint64(i - 8, BigInt(this.length * 8), o), this.process(n, 0);
    const f = $t(t), c = this.outputLen;
    if (c % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const a = c / 4, h = this.get();
    if (a > h.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let b = 0; b < a; b++)
      f.setUint32(4 * b, h[b], o);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t ||= new this.constructor(), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: o, destroyed: s, pos: f } = this;
    return t.destroyed = s, t.finished = o, t.length = i, t.pos = f, i % r && t.buffer.set(n), t;
  }
  clone() {
    return this._cloneInto();
  }
}
const et = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), xn = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), nt = /* @__PURE__ */ new Uint32Array(64);
class vn extends En {
  constructor(t) {
    super(64, t, 8, !1);
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: o, F: s, G: f, H: c } = this;
    return [t, r, n, i, o, s, f, c];
  }
  // prettier-ignore
  set(t, r, n, i, o, s, f, c) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = o | 0, this.F = s | 0, this.G = f | 0, this.H = c | 0;
  }
  process(t, r) {
    for (let b = 0; b < 16; b++, r += 4)
      nt[b] = t.getUint32(r, !1);
    for (let b = 16; b < 64; b++) {
      const m = nt[b - 15], y = nt[b - 2], E = G(m, 7) ^ G(m, 18) ^ m >>> 3, O = G(y, 17) ^ G(y, 19) ^ y >>> 10;
      nt[b] = O + nt[b - 7] + E + nt[b - 16] | 0;
    }
    let { A: n, B: i, C: o, D: s, E: f, F: c, G: a, H: h } = this;
    for (let b = 0; b < 64; b++) {
      const m = G(f, 6) ^ G(f, 11) ^ G(f, 25), y = h + m + pn(f, c, a) + xn[b] + nt[b] | 0, O = (G(n, 2) ^ G(n, 13) ^ G(n, 22)) + mn(n, i, o) | 0;
      h = a, a = c, c = f, f = s + y | 0, s = o, o = i, i = n, n = y + O | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, o = o + this.C | 0, s = s + this.D | 0, f = f + this.E | 0, c = c + this.F | 0, a = a + this.G | 0, h = h + this.H | 0, this.set(n, i, o, s, f, c, a, h);
  }
  roundClean() {
    Ut(nt);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Ut(this.buffer);
  }
}
class Bn extends vn {
  // We cannot use array here since array allows indexing by variable
  // which means optimizer/compiler cannot use registers.
  A = et[0] | 0;
  B = et[1] | 0;
  C = et[2] | 0;
  D = et[3] | 0;
  E = et[4] | 0;
  F = et[5] | 0;
  G = et[6] | 0;
  H = et[7] | 0;
  constructor() {
    super(32);
  }
}
const Et = /* @__PURE__ */ gn(
  () => new Bn(),
  /* @__PURE__ */ wn(1)
);
function Sn(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  const t = new Uint8Array(256);
  for (let a = 0; a < t.length; a++)
    t[a] = 255;
  for (let a = 0; a < e.length; a++) {
    const h = e.charAt(a), b = h.charCodeAt(0);
    if (t[b] !== 255)
      throw new TypeError(h + " is ambiguous");
    t[b] = a;
  }
  const r = e.length, n = e.charAt(0), i = Math.log(r) / Math.log(256), o = Math.log(256) / Math.log(r);
  function s(a) {
    if (a instanceof Uint8Array || (ArrayBuffer.isView(a) ? a = new Uint8Array(a.buffer, a.byteOffset, a.byteLength) : Array.isArray(a) && (a = Uint8Array.from(a))), !(a instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (a.length === 0)
      return "";
    let h = 0, b = 0, m = 0;
    const y = a.length;
    for (; m !== y && a[m] === 0; )
      m++, h++;
    const E = (y - m) * o + 1 >>> 0, O = new Uint8Array(E);
    for (; m !== y; ) {
      let q = a[m], Z = 0;
      for (let L = E - 1; (q !== 0 || Z < b) && L !== -1; L--, Z++)
        q += 256 * O[L] >>> 0, O[L] = q % r >>> 0, q = q / r >>> 0;
      if (q !== 0)
        throw new Error("Non-zero carry");
      b = Z, m++;
    }
    let A = E - b;
    for (; A !== E && O[A] === 0; )
      A++;
    let T = n.repeat(h);
    for (; A < E; ++A)
      T += e.charAt(O[A]);
    return T;
  }
  function f(a) {
    if (typeof a != "string")
      throw new TypeError("Expected String");
    if (a.length === 0)
      return new Uint8Array();
    let h = 0, b = 0, m = 0;
    for (; a[h] === n; )
      b++, h++;
    const y = (a.length - h) * i + 1 >>> 0, E = new Uint8Array(y);
    for (; h < a.length; ) {
      const q = a.charCodeAt(h);
      if (q > 255)
        return;
      let Z = t[q];
      if (Z === 255)
        return;
      let L = 0;
      for (let j = y - 1; (Z !== 0 || L < m) && j !== -1; j--, L++)
        Z += r * E[j] >>> 0, E[j] = Z % 256 >>> 0, Z = Z / 256 >>> 0;
      if (Z !== 0)
        throw new Error("Non-zero carry");
      m = L, h++;
    }
    let O = y - m;
    for (; O !== y && E[O] === 0; )
      O++;
    const A = new Uint8Array(b + (y - O));
    let T = b;
    for (; O !== y; )
      A[T++] = E[O++];
    return A;
  }
  function c(a) {
    const h = f(a);
    if (h)
      return h;
    throw new Error("Non-base" + r + " character");
  }
  return {
    encode: s,
    decodeUnsafe: f,
    decode: c
  };
}
var An = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const Vt = Sn(An);
function On(e) {
  function t(o) {
    const s = e(o), f = o.length + 4, c = new Uint8Array(f);
    return c.set(o, 0), c.set(s.subarray(0, 4), o.length), Vt.encode(c);
  }
  function r(o) {
    const s = o.slice(0, -4), f = o.slice(-4), c = e(s);
    if (!(f[0] ^ c[0] | f[1] ^ c[1] | f[2] ^ c[2] | f[3] ^ c[3]))
      return s;
  }
  function n(o) {
    const s = Vt.decodeUnsafe(o);
    if (s !== void 0)
      return r(s);
  }
  function i(o) {
    const s = Vt.decode(o), f = r(s);
    if (f === void 0)
      throw new Error("Invalid checksum");
    return f;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: n
  };
}
function Rn(e) {
  return Et(Et(e));
}
const { encode: In, decode: Un, decodeUnsafe: Pn } = On(Rn), Ie = { encode: In, decode: Un, decodeUnsafe: Pn };
function Nn(e, t) {
  if (e.length === 33)
    return {
      version: e[0],
      privateKey: e.slice(1, 33),
      compressed: !1
    };
  if (e.length !== 34)
    throw new Error("Invalid WIF length");
  if (e[33] !== 1)
    throw new Error("Invalid compression flag");
  return {
    version: e[0],
    privateKey: e.slice(1, 33),
    compressed: !0
  };
}
function Tn(e, t, r) {
  if (t.length !== 32)
    throw new TypeError("Invalid privateKey length");
  const n = new Uint8Array(r ? 34 : 33);
  return new DataView(n.buffer).setUint8(0, e), n.set(t, 1), r && (n[33] = 1), n;
}
function _n(e, t) {
  return Nn(Ie.decode(e));
}
function kn(e) {
  return Ie.encode(Tn(e.version, e.privateKey, e.compressed));
}
function Ln(e, t, r) {
  return kn({
    version: r.wif,
    privateKey: e,
    compressed: t
  });
}
function Hn(e, t) {
  const r = _n(e), n = r.version;
  if (Array.isArray(t)) {
    const s = t.find((f) => f.wif === n);
    if (!s) throw new Error("Unknown network version");
    return {
      privateKey: zt(r.privateKey),
      compressed: r.compressed,
      network: s
    };
  }
  const i = t;
  if (n !== i.wif)
    throw new Error("Invalid network version");
  return {
    privateKey: zt(r.privateKey),
    compressed: r.compressed,
    network: i
  };
}
function Kn(e) {
  return e[0] === 3 ? !0 : e[0] === 4 && e.length === 65 ? (e[64] & 1) === 1 : !1;
}
function qn(e) {
  const t = e.length === 32 ? e : e.subarray(1, 33);
  return hn(t);
}
const Dt = 48;
function Zn(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
function Cn(e) {
  const t = new Uint8Array(32);
  for (let r = 31; r >= 0; r--)
    t[r] = Number(e & 0xffn), e >>= 8n;
  return t;
}
class st {
  #t;
  #e;
  #r;
  #n;
  #i;
  #o;
  #s;
  constructor(t, r, n, i, o) {
    if (o?.compressed !== void 0 && typeof o.compressed != "boolean")
      throw new TypeError(
        `Expected boolean for compressed, got ${typeof o.compressed}`
      );
    this.#t = t, this.#e = r, this.#n = o?.compressed ?? !0, this.#r = i, n !== void 0 && (this.#i = t.pointCompress(n, this.#n));
  }
  /** Raw private key bytes, or `undefined` for public-key-only signers. */
  get privateKey() {
    return this.#e;
  }
  /**
   * SEC1-encoded public key.  Lazily derived from the private key when
   * the signer was created via {@link fromPrivateKey} or {@link fromWIF}.
   *
   * @throws If neither a private nor public key is available (should never happen).
   */
  get publicKey() {
    if (this.#i === void 0) {
      const t = this.#e;
      if (t === void 0)
        throw new Error("Missing both private and public key");
      const r = this.#t.pointFromScalar(t, this.#n);
      if (r === null)
        throw new Error("Failed to derive public key from private key");
      this.#i = r;
    }
    return this.#i;
  }
  /** 32-byte BIP-340 x-only public key (lazily derived and cached). */
  get xOnlyPublicKey() {
    return this.#o === void 0 && (this.#o = qn(this.publicKey)), this.#o;
  }
  /** Network this signer is bound to. */
  get network() {
    return this.#r;
  }
  /** Whether the public key is in compressed SEC1 form. */
  get compressed() {
    return this.#n;
  }
  /**
   * Bitmask of {@link SignerCapability} flags representing the operations
   * this signer can perform.  Lazily computed and cached.
   */
  get capabilities() {
    if (this.#s === void 0) {
      let t = lt.EcdsaVerify | lt.PublicKeyTweak;
      this.#e !== void 0 && (t |= lt.EcdsaSign | lt.PrivateKeyExport), this.#t.signSchnorr && this.#e !== void 0 && (t |= lt.SchnorrSign), this.#t.verifySchnorr && (t |= lt.SchnorrVerify), this.#s = t;
    }
    return this.#s;
  }
  /**
   * Creates a signer from a raw private key.
   *
   * @param backend - Cryptographic backend to use.
   * @param privateKey - 32-byte secp256k1 private key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws {TypeError} If the private key is not in the valid range `[1, n)`.
   */
  static fromPrivateKey(t, r, n, i) {
    if (!t.isPrivate(r))
      throw new TypeError("Private key not in range [1, n)");
    return new st(t, r, void 0, n, i);
  }
  /**
   * Creates a public-key-only signer (cannot sign, export WIF, etc.).
   *
   * @param backend - Cryptographic backend to use.
   * @param publicKey - SEC1-encoded public key.
   * @param network - Target network.
   * @param options - Optional settings (e.g. compressed).
   * @throws If the public key is not a valid curve point.
   */
  static fromPublicKey(t, r, n, i) {
    if (!t.isPoint(r))
      throw new Error("Point not on the curve");
    return new st(t, void 0, r, n, i);
  }
  /**
   * Imports a signer from a WIF-encoded private key string.
   *
   * @param backend - Cryptographic backend to use.
   * @param wifString - Base58Check WIF string.
   * @param network - One or more candidate networks whose WIF version byte is matched.
   * @throws If no network matches the decoded version byte.
   */
  static fromWIF(t, r, n) {
    const i = Hn(r, n);
    return st.fromPrivateKey(t, i.privateKey, i.network, {
      compressed: i.compressed
    });
  }
  /**
   * Generates a new signer with a random private key.
   *
   * Uses FIPS 186-5 B.4.2 / RFC 9380 modular reduction:
   * 48 bytes of entropy are reduced via `(seed mod (n ‚àí 1)) + 1`,
   * producing a key in `[1, n)` with negligible bias (< 2^‚àí128).
   *
   * @param backend - Cryptographic backend to use.
   * @param network - Target network.
   * @param options - Optional settings (rng, compressed).
   */
  static makeRandom(t, r, n) {
    const o = (n?.rng ?? ((a) => crypto.getRandomValues(new Uint8Array(a))))(Dt);
    if (o.length !== Dt)
      throw new TypeError(
        `Expected ${Dt} bytes from rng, got ${o.length} bytes`
      );
    const f = Zn(o) % (Jt - 1n) + 1n, c = Cn(f);
    return st.fromPrivateKey(
      t,
      zt(c),
      r,
      n
    );
  }
  /**
   * Tests whether this signer has a specific capability.
   * @param cap - {@link SignerCapability} flag to test.
   */
  hasCapability(t) {
    return (this.capabilities & t) !== 0;
  }
  /**
   * Produces a compact ECDSA signature.
   *
   * When `lowR` is `true`, grinds the nonce until the R value's first
   * byte is `<= 0x7f`, producing a smaller DER encoding.
   *
   * @param hash - 32-byte message digest.
   * @param lowR - Enable low-R grinding.  Defaults to `false`.
   * @throws If this is a public-key-only signer.
   */
  sign(t, r) {
    if (this.#e === void 0) throw new Error("Missing private key");
    if (!r)
      return this.#t.sign(t, this.#e);
    let n = this.#t.sign(t, this.#e);
    const i = new Uint8Array(32), o = new DataView(i.buffer, i.byteOffset, i.byteLength);
    let s = 0;
    for (; ; ) {
      const f = n[0];
      if (f === void 0) throw new Error("Backend returned invalid signature");
      if (f <= 127) break;
      s++, o.setUint32(0, s, !0), n = this.#t.sign(t, this.#e, i);
    }
    return n;
  }
  /**
   * Produces a 64-byte BIP-340 Schnorr signature.
   *
   * @param hash - 32-byte message digest.
   * @throws If this is a public-key-only signer.
   * @throws If the backend does not support Schnorr signing.
   */
  signSchnorr(t) {
    if (this.#e === void 0) throw new Error("Missing private key");
    if (!this.#t.signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return this.#t.signSchnorr(t, this.#e);
  }
  /**
   * Verifies a compact ECDSA signature against this signer's public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - Compact ECDSA signature.
   */
  verify(t, r) {
    return this.#t.verify(t, this.publicKey, r);
  }
  /**
   * Verifies a BIP-340 Schnorr signature against this signer's x-only public key.
   *
   * @param hash - 32-byte message digest.
   * @param signature - 64-byte Schnorr signature.
   * @throws If the backend does not support Schnorr verification.
   */
  verifySchnorr(t, r) {
    if (!this.#t.verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return this.#t.verifySchnorr(t, this.xOnlyPublicKey, r);
  }
  /**
   * Derives a new signer by applying a Taproot-style scalar tweak.
   *
   * When a private key is available the tweak is applied to the scalar
   * (negating first if the public key has odd Y).  Otherwise, only the
   * public key is tweaked via x-only point addition.
   *
   * @param t - 32-byte tweak scalar.
   * @throws If the tweaked key is invalid (e.g. lands on the point at infinity).
   */
  tweak(t) {
    return Ae(t), this.#e !== void 0 ? this.#f(t) : this.#c(t);
  }
  /**
   * Exports the private key as a WIF string using this signer's network.
   *
   * @throws If this is a public-key-only signer.
   */
  toWIF() {
    if (this.#e === void 0) throw new Error("Missing private key");
    return Ln(this.#e, this.#n, this.#r);
  }
  #f(t) {
    const r = this.publicKey, n = this.#e;
    if (n === void 0)
      throw new Error("Missing private key");
    const i = Kn(r) ? this.#t.privateNegate(n) : n, o = this.#t.privateAdd(i, t);
    if (o === null) throw new Error("Invalid tweaked private key!");
    return st.fromPrivateKey(this.#t, o, this.#r, {
      compressed: this.#n
    });
  }
  #c(t) {
    const r = this.xOnlyPublicKey, n = this.#t.xOnlyPointAddTweak(r, t);
    if (n === null || n.xOnlyPubkey === null)
      throw new Error("Cannot tweak public key!");
    const i = new Uint8Array([n.parity === 0 ? 2 : 3]), o = nn(i, n.xOnlyPubkey);
    return st.fromPublicKey(this.#t, ln(o), this.#r, {
      compressed: this.#n
    });
  }
}
const ee = /* @__PURE__ */ BigInt(0), Ft = /* @__PURE__ */ BigInt(1);
function Nt(e, t = "") {
  if (typeof e != "boolean") {
    const r = t && `"${t}" `;
    throw new Error(r + "expected boolean, got type=" + typeof e);
  }
  return e;
}
function Ue(e) {
  if (typeof e == "bigint") {
    if (!Rt(e))
      throw new Error("positive bigint expected, got " + e);
  } else
    dt(e);
  return e;
}
function St(e) {
  const t = Ue(e).toString(16);
  return t.length & 1 ? "0" + t : t;
}
function Pe(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return e === "" ? ee : BigInt("0x" + e);
}
function xt(e) {
  return Pe(Ht(e));
}
function Ne(e) {
  return Pe(Ht($n(_(e)).reverse()));
}
function ne(e, t) {
  dt(t), e = Ue(e);
  const r = Pt(e.toString(16).padStart(t * 2, "0"));
  if (r.length !== t)
    throw new Error("number too large");
  return r;
}
function Te(e, t) {
  return ne(e, t).reverse();
}
function $n(e) {
  return Uint8Array.from(e);
}
function Vn(e) {
  return Uint8Array.from(e, (t, r) => {
    const n = t.charCodeAt(0);
    if (t.length !== 1 || n > 127)
      throw new Error(`string contains non-ASCII character "${e[r]}" with code ${n} at position ${r}`);
    return n;
  });
}
const Rt = (e) => typeof e == "bigint" && ee <= e;
function Dn(e, t, r) {
  return Rt(e) && Rt(t) && Rt(r) && t <= e && e < r;
}
function Mn(e, t, r, n) {
  if (!Dn(t, r, n))
    throw new Error("expected valid " + e + ": " + r + " <= n < " + n + ", got " + t);
}
function Xn(e) {
  let t;
  for (t = 0; e > ee; e >>= Ft, t += 1)
    ;
  return t;
}
const re = (e) => (Ft << BigInt(e)) - Ft;
function Yn(e, t, r) {
  if (dt(e, "hashLen"), dt(t, "qByteLen"), typeof r != "function")
    throw new Error("hmacFn must be a function");
  const n = (A) => new Uint8Array(A), i = Uint8Array.of(), o = Uint8Array.of(0), s = Uint8Array.of(1), f = 1e3;
  let c = n(e), a = n(e), h = 0;
  const b = () => {
    c.fill(1), a.fill(0), h = 0;
  }, m = (...A) => r(a, W(c, ...A)), y = (A = i) => {
    a = m(o, A), c = m(), A.length !== 0 && (a = m(s, A), c = m());
  }, E = () => {
    if (h++ >= f)
      throw new Error("drbg: tried max amount of iterations");
    let A = 0;
    const T = [];
    for (; A < t; ) {
      c = m();
      const q = c.slice();
      T.push(q), A += c.length;
    }
    return W(...T);
  };
  return (A, T) => {
    b(), y(A);
    let q;
    for (; !(q = T(E())); )
      y();
    return b(), q;
  };
}
function ie(e, t = {}, r = {}) {
  if (!e || typeof e != "object")
    throw new Error("expected valid options object");
  function n(o, s, f) {
    const c = e[o];
    if (f && c === void 0)
      return;
    const a = typeof c;
    if (a !== s || c === null)
      throw new Error(`param "${o}" is invalid: expected ${s}, got ${a}`);
  }
  const i = (o, s) => Object.entries(o).forEach(([f, c]) => n(f, c, s));
  i(t, !1), i(r, !0);
}
function le(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (r, ...n) => {
    const i = t.get(r);
    if (i !== void 0)
      return i;
    const o = e(r, ...n);
    return t.set(r, o), o;
  };
}
const X = /* @__PURE__ */ BigInt(0), D = /* @__PURE__ */ BigInt(1), ct = /* @__PURE__ */ BigInt(2), _e = /* @__PURE__ */ BigInt(3), ke = /* @__PURE__ */ BigInt(4), Le = /* @__PURE__ */ BigInt(5), jn = /* @__PURE__ */ BigInt(7), He = /* @__PURE__ */ BigInt(8), zn = /* @__PURE__ */ BigInt(9), Ke = /* @__PURE__ */ BigInt(16);
function Y(e, t) {
  const r = e % t;
  return r >= X ? r : t + r;
}
function z(e, t, r) {
  let n = e;
  for (; t-- > X; )
    n *= n, n %= r;
  return n;
}
function he(e, t) {
  if (e === X)
    throw new Error("invert: expected non-zero number");
  if (t <= X)
    throw new Error("invert: expected positive modulus, got " + t);
  let r = Y(e, t), n = t, i = X, o = D;
  for (; r !== X; ) {
    const f = n / r, c = n % r, a = i - o * f;
    n = r, r = c, i = o, o = a;
  }
  if (n !== D)
    throw new Error("invert: does not exist");
  return Y(i, t);
}
function oe(e, t, r) {
  if (!e.eql(e.sqr(t), r))
    throw new Error("Cannot find square root");
}
function qe(e, t) {
  const r = (e.ORDER + D) / ke, n = e.pow(t, r);
  return oe(e, n, t), n;
}
function Fn(e, t) {
  const r = (e.ORDER - Le) / He, n = e.mul(t, ct), i = e.pow(n, r), o = e.mul(t, i), s = e.mul(e.mul(o, ct), i), f = e.mul(o, e.sub(s, e.ONE));
  return oe(e, f, t), f;
}
function Gn(e) {
  const t = qt(e), r = Ze(e), n = r(t, t.neg(t.ONE)), i = r(t, n), o = r(t, t.neg(n)), s = (e + jn) / Ke;
  return (f, c) => {
    let a = f.pow(c, s), h = f.mul(a, n);
    const b = f.mul(a, i), m = f.mul(a, o), y = f.eql(f.sqr(h), c), E = f.eql(f.sqr(b), c);
    a = f.cmov(a, h, y), h = f.cmov(m, b, E);
    const O = f.eql(f.sqr(h), c), A = f.cmov(a, h, O);
    return oe(f, A, c), A;
  };
}
function Ze(e) {
  if (e < _e)
    throw new Error("sqrt is not defined for small field");
  let t = e - D, r = 0;
  for (; t % ct === X; )
    t /= ct, r++;
  let n = ct;
  const i = qt(e);
  for (; be(i, n) === 1; )
    if (n++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (r === 1)
    return qe;
  let o = i.pow(n, t);
  const s = (t + D) / ct;
  return function(c, a) {
    if (c.is0(a))
      return a;
    if (be(c, a) !== 1)
      throw new Error("Cannot find square root");
    let h = r, b = c.mul(c.ONE, o), m = c.pow(a, t), y = c.pow(a, s);
    for (; !c.eql(m, c.ONE); ) {
      if (c.is0(m))
        return c.ZERO;
      let E = 1, O = c.sqr(m);
      for (; !c.eql(O, c.ONE); )
        if (E++, O = c.sqr(O), E === h)
          throw new Error("Cannot find square root");
      const A = D << BigInt(h - E - 1), T = c.pow(b, A);
      h = E, b = c.sqr(T), m = c.mul(m, b), y = c.mul(y, T);
    }
    return y;
  };
}
function Wn(e) {
  return e % ke === _e ? qe : e % He === Le ? Fn : e % Ke === zn ? Gn(e) : Ze(e);
}
const Qn = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function Jn(e) {
  const t = {
    ORDER: "bigint",
    BYTES: "number",
    BITS: "number"
  }, r = Qn.reduce((n, i) => (n[i] = "function", n), t);
  return ie(e, r), e;
}
function tr(e, t, r) {
  if (r < X)
    throw new Error("invalid exponent, negatives unsupported");
  if (r === X)
    return e.ONE;
  if (r === D)
    return t;
  let n = e.ONE, i = t;
  for (; r > X; )
    r & D && (n = e.mul(n, i)), i = e.sqr(i), r >>= D;
  return n;
}
function Ce(e, t, r = !1) {
  const n = new Array(t.length).fill(r ? e.ZERO : void 0), i = t.reduce((s, f, c) => e.is0(f) ? s : (n[c] = s, e.mul(s, f)), e.ONE), o = e.inv(i);
  return t.reduceRight((s, f, c) => e.is0(f) ? s : (n[c] = e.mul(s, n[c]), e.mul(s, f)), o), n;
}
function be(e, t) {
  const r = (e.ORDER - D) / ct, n = e.pow(t, r), i = e.eql(n, e.ONE), o = e.eql(n, e.ZERO), s = e.eql(n, e.neg(e.ONE));
  if (!i && !o && !s)
    throw new Error("invalid Legendre symbol result");
  return i ? 1 : o ? 0 : -1;
}
function er(e, t) {
  t !== void 0 && dt(t);
  const r = t !== void 0 ? t : e.toString(2).length, n = Math.ceil(r / 8);
  return { nBitLength: r, nByteLength: n };
}
class nr {
  ORDER;
  BITS;
  BYTES;
  isLE;
  ZERO = X;
  ONE = D;
  _lengths;
  _sqrt;
  // cached sqrt
  _mod;
  constructor(t, r = {}) {
    if (t <= X)
      throw new Error("invalid field: expected ORDER > 0, got " + t);
    let n;
    this.isLE = !1, r != null && typeof r == "object" && (typeof r.BITS == "number" && (n = r.BITS), typeof r.sqrt == "function" && (this.sqrt = r.sqrt), typeof r.isLE == "boolean" && (this.isLE = r.isLE), r.allowedLengths && (this._lengths = r.allowedLengths?.slice()), typeof r.modFromBytes == "boolean" && (this._mod = r.modFromBytes));
    const { nBitLength: i, nByteLength: o } = er(t, n);
    if (o > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    this.ORDER = t, this.BITS = i, this.BYTES = o, this._sqrt = void 0, Object.preventExtensions(this);
  }
  create(t) {
    return Y(t, this.ORDER);
  }
  isValid(t) {
    if (typeof t != "bigint")
      throw new Error("invalid field element: expected bigint, got " + typeof t);
    return X <= t && t < this.ORDER;
  }
  is0(t) {
    return t === X;
  }
  // is valid and invertible
  isValidNot0(t) {
    return !this.is0(t) && this.isValid(t);
  }
  isOdd(t) {
    return (t & D) === D;
  }
  neg(t) {
    return Y(-t, this.ORDER);
  }
  eql(t, r) {
    return t === r;
  }
  sqr(t) {
    return Y(t * t, this.ORDER);
  }
  add(t, r) {
    return Y(t + r, this.ORDER);
  }
  sub(t, r) {
    return Y(t - r, this.ORDER);
  }
  mul(t, r) {
    return Y(t * r, this.ORDER);
  }
  pow(t, r) {
    return tr(this, t, r);
  }
  div(t, r) {
    return Y(t * he(r, this.ORDER), this.ORDER);
  }
  // Same as above, but doesn't normalize
  sqrN(t) {
    return t * t;
  }
  addN(t, r) {
    return t + r;
  }
  subN(t, r) {
    return t - r;
  }
  mulN(t, r) {
    return t * r;
  }
  inv(t) {
    return he(t, this.ORDER);
  }
  sqrt(t) {
    return this._sqrt || (this._sqrt = Wn(this.ORDER)), this._sqrt(this, t);
  }
  toBytes(t) {
    return this.isLE ? Te(t, this.BYTES) : ne(t, this.BYTES);
  }
  fromBytes(t, r = !1) {
    _(t);
    const { _lengths: n, BYTES: i, isLE: o, ORDER: s, _mod: f } = this;
    if (n) {
      if (!n.includes(t.length) || t.length > i)
        throw new Error("Field.fromBytes: expected " + n + " bytes, got " + t.length);
      const a = new Uint8Array(i);
      a.set(t, o ? 0 : a.length - t.length), t = a;
    }
    if (t.length !== i)
      throw new Error("Field.fromBytes: expected " + i + " bytes, got " + t.length);
    let c = o ? Ne(t) : xt(t);
    if (f && (c = Y(c, s)), !r && !this.isValid(c))
      throw new Error("invalid field element: outside of range 0..ORDER");
    return c;
  }
  // TODO: we don't need it here, move out to separate fn
  invertBatch(t) {
    return Ce(this, t);
  }
  // We can't move this out because Fp6, Fp12 implement it
  // and it's unclear what to return in there.
  cmov(t, r, n) {
    return n ? r : t;
  }
}
function qt(e, t = {}) {
  return new nr(e, t);
}
function $e(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function Ve(e) {
  const t = $e(e);
  return t + Math.ceil(t / 2);
}
function De(e, t, r = !1) {
  _(e);
  const n = e.length, i = $e(t), o = Ve(t);
  if (n < 16 || n < o || n > 1024)
    throw new Error("expected " + o + "-1024 bytes of input, got " + n);
  const s = r ? Ne(e) : xt(e), f = Y(s, t - D) + D;
  return r ? Te(f, i) : ne(f, i);
}
const yt = /* @__PURE__ */ BigInt(0), at = /* @__PURE__ */ BigInt(1);
function Tt(e, t) {
  const r = t.negate();
  return e ? r : t;
}
function ye(e, t) {
  const r = Ce(e.Fp, t.map((n) => n.Z));
  return t.map((n, i) => e.fromAffine(n.toAffine(r[i])));
}
function Me(e, t) {
  if (!Number.isSafeInteger(e) || e <= 0 || e > t)
    throw new Error("invalid window size, expected [1.." + t + "], got W=" + e);
}
function Mt(e, t) {
  Me(e, t);
  const r = Math.ceil(t / e) + 1, n = 2 ** (e - 1), i = 2 ** e, o = re(e), s = BigInt(e);
  return { windows: r, windowSize: n, mask: o, maxNumber: i, shiftBy: s };
}
function ge(e, t, r) {
  const { windowSize: n, mask: i, maxNumber: o, shiftBy: s } = r;
  let f = Number(e & i), c = e >> s;
  f > n && (f -= o, c += at);
  const a = t * n, h = a + Math.abs(f) - 1, b = f === 0, m = f < 0, y = t % 2 !== 0;
  return { nextN: c, offset: h, isZero: b, isNeg: m, isNegF: y, offsetF: a };
}
const Xt = /* @__PURE__ */ new WeakMap(), Xe = /* @__PURE__ */ new WeakMap();
function Yt(e) {
  return Xe.get(e) || 1;
}
function we(e) {
  if (e !== yt)
    throw new Error("invalid wNAF");
}
class rr {
  BASE;
  ZERO;
  Fn;
  bits;
  // Parametrized with a given Point class (not individual point)
  constructor(t, r) {
    this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = r;
  }
  // non-const time multiplication ladder
  _unsafeLadder(t, r, n = this.ZERO) {
    let i = t;
    for (; r > yt; )
      r & at && (n = n.add(i)), i = i.double(), r >>= at;
    return n;
  }
  /**
   * Creates a wNAF precomputation window. Used for caching.
   * Default window size is set by `utils.precompute()` and is equal to 8.
   * Number of precomputed points depends on the curve size:
   * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
   * - ùëä is the window size
   * - ùëõ is the bitlength of the curve order.
   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
   * @param point Point instance
   * @param W window size
   * @returns precomputed point tables flattened to a single array
   */
  precomputeWindow(t, r) {
    const { windows: n, windowSize: i } = Mt(r, this.bits), o = [];
    let s = t, f = s;
    for (let c = 0; c < n; c++) {
      f = s, o.push(f);
      for (let a = 1; a < i; a++)
        f = f.add(s), o.push(f);
      s = f.double();
    }
    return o;
  }
  /**
   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
   * More compact implementation:
   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
   * @returns real and fake (for const-time) points
   */
  wNAF(t, r, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let i = this.ZERO, o = this.BASE;
    const s = Mt(t, this.bits);
    for (let f = 0; f < s.windows; f++) {
      const { nextN: c, offset: a, isZero: h, isNeg: b, isNegF: m, offsetF: y } = ge(n, f, s);
      n = c, h ? o = o.add(Tt(m, r[y])) : i = i.add(Tt(b, r[a]));
    }
    return we(n), { p: i, f: o };
  }
  /**
   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
   * @param acc accumulator point to add result of multiplication
   * @returns point
   */
  wNAFUnsafe(t, r, n, i = this.ZERO) {
    const o = Mt(t, this.bits);
    for (let s = 0; s < o.windows && n !== yt; s++) {
      const { nextN: f, offset: c, isZero: a, isNeg: h } = ge(n, s, o);
      if (n = f, !a) {
        const b = r[c];
        i = i.add(h ? b.negate() : b);
      }
    }
    return we(n), i;
  }
  getPrecomputes(t, r, n) {
    let i = Xt.get(r);
    return i || (i = this.precomputeWindow(r, t), t !== 1 && (typeof n == "function" && (i = n(i)), Xt.set(r, i))), i;
  }
  cached(t, r, n) {
    const i = Yt(t);
    return this.wNAF(i, this.getPrecomputes(i, t, n), r);
  }
  unsafe(t, r, n, i) {
    const o = Yt(t);
    return o === 1 ? this._unsafeLadder(t, r, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, n), r, i);
  }
  // We calculate precomputes for elliptic curve point multiplication
  // using windowed method. This specifies window size and
  // stores precomputed values. Usually only base point would be precomputed.
  createCache(t, r) {
    Me(r, this.bits), Xe.set(t, r), Xt.delete(t);
  }
  hasCache(t) {
    return Yt(t) !== 1;
  }
}
function ir(e, t, r, n) {
  let i = t, o = e.ZERO, s = e.ZERO;
  for (; r > yt || n > yt; )
    r & at && (o = o.add(i)), n & at && (s = s.add(i)), i = i.double(), r >>= at, n >>= at;
  return { p1: o, p2: s };
}
function pe(e, t, r) {
  if (t) {
    if (t.ORDER !== e)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return Jn(t), t;
  } else
    return qt(e, { isLE: r });
}
function or(e, t, r = {}, n) {
  if (n === void 0 && (n = e === "edwards"), !t || typeof t != "object")
    throw new Error(`expected valid ${e} CURVE object`);
  for (const c of ["p", "n", "h"]) {
    const a = t[c];
    if (!(typeof a == "bigint" && a > yt))
      throw new Error(`CURVE.${c} must be positive bigint`);
  }
  const i = pe(t.p, r.Fp, n), o = pe(t.n, r.Fn, n), f = ["Gx", "Gy", "a", "b"];
  for (const c of f)
    if (!i.isValid(t[c]))
      throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);
  return t = Object.freeze(Object.assign({}, t)), { CURVE: t, Fp: i, Fn: o };
}
function Ye(e, t) {
  return function(n) {
    const i = e(n);
    return { secretKey: i, publicKey: t(i) };
  };
}
class je {
  oHash;
  iHash;
  blockLen;
  outputLen;
  finished = !1;
  destroyed = !1;
  constructor(t, r) {
    if (Oe(t), _(r, void 0, "key"), this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const n = this.blockLen, i = new Uint8Array(n);
    i.set(r.length > n ? t.create().update(r).digest() : r);
    for (let o = 0; o < i.length; o++)
      i[o] ^= 54;
    this.iHash.update(i), this.oHash = t.create();
    for (let o = 0; o < i.length; o++)
      i[o] ^= 106;
    this.oHash.update(i), Ut(i);
  }
  update(t) {
    return It(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    It(this), _(t, this.outputLen, "output"), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t ||= Object.create(Object.getPrototypeOf(this), {});
    const { oHash: r, iHash: n, finished: i, destroyed: o, blockLen: s, outputLen: f } = this;
    return t = t, t.finished = i, t.destroyed = o, t.blockLen = s, t.outputLen = f, t.oHash = r._cloneInto(t.oHash), t.iHash = n._cloneInto(t.iHash), t;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const ze = (e, t, r) => new je(e, t).update(r).digest();
ze.create = (e, t) => new je(e, t);
const me = (e, t) => (e + (e >= 0 ? t : -t) / Fe) / t;
function sr(e, t, r) {
  const [[n, i], [o, s]] = t, f = me(s * e, r), c = me(-i * e, r);
  let a = e - f * n - c * o, h = -f * i - c * s;
  const b = a < J, m = h < J;
  b && (a = -a), m && (h = -h);
  const y = re(Math.ceil(Xn(r) / 2)) + bt;
  if (a < J || a >= y || h < J || h >= y)
    throw new Error("splitScalar (endomorphism): failed, k=" + e);
  return { k1neg: b, k1: a, k2neg: m, k2: h };
}
function Gt(e) {
  if (!["compact", "recovered", "der"].includes(e))
    throw new Error('Signature format must be "compact", "recovered", or "der"');
  return e;
}
function jt(e, t) {
  const r = {};
  for (let n of Object.keys(t))
    r[n] = e[n] === void 0 ? t[n] : e[n];
  return Nt(r.lowS, "lowS"), Nt(r.prehash, "prehash"), r.format !== void 0 && Gt(r.format), r;
}
class fr extends Error {
  constructor(t = "") {
    super(t);
  }
}
const rt = {
  // asn.1 DER encoding utils
  Err: fr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: r } = rt;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new r("tlv.encode: unpadded data");
      const n = t.length / 2, i = St(n);
      if (i.length / 2 & 128)
        throw new r("tlv.encode: long form length too big");
      const o = n > 127 ? St(i.length / 2 | 128) : "";
      return St(e) + o + i + t;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: r } = rt;
      let n = 0;
      if (e < 0 || e > 256)
        throw new r("tlv.encode: wrong tag");
      if (t.length < 2 || t[n++] !== e)
        throw new r("tlv.decode: wrong tlv");
      const i = t[n++], o = !!(i & 128);
      let s = 0;
      if (!o)
        s = i;
      else {
        const c = i & 127;
        if (!c)
          throw new r("tlv.decode(long): indefinite length not supported");
        if (c > 4)
          throw new r("tlv.decode(long): byte length is too big");
        const a = t.subarray(n, n + c);
        if (a.length !== c)
          throw new r("tlv.decode: length bytes not complete");
        if (a[0] === 0)
          throw new r("tlv.decode(long): zero leftmost byte");
        for (const h of a)
          s = s << 8 | h;
        if (n += c, s < 128)
          throw new r("tlv.decode(long): not minimal encoding");
      }
      const f = t.subarray(n, n + s);
      if (f.length !== s)
        throw new r("tlv.decode: wrong value length");
      return { v: f, l: t.subarray(n + s) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = rt;
      if (e < J)
        throw new t("integer: negative integers are not allowed");
      let r = St(e);
      if (Number.parseInt(r[0], 16) & 8 && (r = "00" + r), r.length & 1)
        throw new t("unexpected DER parsing assertion: unpadded hex");
      return r;
    },
    decode(e) {
      const { Err: t } = rt;
      if (e[0] & 128)
        throw new t("invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("invalid signature integer: unnecessary leading zero");
      return xt(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: r, _tlv: n } = rt, i = _(e, void 0, "signature"), { v: o, l: s } = n.decode(48, i);
    if (s.length)
      throw new t("invalid signature: left bytes after parsing");
    const { v: f, l: c } = n.decode(2, o), { v: a, l: h } = n.decode(2, c);
    if (h.length)
      throw new t("invalid signature: left bytes after parsing");
    return { r: r.decode(f), s: r.decode(a) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: r } = rt, n = t.encode(2, r.encode(e.r)), i = t.encode(2, r.encode(e.s)), o = n + i;
    return t.encode(48, o);
  }
}, J = BigInt(0), bt = BigInt(1), Fe = BigInt(2), At = BigInt(3), cr = BigInt(4);
function ar(e, t = {}) {
  const r = or("weierstrass", e, t), { Fp: n, Fn: i } = r;
  let o = r.CURVE;
  const { h: s, n: f } = o;
  ie(t, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object"
  });
  const { endo: c } = t;
  if (c && (!n.is0(o.a) || typeof c.beta != "bigint" || !Array.isArray(c.basises)))
    throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const a = We(n, i);
  function h() {
    if (!n.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function b(U, l, u) {
    const { x: d, y: g } = l.toAffine(), x = n.toBytes(d);
    if (Nt(u, "isCompressed"), u) {
      h();
      const B = !n.isOdd(g);
      return W(Ge(B), x);
    } else
      return W(Uint8Array.of(4), x, n.toBytes(g));
  }
  function m(U) {
    _(U, void 0, "Point");
    const { publicKey: l, publicKeyUncompressed: u } = a, d = U.length, g = U[0], x = U.subarray(1);
    if (d === l && (g === 2 || g === 3)) {
      const B = n.fromBytes(x);
      if (!n.isValid(B))
        throw new Error("bad point: is not on curve, wrong x");
      const v = O(B);
      let p;
      try {
        p = n.sqrt(v);
      } catch (C) {
        const k = C instanceof Error ? ": " + C.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + k);
      }
      h();
      const S = n.isOdd(p);
      return (g & 1) === 1 !== S && (p = n.neg(p)), { x: B, y: p };
    } else if (d === u && g === 4) {
      const B = n.BYTES, v = n.fromBytes(x.subarray(0, B)), p = n.fromBytes(x.subarray(B, B * 2));
      if (!A(v, p))
        throw new Error("bad point: is not on curve");
      return { x: v, y: p };
    } else
      throw new Error(`bad point: got length ${d}, expected compressed=${l} or uncompressed=${u}`);
  }
  const y = t.toBytes || b, E = t.fromBytes || m;
  function O(U) {
    const l = n.sqr(U), u = n.mul(l, U);
    return n.add(n.add(u, n.mul(U, o.a)), o.b);
  }
  function A(U, l) {
    const u = n.sqr(l), d = O(U);
    return n.eql(u, d);
  }
  if (!A(o.Gx, o.Gy))
    throw new Error("bad curve params: generator point");
  const T = n.mul(n.pow(o.a, At), cr), q = n.mul(n.sqr(o.b), BigInt(27));
  if (n.is0(n.add(T, q)))
    throw new Error("bad curve params: a or b");
  function Z(U, l, u = !1) {
    if (!n.isValid(l) || u && n.is0(l))
      throw new Error(`bad point coordinate ${U}`);
    return l;
  }
  function L(U) {
    if (!(U instanceof N))
      throw new Error("Weierstrass Point expected");
  }
  function j(U) {
    if (!c || !c.basises)
      throw new Error("no endo");
    return sr(U, c.basises, i.ORDER);
  }
  const tt = le((U, l) => {
    const { X: u, Y: d, Z: g } = U;
    if (n.eql(g, n.ONE))
      return { x: u, y: d };
    const x = U.is0();
    l == null && (l = x ? n.ONE : n.inv(g));
    const B = n.mul(u, l), v = n.mul(d, l), p = n.mul(g, l);
    if (x)
      return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(p, n.ONE))
      throw new Error("invZ was invalid");
    return { x: B, y: v };
  }), Ct = le((U) => {
    if (U.is0()) {
      if (t.allowInfinityPoint && !n.is0(U.Y))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: l, y: u } = U.toAffine();
    if (!n.isValid(l) || !n.isValid(u))
      throw new Error("bad point: x or y not field elements");
    if (!A(l, u))
      throw new Error("bad point: equation left != right");
    if (!U.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  function gt(U, l, u, d, g) {
    return u = new N(n.mul(u.X, U), u.Y, u.Z), l = Tt(d, l), u = Tt(g, u), l.add(u);
  }
  class N {
    // base / generator point
    static BASE = new N(o.Gx, o.Gy, n.ONE);
    // zero / infinity / identity point
    static ZERO = new N(n.ZERO, n.ONE, n.ZERO);
    // 0, 1, 0
    // math field
    static Fp = n;
    // scalar field
    static Fn = i;
    X;
    Y;
    Z;
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(l, u, d) {
      this.X = Z("x", l), this.Y = Z("y", u, !0), this.Z = Z("z", d), Object.freeze(this);
    }
    static CURVE() {
      return o;
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(l) {
      const { x: u, y: d } = l || {};
      if (!l || !n.isValid(u) || !n.isValid(d))
        throw new Error("invalid affine point");
      if (l instanceof N)
        throw new Error("projective point not allowed");
      return n.is0(u) && n.is0(d) ? N.ZERO : new N(u, d, n.ONE);
    }
    static fromBytes(l) {
      const u = N.fromAffine(E(_(l, void 0, "point")));
      return u.assertValidity(), u;
    }
    static fromHex(l) {
      return N.fromBytes(Pt(l));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(l = 8, u = !0) {
      return it.createCache(this, l), u || this.multiply(At), this;
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      Ct(this);
    }
    hasEvenY() {
      const { y: l } = this.toAffine();
      if (!n.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !n.isOdd(l);
    }
    /** Compare one point to another. */
    equals(l) {
      L(l);
      const { X: u, Y: d, Z: g } = this, { X: x, Y: B, Z: v } = l, p = n.eql(n.mul(u, v), n.mul(x, g)), S = n.eql(n.mul(d, v), n.mul(B, g));
      return p && S;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new N(this.X, n.neg(this.Y), this.Z);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: l, b: u } = o, d = n.mul(u, At), { X: g, Y: x, Z: B } = this;
      let v = n.ZERO, p = n.ZERO, S = n.ZERO, R = n.mul(g, g), C = n.mul(x, x), k = n.mul(B, B), I = n.mul(g, x);
      return I = n.add(I, I), S = n.mul(g, B), S = n.add(S, S), v = n.mul(l, S), p = n.mul(d, k), p = n.add(v, p), v = n.sub(C, p), p = n.add(C, p), p = n.mul(v, p), v = n.mul(I, v), S = n.mul(d, S), k = n.mul(l, k), I = n.sub(R, k), I = n.mul(l, I), I = n.add(I, S), S = n.add(R, R), R = n.add(S, R), R = n.add(R, k), R = n.mul(R, I), p = n.add(p, R), k = n.mul(x, B), k = n.add(k, k), R = n.mul(k, I), v = n.sub(v, R), S = n.mul(k, C), S = n.add(S, S), S = n.add(S, S), new N(v, p, S);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(l) {
      L(l);
      const { X: u, Y: d, Z: g } = this, { X: x, Y: B, Z: v } = l;
      let p = n.ZERO, S = n.ZERO, R = n.ZERO;
      const C = o.a, k = n.mul(o.b, At);
      let I = n.mul(u, x), H = n.mul(d, B), $ = n.mul(g, v), F = n.add(u, d), K = n.add(x, B);
      F = n.mul(F, K), K = n.add(I, H), F = n.sub(F, K), K = n.add(u, g);
      let V = n.add(x, v);
      return K = n.mul(K, V), V = n.add(I, $), K = n.sub(K, V), V = n.add(d, g), p = n.add(B, v), V = n.mul(V, p), p = n.add(H, $), V = n.sub(V, p), R = n.mul(C, K), p = n.mul(k, $), R = n.add(p, R), p = n.sub(H, R), R = n.add(H, R), S = n.mul(p, R), H = n.add(I, I), H = n.add(H, I), $ = n.mul(C, $), K = n.mul(k, K), H = n.add(H, $), $ = n.sub(I, $), $ = n.mul(C, $), K = n.add(K, $), I = n.mul(H, K), S = n.add(S, I), I = n.mul(V, K), p = n.mul(F, p), p = n.sub(p, I), I = n.mul(F, H), R = n.mul(V, R), R = n.add(R, I), new N(p, S, R);
    }
    subtract(l) {
      return this.add(l.negate());
    }
    is0() {
      return this.equals(N.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(l) {
      const { endo: u } = t;
      if (!i.isValidNot0(l))
        throw new Error("invalid scalar: out of range");
      let d, g;
      const x = (B) => it.cached(this, B, (v) => ye(N, v));
      if (u) {
        const { k1neg: B, k1: v, k2neg: p, k2: S } = j(l), { p: R, f: C } = x(v), { p: k, f: I } = x(S);
        g = C.add(I), d = gt(u.beta, R, k, B, p);
      } else {
        const { p: B, f: v } = x(l);
        d = B, g = v;
      }
      return ye(N, [d, g])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed secret key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(l) {
      const { endo: u } = t, d = this;
      if (!i.isValid(l))
        throw new Error("invalid scalar: out of range");
      if (l === J || d.is0())
        return N.ZERO;
      if (l === bt)
        return d;
      if (it.hasCache(this))
        return this.multiply(l);
      if (u) {
        const { k1neg: g, k1: x, k2neg: B, k2: v } = j(l), { p1: p, p2: S } = ir(N, d, x, v);
        return gt(u.beta, p, S, g, B);
      } else
        return it.unsafe(d, l);
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(l) {
      return tt(this, l);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree: l } = t;
      return s === bt ? !0 : l ? l(N, this) : it.unsafe(this, f).is0();
    }
    clearCofactor() {
      const { clearCofactor: l } = t;
      return s === bt ? this : l ? l(N, this) : this.multiplyUnsafe(s);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(s).is0();
    }
    toBytes(l = !0) {
      return Nt(l, "isCompressed"), this.assertValidity(), y(N, this, l);
    }
    toHex(l = !0) {
      return Ht(this.toBytes(l));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  const vt = i.BITS, it = new rr(N, t.endo ? Math.ceil(vt / 2) : vt);
  return N.BASE.precompute(8), N;
}
function Ge(e) {
  return Uint8Array.of(e ? 2 : 3);
}
function We(e, t) {
  return {
    secretKey: t.BYTES,
    publicKey: 1 + e.BYTES,
    publicKeyUncompressed: 1 + 2 * e.BYTES,
    publicKeyHasPrefix: !0,
    signature: 2 * t.BYTES
  };
}
function dr(e, t = {}) {
  const { Fn: r } = e, n = t.randomBytes || Kt, i = Object.assign(We(e.Fp, r), { seed: Ve(r.ORDER) });
  function o(y) {
    try {
      const E = r.fromBytes(y);
      return r.isValidNot0(E);
    } catch {
      return !1;
    }
  }
  function s(y, E) {
    const { publicKey: O, publicKeyUncompressed: A } = i;
    try {
      const T = y.length;
      return E === !0 && T !== O || E === !1 && T !== A ? !1 : !!e.fromBytes(y);
    } catch {
      return !1;
    }
  }
  function f(y = n(i.seed)) {
    return De(_(y, i.seed, "seed"), r.ORDER);
  }
  function c(y, E = !0) {
    return e.BASE.multiply(r.fromBytes(y)).toBytes(E);
  }
  function a(y) {
    const { secretKey: E, publicKey: O, publicKeyUncompressed: A } = i;
    if (!te(y) || "_lengths" in r && r._lengths || E === O)
      return;
    const T = _(y, void 0, "key").length;
    return T === O || T === A;
  }
  function h(y, E, O = !0) {
    if (a(y) === !0)
      throw new Error("first arg must be private key");
    if (a(E) === !1)
      throw new Error("second arg must be public key");
    const A = r.fromBytes(y);
    return e.fromBytes(E).multiply(A).toBytes(O);
  }
  const b = {
    isValidSecretKey: o,
    isValidPublicKey: s,
    randomSecretKey: f
  }, m = Ye(f, c);
  return Object.freeze({ getPublicKey: c, getSharedSecret: h, keygen: m, Point: e, utils: b, lengths: i });
}
function ur(e, t, r = {}) {
  Oe(t), ie(r, {}, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  }), r = Object.assign({}, r);
  const n = r.randomBytes || Kt, i = r.hmac || ((u, d) => ze(t, u, d)), { Fp: o, Fn: s } = e, { ORDER: f, BITS: c } = s, { keygen: a, getPublicKey: h, getSharedSecret: b, utils: m, lengths: y } = dr(e, r), E = {
    prehash: !0,
    lowS: typeof r.lowS == "boolean" ? r.lowS : !0,
    format: "compact",
    extraEntropy: !1
  }, O = f * Fe < o.ORDER;
  function A(u) {
    const d = f >> bt;
    return u > d;
  }
  function T(u, d) {
    if (!s.isValidNot0(d))
      throw new Error(`invalid signature ${u}: out of range 1..Point.Fn.ORDER`);
    return d;
  }
  function q() {
    if (O)
      throw new Error('"recovered" sig type is not supported for cofactor >2 curves');
  }
  function Z(u, d) {
    Gt(d);
    const g = y.signature, x = d === "compact" ? g : d === "recovered" ? g + 1 : void 0;
    return _(u, x);
  }
  class L {
    r;
    s;
    recovery;
    constructor(d, g, x) {
      if (this.r = T("r", d), this.s = T("s", g), x != null) {
        if (q(), ![0, 1, 2, 3].includes(x))
          throw new Error("invalid recovery id");
        this.recovery = x;
      }
      Object.freeze(this);
    }
    static fromBytes(d, g = E.format) {
      Z(d, g);
      let x;
      if (g === "der") {
        const { r: S, s: R } = rt.toSig(_(d));
        return new L(S, R);
      }
      g === "recovered" && (x = d[0], g = "compact", d = d.subarray(1));
      const B = y.signature / 2, v = d.subarray(0, B), p = d.subarray(B, B * 2);
      return new L(s.fromBytes(v), s.fromBytes(p), x);
    }
    static fromHex(d, g) {
      return this.fromBytes(Pt(d), g);
    }
    assertRecovery() {
      const { recovery: d } = this;
      if (d == null)
        throw new Error("invalid recovery id: must be present");
      return d;
    }
    addRecoveryBit(d) {
      return new L(this.r, this.s, d);
    }
    recoverPublicKey(d) {
      const { r: g, s: x } = this, B = this.assertRecovery(), v = B === 2 || B === 3 ? g + f : g;
      if (!o.isValid(v))
        throw new Error("invalid recovery id: sig.r+curve.n != R.x");
      const p = o.toBytes(v), S = e.fromBytes(W(Ge((B & 1) === 0), p)), R = s.inv(v), C = tt(_(d, void 0, "msgHash")), k = s.create(-C * R), I = s.create(x * R), H = e.BASE.multiplyUnsafe(k).add(S.multiplyUnsafe(I));
      if (H.is0())
        throw new Error("invalid recovery: point at infinify");
      return H.assertValidity(), H;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return A(this.s);
    }
    toBytes(d = E.format) {
      if (Gt(d), d === "der")
        return Pt(rt.hexFromSig(this));
      const { r: g, s: x } = this, B = s.toBytes(g), v = s.toBytes(x);
      return d === "recovered" ? (q(), W(Uint8Array.of(this.assertRecovery()), B, v)) : W(B, v);
    }
    toHex(d) {
      return Ht(this.toBytes(d));
    }
  }
  const j = r.bits2int || function(d) {
    if (d.length > 8192)
      throw new Error("input is too large");
    const g = xt(d), x = d.length * 8 - c;
    return x > 0 ? g >> BigInt(x) : g;
  }, tt = r.bits2int_modN || function(d) {
    return s.create(j(d));
  }, Ct = re(c);
  function gt(u) {
    return Mn("num < 2^" + c, u, J, Ct), s.toBytes(u);
  }
  function N(u, d) {
    return _(u, void 0, "message"), d ? _(t(u), void 0, "prehashed message") : u;
  }
  function vt(u, d, g) {
    const { lowS: x, prehash: B, extraEntropy: v } = jt(g, E);
    u = N(u, B);
    const p = tt(u), S = s.fromBytes(d);
    if (!s.isValidNot0(S))
      throw new Error("invalid private key");
    const R = [gt(S), gt(p)];
    if (v != null && v !== !1) {
      const H = v === !0 ? n(y.secretKey) : v;
      R.push(_(H, void 0, "extraEntropy"));
    }
    const C = W(...R), k = p;
    function I(H) {
      const $ = j(H);
      if (!s.isValidNot0($))
        return;
      const F = s.inv($), K = e.BASE.multiply($).toAffine(), V = s.create(K.x);
      if (V === J)
        return;
      const Bt = s.create(F * s.create(k + V * S));
      if (Bt === J)
        return;
      let ce = (K.x === V ? 0 : 2) | Number(K.y & bt), ae = Bt;
      return x && A(Bt) && (ae = s.neg(Bt), ce ^= 1), new L(V, ae, O ? void 0 : ce);
    }
    return { seed: C, k2sig: I };
  }
  function it(u, d, g = {}) {
    const { seed: x, k2sig: B } = vt(u, d, g);
    return Yn(t.outputLen, s.BYTES, i)(x, B).toBytes(g.format);
  }
  function U(u, d, g, x = {}) {
    const { lowS: B, prehash: v, format: p } = jt(x, E);
    if (g = _(g, void 0, "publicKey"), d = N(d, v), !te(u)) {
      const S = u instanceof L ? ", use sig.toBytes()" : "";
      throw new Error("verify expects Uint8Array signature" + S);
    }
    Z(u, p);
    try {
      const S = L.fromBytes(u, p), R = e.fromBytes(g);
      if (B && S.hasHighS())
        return !1;
      const { r: C, s: k } = S, I = tt(d), H = s.inv(k), $ = s.create(I * H), F = s.create(C * H), K = e.BASE.multiplyUnsafe($).add(R.multiplyUnsafe(F));
      return K.is0() ? !1 : s.create(K.x) === C;
    } catch {
      return !1;
    }
  }
  function l(u, d, g = {}) {
    const { prehash: x } = jt(g, E);
    return d = N(d, x), L.fromBytes(u, "recovered").recoverPublicKey(d).toBytes();
  }
  return Object.freeze({
    keygen: a,
    getPublicKey: h,
    getSharedSecret: b,
    utils: m,
    lengths: y,
    Point: e,
    sign: it,
    verify: U,
    recoverPublicKey: l,
    Signature: L,
    hash: t
  });
}
const Zt = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
}, lr = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
}, hr = /* @__PURE__ */ BigInt(0), Wt = /* @__PURE__ */ BigInt(2);
function br(e) {
  const t = Zt.p, r = BigInt(3), n = BigInt(6), i = BigInt(11), o = BigInt(22), s = BigInt(23), f = BigInt(44), c = BigInt(88), a = e * e * e % t, h = a * a * e % t, b = z(h, r, t) * h % t, m = z(b, r, t) * h % t, y = z(m, Wt, t) * a % t, E = z(y, i, t) * y % t, O = z(E, o, t) * E % t, A = z(O, f, t) * O % t, T = z(A, c, t) * A % t, q = z(T, f, t) * O % t, Z = z(q, r, t) * h % t, L = z(Z, s, t) * E % t, j = z(L, n, t) * a % t, tt = z(j, Wt, t);
  if (!_t.eql(_t.sqr(tt), e))
    throw new Error("Cannot find square root");
  return tt;
}
const _t = qt(Zt.p, { sqrt: br }), ut = /* @__PURE__ */ ar(Zt, {
  Fp: _t,
  endo: lr
}), ft = /* @__PURE__ */ ur(ut, Et), Ee = {};
function kt(e, ...t) {
  let r = Ee[e];
  if (r === void 0) {
    const n = Et(Vn(e));
    r = W(n, n), Ee[e] = r;
  }
  return Et(W(r, ...t));
}
const se = (e) => e.toBytes(!0).slice(1), fe = (e) => e % Wt === hr;
function Qt(e) {
  const { Fn: t, BASE: r } = ut, n = t.fromBytes(e), i = r.multiply(n);
  return { scalar: fe(i.y) ? n : t.neg(n), bytes: se(i) };
}
function Qe(e) {
  const t = _t;
  if (!t.isValidNot0(e))
    throw new Error("invalid x: Fail if x ‚â• p");
  const r = t.create(e * e), n = t.create(r * e + BigInt(7));
  let i = t.sqrt(n);
  fe(i) || (i = t.neg(i));
  const o = ut.fromAffine({ x: e, y: i });
  return o.assertValidity(), o;
}
const mt = xt;
function Je(...e) {
  return ut.Fn.create(mt(kt("BIP0340/challenge", ...e)));
}
function xe(e) {
  return Qt(e).bytes;
}
function yr(e, t, r = Kt(32)) {
  const { Fn: n } = ut, i = _(e, void 0, "message"), { bytes: o, scalar: s } = Qt(t), f = _(r, 32, "auxRand"), c = n.toBytes(s ^ mt(kt("BIP0340/aux", f))), a = kt("BIP0340/nonce", c, o, i), { bytes: h, scalar: b } = Qt(a), m = Je(h, o, i), y = new Uint8Array(64);
  if (y.set(h, 0), y.set(n.toBytes(n.create(b + m * s)), 32), !tn(y, i, o))
    throw new Error("sign: Invalid signature produced");
  return y;
}
function tn(e, t, r) {
  const { Fp: n, Fn: i, BASE: o } = ut, s = _(e, 64, "signature"), f = _(t, void 0, "message"), c = _(r, 32, "publicKey");
  try {
    const a = Qe(mt(c)), h = mt(s.subarray(0, 32));
    if (!n.isValidNot0(h))
      return !1;
    const b = mt(s.subarray(32, 64));
    if (!i.isValidNot0(b))
      return !1;
    const m = Je(i.toBytes(h), se(a), f), y = o.multiplyUnsafe(b).add(a.multiplyUnsafe(i.neg(m))), { x: E, y: O } = y.toAffine();
    return !(y.is0() || !fe(O) || E !== h);
  } catch {
    return !1;
  }
}
const pt = /* @__PURE__ */ (() => {
  const r = (n = Kt(48)) => De(n, Zt.n);
  return {
    keygen: Ye(r, xe),
    getPublicKey: xe,
    sign: yr,
    verify: tn,
    Point: ut,
    utils: {
      randomSecretKey: r,
      taggedHash: kt,
      lift_x: Qe,
      pointToBytes: se
    },
    lengths: {
      secretKey: 32,
      publicKey: 32,
      publicKeyHasPrefix: !1,
      signature: 64,
      seed: 48
    }
  };
})(), ht = ft.Point, Ot = ht.Fn.ORDER;
function ve(e) {
  const t = e.toString(16).padStart(64, "0"), r = new Uint8Array(32);
  for (let n = 0; n < 32; n++)
    r[n] = parseInt(t.slice(n * 2, n * 2 + 2), 16);
  return r;
}
function ot(e) {
  let t = 0n;
  for (let r = 0; r < e.length; r++)
    t = t << 8n | BigInt(e[r]);
  return t;
}
class gr {
  /** @inheritDoc */
  isPrivate(t) {
    return ft.utils.isValidSecretKey(t);
  }
  /** @inheritDoc */
  isPoint(t) {
    try {
      return ht.fromHex(wt(t)), !0;
    } catch {
      return !1;
    }
  }
  /** @inheritDoc */
  isXOnlyPoint(t) {
    if (t.length !== 32) return !1;
    try {
      return pt.utils.lift_x(ot(t)), !0;
    } catch {
      return !1;
    }
  }
  /** @inheritDoc */
  pointFromScalar(t, r) {
    try {
      return ft.getPublicKey(t, r ?? !0);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  pointCompress(t, r) {
    return ht.fromHex(wt(t)).toBytes(r ?? !0);
  }
  /** @inheritDoc */
  pointAddScalar(t, r, n) {
    try {
      const i = ht.fromHex(wt(t));
      if (ot(r) === 0n)
        return i.toBytes(n ?? !0);
      const s = ft.getPublicKey(r, !0), f = ht.fromHex(wt(s));
      return i.add(f).toBytes(n ?? !0);
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t, r) {
    try {
      const n = pt.utils.lift_x(ot(t));
      if (ot(r) >= Ot) return null;
      const o = ft.getPublicKey(r, !0), s = ht.fromHex(wt(o)), f = n.add(s), c = pt.utils.pointToBytes(f);
      return {
        parity: Number(f.y & 1n),
        xOnlyPubkey: c
      };
    } catch {
      return null;
    }
  }
  /** @inheritDoc */
  privateAdd(t, r) {
    const n = ot(t), i = ot(r), o = Y(n + i, Ot);
    return o === 0n ? null : ve(o);
  }
  /** @inheritDoc */
  privateNegate(t) {
    const r = ot(t), n = Y(Ot - r, Ot);
    return ve(n);
  }
  /** @inheritDoc */
  sign(t, r, n) {
    return ft.sign(t, r, {
      prehash: !1,
      lowS: !0,
      extraEntropy: n ?? !1
    });
  }
  /** @inheritDoc */
  verify(t, r, n) {
    return ft.verify(n, t, r, {
      prehash: !1,
      lowS: !0
    });
  }
  /** @inheritDoc */
  signSchnorr(t, r, n) {
    return pt.sign(t, r, n);
  }
  /** @inheritDoc */
  verifySchnorr(t, r, n) {
    return pt.verify(n, t, r);
  }
}
function Nr() {
  return new gr();
}
class wr {
  #t;
  /**
   * @param ecc - Object implementing the {@link TinySecp256k1Interface}.
   */
  constructor(t) {
    this.#t = t;
  }
  /** `true` when the underlying library supports Schnorr signing. */
  get hasSchnorrSign() {
    return typeof this.#t.signSchnorr == "function";
  }
  /** `true` when the underlying library supports Schnorr verification. */
  get hasSchnorrVerify() {
    return typeof this.#t.verifySchnorr == "function";
  }
  /** @inheritDoc */
  isPrivate(t) {
    return this.#t.isPrivate(t);
  }
  /** @inheritDoc */
  isPoint(t) {
    return this.#t.isPoint(t);
  }
  /** @inheritDoc */
  isXOnlyPoint(t) {
    if (t.length !== 32) return !1;
    const r = new Uint8Array(33);
    return r[0] = 2, r.set(t, 1), this.#t.isPoint(r);
  }
  /** @inheritDoc */
  pointFromScalar(t, r) {
    return this.#t.pointFromScalar(t, r);
  }
  /** @inheritDoc */
  pointCompress(t, r) {
    return this.#t.pointCompress(t, r);
  }
  /** @inheritDoc */
  pointAddScalar(t, r, n) {
    return this.#t.pointAddScalar(t, r, n);
  }
  /** @inheritDoc */
  xOnlyPointAddTweak(t, r) {
    const n = this.#t.xOnlyPointAddTweak(t, r);
    return n === null ? null : {
      parity: n.parity,
      xOnlyPubkey: n.xOnlyPubkey
    };
  }
  /** @inheritDoc */
  privateAdd(t, r) {
    return this.#t.privateAdd(t, r);
  }
  /** @inheritDoc */
  privateNegate(t) {
    return this.#t.privateNegate(t);
  }
  /** @inheritDoc */
  sign(t, r, n) {
    return this.#t.sign(t, r, n);
  }
  /** @inheritDoc */
  verify(t, r, n) {
    return this.#t.verify(t, r, n);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `signSchnorr`.
   */
  signSchnorr(t, r, n) {
    if (!this.#t.signSchnorr)
      throw new Error("signSchnorr not supported by ecc library");
    return this.#t.signSchnorr(t, r, n);
  }
  /**
   * @inheritDoc
   * @throws If the underlying `tiny-secp256k1` library lacks `verifySchnorr`.
   */
  verifySchnorr(t, r, n) {
    if (!this.#t.verifySchnorr)
      throw new Error("verifySchnorr not supported by ecc library");
    return this.#t.verifySchnorr(t, r, n);
  }
}
function Tr(e) {
  return new wr(e);
}
function w(e) {
  return en(e);
}
function P(e, t) {
  if (!e) throw new Error(`verifyCryptoBackend: ${t}`);
}
function _r(e) {
  P(
    e.isPoint(w("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPoint should accept generator point"
  ), P(
    !e.isPoint(w("030000000000000000000000000000000000000000000000000000000000000005")),
    "isPoint should reject invalid point"
  ), P(
    e.isXOnlyPoint(
      w("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "isXOnlyPoint should accept generator x-coordinate"
  ), P(
    !e.isXOnlyPoint(
      w("0000000000000000000000000000000000000000000000000000000000000005")
    ),
    "isXOnlyPoint should reject x-coordinate not on curve"
  ), P(
    !e.isXOnlyPoint(
      w("0000000000000000000000000000000000000000000000000000000000000000")
    ),
    "isXOnlyPoint should reject zero"
  ), P(
    !e.isXOnlyPoint(w("79be667ef9dcbbac55a06295ce870b07")),
    "isXOnlyPoint should reject wrong length"
  ), P(
    e.isPrivate(w("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")),
    "isPrivate should accept valid scalar"
  ), P(
    e.isPrivate(w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")),
    "isPrivate should accept n-1"
  ), P(
    !e.isPrivate(w("0000000000000000000000000000000000000000000000000000000000000000")),
    "isPrivate should reject zero"
  ), P(
    !e.isPrivate(w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")),
    "isPrivate should reject n"
  ), P(
    !e.isPrivate(w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")),
    "isPrivate should reject n+1"
  );
  const t = e.privateAdd(
    w("0000000000000000000000000000000000000000000000000000000000000001"),
    w("0000000000000000000000000000000000000000000000000000000000000000")
  );
  P(
    t !== null && M(
      t,
      w("0000000000000000000000000000000000000000000000000000000000000001")
    ),
    "privateAdd: 1 + 0 should equal 1"
  ), P(
    e.privateAdd(
      w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      w("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null,
    "privateAdd: (n-3) + 3 should return null (result is zero mod n)"
  );
  const r = e.privateAdd(
    w("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
    w("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
  );
  P(
    r !== null && M(
      r,
      w("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    ),
    "privateAdd: known vector failed"
  ), P(
    M(
      e.privateNegate(
        w("0000000000000000000000000000000000000000000000000000000000000001")
      ),
      w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ),
    "privateNegate(1) should equal n-1"
  ), P(
    M(
      e.privateNegate(
        w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      ),
      w("0000000000000000000000000000000000000000000000000000000000000003")
    ),
    "privateNegate(n-3) should equal 3"
  ), P(
    M(
      e.privateNegate(
        w("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      ),
      w("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    ),
    "privateNegate known vector failed"
  ), P(
    M(
      e.pointCompress(
        w(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !0
      ),
      w("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress uncompressed->compressed failed"
  ), P(
    M(
      e.pointCompress(
        w(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !1
      ),
      w(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress uncompressed->uncompressed failed"
  ), P(
    M(
      e.pointCompress(
        w(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        !0
      ),
      w("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    ),
    "pointCompress compressed->compressed failed"
  ), P(
    M(
      e.pointCompress(
        w(
          "0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"
        ),
        !1
      ),
      w(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    ),
    "pointCompress compressed->uncompressed failed"
  );
  const n = e.pointFromScalar(
    w("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
  );
  P(
    n !== null && M(
      n,
      w("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    ),
    "pointFromScalar known vector failed"
  ), P(
    e.xOnlyPointAddTweak(
      w("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null,
    "xOnlyPointAddTweak should return null for infinity result"
  );
  let i = e.xOnlyPointAddTweak(
    w("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    w("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  P(
    i !== null && M(
      i.xOnlyPubkey,
      w("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && i.parity === 1,
    "xOnlyPointAddTweak parity=1 case failed"
  ), i = e.xOnlyPointAddTweak(
    w("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    w("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), P(
    i !== null && M(
      i.xOnlyPubkey,
      w("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && i.parity === 0,
    "xOnlyPointAddTweak parity=0 case failed"
  );
  const o = e.sign(
    w("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
    w("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
  );
  if (P(
    M(
      o,
      w(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    ),
    "sign known vector failed"
  ), P(
    e.verify(
      w("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      w("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      o
    ),
    "verify known vector failed"
  ), e.signSchnorr) {
    const s = e.signSchnorr(
      w("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      w("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
      w("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
    );
    P(
      M(
        s,
        w(
          "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
        )
      ),
      "signSchnorr known vector failed"
    );
  }
  e.verifySchnorr && P(
    e.verifySchnorr(
      w(
        "7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"
      ),
      w(
        "dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"
      ),
      w(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    ),
    "verifySchnorr known vector failed"
  );
}
export {
  st as ECPairSigner,
  Jt as EC_N,
  mr as EC_P,
  wr as LegacyBackend,
  gr as NobleBackend,
  Be as SATOSHI_MAX,
  lt as SignerCapability,
  Ae as assertBytes32,
  un as assertMessageHash,
  cn as assertPrivateKey,
  an as assertPublicKey,
  dn as assertXOnlyPublicKey,
  M as bytesEqual,
  pr as compareBytes,
  nn as concatBytes,
  Or as createBytes20,
  Ar as createBytes32,
  Tr as createLegacyBackend,
  Ur as createMessageHash,
  Nr as createNobleBackend,
  zt as createPrivateKey,
  ln as createPublicKey,
  Pr as createSatoshi,
  Ir as createSchnorrSignature,
  Rr as createSignature,
  hn as createXOnlyPublicKey,
  Hn as decodeWIF,
  Ln as encodeWIF,
  en as fromHexInternal,
  xr as isBytes20,
  Er as isBytes32,
  Sr as isMessageHash,
  vr as isPrivateKey,
  rn as isPublicKey,
  fn as isSatoshi,
  sn as isSchnorrSignature,
  on as isSignature,
  Br as isXOnlyPublicKey,
  Lt as isZeroBytes,
  wt as toHex,
  _r as verifyCryptoBackend
};
