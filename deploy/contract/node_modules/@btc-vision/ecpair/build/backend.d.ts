import type { Bytes32, MessageHash, PrivateKey, PublicKey, SchnorrSignature, Signature, XOnlyPublicKey } from './branded.js';
/**
 * Y-coordinate parity of a point on the secp256k1 curve.
 *
 * - `0` = even Y
 * - `1` = odd Y
 */
export type Parity = 0 | 1;
/**
 * Result returned by {@link CryptoBackend.xOnlyPointAddTweak} on success.
 */
export interface XOnlyPointAddTweakResult {
    /** Parity of the resulting point's Y coordinate. */
    readonly parity: Parity;
    /** 32-byte x-only public key of the tweaked point. */
    readonly xOnlyPubkey: XOnlyPublicKey;
}
/**
 * Low-level secp256k1 operations required by the signer layer.
 *
 * Two concrete implementations ship with this package:
 *
 * - {@link NobleBackend} (pure JS, `@noble/curves`)
 * - {@link LegacyBackend} (wraps `tiny-secp256k1`)
 *
 * Third-party implementations must satisfy every non-optional method.
 */
export interface CryptoBackend {
    /**
     * Returns `true` if `d` is a valid secp256k1 private key (32 bytes, in range `[1, n)`).
     * @param d - Raw bytes to test.
     */
    isPrivate(d: Uint8Array): boolean;
    /**
     * Returns `true` if `p` is a valid SEC1-encoded secp256k1 point.
     * @param p - Compressed (33 bytes) or uncompressed (65 bytes) SEC1 encoding.
     */
    isPoint(p: Uint8Array): boolean;
    /**
     * Returns `true` if `p` is a valid 32-byte x-only public key whose
     * x-coordinate lies on the secp256k1 curve.
     * @param p - 32-byte x-only encoding.
     */
    isXOnlyPoint(p: Uint8Array): boolean;
    /**
     * Derives the public key for a private key scalar.
     * @param d - Private key scalar.
     * @param compressed - Return compressed (33 bytes) when `true` (default), uncompressed (65 bytes) when `false`.
     * @returns The public key, or `null` if `d` is invalid.
     */
    pointFromScalar(d: PrivateKey, compressed?: boolean): PublicKey | null;
    /**
     * Re-encodes a public key in the requested SEC1 form.
     * @param p - Input public key in any SEC1 form.
     * @param compressed - Target form. Defaults to compressed.
     */
    pointCompress(p: PublicKey, compressed?: boolean): PublicKey;
    /**
     * Adds a scalar tweak to a public key point (`P + tweak·G`).
     * @param p - Base public key.
     * @param tweak - 32-byte scalar to add.
     * @param compressed - Encoding of the returned point.
     * @returns The resulting point, or `null` if the result is the point at infinity.
     */
    pointAddScalar(p: PublicKey, tweak: Bytes32, compressed?: boolean): PublicKey | null;
    /**
     * Adds a scalar tweak to an x-only public key, returning the resulting
     * x-only key together with its Y-coordinate parity.
     * @param p - 32-byte x-only public key.
     * @param tweak - 32-byte scalar.
     * @returns Tweak result, or `null` on failure (infinity or invalid tweak).
     */
    xOnlyPointAddTweak(p: XOnlyPublicKey, tweak: Bytes32): XOnlyPointAddTweakResult | null;
    /**
     * Adds two private key scalars modulo the curve order (`(d + tweak) mod n`).
     * @param d - First scalar (private key).
     * @param tweak - Second scalar.
     * @returns The sum, or `null` if the result is zero mod `n`.
     */
    privateAdd(d: PrivateKey, tweak: Bytes32): PrivateKey | null;
    /**
     * Negates a private key scalar modulo the curve order (`n - d`).
     * @param d - Scalar to negate.
     */
    privateNegate(d: PrivateKey): PrivateKey;
    /**
     * Produces a compact (64-byte) ECDSA signature.
     * @param hash - 32-byte message hash.
     * @param privateKey - Signing key.
     * @param extraEntropy - Optional additional randomness for RFC 6979.
     */
    sign(hash: MessageHash, privateKey: PrivateKey, extraEntropy?: Uint8Array): Signature;
    /**
     * Verifies a compact ECDSA signature.
     * @param hash - 32-byte message hash.
     * @param publicKey - Signer's public key.
     * @param signature - 64-byte compact signature.
     */
    verify(hash: MessageHash, publicKey: PublicKey, signature: Signature): boolean;
    /**
     * Produces a 64-byte BIP-340 Schnorr signature.
     *
     * Optional — backends that omit this method will cause
     * {@link ECPairSigner.signSchnorr} to throw at runtime.
     * @param hash - 32-byte message hash.
     * @param privateKey - Signing key.
     * @param extraEntropy - Optional auxiliary randomness.
     */
    signSchnorr?(hash: MessageHash, privateKey: PrivateKey, extraEntropy?: Uint8Array): SchnorrSignature;
    /**
     * Verifies a 64-byte BIP-340 Schnorr signature.
     *
     * Optional — backends that omit this method will cause
     * {@link ECPairSigner.verifySchnorr} to throw at runtime.
     * @param hash - 32-byte message hash.
     * @param publicKey - 32-byte x-only public key.
     * @param signature - 64-byte Schnorr signature.
     */
    verifySchnorr?(hash: MessageHash, publicKey: XOnlyPublicKey, signature: SchnorrSignature): boolean;
}
//# sourceMappingURL=backend.d.ts.map