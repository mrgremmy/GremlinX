import { SimpleParser, TransformVisitor } from "../index.js";
import { IdentifierExpression, } from "@btc-vision/assemblyscript/dist/assemblyscript.js";
import { isStdlib, not } from "../utils.js";
import * as path from "path";
import * as fs from "fs";
class IncludeBytesTransform extends TransformVisitor {
    visitCallExpression(node) {
        if (node.expression instanceof IdentifierExpression) {
            if (node.expression.text == "includeBytes") {
                if (!node.args[0].isLiteralKind(2 /* LiteralKind.String */))
                    throw "[Error] includeBytes requires a constant literal filename";
                let arg0 = node.args[0];
                let filename = path.join(path.dirname(node.range.source.normalizedPath), arg0.value);
                var data;
                try {
                    data = fs.readFileSync(filename);
                }
                catch (e) {
                    throw `[Error] includeBytes '${filename}', ${e}`;
                }
                let asJSONString = JSON.stringify(data); // use stringify to convert bytes to text
                let arrayStart = asJSONString.indexOf("["); //find the u8 array inside the JSON string
                let arrayEnd = asJSONString.lastIndexOf("]");
                let newCode = "StaticArray.fromArray<u8>(" +
                    asJSONString.substring(arrayStart, arrayEnd + 1) +
                    ")";
                let res = SimpleParser.parseExpression(newCode); //parse StaticArray.fromArray expression
                res.range = node.range; //same range
                return res; //replace node
            }
        }
        return super.visitCallExpression(node);
    }
    afterParse(_) {
        let sources = _.sources.filter(not(isStdlib));
        this.visit(sources);
    }
}
export default IncludeBytesTransform;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5jbHVkZUJ5dGVzVHJhbnNmb3JtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2V4YW1wbGVzL2luY2x1ZGVCeXRlc1RyYW5zZm9ybS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzdELE9BQU8sRUFHSCxvQkFBb0IsR0FJdkIsTUFBTSxtREFBbUQsQ0FBQztBQUMzRCxPQUFPLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM1QyxPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEtBQUssRUFBRSxNQUFNLElBQUksQ0FBQztBQUV6QixNQUFNLHFCQUFzQixTQUFRLGdCQUFnQjtJQUNoRCxtQkFBbUIsQ0FBQyxJQUFvQjtRQUNwQyxJQUFJLElBQUksQ0FBQyxVQUFVLFlBQVksb0JBQW9CLEVBQUUsQ0FBQztZQUNsRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLGNBQWMsRUFBRSxDQUFDO2dCQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLDRCQUFvQjtvQkFDL0MsTUFBTSwyREFBMkQsQ0FBQztnQkFDdEUsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQTRCLENBQUM7Z0JBQ25ELElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQ3BCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQzlDLElBQUksQ0FBQyxLQUFLLENBQ2IsQ0FBQztnQkFDRixJQUFJLElBQUksQ0FBQztnQkFDVCxJQUFJLENBQUM7b0JBQ0QsSUFBSSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3JDLENBQUM7Z0JBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztvQkFDVCxNQUFNLHlCQUF5QixRQUFRLE1BQU0sQ0FBQyxFQUFFLENBQUM7Z0JBQ3JELENBQUM7Z0JBQ0QsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLHlDQUF5QztnQkFDbEYsSUFBSSxVQUFVLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLDBDQUEwQztnQkFDdEYsSUFBSSxRQUFRLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDN0MsSUFBSSxPQUFPLEdBQ1AsNEJBQTRCO29CQUM1QixZQUFZLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxRQUFRLEdBQUcsQ0FBQyxDQUFDO29CQUNoRCxHQUFHLENBQUM7Z0JBQ1IsSUFBSSxHQUFHLEdBQUcsWUFBWSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLHdDQUF3QztnQkFDekYsR0FBRyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWTtnQkFDcEMsT0FBTyxHQUFHLENBQUMsQ0FBQyxjQUFjO1lBQzlCLENBQUM7UUFDTCxDQUFDO1FBQ0QsT0FBTyxLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELFVBQVUsQ0FBQyxDQUFTO1FBQ2hCLElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDeEIsQ0FBQztDQUNKO0FBRUQsZUFBZSxxQkFBcUIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNpbXBsZVBhcnNlciwgVHJhbnNmb3JtVmlzaXRvciB9IGZyb20gXCIuLi9pbmRleC5qc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgQ2FsbEV4cHJlc3Npb24sXHJcbiAgICBFeHByZXNzaW9uLFxyXG4gICAgSWRlbnRpZmllckV4cHJlc3Npb24sXHJcbiAgICBMaXRlcmFsS2luZCxcclxuICAgIFBhcnNlcixcclxuICAgIFN0cmluZ0xpdGVyYWxFeHByZXNzaW9uLFxyXG59IGZyb20gXCJAYnRjLXZpc2lvbi9hc3NlbWJseXNjcmlwdC9kaXN0L2Fzc2VtYmx5c2NyaXB0LmpzXCI7XHJcbmltcG9ydCB7IGlzU3RkbGliLCBub3QgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcclxuXHJcbmNsYXNzIEluY2x1ZGVCeXRlc1RyYW5zZm9ybSBleHRlbmRzIFRyYW5zZm9ybVZpc2l0b3Ige1xyXG4gICAgdmlzaXRDYWxsRXhwcmVzc2lvbihub2RlOiBDYWxsRXhwcmVzc2lvbik6IEV4cHJlc3Npb24ge1xyXG4gICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBJZGVudGlmaWVyRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5leHByZXNzaW9uLnRleHQgPT0gXCJpbmNsdWRlQnl0ZXNcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmFyZ3NbMF0uaXNMaXRlcmFsS2luZChMaXRlcmFsS2luZC5TdHJpbmcpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiW0Vycm9yXSBpbmNsdWRlQnl0ZXMgcmVxdWlyZXMgYSBjb25zdGFudCBsaXRlcmFsIGZpbGVuYW1lXCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXJnMCA9IG5vZGUuYXJnc1swXSBhcyBTdHJpbmdMaXRlcmFsRXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlbmFtZSA9IHBhdGguam9pbihcclxuICAgICAgICAgICAgICAgICAgICBwYXRoLmRpcm5hbWUobm9kZS5yYW5nZS5zb3VyY2Uubm9ybWFsaXplZFBhdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZzAudmFsdWVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYFtFcnJvcl0gaW5jbHVkZUJ5dGVzICcke2ZpbGVuYW1lfScsICR7ZX1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGFzSlNPTlN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpOyAvLyB1c2Ugc3RyaW5naWZ5IHRvIGNvbnZlcnQgYnl0ZXMgdG8gdGV4dFxyXG4gICAgICAgICAgICAgICAgbGV0IGFycmF5U3RhcnQgPSBhc0pTT05TdHJpbmcuaW5kZXhPZihcIltcIik7IC8vZmluZCB0aGUgdTggYXJyYXkgaW5zaWRlIHRoZSBKU09OIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgbGV0IGFycmF5RW5kID0gYXNKU09OU3RyaW5nLmxhc3RJbmRleE9mKFwiXVwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdDb2RlID1cclxuICAgICAgICAgICAgICAgICAgICBcIlN0YXRpY0FycmF5LmZyb21BcnJheTx1OD4oXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIGFzSlNPTlN0cmluZy5zdWJzdHJpbmcoYXJyYXlTdGFydCwgYXJyYXlFbmQgKyAxKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gU2ltcGxlUGFyc2VyLnBhcnNlRXhwcmVzc2lvbihuZXdDb2RlKTsgLy9wYXJzZSBTdGF0aWNBcnJheS5mcm9tQXJyYXkgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgcmVzLnJhbmdlID0gbm9kZS5yYW5nZTsgLy9zYW1lIHJhbmdlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzOyAvL3JlcGxhY2Ugbm9kZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBlci52aXNpdENhbGxFeHByZXNzaW9uKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGFmdGVyUGFyc2UoXzogUGFyc2VyKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHNvdXJjZXMgPSBfLnNvdXJjZXMuZmlsdGVyKG5vdChpc1N0ZGxpYikpO1xyXG4gICAgICAgIHRoaXMudmlzaXQoc291cmNlcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEluY2x1ZGVCeXRlc1RyYW5zZm9ybTtcclxuIl19