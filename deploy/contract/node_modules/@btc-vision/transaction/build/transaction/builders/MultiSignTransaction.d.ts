import { type P2TRPayment, Psbt, type PsbtInput, type PublicKey, type Script, type Signer, type TapScriptSig, type Taptree } from '@btc-vision/bitcoin';
import { TransactionBuilder } from './TransactionBuilder.js';
import type { TapPayment } from '../shared/TweakedTransaction.js';
import { TransactionType } from '../enums/TransactionType.js';
import type { ITransactionParameters } from '../interfaces/ITransactionParameters.js';
import { type UniversalSigner } from '@btc-vision/ecpair';
export interface MultiSignParameters extends Omit<ITransactionParameters, 'gasSatFee' | 'priorityFee' | 'signer' | 'from' | 'to'> {
    readonly pubkeys: Uint8Array[];
    readonly minimumSignatures: number;
    readonly from?: string | undefined;
    readonly to?: string | undefined;
    readonly psbt?: Psbt;
    readonly receiver: string;
    readonly requestedAmount: bigint;
    readonly refundVault: string;
}
export interface MultiSignFromBase64Params extends Omit<MultiSignParameters, 'psbt'> {
    readonly psbt: string;
}
/**
 * Create a multi sign p2tr transaction
 * @class MultiSignTransaction
 */
export declare class MultiSignTransaction extends TransactionBuilder<TransactionType.MULTI_SIG> {
    static readonly LOCK_LEAF_SCRIPT: Script;
    static readonly signHashTypesArray: number[];
    static readonly numsPoint: PublicKey;
    type: TransactionType.MULTI_SIG;
    protected targetScriptRedeem: P2TRPayment | null;
    protected leftOverFundsScriptRedeem: P2TRPayment | null;
    protected readonly compiledTargetScript: Uint8Array;
    protected readonly scriptTree: Taptree;
    protected readonly publicKeys: Uint8Array[];
    protected readonly minimumSignatures: number;
    protected readonly originalInputCount: number;
    protected readonly requestedAmount: bigint;
    protected readonly receiver: string;
    protected readonly refundVault: string;
    /**
     * @description Sign hash types
     * @protected
     */
    protected readonly sighashTypes: number[];
    constructor(parameters: MultiSignParameters);
    /**
     * Generate a multisig transaction from a base64 psbt.
     * @param {MultiSignFromBase64Params} params The parameters
     * @returns {MultiSignTransaction} The multisig transaction
     */
    static fromBase64(params: MultiSignFromBase64Params): MultiSignTransaction;
    /**
     * Verify if that public key already signed the transaction
     * @param {Psbt} psbt The psbt
     * @param {Uint8Array} signerPubKey The signer public key
     * @returns {boolean} True if the public key signed the transaction
     */
    static verifyIfSigned(psbt: Psbt, signerPubKey: Uint8Array): boolean;
    /**
     * Partially sign the transaction
     * @returns {boolean} True if the transaction was signed
     * @public
     */
    static signPartial(psbt: Psbt, signer: Signer | UniversalSigner, originalInputCount: number, minimums: number[]): {
        final: boolean;
        signed: boolean;
    };
    /**
     * Partially finalize a P2TR MS transaction
     * @param {number} inputIndex The input index
     * @param {PsbtInput} input The input
     * @param {Uint8Array[]} partialSignatures The partial signatures
     * @param {Uint8Array[]} orderedPubKeys The ordered public keys
     * @param {boolean} isFinal If the transaction is final
     */
    static partialFinalizer: (inputIndex: number, input: PsbtInput, partialSignatures: Uint8Array[], orderedPubKeys: Uint8Array[], isFinal: boolean) => {
        finalScriptWitness: Uint8Array<ArrayBufferLike>;
    };
    /**
     * Dedupe signatures
     * @param {TapScriptSig[]} original The original signatures
     * @param {TapScriptSig[]} partial The partial signatures
     * @returns {TapScriptSig[]} The deduped signatures
     */
    static dedupeSignatures(original: TapScriptSig[], partial: TapScriptSig[]): TapScriptSig[];
    /**
     * Attempt to finalize the inputs
     * @param {Psbt} psbt The psbt
     * @param {number} startIndex The start index
     * @param {Uint8Array[]} orderedPubKeys The ordered public keys
     * @param {boolean} isFinal If the transaction is final
     * @returns {boolean} True if the inputs were finalized
     */
    static attemptFinalizeInputs(psbt: Psbt, startIndex: number, orderedPubKeys: Uint8Array[][], isFinal: boolean): boolean;
    /**
     * Finalize the psbt multisig transaction
     */
    finalizeTransactionInputs(): boolean;
    /**
     * @description Signs the transaction
     * @public
     * @returns {Promise<Psbt>} - The signed transaction in hex format
     * @throws {Error} - If something went wrong
     */
    signPSBT(): Promise<Psbt>;
    /**
     * Build the transaction
     * @protected
     *
     * @throws {Error} If the left over funds script redeem is required
     * @throws {Error} If the left over funds script redeem version is required
     * @throws {Error} If the left over funds script redeem output is required
     */
    protected buildTransaction(): Promise<void>;
    /**
     * Builds the transaction.
     * @param {Psbt} transaction - The transaction to build
     * @param checkPartialSigs
     * @protected
     * @returns {Promise<boolean>}
     * @throws {Error} - If something went wrong while building the transaction
     */
    protected internalBuildTransaction(transaction: Psbt, checkPartialSigs?: boolean): Promise<boolean>;
    /**
     * Sign the inputs
     * @protected
     */
    protected signInputs(_transaction: Psbt): Promise<void>;
    protected generateScriptAddress(): TapPayment;
    protected generateTapData(): TapPayment;
    /**
     * Generate the script solution
     * @param {PsbtInput} input The input
     * @protected
     *
     * @returns {Uint8Array[]} The script solution
     */
    protected getScriptSolution(input: PsbtInput): Uint8Array[];
    /**
     * Get the script tree
     * @private
     *
     * @returns {Taptree} The script tree
     */
    protected getScriptTree(): Taptree;
    private getTotalOutputAmount;
    /**
     * @description Calculate the amount left to refund to the first vault.
     * @private
     * @returns {bigint} The amount left
     */
    private calculateOutputLeftAmountFromVaults;
    /**
     * Transaction finalizer
     * @param {number} _inputIndex The input index
     * @param {PsbtInput} input The input
     */
    private customFinalizer;
    /**
     * Generate the redeem scripts
     * @private
     *
     * @throws {Error} If the public keys are required
     * @throws {Error} If the leaf script is required
     * @throws {Error} If the leaf script version is required
     * @throws {Error} If the leaf script output is required
     * @throws {Error} If the target script redeem is required
     */
    private generateRedeemScripts;
}
//# sourceMappingURL=MultiSignTransaction.d.ts.map