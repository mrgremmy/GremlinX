import bitcoin, { fromHex, networks, opcodes, script, payments, } from '@btc-vision/bitcoin';
export class TimeLockGenerator {
    static UNSPENDABLE_INTERNAL_KEY = fromHex('50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0');
    static CSV_BLOCKS = 75;
    /**
     * Generate a P2WSH address with CSV timelock
     * Note: This uses ECDSA, not Schnorr (Schnorr only available in Taproot)
     */
    static generateTimeLockAddress(publicKey, network = networks.bitcoin, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const p2wsh = bitcoin.payments.p2wsh({
            redeem: { output: witnessScript },
            network,
        });
        if (!p2wsh.address) {
            throw new Error('Failed to generate P2WSH address');
        }
        return {
            address: p2wsh.address,
            witnessScript: witnessScript,
        };
    }
    /**
     * Generate a P2TR address with CSV time lock
     * Note: This uses Schnorr signatures
     */
    static generateTimeLockAddressP2TR(publicKey, network = networks.bitcoin, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        if (publicKey.length !== 32) {
            throw new Error('Public key must be 32 bytes for Taproot');
        }
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const taproot = bitcoin.payments.p2tr({
            redeem: { output: witnessScript },
            network,
            internalPubkey: TimeLockGenerator.UNSPENDABLE_INTERNAL_KEY,
        });
        if (!taproot.address) {
            throw new Error('Failed to generate P2TR address');
        }
        return taproot.address;
    }
    /**
     * Generate a P2MR address with CSV time lock
     * Note: This uses Schnorr signatures within a P2MR (BIP 360) script tree
     */
    static generateTimeLockAddressP2MR(publicKey, network = networks.bitcoin, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        if (publicKey.length !== 32) {
            throw new Error('Public key must be 32 bytes for P2MR');
        }
        const witnessScript = this.generateTimeLockScript(publicKey, csvBlocks);
        const scriptTree = { output: witnessScript, version: 192 };
        const p2mr = payments.p2mr({ scriptTree, network });
        if (!p2mr.address) {
            throw new Error('Failed to generate P2MR address');
        }
        return p2mr.address;
    }
    static generateTimeLockScript(publicKey, csvBlocks = TimeLockGenerator.CSV_BLOCKS) {
        return script.compile([
            script.number.encode(csvBlocks),
            opcodes.OP_CHECKSEQUENCEVERIFY,
            opcodes.OP_DROP,
            publicKey,
            opcodes.OP_CHECKSIG,
        ]);
    }
}
//# sourceMappingURL=TimelockGenerator.js.map