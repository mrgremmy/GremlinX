import type { IChallengeSolution, IChallengeSubmission, IChallengeVerification, RawChallenge, RawChallengeSubmission, RawChallengeVerification } from './interfaces/IChallengeSolution.js';
import { Address } from '../keypair/Address.js';
export declare class ChallengeVerification implements IChallengeVerification {
    readonly epochHash: Uint8Array;
    readonly epochRoot: Uint8Array;
    readonly targetHash: Uint8Array;
    readonly targetChecksum: Uint8Array;
    readonly startBlock: bigint;
    readonly endBlock: bigint;
    readonly proofs: readonly Uint8Array[];
    constructor(data: RawChallengeVerification);
}
export declare class ChallengeSubmission implements IChallengeSubmission {
    readonly epochNumber: bigint;
    readonly publicKey: Address;
    readonly solution: Uint8Array;
    readonly graffiti: Uint8Array | undefined;
    readonly signature: Uint8Array;
    constructor(data: RawChallengeSubmission, epochNumber: bigint);
    verifySignature(): boolean;
}
export declare class ChallengeSolution implements IChallengeSolution {
    readonly epochNumber: bigint;
    readonly publicKey: Address;
    readonly solution: Uint8Array;
    readonly salt: Uint8Array;
    readonly graffiti: Uint8Array;
    readonly difficulty: number;
    readonly verification: ChallengeVerification;
    private readonly submission?;
    constructor(data: RawChallenge);
    /**
     * Static method to validate from raw data directly
     */
    static validateRaw(data: RawChallenge): boolean;
    verifySubmissionSignature(): boolean;
    getSubmission(): ChallengeSubmission | undefined;
    /**
     * Verify this challenge
     * @returns {boolean} True if the challenge is valid
     */
    verify(): boolean;
    /**
     * Get the preimage challenge
     * @returns {Uint8Array} The solution/challenge as a Uint8Array
     */
    toBuffer(): Uint8Array;
    /**
     * Get the solution as a hex string
     * @returns {string} The solution as a hex string with 0x prefix
     */
    toHex(): string;
    /**
     * Convert to raw format for serialization
     */
    toRaw(): RawChallenge;
    /**
     * Calculate the expected solution hash for this challenge
     * @returns {Uint8Array} The calculated solution hash
     */
    calculateSolution(): Uint8Array;
    /**
     * Check if the challenge meets a specific difficulty requirement
     * @param {number} minDifficulty The minimum difficulty required
     * @returns {Promise<{valid: boolean; difficulty: number}>} Validation result
     */
    checkDifficulty(minDifficulty: number): {
        valid: boolean;
        difficulty: number;
    };
    /**
     * Get the mining target block for this epoch
     * @returns {bigint | null} The target block number or null if epoch 0
     */
    getMiningTargetBlock(): bigint | null;
}
//# sourceMappingURL=ChallengeSolution.d.ts.map