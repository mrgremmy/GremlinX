export declare class Secp256k1PointDeriver {
    /**
     * The maximum increments to try before giving up on deriving a valid x.
     */
    private maxTries;
    constructor(maxTries?: number);
    /**
     * Main entry point.
     * Given a 32-byte input, ensures we obtain a "real" x on secp256k1.
     * - If the given x is valid, we use it.
     * - Otherwise, we increment x (mod p) until we find one whose (x^3 + 7) is a quadratic residue.
     * Then we return { x, y1, y2 } for that valid point.
     *
     * @param xBytes A 32-byte Uint8Array for the candidate x
     * @param failOnInvalidX (optional) whether to throw if the given x is not a valid curve point, defaults to true
     * @param maxTries (optional) number of increments to attempt, defaults to this.maxTries
     * @returns An object { x: bigint; y1: bigint; y2: bigint } describing a valid curve point
     * @throws If no valid x found within maxTries
     */
    findOrDeriveValidPoint(xBytes: Uint8Array, failOnInvalidX?: boolean, maxTries?: number): {
        x: bigint;
        y1: bigint;
        y2: bigint;
    };
    /**
     * Given two candidate y values, returns the one with the smaller y-coordinate.
     * @param {bigint} y
     * @param {bigint} y2
     */
    getCanonicalY(y: bigint, y2: bigint): bigint;
    /**
     * Creates a 65-byte "hybrid public key" from the specified x and y.
     * - First byte:
     *   - 0x06 if y is even
     *   - 0x07 if y is odd
     * - Next 32 bytes: x
     * - Last 32 bytes: y
     *
     * @param x X-coordinate as a bigint
     * @param y Y-coordinate as a bigint
     * @returns A Uint8Array of length 65
     */
    getHybridPublicKey(x: bigint, y: bigint): Uint8Array;
    /**
     * Checks if (x^3 + 7) is a quadratic residue mod p.
     * Returns the square root if it is, or null if not.
     */
    private isValidX;
    /**
     * Computes base^exp (mod m) using exponentiation by squaring.
     */
    private modPow;
    /**
     * sqrtModP(a, p):
     *   Attempts to compute the square root of `a` modulo prime `p`.
     *   Returns the root if it exists, or null if `a` is not a quadratic residue.
     *
     * Since p â‰¡ 3 (mod 4), we can do:
     *   sqrt(a) = a^((p+1)/4) mod p
     */
    private sqrtModP;
    /**
     * Convert a 32-byte Uint8Array (big-endian) to a BigInt.
     */
    private bytesToBigInt;
    /**
     * Convert a BigInt to a 32-byte array (big-endian).
     */
    private bigIntTo32Bytes;
}
//# sourceMappingURL=Secp256k1PointDeriver.d.ts.map