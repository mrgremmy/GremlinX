import { AddressMap } from '../deterministic/AddressMap.js';
import { ExtendedAddressMap } from '../deterministic/ExtendedAddressMap.js';
import { Address } from '../keypair/Address.js';
import type { i16, i32, i64, i8, Selector, u16, u32, u64, u8 } from '../utils/types.js';
import { BinaryReader } from './BinaryReader.js';
export declare class BinaryWriter implements Disposable {
    private currentOffset;
    private buffer;
    constructor(length?: number);
    static estimateArrayOfBufferLength(values: Uint8Array[]): u32;
    writeU8(value: u8): void;
    writeU16(value: u16, be?: boolean): void;
    writeU32(value: u32, be?: boolean): void;
    writeU64(value: u64, be?: boolean): void;
    /**
     * Writes a signed 8-bit integer.
     */
    writeI8(value: i8): void;
    /**
     * Writes a signed 16-bit integer. By default big-endian (be = true).
     */
    writeI16(value: i16, be?: boolean): void;
    /**
     * Writes a signed 32-bit integer. By default big-endian (be = true).
     */
    writeI32(value: i32, be?: boolean): void;
    /**
     * Writes a signed 64-bit integer. By default big-endian (be = true).
     */
    writeI64(value: i64, be?: boolean): void;
    writeSelector(value: Selector): void;
    writeBoolean(value: boolean): void;
    writeI128(bigIntValue: bigint, be?: boolean): void;
    writeU256(bigIntValue: bigint, be?: boolean): void;
    writeU128(bigIntValue: bigint, be?: boolean): void;
    writeBytes(value: Uint8Array): void;
    writeString(value: string): void;
    writeStringWithLength(value: string): void;
    /**
     * Writes an address (32 bytes MLDSA key hash only).
     */
    writeAddress(value: Address): void;
    /**
     * Writes the tweaked public key from an Address (32 bytes).
     * @param value - The Address containing the tweaked public key
     */
    writeTweakedPublicKey(value: Address): void;
    /**
     * Writes a full address with both tweaked public key and MLDSA key hash (64 bytes total).
     * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
     *
     * This is the equivalent of btc-runtime's writeExtendedAddress().
     *
     * @param value - The Address containing both keys
     */
    writeExtendedAddress(value: Address): void;
    /**
     * Writes a Schnorr signature with its associated full Address.
     * Format: [64 bytes full Address][64 bytes signature]
     *
     * Used for serializing signed data where both the signer's address
     * and their Schnorr signature need to be stored together.
     *
     * @param address - The signer's Address (with both MLDSA and tweaked keys)
     * @param signature - The 64-byte Schnorr signature
     * @throws {Error} If signature is not exactly 64 bytes
     */
    writeSchnorrSignature(address: Address, signature: Uint8Array): void;
    getBuffer(clear?: boolean): Uint8Array;
    reset(): void;
    toBytesReader(): BinaryReader;
    getOffset(): u32;
    setOffset(offset: u32): void;
    clear(): void;
    [Symbol.dispose](): void;
    allocSafe(size: u32): void;
    writeAddressValueTuple(map: AddressMap<bigint>, be?: boolean): void;
    /**
     * Writes a map of full Address -> u256 using the tweaked key for map lookup.
     * Format: [u16 length][FullAddress key][u256 value]...
     *
     * This is the equivalent of btc-runtime's writeExtendedAddressMapU256().
     */
    writeExtendedAddressMapU256(map: ExtendedAddressMap<bigint>, be?: boolean): void;
    writeBytesWithLength(value: Uint8Array): void;
    writeArrayOfBuffer(values: Uint8Array[], be?: boolean): void;
    writeAddressArray(value: Address[]): void;
    /**
     * Writes an array of full addresses (64 bytes each).
     * Format: [u16 length][FullAddress 0][FullAddress 1]...
     */
    writeExtendedAddressArray(value: Address[]): void;
    writeU32Array(value: u32[], be?: boolean): void;
    writeU256Array(value: bigint[], be?: boolean): void;
    writeU128Array(value: bigint[], be?: boolean): void;
    writeStringArray(value: string[]): void;
    writeU16Array(value: u16[], be?: boolean): void;
    writeU8Array(value: u8[]): void;
    writeU64Array(value: bigint[], be?: boolean): void;
    writeBytesArray(value: Uint8Array[]): void;
    private verifyAddress;
    private resize;
    private getDefaultBuffer;
}
//# sourceMappingURL=BinaryWriter.d.ts.map