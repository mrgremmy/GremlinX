import { fromHex, toHex } from '@btc-vision/bitcoin';
import { U256_BYTE_LENGTH } from './lengths.js';
export class BufferHelper {
    static EXPECTED_BUFFER_LENGTH = 32;
    static bufferToUint8Array(buffer) {
        const result = new Uint8Array(buffer.byteLength);
        result.set(buffer);
        return result;
    }
    static uint8ArrayToHex(input) {
        return toHex(input);
    }
    static hexToUint8Array(input) {
        let hex = input;
        if (hex.length >= 2 && hex[0] === '0' && (hex[1] === 'x' || hex[1] === 'X')) {
            hex = hex.slice(2);
        }
        // Pad with a leading zero if the length is odd
        if (hex.length % 2 !== 0) {
            hex = '0' + hex;
        }
        return fromHex(hex);
    }
    static pointerToUint8Array(pointer) {
        if (pointer < 0n) {
            throw new RangeError('Pointer cannot be negative');
        }
        const hex = pointer.toString(16).padStart(64, '0');
        if (hex.length > 64) {
            throw new RangeError('Pointer exceeds 256-bit range');
        }
        return fromHex(hex);
    }
    static uint8ArrayToPointer(input) {
        if (input.length === 0) {
            return 0n;
        }
        return BigInt('0x' + toHex(input));
    }
    static valueToUint8Array(value, length = U256_BYTE_LENGTH) {
        if (value < 0n) {
            throw new RangeError('Value cannot be negative');
        }
        const hex = value.toString(16).padStart(length * 2, '0');
        if (hex.length > length * 2) {
            throw new RangeError(`Value exceeds ${length}-byte range`);
        }
        return fromHex(hex);
    }
    static uint8ArrayToValue(input) {
        if (input.length === 0) {
            return 0n;
        }
        return BigInt('0x' + toHex(input));
    }
}
//# sourceMappingURL=BufferHelper.js.map