import { UniversalSigner } from '@btc-vision/ecpair';
import { TransactionType } from '../enums/TransactionType.js';
import { TransactionBuilder } from './TransactionBuilder.js';
import { HashCommitmentGenerator } from '../../generators/builders/HashCommitmentGenerator.js';
import { CalldataGenerator } from '../../generators/builders/CalldataGenerator.js';
import { IConsolidatedInteractionParameters, IConsolidatedInteractionResult, IHashCommittedP2WSH, IRevealTransactionResult } from '../interfaces/IConsolidatedTransactionParameters.js';
import { IP2WSHAddress } from '../mineable/IP2WSHAddress.js';
import { IChallengeSolution } from '../../epoch/interfaces/IChallengeSolution.js';
/**
 * Consolidated Interaction Transaction
 *
 * Drop-in replacement for InteractionTransaction that bypasses BIP110/Bitcoin Knots censorship.
 *
 * Uses the same parameters and sends the same data on-chain as InteractionTransaction,
 * but embeds data in hash-committed P2WSH witnesses instead of Tapscript.
 *
 * Data is split into 80-byte chunks (P2WSH stack item limit), with up to 14 chunks
 * batched per P2WSH output (~1,120 bytes per output). Each output's witness script
 * commits to all its chunks via HASH160. When spent, all data chunks are revealed
 * in the witness and verified at consensus level.
 *
 * Policy limits respected:
 * - MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80 bytes per chunk
 * - g_script_size_policy_limit = 1650 bytes total witness size (serialized)
 * - MAX_STANDARD_P2WSH_STACK_ITEMS = 100 items per witness
 *
 * Data integrity is consensus-enforced: if any data is stripped or modified,
 * HASH160(data) != committed_hash and the transaction is INVALID.
 *
 * Capacity: ~1.1KB per P2WSH output, ~220 outputs per reveal tx, ~242KB max.
 *
 * Usage:
 * ```typescript
 * // Same parameters as InteractionTransaction
 * const tx = new ConsolidatedInteractionTransaction({
 *     calldata: myCalldata,
 *     to: contractAddress,
 *     contract: contractSecret,
 *     challenge: myChallenge,
 *     utxos: myUtxos,
 *     signer: mySigner,
 *     network: networks.bitcoin,
 *     feeRate: 10,
 *     priorityFee: 0n,
 *     gasSatFee: 330n,
 * });
 *
 * const result = await tx.build();
 * // Broadcast setup first, then reveal (can use CPFP)
 * broadcast(result.setup.txHex);
 * broadcast(result.reveal.txHex);
 * ```
 */
export declare class ConsolidatedInteractionTransaction extends TransactionBuilder<TransactionType.INTERACTION> {
    readonly type: TransactionType.INTERACTION;
    /** Random bytes for interaction (same as InteractionTransaction) */
    readonly randomBytes: Uint8Array;
    /** The contract address (same as InteractionTransaction.to) */
    protected readonly contractAddress: string;
    /** The contract secret - 32 bytes (same as InteractionTransaction) */
    protected readonly contractSecret: Uint8Array;
    /** The compressed calldata (same as InteractionTransaction) */
    protected readonly calldata: Uint8Array;
    /** Challenge solution for epoch (same as InteractionTransaction) */
    protected readonly challenge: IChallengeSolution;
    /** Epoch challenge P2WSH address (same as InteractionTransaction) */
    protected readonly epochChallenge: IP2WSHAddress;
    /** Script signer for interaction (same as InteractionTransaction) */
    protected readonly scriptSigner: UniversalSigner;
    /** Calldata generator - produces same output as InteractionTransaction */
    protected readonly calldataGenerator: CalldataGenerator;
    /** Hash commitment generator for CHCT */
    protected readonly hashCommitmentGenerator: HashCommitmentGenerator;
    /** The compiled operation data - SAME as InteractionTransaction's compiledTargetScript */
    protected readonly compiledTargetScript: Uint8Array;
    /** Generated hash-committed P2WSH outputs */
    protected readonly commitmentOutputs: IHashCommittedP2WSH[];
    /** Disable auto refund (same as InteractionTransaction) */
    protected readonly disableAutoRefund: boolean;
    /** Maximum chunk size (default: 80 bytes per P2WSH stack item limit) */
    protected readonly maxChunkSize: number;
    /** Cached value per output (calculated once, used by setup and reveal) */
    private cachedValuePerOutput;
    constructor(parameters: IConsolidatedInteractionParameters);
    /**
     * Get the compiled target script (same as InteractionTransaction).
     */
    exportCompiledTargetScript(): Uint8Array;
    /**
     * Get the contract secret (same as InteractionTransaction).
     */
    getContractSecret(): Uint8Array;
    /**
     * Get the random bytes (same as InteractionTransaction).
     */
    getRndBytes(): Uint8Array;
    /**
     * Get the challenge solution (same as InteractionTransaction).
     */
    getChallenge(): IChallengeSolution;
    /**
     * Get the commitment outputs for the setup transaction.
     */
    getCommitmentOutputs(): IHashCommittedP2WSH[];
    /**
     * Get the number of P2WSH outputs.
     */
    getOutputCount(): number;
    /**
     * Get the total number of 80-byte chunks across all outputs.
     */
    getTotalChunkCount(): number;
    /**
     * Build both setup and reveal transactions.
     *
     * @returns Complete result with both transactions
     */
    build(): Promise<IConsolidatedInteractionResult>;
    /**
     * Build the reveal transaction.
     * Spends the P2WSH commitment outputs, revealing the compiled data in witnesses.
     *
     * Output structure matches InteractionTransaction:
     * - Output to epochChallenge.address (miner reward)
     * - Change output (if any)
     *
     * @param setupTxId The transaction ID of the setup transaction
     */
    buildRevealTransaction(setupTxId: string): IRevealTransactionResult;
    /**
     * Get the value per commitment output (for external access).
     */
    getValuePerOutput(): bigint;
    /**
     * Build the setup transaction.
     * Creates P2WSH outputs with hash commitments to the compiled data chunks.
     * This is called by signTransaction() in the base class.
     */
    protected buildTransaction(): Promise<void>;
    /**
     * Finalize a commitment input.
     *
     * Witness stack: [signature, data_1, data_2, ..., data_N, witnessScript]
     *
     * The witness script verifies each data chunk against its committed hash.
     * If any data is wrong or missing, the transaction is INVALID at consensus level.
     */
    private finalizeCommitmentInput;
    /**
     * Estimate reveal transaction vBytes.
     */
    private estimateRevealVBytes;
    /**
     * Calculate the required value per commitment output.
     * This must cover: dust minimum + share of reveal fee + share of OPNet fee
     */
    private calculateValuePerOutput;
    /**
     * Get refund address.
     */
    private getRefundAddress;
    /**
     * Generate features (same as InteractionTransaction).
     */
    private generateFeatures;
    /**
     * Validate output count is within standard tx limits.
     */
    private validateOutputCount;
}
//# sourceMappingURL=ConsolidatedInteractionTransaction.d.ts.map