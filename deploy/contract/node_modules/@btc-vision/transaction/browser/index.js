import { p as Jt, N as Ii, s as lt, c as B, b as Le, L as Me, d as Mt, a as Pt, l as pe, z as We, e as Pi } from "./vendors.js";
import { m as vi, X as T, H as _, n as w, V as U, v as dt, i as at, g as O, z as f, I as Oi, x as g, P as q, K as Ui, a as _i, w as se, y as F, b as C, c as Bi, q as ki, u as Li, d as He, e as Ve, l as Ri, C as X, Q as ne, f as v, h as Ki, N as xi, Y as Di, j as Ci, k as Re, o as Ni, S as Ke, T as Fi, p as Mi, A as Wi, E as Hi, r as ze, s as L, t as oe, _ as Vi } from "./btc-vision-bitcoin.js";
import { s as zi, m as qi, b as Xi } from "./noble-curves.js";
import { s as te, c as re, e as $i, v as Yi } from "./noble-hashes.js";
const zt = Symbol;
typeof zt.dispose != "symbol" && (zt.dispose = /* @__PURE__ */ Symbol.for("Symbol.dispose"));
typeof zt.asyncDispose != "symbol" && (zt.asyncDispose = /* @__PURE__ */ Symbol.for("Symbol.asyncDispose"));
const Gi = "1.8.0-rc.10";
function Qi(n, t = {}) {
  return new Uint8Array(Jt.gzip(n, { level: t.level || 6 }));
}
function ji(n) {
  return new Uint8Array(Jt.ungzip(n));
}
function Zi(n, t = {}) {
  return new Uint8Array(Jt.deflate(n, { level: t.level || 6 }));
}
function Ji(n) {
  return new Uint8Array(Jt.inflate(n));
}
const xe = {
  gzipSync: Qi,
  gunzipSync: ji,
  deflateSync: Zi,
  inflateSync: Ji
};
class Y {
  static zlibOptions = {
    level: 9,
    maxOutputLength: 1024 * 1024 * 16
    // 16mb, limit it to 16mb.
  };
  /**
   * Compresses the data using gzip.
   * @param {Uint8Array} data The data to compress.
   * @returns {Uint8Array} The compressed data.
   */
  static compress(t) {
    return new Uint8Array(xe.gzipSync(t, Y.zlibOptions));
  }
  /**
   * Decompresses the data using gunzip.
   * @param {Uint8Array} data The data to decompress.
   * @returns {Uint8Array} The decompressed data.
   */
  static decompress(t) {
    return new Uint8Array(xe.gunzipSync(t, Y.zlibOptions));
  }
}
const N = Ii(), tr = N;
vi(tr);
const qe = typeof Le == "function" ? Le : B.BIP32Factory;
if (!qe)
  throw new Error("Failed to load BIP32 library");
const gt = zi.Point, er = gt.Fn.ORDER, ir = new Uint8Array([84, 97, 112, 84, 119, 101, 97, 107]), De = te(ir);
function rr(n) {
  return te($i(De, De, n));
}
class P {
  static BIP32 = qe(N);
  static ECPairSigner = lt;
  static {
    gt.BASE.precompute(8);
  }
  /**
   * Generate a keypair from a WIF
   * @param {string} wif - The WIF to use
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static fromWIF(t, e = T.bitcoin) {
    return lt.fromWIF(N, t, e);
  }
  /**
   * Generate a keypair from a private key
   * @param {Uint8Array} privateKey - The private key to use
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static fromPrivateKey(t, e = T.bitcoin) {
    return lt.fromPrivateKey(N, t, e);
  }
  /**
   * Generate a keypair from a public key
   * @param {Uint8Array} publicKey - The public key to use
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static fromPublicKey(t, e = T.bitcoin) {
    return lt.fromPublicKey(N, t, e);
  }
  /**
   * Generate a multi-sig address
   * @param {Uint8Array[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(t, e, i = T.bitcoin) {
    const r = this.verifyPubKeys(t, i);
    if (r.length !== t.length) throw new Error("Contains invalid public keys");
    const s = _.p2ms({
      m: e,
      pubkeys: r,
      network: i
    }), a = _.p2wsh({ redeem: s, network: i }).address;
    if (!a)
      throw new Error("Failed to generate address");
    return a;
  }
  /**
   * Verify public keys and return the public keys
   * @param {Uint8Array[]} pubKeys - The public keys to verify
   * @param {Network} network - The network to use
   * @returns {Uint8Array[]} - The verified public keys
   * @throws {Error} - If the key cannot be regenerated
   */
  static verifyPubKeys(t, e = T.bitcoin) {
    return t.map((i) => {
      const r = P.fromPublicKey(i, e);
      if (!r)
        throw new Error("Failed to regenerate key");
      return r.publicKey;
    });
  }
  /**
   * Get a P2WPKH address from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The address
   */
  static getP2WPKHAddress(t, e = T.bitcoin) {
    const i = _.p2wpkh({ pubkey: t.publicKey, network: e });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the address of a tweaked public key
   * @param {string} tweakedPubKeyHex - The tweaked public key hex string
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static tweakedPubKeyToAddress(t, e) {
    t.startsWith("0x") && (t = t.slice(2));
    let i = w(t);
    return i.length !== 32 && (i = U(i)), P.tweakedPubKeyBufferToAddress(i, e);
  }
  /**
   * Get the address of a tweaked public key
   * @param {Uint8Array} tweakedPubKeyBuffer - The tweaked public key buffer
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static tweakedPubKeyBufferToAddress(t, e) {
    const { address: i } = _.p2tr({
      pubkey: t,
      network: e
    });
    if (!i)
      throw new Error("Failed to generate Taproot address");
    return i;
  }
  /**
   * Generate a P2OP address
   * @param bytes - The bytes to use for the P2OP address
   * @param network - The network to use
   * @param deploymentVersion - The deployment version (default is 0)
   * @returns {string} - The generated P2OP address
   */
  static p2op(t, e = T.bitcoin, i = 0) {
    const r = dt([
      new Uint8Array([i]),
      at.crypto.hash160(t)
    ]);
    if (r.length < 2 || r.length > 40)
      throw new Error("Witness program must be 2-40 bytes.");
    const s = O.compile([f.OP_16, r]);
    return Oi(s, e);
  }
  /**
   * Get the address of a xOnly tweaked public key
   * @param {string} tweakedPubKeyHex - The xOnly tweaked public key hex string
   * @param {Network} network - The network to use
   * @returns {string} - The address
   * @throws {Error} - If the address cannot be generated
   */
  static xOnlyTweakedPubKeyToAddress(t, e) {
    t.startsWith("0x") && (t = t.slice(2));
    const i = w(t);
    if (i.length !== 32)
      throw new Error("Invalid xOnly public key length");
    const { address: r } = _.p2tr({
      pubkey: i,
      network: e
    });
    if (!r)
      throw new Error("Failed to generate Taproot address");
    return r;
  }
  /**
   * Tweak a public key
   * @param {Uint8Array | string} pub - The public key to tweak
   * @returns {Uint8Array} - The tweaked public key
   * @throws {Error} - If the public key cannot be tweaked
   */
  static tweakPublicKey(t) {
    typeof t == "string" && t.startsWith("0x") && (t = t.slice(2));
    const e = typeof t == "string" ? t : g(t), i = gt.fromHex(e), r = (i.y & 1n) === 0n ? i : i.negate(), s = r.toBytes(!0).subarray(1), o = rr(s), a = qi(Xi(o), er);
    return r.add(gt.BASE.multiply(a)).toBytes(!0);
  }
  /**
   * Tweak a batch of public keys
   * @param {readonly Uint8Array[]} pubkeys - The public keys to tweak
   * @param {bigint} tweakScalar - The scalar to use for tweaking
   * @returns {Uint8Array[]} - The tweaked public keys
   */
  static tweakBatchSharedT(t, e) {
    const i = gt.BASE.multiply(e);
    return t.map((r) => {
      const s = gt.fromHex(g(r));
      return (s.y % 2n === 0n ? s : s.negate()).add(i).toBytes(!0);
    });
  }
  /**
   * Generate a random wallet with both classical and quantum keys
   *
   * @param network - The network to use
   * @param securityLevel - The ML-DSA security level for quantum keys (default: LEVEL2/44)
   * @returns An object containing both classical and quantum key information
   */
  static generateWallet(t = T.bitcoin, e = B.MLDSASecurityLevel.LEVEL2) {
    const i = lt.makeRandom(N, t, {
      rng: (o) => re(o)
    }), r = this.getP2WPKHAddress(i, t);
    if (!r)
      throw new Error("Failed to generate wallet");
    const s = this.generateQuantumKeyPair(e, t);
    return {
      address: r,
      privateKey: i.toWIF(),
      publicKey: g(i.publicKey),
      quantumPrivateKey: g(s.privateKey),
      quantumPublicKey: g(s.publicKey)
    };
  }
  /**
   * Generate a random quantum ML-DSA keypair
   *
   * This creates a standalone quantum-resistant keypair without using BIP32 derivation.
   * The keys are generated using cryptographically secure random bytes.
   *
   * @param securityLevel - The ML-DSA security level (default: LEVEL2/44)
   * @param network - The Bitcoin network (default: bitcoin mainnet)
   * @returns A random ML-DSA keypair
   */
  static generateQuantumKeyPair(t = B.MLDSASecurityLevel.LEVEL2, e = T.bitcoin) {
    const i = re(64), r = B.QuantumBIP32Factory.fromSeed(i, e, t);
    if (!r.privateKey || !r.publicKey)
      throw new Error("Failed to generate quantum keypair");
    return {
      privateKey: new Uint8Array(r.privateKey),
      publicKey: new Uint8Array(r.publicKey)
    };
  }
  /**
   * Verify that a contract address is a valid p2tr address
   * @param {string} contractAddress - The contract address to verify
   * @param {Network} network - The network to use
   * @returns {boolean} - Whether the address is valid
   */
  static verifyContractAddress(t, e = T.bitcoin) {
    return !!q.toOutputScript(t, e);
  }
  /**
   * Get the legacy segwit address from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getLegacySegwitAddress(t, e = T.bitcoin) {
    const i = _.p2sh({
      redeem: _.p2wpkh({ pubkey: t.publicKey, network: e }),
      network: e
    });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the legacy address from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getLegacyAddress(t, e = T.bitcoin) {
    const i = _.p2pkh({ pubkey: t.publicKey, network: e });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the legacy address from a public key
   * @param publicKey
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getP2PKH(t, e = T.bitcoin) {
    const i = _.p2pkh({ pubkey: t, network: e });
    if (!i.address)
      throw new Error("Failed to generate wallet");
    return i.address;
  }
  /**
   * Get the P2PK output from a keypair
   * @param {UniversalSigner} keyPair - The keypair to get the address for
   * @param {Network} network - The network to use
   * @returns {string} - The legacy address
   */
  static getP2PKAddress(t, e = T.bitcoin) {
    const i = _.p2pk({ pubkey: t.publicKey, network: e });
    if (!i.output)
      throw new Error("Failed to generate wallet");
    return "0x" + g(i.output);
  }
  /**
   * Generate a random keypair
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated keypair
   */
  static generateRandomKeyPair(t = T.bitcoin) {
    return lt.makeRandom(N, t, {
      rng: (e) => re(e)
    });
  }
  /**
   * Generate a BIP32 keypair from a seed
   * @param {Uint8Array} seed - The seed to generate the keypair from
   * @param {Network} network - The network to use
   * @returns {BIP32Interface} - The generated keypair
   */
  static fromSeed(t, e = T.bitcoin) {
    return this.BIP32.fromSeed(t, e);
  }
  /**
   * Get taproot address from keypair
   * @param {UniversalSigner | Signer} keyPair - The keypair to get the taproot address for
   * @param {Network} network - The network to use
   * @returns {string} - The taproot address
   */
  static getTaprootAddress(t, e = T.bitcoin) {
    const { address: i } = _.p2tr({
      internalPubkey: U(t.publicKey),
      network: e
    });
    if (!i)
      throw new Error("Failed to generate sender address for transaction");
    return i;
  }
  /**
   * Get taproot address from address
   * @param {string} inAddr - The address to convert to taproot
   * @param {Network} network - The network to use
   * @returns {string} - The taproot address
   */
  static getTaprootAddressFromAddress(t, e = T.bitcoin) {
    const { address: i } = _.p2tr({
      address: t,
      network: e
    });
    if (!i)
      throw new Error("Failed to generate sender address for transaction");
    return i;
  }
  /**
   * Get a keypair from a given seed.
   * @param {Uint8Array} seed - The seed to generate the key pair from
   * @param {Network} network - The network to use
   * @returns {UniversalSigner} - The generated key pair
   */
  static fromSeedKeyPair(t, e = T.bitcoin) {
    const r = this.BIP32.fromSeed(t, e).privateKey;
    if (!r) throw new Error("Failed to generate key pair");
    return lt.fromPrivateKey(N, r, e);
  }
}
var $ = /* @__PURE__ */ ((n) => (n[n.ACCESS_LIST = 1] = "ACCESS_LIST", n[n.EPOCH_SUBMISSION = 2] = "EPOCH_SUBMISSION", n[n.MLDSA_LINK_PUBKEY = 4] = "MLDSA_LINK_PUBKEY", n))($ || {}), et = /* @__PURE__ */ ((n) => (n[n.ACCESS_LIST = 1] = "ACCESS_LIST", n[n.EPOCH_SUBMISSION = 2] = "EPOCH_SUBMISSION", n[n.MLDSA_LINK_PUBKEY = 3] = "MLDSA_LINK_PUBKEY", n))(et || {});
const D = 32, mt = 64, Tt = 64, sr = 4, kt = 32, Ut = 16, qt = 8, bt = 4, At = 2, Xt = 1, nr = 32, _t = 16, Lt = 8, Rt = 4, Kt = 2, xt = 1, or = 1;
function ar(n, t, e, i) {
  throw new Error(`${t} (${e}: ${i})`);
}
function cr() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof globalThis < "u")
    return globalThis;
  throw new Error("unable to locate global object");
}
const Ce = cr();
Ce.crypto || Ce.msCrypto;
function ae(n) {
  switch (n) {
    case "sha256":
      return te.create();
    case "sha512":
      return Yi.create();
  }
  ar(!1, "invalid hashing algorithm name", "algorithm", n);
}
const ur = /^[0-9a-fA-F]+$/;
class W {
  /**
   * Converts satoshi to BTC
   * @param {number} btc - The amount in BTC
   * @returns {bigint} The amount in satoshi
   */
  static btcToSatoshi(t) {
    return BigInt(t * 1e8);
  }
  /**
   * Generates random bytes.
   * @public
   * @returns {Uint8Array} The random bytes
   */
  static rndBytes() {
    return W.getSafeRandomValues(64);
  }
  static getSafeRandomValues(t) {
    if (typeof globalThis.window < "u" && globalThis.window.crypto && typeof globalThis.window.crypto.getRandomValues == "function") {
      const e = new Uint8Array(t);
      return window.crypto.getRandomValues(e), e;
    } else if (globalThis.crypto && typeof globalThis.crypto.getRandomValues == "function") {
      const e = new Uint8Array(t);
      return globalThis.crypto.getRandomValues(e), e;
    } else
      throw console.log(
        "No secure random number generator available. Please upgrade your environment.",
        globalThis.window.crypto,
        globalThis.crypto
      ), new Error(
        "No secure random number generator available. Please upgrade your environment."
      );
  }
  static isValidHex(t) {
    return ur.test(t);
  }
  /**
   * Hashes the given data
   * @param {Uint8Array} data - The data to hash
   * @returns {string} The hashed data
   */
  static opnetHash(t) {
    const e = ae("sha512");
    e.update(t);
    const i = e.digest();
    return `0x${g(new Uint8Array(i))}`;
  }
}
class Z {
  /**
   * Check if a UTXO is a P2WDA output by examining its script structure
   */
  static isP2WDAUTXO(t) {
    if (!t.witnessScript)
      return !1;
    const e = t.witnessScript instanceof Uint8Array ? t.witnessScript : w(t.witnessScript);
    return this.isP2WDAWitnessScript(e);
  }
  /**
   * Check if a witness script follows the P2WDA pattern
   */
  static isP2WDAWitnessScript(t) {
    try {
      const e = O.decompile(t);
      if (!e || e.length !== 7)
        return !1;
      for (let i = 0; i < 5; i++)
        if (e[i] !== f.OP_2DROP)
          return !1;
      return e[5] instanceof Uint8Array && e[5].length === 33 && // Compressed public key
      e[6] === f.OP_CHECKSIG;
    } catch {
      return !1;
    }
  }
  /**
   * Generate a P2WDA address from a public key
   */
  static generateP2WDAAddress(t, e) {
    if (t.length !== 33)
      throw new Error("Public key must be 33 bytes (compressed)");
    const i = O.compile([
      f.OP_2DROP,
      f.OP_2DROP,
      f.OP_2DROP,
      f.OP_2DROP,
      f.OP_2DROP,
      t,
      f.OP_CHECKSIG
    ]), r = _.p2wsh({
      redeem: { output: i },
      network: e
    });
    if (!r.address || !r.output)
      throw new Error("Failed to generate P2WDA address");
    return {
      address: r.address,
      witnessScript: i,
      scriptPubKey: r.output
    };
  }
  /**
   * Extract the public key from a P2WDA witness script
   */
  static extractPublicKeyFromP2WDA(t) {
    try {
      const e = O.decompile(t);
      if (!e || e.length !== 7)
        return null;
      for (let i = 0; i < 5; i++)
        if (e[i] !== f.OP_2DROP)
          return null;
      return e[5] instanceof Uint8Array && e[5].length === 33 && e[6] === f.OP_CHECKSIG ? e[5] : null;
    } catch {
      return null;
    }
  }
  /**
   * Create witness data for a simple P2WDA spend (no operation data)
   */
  static createSimpleP2WDAWitness(t, e) {
    const i = [t];
    for (let r = 0; r < 10; r++)
      i.push(new Uint8Array(0));
    return i.push(e), i;
  }
  /**
   * Validate P2WDA operation data signature
   */
  static validateP2WDASignature(t, e, i) {
    return e.length === 64;
  }
  /**
   * Calculate the witness size for P2WDA transaction estimation
   */
  static estimateP2WDAWitnessSize(t = 0) {
    return 72 + t + 39 + 12;
  }
  /**
   * Check if a scriptPubKey is a P2WSH that could be P2WDA
   */
  static couldBeP2WDA(t) {
    return t.length === 34 && t[0] === 0 && t[1] === 32;
  }
}
var st = /* @__PURE__ */ ((n) => (n.P2PKH = "P2PKH", n.P2OP = "P2OP", n.P2SH_OR_P2SH_P2WPKH = "P2SH_OR_P2SH-P2WPKH", n.P2PK = "P2PK", n.P2TR = "P2TR", n.P2MR = "P2MR", n.P2WPKH = "P2WPKH", n.P2WSH = "P2WSH", n.P2WDA = "P2WDA", n))(st || {});
class Q {
  static isValidP2TRAddress(t, e) {
    if (!t || t.length < 50) return !1;
    let i = !1;
    try {
      q.toOutputScript(t, e), i = q.fromBech32(t).version === 1;
    } catch {
    }
    return i;
  }
  /**
   * Validates that the given address is a valid P2MR (BIP 360) address.
   * Checks for witness version 2 with a 32-byte Merkle root program.
   */
  static isValidP2MRAddress(t, e) {
    if (!t || t.length < 50) return !1;
    let i = !1;
    try {
      q.toOutputScript(t, e);
      const r = q.fromBech32(t);
      i = r.version === 2 && r.data.length === 32;
    } catch {
    }
    return i;
  }
  static isP2WPKHAddress(t, e) {
    if (!t || t.length < 20 || t.length > 50) return !1;
    let i = !1;
    try {
      const r = q.fromBech32(t);
      q.toOutputScript(t, e), i = r.version === 0 && r.data.length === 20;
    } catch {
    }
    return i;
  }
  static isP2WDAWitnessScript(t) {
    return Z.isP2WDAWitnessScript(t);
  }
  static isP2PKHOrP2SH(t, e) {
    try {
      const i = q.fromBase58Check(t);
      return i.version === e.pubKeyHash ? !0 : i.version === e.scriptHash;
    } catch {
      return !1;
    }
  }
  static isValidPublicKey(t, e) {
    try {
      if (t.startsWith("0x") && (t = t.slice(2)), !W.isValidHex(t))
        return !1;
      if (t.length === 64)
        return !0;
      const i = w(t);
      if (t.length === 130 && i[0] === 6 || i[0] === 7)
        return !0;
      if (t.length === 66 || t.length === 130)
        return P.fromPublicKey(i, e), !0;
    } catch {
      return !1;
    }
    return !1;
  }
  static isValidMLDSAPublicKey(t) {
    try {
      let e;
      if (typeof t != "string" && t instanceof Uint8Array)
        e = t.length;
      else {
        if (t.startsWith("0x") && (t = t.slice(2)), !W.isValidHex(t))
          return null;
        e = t.length / 2;
      }
      switch (e) {
        case 1312:
          return B.MLDSASecurityLevel.LEVEL2;
        case 1952:
          return B.MLDSASecurityLevel.LEVEL3;
        case 2592:
          return B.MLDSASecurityLevel.LEVEL5;
        default:
          return null;
      }
    } catch {
      return null;
    }
  }
  static isValidP2OPAddress(t, e) {
    if (!t || t.length < 20) return !1;
    try {
      const i = q.fromBech32(t);
      return i.prefix === e.bech32 || i.prefix === e.bech32Opnet ? i.version === 16 && i.data.length === 21 : !1;
    } catch {
      return !1;
    }
  }
  static requireRedeemScript(t, e) {
    try {
      const i = q.fromBase58Check(t);
      return i.version === e.pubKeyHash ? !1 : i.version === e.scriptHash;
    } catch {
      return !1;
    }
  }
  static detectAddressType(t, e) {
    if (Q.isValidPublicKey(t, e))
      return "P2PK";
    try {
      const i = q.fromBase58Check(t);
      if (i.version === e.pubKeyHash)
        return "P2PKH";
      if (i.version === e.scriptHash)
        return "P2SH_OR_P2SH-P2WPKH";
    } catch {
    }
    try {
      const i = q.fromBech32(t);
      if ((i.prefix === e.bech32Opnet || i.prefix === e.bech32) && i.version === 16 && i.data.length === 21)
        return "P2OP";
      if (i.prefix === e.bech32) {
        if (i.version === 0 && i.data.length === 20)
          return "P2WPKH";
        if (i.version === 0 && i.data.length === 32)
          return "P2WSH";
        if (i.version === 1 && i.data.length === 32)
          return "P2TR";
        if (i.version === 2 && i.data.length === 32)
          return "P2MR";
      }
    } catch {
    }
    return null;
  }
  static detectAddressTypeWithWitnessScript(t, e, i) {
    const r = Q.detectAddressType(t, e);
    return r === "P2WSH" && i && Q.isP2WDAWitnessScript(i) ? "P2WDA" : r;
  }
  static validateP2WDAAddress(t, e, i) {
    try {
      if (Q.detectAddressType(t, e) !== "P2WSH")
        return {
          isValid: !1,
          isPotentiallyP2WDA: !1,
          isDefinitelyP2WDA: !1,
          error: "Not a P2WSH address"
        };
      if (!i)
        return {
          isValid: !0,
          isPotentiallyP2WDA: !0,
          isDefinitelyP2WDA: !1
        };
      if (!Q.isP2WDAWitnessScript(i))
        return {
          isValid: !0,
          isPotentiallyP2WDA: !0,
          isDefinitelyP2WDA: !1,
          error: "Witness script does not match P2WDA pattern"
        };
      if (_.p2wsh({
        redeem: { output: i },
        network: e
      }).address !== t)
        return {
          isValid: !1,
          isPotentiallyP2WDA: !1,
          isDefinitelyP2WDA: !1,
          error: "Witness script does not match address"
        };
      const o = Z.extractPublicKeyFromP2WDA(i);
      return o ? {
        isValid: !0,
        isPotentiallyP2WDA: !0,
        isDefinitelyP2WDA: !0,
        publicKey: o
      } : {
        isValid: !1,
        isPotentiallyP2WDA: !1,
        isDefinitelyP2WDA: !1,
        error: "Failed to extract public key from witness script"
      };
    } catch (r) {
      return {
        isValid: !1,
        isPotentiallyP2WDA: !1,
        isDefinitelyP2WDA: !1,
        error: r.message
      };
    }
  }
}
const ht = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;
class Xe {
  /**
   * The maximum increments to try before giving up on deriving a valid x.
   */
  maxTries;
  constructor(t = 1e4) {
    this.maxTries = t;
  }
  /**
   * Main entry point.
   * Given a 32-byte input, ensures we obtain a "real" x on secp256k1.
   * - If the given x is valid, we use it.
   * - Otherwise, we increment x (mod p) until we find one whose (x^3 + 7) is a quadratic residue.
   * Then we return { x, y1, y2 } for that valid point.
   *
   * @param xBytes A 32-byte Uint8Array for the candidate x
   * @param failOnInvalidX (optional) whether to throw if the given x is not a valid curve point, defaults to true
   * @param maxTries (optional) number of increments to attempt, defaults to this.maxTries
   * @returns An object { x: bigint; y1: bigint; y2: bigint } describing a valid curve point
   * @throws If no valid x found within maxTries
   */
  findOrDeriveValidPoint(t, e = !0, i = this.maxTries) {
    if (t.length !== 32)
      throw new Error("xBytes must be exactly 32 bytes.");
    let r = this.bytesToBigInt(t) % ht, s = this.isValidX(r);
    if (e && s === null)
      throw new Error("The given x is not a valid curve point.");
    let o = 0;
    for (; s === null; )
      if (r = (r + 1n) % ht, s = this.isValidX(r), o++, o > i)
        throw new Error(`Could not find a valid X point within ${i} increments.`);
    const a = s, c = (ht - a) % ht;
    return { x: r, y1: a, y2: c };
  }
  /**
   * Given two candidate y values, returns the one with the smaller y-coordinate.
   * @param {bigint} y
   * @param {bigint} y2
   */
  getCanonicalY(t, e) {
    return t < e ? t : e;
  }
  /**
   * Creates a 65-byte "hybrid public key" from the specified x and y.
   * - First byte:
   *   - 0x06 if y is even
   *   - 0x07 if y is odd
   * - Next 32 bytes: x
   * - Last 32 bytes: y
   *
   * @param x X-coordinate as a bigint
   * @param y Y-coordinate as a bigint
   * @returns A Uint8Array of length 65
   */
  getHybridPublicKey(t, e) {
    const i = e % 2n === 0n ? 6 : 7, r = this.bigIntTo32Bytes(t), s = this.bigIntTo32Bytes(e), o = new Uint8Array(65);
    return o[0] = i, o.set(r, 1), o.set(s, 33), o;
  }
  /**
   * Checks if (x^3 + 7) is a quadratic residue mod p.
   * Returns the square root if it is, or null if not.
   */
  isValidX(t) {
    const e = (this.modPow(t, 3n, ht) + 7n) % ht;
    return this.sqrtModP(e, ht);
  }
  /**
   * Computes base^exp (mod m) using exponentiation by squaring.
   */
  modPow(t, e, i) {
    let r = 1n, s = t % i, o = e;
    for (; o > 0; )
      (o & 1n) === 1n && (r = r * s % i), s = s * s % i, o >>= 1n;
    return r;
  }
  /**
   * sqrtModP(a, p):
   *   Attempts to compute the square root of `a` modulo prime `p`.
   *   Returns the root if it exists, or null if `a` is not a quadratic residue.
   *
   * Since p â‰¡ 3 (mod 4), we can do:
   *   sqrt(a) = a^((p+1)/4) mod p
   */
  sqrtModP(t, e) {
    const i = this.modPow(t, e + 1n >> 2n, e);
    return i * i % e !== t % e ? null : i;
  }
  /**
   * Convert a 32-byte Uint8Array (big-endian) to a BigInt.
   */
  bytesToBigInt(t) {
    let e = 0n;
    for (const i of t)
      e = e << 8n | BigInt(i);
    return e;
  }
  /**
   * Convert a BigInt to a 32-byte array (big-endian).
   */
  bigIntTo32Bytes(t) {
    const e = new Uint8Array(32);
    for (let i = 31; i >= 0; i--)
      e[i] = Number(t & 0xffn), t >>= 8n;
    return e;
  }
}
class lr {
  deriver = new Xe();
  generateHybridKeyFromHash(t) {
    const e = this.deriver.findOrDeriveValidPoint(new Uint8Array(t), !1), i = this.deriver.getCanonicalY(e.y1, e.y2);
    return new Uint8Array(this.deriver.getHybridPublicKey(e.x, i));
  }
}
const ce = new lr();
class z {
  static UNSPENDABLE_INTERNAL_KEY = w(
    "50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0"
  );
  static CSV_BLOCKS = 75;
  /**
   * Generate a P2WSH address with CSV timelock
   * Note: This uses ECDSA, not Schnorr (Schnorr only available in Taproot)
   */
  static generateTimeLockAddress(t, e = T.bitcoin, i = z.CSV_BLOCKS) {
    const r = this.generateTimeLockScript(t, i), s = at.payments.p2wsh({
      redeem: { output: r },
      network: e
    });
    if (!s.address)
      throw new Error("Failed to generate P2WSH address");
    return {
      address: s.address,
      witnessScript: r
    };
  }
  /**
   * Generate a P2TR address with CSV time lock
   * Note: This uses Schnorr signatures
   */
  static generateTimeLockAddressP2TR(t, e = T.bitcoin, i = z.CSV_BLOCKS) {
    if (t.length !== 32)
      throw new Error("Public key must be 32 bytes for Taproot");
    const r = this.generateTimeLockScript(t, i), s = at.payments.p2tr({
      redeem: { output: r },
      network: e,
      internalPubkey: z.UNSPENDABLE_INTERNAL_KEY
    });
    if (!s.address)
      throw new Error("Failed to generate P2TR address");
    return s.address;
  }
  /**
   * Generate a P2MR address with CSV time lock
   * Note: This uses Schnorr signatures within a P2MR (BIP 360) script tree
   */
  static generateTimeLockAddressP2MR(t, e = T.bitcoin, i = z.CSV_BLOCKS) {
    if (t.length !== 32)
      throw new Error("Public key must be 32 bytes for P2MR");
    const s = { output: this.generateTimeLockScript(t, i), version: 192 }, o = _.p2mr({ scriptTree: s, network: e });
    if (!o.address)
      throw new Error("Failed to generate P2MR address");
    return o.address;
  }
  static generateTimeLockScript(t, e = z.CSV_BLOCKS) {
    return O.compile([
      O.number.encode(e),
      f.OP_CHECKSEQUENCEVERIFY,
      f.OP_DROP,
      t,
      f.OP_CHECKSIG
    ]);
  }
}
const hr = [1312, 1952, 2592];
class K extends Uint8Array {
  #t;
  #e;
  #n;
  #i;
  #h;
  #r;
  #s;
  #d;
  #a;
  #c;
  #u;
  #l;
  #p;
  #f;
  // Lazy loading state - defers expensive EC operations until actually needed
  #g;
  #S = !1;
  // After processing, this is 32-byte tweaked x-only (same as original behavior)
  #o;
  constructor(t, e) {
    if (super(D), !!t) {
      if (e) {
        if (![D, 33, 65].includes(e.length))
          throw new Error(`Invalid public key length ${e.length}`);
        this.#g = new Uint8Array(e.length), this.#g.set(e);
      }
      this.setMldsaKey(t);
    }
  }
  /**
   * Prevent TypedArray methods (subarray, slice, etc.) from creating Address
   * instances. Without this, @noble/hashes and other libraries that call
   * subarray() on an Address would invoke the Address constructor that recomputes
   * everything leading to bad performance.
   */
  static get [Symbol.species]() {
    return Uint8Array;
  }
  get mldsaLevel() {
    return this.#f;
  }
  set mldsaLevel(t) {
    this.#f = t;
  }
  get originalMDLSAPublicKey() {
    return this.#p;
  }
  set originalMDLSAPublicKey(t) {
    this.#p = t ? new Uint8Array(t) : void 0;
  }
  /**
   * If available, this will return the original public key associated with the address.
   * @returns {Uint8Array} The original public key used to create the address.
   */
  get originalPublicKey() {
    return this.ensureLegacyProcessed(), this.#i;
  }
  get mldsaPublicKey() {
    return this.#a;
  }
  /**
   * Get the legacy public key (32-byte tweaked x-only after processing).
   * Triggers lazy processing if not yet done.
   */
  get legacyPublicKey() {
    return this.ensureLegacyProcessed(), this.#o;
  }
  /**
   * Get the key pair for the address
   * @description This is only for internal use. Please use address.tweakedBytes instead.
   */
  get keyPair() {
    if (this.ensureLegacyProcessed(), !this.#h)
      throw new Error("Legacy public key not set for address");
    return this.#h;
  }
  static dead() {
    return K.fromString(
      "0x0000000000000000000000000000000000000000000000000000000000000000",
      // DEAD ADDRESS
      "0x04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"
    );
  }
  /**
   * Create an address from a hex string
   * @param {string} mldsaPublicKey The ml-dsa public key in hex format
   * @param {string} legacyPublicKey The classical public key in hex format
   * @returns {Address} The address
   */
  static fromString(t, e) {
    if (!t)
      throw new Error("Invalid public key");
    if (t.startsWith("0x") && (t = t.slice(2)), !W.isValidHex(t))
      throw new Error(
        'You must only pass public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.'
      );
    let i;
    if (e) {
      if (e.startsWith("0x") && (e = e.slice(2)), !W.isValidHex(e))
        throw new Error(
          'You must only pass classical public keys in hexadecimal format. If you have an address such as bc1q... you must convert it to a public key first. Please refer to await provider.getPublicKeyInfo("bc1q..."). If the public key associated with the address is not found, you must force the user to enter the destination public key. It looks like: 0x020373626d317ae8788ce3280b491068610d840c23ecb64c14075bbb9f670af52c.'
        );
      i = w(e);
    }
    return new K(w(t), i);
  }
  /**
   * Create an address from a public key
   * @returns {Address} The address
   * @param {ArrayLike<number>} bytes The public key
   */
  static wrap(t) {
    return new K(t);
  }
  static uncompressedToCompressed(t) {
    const e = Uint8Array.from(t), i = e.slice(1, 33), r = e.slice(33), s = new Uint8Array(33);
    return s[0] = 2 + (r[r.length - 1] & 1), s.set(i, 1), s;
  }
  /**
   * Creates an Address instance from a BigInt value.
   *
   * Converts a 256-bit unsigned integer into a 32-byte address by splitting it
   * into four 64-bit chunks and writing them in big-endian format using DataView.
   * This is the inverse operation of toBigInt().
   *
   * @param {bigint} value - The 256-bit unsigned integer to convert (0 to 2^256-1)
   * @param {bigint} [tweakedValue] - Optional tweaked public key as a 256-bit unsigned integer
   * @returns {Address} A new Address instance containing the converted value
   *
   * @throws {RangeError} If the value is negative or exceeds 2^256-1
   *
   * @example
   * ```typescript
   * const bigIntValue = 12345678901234567890n;
   * const address = Address.fromBigInt(bigIntValue);
   * console.log(address.toHex()); // 0x0000000000000000000000000000000000000000000000000000abc123...
   * ```
   */
  static fromBigInt(t, e) {
    const i = K.bigintToUint8Array(t), r = e !== void 0 ? K.bigintToUint8Array(e) : void 0;
    return new K(i, r);
  }
  /**
   * Creates an Address instance from four 64-bit unsigned integers.
   *
   * Constructs a 32-byte address by combining four 64-bit big-endian unsigned integers.
   * This is the inverse operation of toUint64Array() and provides an efficient way
   * to create addresses from word-aligned data.
   *
   * @param {bigint} w0 - Most significant 64 bits (bytes 0-7)
   * @param {bigint} w1 - Second 64 bits (bytes 8-15)
   * @param {bigint} w2 - Third 64 bits (bytes 16-23)
   * @param {bigint} w3 - Least significant 64 bits (bytes 24-31)
   * @returns {Address} A new Address instance containing the combined value
   *
   * @throws {RangeError} If any value exceeds 64 bits (2^64-1)
   *
   * @example
   * ```typescript
   * const address = Address.fromUint64Array(
   *     0x0123456789abcdefn,
   *     0xfedcba9876543210n,
   *     0x1111222233334444n,
   *     0x5555666677778888n
   * );
   * console.log(address.toHex());
   * ```
   */
  static fromUint64Array(t, e, i, r) {
    const s = new Uint8Array(32), o = new DataView(s.buffer);
    return o.setBigUint64(0, t, !1), o.setBigUint64(8, e, !1), o.setBigUint64(16, i, !1), o.setBigUint64(24, r, !1), new K(s);
  }
  static bigintToUint8Array(t) {
    const e = new Uint8Array(32), i = new DataView(e.buffer);
    return i.setBigUint64(0, t >> 192n & 0xffffffffffffffffn, !1), i.setBigUint64(8, t >> 128n & 0xffffffffffffffffn, !1), i.setBigUint64(16, t >> 64n & 0xffffffffffffffffn, !1), i.setBigUint64(24, t & 0xffffffffffffffffn, !1), e;
  }
  [Symbol.dispose]() {
    this.fill(0), this.#t = void 0, this.#e = void 0, this.#n = void 0, this.#i = void 0, this.#h = void 0, this.#r = void 0, this.#s = void 0, this.#d = void 0, this.#a?.fill(0), this.#a = void 0, this.#c = void 0, this.#u = void 0, this.#l = void 0, this.#p?.fill(0), this.#p = void 0, this.#f = void 0, this.#S = !1, this.#o = void 0;
  }
  /**
   * Converts the address to four 64-bit unsigned integers.
   *
   * Splits the 32-byte (256-bit) address into four 64-bit big-endian unsigned integers.
   * This representation is useful for efficient storage, comparison operations, or
   * interfacing with systems that work with 64-bit word sizes.
   *
   * @returns {[bigint, bigint, bigint, bigint]} An array of four 64-bit unsigned integers
   *          representing the address from most significant to least significant bits
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...');
   * const [w0, w1, w2, w3] = address.toUint64Array();
   * console.log(w0); // Most significant 64 bits
   * console.log(w3); // Least significant 64 bits
   * ```
   */
  toUint64Array() {
    if (this.#l !== void 0)
      return this.#l;
    const t = new DataView(this.buffer, this.byteOffset, 32);
    return this.#l = [
      t.getBigUint64(0, !1),
      t.getBigUint64(8, !1),
      t.getBigUint64(16, !1),
      t.getBigUint64(24, !1)
    ], this.#l;
  }
  /**
   * Check if the address is the dead address
   * @returns {boolean}
   */
  isDead() {
    for (let t = 0; t < D; t++)
      if (this[t] !== 0)
        return !1;
    return !0;
  }
  /**
   * Converts the address to a hex string
   * @returns {string} The hex string
   */
  toHex() {
    return "0x" + g(this);
  }
  /**
   * Converts the classical public key to a hex string
   * @returns {string} The hex string
   */
  tweakedToHex() {
    const t = this.legacyPublicKey;
    if (!t)
      throw new Error("Legacy public key not set");
    return "0x" + g(t);
  }
  /**
   * Converts the address content (SHA256 hash of ML-DSA public key) to a Uint8Array
   * @returns {Uint8Array} The Uint8Array containing the hashed ML-DSA public key
   */
  toBuffer() {
    return new Uint8Array(this);
  }
  /**
   * Converts the classical public key to a Uint8Array
   * @returns {Uint8Array} The Uint8Array
   */
  tweakedPublicKeyToBuffer() {
    const t = this.legacyPublicKey;
    if (!t)
      throw new Error("Legacy public key not set");
    return new Uint8Array(t);
  }
  toUncompressedHex() {
    if (this.ensureLegacyProcessed(), !this.#r)
      throw new Error("Legacy public key not set");
    return "0x" + g(this.#r.uncompressed);
  }
  toUncompressedBuffer() {
    if (this.ensureLegacyProcessed(), !this.#r)
      throw new Error("Legacy public key not set");
    return this.#r.uncompressed;
  }
  toHybridPublicKeyHex() {
    if (this.ensureLegacyProcessed(), !this.#r)
      throw new Error("Legacy public key not set");
    return "0x" + g(this.#r.hybrid);
  }
  toHybridPublicKeyBuffer() {
    if (this.ensureLegacyProcessed(), !this.#r)
      throw new Error("Legacy public key not set");
    return this.#r.hybrid;
  }
  originalPublicKeyBuffer() {
    if (this.ensureLegacyProcessed(), !this.#i)
      throw new Error("Legacy public key not set");
    return new Uint8Array(this.#i);
  }
  /**
   * Converts the address to a BigInt representation.
   *
   * This method uses an optimized DataView approach to read the 32-byte address
   * as four 64-bit big-endian unsigned integers, then combines them using bitwise
   * operations. This is approximately 10-20x faster than string-based conversion.
   *
   * @returns {bigint} The address as a 256-bit unsigned integer
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...');
   * const bigIntValue = address.toBigInt();
   * console.log(bigIntValue); // 123456789...n
   * ```
   */
  toBigInt() {
    if (this.#c !== void 0)
      return this.#c;
    const t = new DataView(this.buffer, this.byteOffset, 32);
    return this.#c = t.getBigUint64(0, !1) << 192n | t.getBigUint64(8, !1) << 128n | t.getBigUint64(16, !1) << 64n | t.getBigUint64(24, !1), this.#c;
  }
  /**
   * Converts the tweaked public key to a BigInt representation.
   *
   * This method uses an optimized DataView approach to read the 32-byte address
   * as four 64-bit big-endian unsigned integers, then combines them using bitwise
   * operations. This is approximately 10-20x faster than string-based conversion.
   *
   * @returns {bigint} The address as a 256-bit unsigned integer
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x0123456789abcdef...', '0xtweaked...');
   * const bigIntValue = address.tweakedToBigInt();
   * console.log(bigIntValue); // 123456789...n
   * ```
   */
  tweakedToBigInt() {
    if (!this.legacyPublicKey)
      throw new Error("Legacy public key not set");
    if (this.#u !== void 0)
      return this.#u;
    const t = new DataView(this.legacyPublicKey.buffer, this.byteOffset, 32);
    return this.#u = t.getBigUint64(0, !1) << 192n | t.getBigUint64(8, !1) << 128n | t.getBigUint64(16, !1) << 64n | t.getBigUint64(24, !1), this.#u;
  }
  equals(t) {
    const e = this;
    if (t.length !== e.length)
      return !1;
    for (let i = 0; i < e.length; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  /**
   * Check if the address is bigger than another address
   * @returns {boolean} If bigger
   */
  lessThan(t) {
    const e = this;
    for (let i = 0; i < D; i++) {
      const r = e[i], s = t[i];
      if (r < s)
        return !0;
      if (r > s)
        return !1;
    }
    return !1;
  }
  /**
   * Check if the address is smaller than another address
   * @returns {boolean} If smaller
   */
  greaterThan(t) {
    const e = this;
    for (let i = 0; i < D; i++) {
      const r = e[i], s = t[i];
      if (r > s)
        return !0;
      if (r < s)
        return !1;
    }
    return !1;
  }
  /**
   * Set the public key
   * @param {ArrayLike<number>} mldsaPublicKey ML-DSA public key
   * @returns {void}
   */
  set(t) {
    this.setMldsaKey(t);
  }
  /**
   * Check if the public key is valid
   * @param {Network} network The network
   * @returns {boolean} If the public key is valid
   */
  isValidLegacyPublicKey(t) {
    const e = this.legacyPublicKey;
    if (!e)
      throw new Error("Legacy key not set.");
    return Q.isValidPublicKey(g(e), t);
  }
  /**
   * Get the public key as address
   */
  p2pk() {
    return this.toHex();
  }
  /**
   * Get the address in p2wpkh format
   * @param {Network} network The network
   */
  p2wpkh(t) {
    return P.getP2WPKHAddress(this.keyPair, t);
  }
  /**
   * Get the address in p2pkh format
   * @param {Network} network The network
   */
  p2pkh(t) {
    return P.getLegacyAddress(this.keyPair, t);
  }
  /**
   * Get the address in p2sh-p2wpkh format
   * @param {Network} network The network
   */
  p2shp2wpkh(t) {
    return P.getLegacySegwitAddress(this.keyPair, t);
  }
  /**
   * Convert the address to a string
   */
  toString() {
    return this.toHex();
  }
  /**
   * Convert the address to a JSON string
   */
  toJSON() {
    return this.toHex();
  }
  /**
   * Get the address in p2tr format
   * @param {Network} network The network
   */
  p2tr(t) {
    if (this.#t && this.#n === t)
      return this.#t;
    const e = this.legacyPublicKey;
    if (!e)
      throw new Error("Legacy public key not set");
    const i = P.tweakedPubKeyBufferToAddress(e, t);
    if (i)
      return this.#n = t, this.#t = i, i;
    throw new Error("Legacy public key not set");
  }
  /**
   * Generate a P2WDA (Pay-to-Witness-Data-Authentication) address
   *
   * P2WDA addresses are a special type of P2WSH address that allows embedding
   * authenticated data directly in the witness field, achieving 75% cost reduction
   * through Bitcoin's witness discount.
   *
   * The witness script pattern is: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   * This allows up to 10 witness data fields (5 * 2 = 10), where each field
   * can hold up to 80 bytes of data due to relay rules.
   *
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The P2WDA address
   * @throws {Error} If the public key is not set or address generation fails
   *
   * @example
   * ```typescript
   * const address = Address.fromString('0x02...');
   * const p2wdaAddress = address.p2wda(networks.bitcoin);
   * console.log(p2wdaAddress); // bc1q...
   * ```
   */
  p2wda(t) {
    if (this.#d && this.#n === t)
      return this.#d;
    if (this.ensureLegacyProcessed(), !this.#i)
      throw new Error("Cannot create P2WDA address: public key not set");
    const e = new Uint8Array(this.#i);
    if (e.length !== 33)
      throw new Error("P2WDA requires a compressed public key (33 bytes)");
    try {
      const i = Z.generateP2WDAAddress(e, t);
      return this.#n = t, this.#d = i, {
        address: i.address,
        witnessScript: i.witnessScript
      };
    } catch (i) {
      throw new Error(`Failed to generate P2WDA address: ${i.message}`, {
        cause: i
      });
    }
  }
  /**
   * Generate a P2WSH address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The timelocked address and its witness script
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSV(t, e) {
    const i = Number(t);
    if (i < 1 || i > 65535)
      throw new Error("CSV block number must be between 1 and 65535");
    if (this.ensureLegacyProcessed(), !this.#i)
      throw new Error("Cannot create CSV address: public key not set");
    const r = new Uint8Array(this.#i);
    return z.generateTimeLockAddress(r, e, i);
  }
  /**
   * Generate a P2TR address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {IP2WSHAddress} The timelocked address and its witness script
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSVTweaked(t, e) {
    const i = Number(t);
    if (i < 1 || i > 65535)
      throw new Error("CSV block number must be between 1 and 65535");
    if (this.ensureLegacyProcessed(), !this.#i)
      throw new Error("Cannot create CSV address: public key not set");
    return z.generateTimeLockAddressP2TR(
      this.tweakedPublicKeyToBuffer(),
      e,
      i
    );
  }
  /**
   * Generate a P2MR address with CSV (CheckSequenceVerify) time lock
   * The resulting address can only be spent after the specified number of blocks
   * have passed since the UTXO was created. Uses P2MR (BIP 360) instead of P2TR.
   *
   * @param {bigint | number | string} duration - The number of blocks that must pass before spending (1-65535)
   * @param {Network} network - The Bitcoin network to use
   * @returns {string} The timelocked P2MR address
   * @throws {Error} If the block number is out of range or public key is not available
   */
  toCSVP2MR(t, e) {
    const i = Number(t);
    if (i < 1 || i > 65535)
      throw new Error("CSV block number must be between 1 and 65535");
    if (this.ensureLegacyProcessed(), !this.#o)
      throw new Error("Cannot create CSV P2MR address: public key not set");
    return z.generateTimeLockAddressP2MR(
      this.tweakedPublicKeyToBuffer(),
      e,
      i
    );
  }
  /**
   * Returns the OPNet address encoded in bech32m format, derived from the SHA256 hash of the ML-DSA public key
   * (which is what the Address internally stores).
   *
   * This method generates a P2OP (Pay-to-OPNet) address using witness version 16, suitable for
   * quantum-resistant transactions on the OPNet protocol.
   *
   * @param network - The Bitcoin network to use (mainnet, testnet, regtest)
   * @returns The P2OP address in bech32m format
   */
  p2op(t) {
    if (this.#e && this.#n === t)
      return this.#e;
    const e = P.p2op(this, t);
    if (e)
      return this.#n = t, this.#e = e, e;
    throw new Error("ML-DSA public key not set");
  }
  toTweakedHybridPublicKeyHex() {
    if (this.ensureLegacyProcessed(), this.ensureTweakedUncompressed(), !this.#s)
      throw new Error("Legacy public key not set");
    return "0x" + g(this.#s);
  }
  toTweakedHybridPublicKeyBuffer() {
    if (this.ensureLegacyProcessed(), this.ensureTweakedUncompressed(), !this.#s)
      throw new Error("Legacy public key not set");
    return this.#s;
  }
  /**
   * Lazily generates the tweaked uncompressed/hybrid key from the legacy public key.
   * Only called when toTweakedHybridPublicKey* methods are accessed.
   */
  ensureTweakedUncompressed() {
    if (this.#s) return;
    const t = this.#o;
    if (t && t.length === D && !this.#i)
      try {
        this.#s = ce.generateHybridKeyFromHash(t);
      } catch {
      }
  }
  /**
   * Sets the MLDSA key portion of the address.
   * @param {ArrayLike<number>} mldsaPublicKey - The MLDSA public key or its hash
   */
  setMldsaKey(t) {
    if (t.length === D) {
      const e = new Uint8Array(D);
      e.set(t), super.set(e);
    } else {
      if (!hr.includes(t.length))
        throw new Error(
          `Invalid ML-DSA public key length: ${t.length}. Expected 1312 (ML-DSA-44/LEVEL2), 1952 (ML-DSA-65/LEVEL3), or 2592 (ML-DSA-87/LEVEL5) bytes.`
        );
      this.#a = new Uint8Array(t.length), this.#a.set(t);
      const e = te(new Uint8Array(t)), i = new Uint8Array(D);
      i.set(e), super.set(i);
    }
  }
  /**
   * Lazy processing of legacy key - defers expensive EC operations until actually needed.
   * Does the EXACT same logic as the original set() method did for legacy keys.
   */
  ensureLegacyProcessed() {
    if (this.#S) return;
    this.#S = !0;
    const t = this.#g;
    t && (t.length === D ? this.#o = t : this.autoFormat(t));
  }
  /**
   * Processes a 33 or 65 byte public key, performing EC operations.
   * Sets #tweakedPublicKey to 32-byte tweaked x-only (same as original behavior).
   */
  autoFormat(t) {
    const e = t[0];
    e === 3 || e === 2 || (e === 4 || e === 6 || e === 7) && (t = K.uncompressedToCompressed(t)), this.#i = Uint8Array.from(t), this.#h = P.fromPublicKey(this.#i), this.#r = Ui(this.#i);
    const i = U(
      P.tweakPublicKey(this.#i)
    );
    this.#s = ce.generateHybridKeyFromHash(i), this.#o = new Uint8Array(D), this.#o.set(i);
  }
}
class It {
  _keys = [];
  _values = {};
  constructor(t) {
    if (t instanceof It)
      this.setAll(t);
    else if (t)
      for (const [e, i] of t)
        this.set(e, i);
  }
  get size() {
    return this._keys.length;
  }
  setAll(t) {
    this._keys = [...t._keys], this._values = { ...t._values };
  }
  addAll(t) {
    for (const [e, i] of t.entries())
      this.set(e, i);
  }
  *keys() {
    yield* this._keys;
  }
  *values() {
    for (const t of this._keys)
      yield this._values[t];
  }
  *entries() {
    for (const t of this._keys)
      yield [t, this._values[t]];
  }
  set(t, e) {
    return this.has(t) || this._keys.push(t), this._values[t] = e, this;
  }
  indexOf(t) {
    if (!this.has(t))
      return -1;
    for (let e = 0; e < this._keys.length; e++)
      if (this._keys[e] === t)
        return e;
    throw new Error("Key not found, this should not happen.");
  }
  get(t) {
    return this._values[t];
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this._values, t);
  }
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = this.indexOf(t);
    return this._keys.splice(e, 1), delete this._values[t], !0;
  }
  clear() {
    this._keys = [], this._values = {};
  }
  [Symbol.dispose]() {
    this.clear();
  }
  forEach(t, e) {
    for (const i of this._keys)
      t.call(e, this._values[i], i, this);
  }
  *[Symbol.iterator]() {
    for (const t of this._keys)
      yield [t, this._values[t]];
  }
}
class $e {
  items;
  constructor(t) {
    if (this.items = new It(), t)
      for (const [e, i] of t)
        this.set(e, i);
  }
  get size() {
    return this.items.size;
  }
  set(t, e) {
    const i = t.toBigInt();
    return this.items.set(i, e), this;
  }
  get(t) {
    return this.items.get(t.toBigInt());
  }
  has(t) {
    return this.items.has(t.toBigInt());
  }
  delete(t) {
    const e = t.toBigInt();
    return this.items.delete(e);
  }
  clear() {
    this.items.clear();
  }
  [Symbol.dispose]() {
    this.clear();
  }
  indexOf(t) {
    return this.items.indexOf(t.toBigInt());
  }
  /**
   * WARNING, THIS RETURN NEW COPY OF THE KEYS
   */
  *entries() {
    for (const [t, e] of this.items.entries())
      yield [K.fromBigInt(t), e];
  }
  *keys() {
    for (const t of this.items.keys())
      yield K.fromBigInt(t);
  }
  *values() {
    for (const t of this.items.values())
      yield t;
  }
  forEach(t, e) {
    for (const [i, r] of this.items.entries()) {
      const s = K.fromBigInt(i);
      t.call(e, r, s, this);
    }
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
}
class Ye {
  // Store tweaked bigint -> index mapping for fast lookup
  indexMap;
  // Store actual addresses and values
  _keys = [];
  _values = [];
  constructor(t) {
    if (this.indexMap = new It(), t)
      for (const [e, i] of t)
        this.set(e, i);
  }
  get size() {
    return this._keys.length;
  }
  set(t, e) {
    const i = t.tweakedToBigInt(), r = this.indexMap.get(i);
    if (r !== void 0)
      this._values[r] = e;
    else {
      const s = this._keys.length;
      this._keys.push(t), this._values.push(e), this.indexMap.set(i, s);
    }
    return this;
  }
  get(t) {
    const e = t.tweakedToBigInt(), i = this.indexMap.get(e);
    if (i !== void 0)
      return this._values[i];
  }
  has(t) {
    return this.indexMap.has(t.tweakedToBigInt());
  }
  delete(t) {
    const e = t.tweakedToBigInt(), i = this.indexMap.get(e);
    if (i === void 0)
      return !1;
    this._keys.splice(i, 1), this._values.splice(i, 1), this.indexMap.clear();
    for (let r = 0; r < this._keys.length; r++)
      this.indexMap.set(this._keys[r].tweakedToBigInt(), r);
    return !0;
  }
  clear() {
    this.indexMap.clear(), this._keys = [], this._values = [];
  }
  [Symbol.dispose]() {
    this.clear();
  }
  indexOf(t) {
    const e = this.indexMap.get(t.tweakedToBigInt());
    return e !== void 0 ? e : -1;
  }
  *entries() {
    for (let t = 0; t < this._keys.length; t++)
      yield [this._keys[t], this._values[t]];
  }
  *keys() {
    for (const t of this._keys)
      yield t;
  }
  *values() {
    for (const t of this._values)
      yield t;
  }
  forEach(t, e) {
    for (let i = 0; i < this._keys.length; i++)
      t.call(e, this._values[i], this._keys[i], this);
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
}
class Wt {
  static EXPECTED_BUFFER_LENGTH = 32;
  static bufferToUint8Array(t) {
    const e = new Uint8Array(t.byteLength);
    return e.set(t), e;
  }
  static uint8ArrayToHex(t) {
    return g(t);
  }
  static hexToUint8Array(t) {
    let e = t;
    return e.length >= 2 && e[0] === "0" && (e[1] === "x" || e[1] === "X") && (e = e.slice(2)), e.length % 2 !== 0 && (e = "0" + e), w(e);
  }
  static pointerToUint8Array(t) {
    if (t < 0n)
      throw new RangeError("Pointer cannot be negative");
    const e = t.toString(16).padStart(64, "0");
    if (e.length > 64)
      throw new RangeError("Pointer exceeds 256-bit range");
    return w(e);
  }
  static uint8ArrayToPointer(t) {
    return t.length === 0 ? 0n : BigInt("0x" + g(t));
  }
  static valueToUint8Array(t, e = kt) {
    if (t < 0n)
      throw new RangeError("Value cannot be negative");
    const i = t.toString(16).padStart(e * 2, "0");
    if (i.length > e * 2)
      throw new RangeError(`Value exceeds ${e}-byte range`);
    return w(i);
  }
  static uint8ArrayToValue(t) {
    return t.length === 0 ? 0n : BigInt("0x" + g(t));
  }
}
class ee {
  buffer;
  currentOffset = 0;
  constructor(t) {
    this.buffer = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  get byteLength() {
    return this.buffer.byteLength;
  }
  // Helpers for comparisons; unchanged
  static stringCompare(t, e) {
    return t.localeCompare(e);
  }
  static bigintCompare(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  static numberCompare(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  setBuffer(t) {
    this.buffer = new DataView(t.buffer, t.byteOffset, t.byteLength), this.currentOffset = 0;
  }
  length() {
    return this.buffer.byteLength;
  }
  bytesLeft() {
    return this.buffer.byteLength - this.currentOffset;
  }
  // ------------------- Signed Integer Readers ------------------- //
  /**
   * Reads a single signed byte (i8).
   */
  readI8() {
    this.verifyEnd(this.currentOffset + xt);
    const t = this.buffer.getInt8(this.currentOffset);
    return this.currentOffset += xt, t;
  }
  /**
   * Reads a signed 16-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readI16(t = !0) {
    this.verifyEnd(this.currentOffset + Kt);
    const e = this.buffer.getInt16(this.currentOffset, !t);
    return this.currentOffset += Kt, e;
  }
  /**
   * Reads a signed 32-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readI32(t = !0) {
    this.verifyEnd(this.currentOffset + Rt);
    const e = this.buffer.getInt32(this.currentOffset, !t);
    return this.currentOffset += Rt, e;
  }
  /**
   * Reads a signed 64-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readI64(t = !0) {
    this.verifyEnd(this.currentOffset + Lt);
    const e = this.buffer.getBigInt64(this.currentOffset, !t);
    return this.currentOffset += Lt, e;
  }
  // ------------------- Unsigned Integer Readers ------------------- //
  /**
   * Reads a single unsigned byte (u8).
   */
  readU8() {
    this.verifyEnd(this.currentOffset + Xt);
    const t = this.buffer.getUint8(this.currentOffset);
    return this.currentOffset += Xt, t;
  }
  /**
   * Reads an unsigned 16-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU16(t = !0) {
    this.verifyEnd(this.currentOffset + At);
    const e = this.buffer.getUint16(this.currentOffset, !t);
    return this.currentOffset += At, e;
  }
  /**
   * Reads an unsigned 32-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU32(t = !0) {
    this.verifyEnd(this.currentOffset + bt);
    const e = this.buffer.getUint32(this.currentOffset, !t);
    return this.currentOffset += bt, e;
  }
  /**
   * Reads an unsigned 64-bit integer. By default, big-endian.
   * @param be - Endianness; true means big-endian (the default).
   */
  readU64(t = !0) {
    this.verifyEnd(this.currentOffset + qt);
    const e = this.buffer.getBigUint64(this.currentOffset, !t);
    return this.currentOffset += qt, e;
  }
  /**
   * Reads a 128-bit unsigned integer. By default, read big-endian.
   * @param be - Endianness; true => big-endian (default).
   */
  readU128(t = !0) {
    const e = this.readBytes(Ut);
    let i = e;
    return t || (i = this.reverseBytes(e)), BigInt("0x" + this.toHexString(i));
  }
  /**
   * Reads a 256-bit unsigned integer. Same approach as readU128.
   * @param be - Endianness; true => big-endian (default).
   */
  readU256(t = !0) {
    const e = this.readBytes(kt);
    let i = e;
    return t || (i = this.reverseBytes(e)), BigInt("0x" + this.toHexString(i));
  }
  /**
   * Reads a 128-bit signed integer. Interpret the sign bit if big-endian.
   * @param be - Endianness; true => big-endian (default).
   */
  readI128(t = !0) {
    const e = this.readBytes(_t);
    let i = e;
    t || (i = this.reverseBytes(e));
    let r = BigInt("0x" + this.toHexString(i));
    if (i[0] & 128) {
      const o = BigInt(1) << BigInt(128);
      r = r - o;
    }
    return r;
  }
  /**
   * Read a boolean (u8 != 0).
   */
  readBoolean() {
    return this.readU8() !== 0;
  }
  /**
   * Reads 32 bits
   */
  readSelector() {
    return this.readU32(!0);
  }
  /**
   * Reads a raw sequence of bytes (length must be known).
   * If zeroStop = true, stops if we encounter 0x00 early.
   */
  readBytes(t, e = !1) {
    this.verifyEnd(this.currentOffset + t);
    let i = new Uint8Array(t);
    for (let r = 0; r < t; r++) {
      const s = this.buffer.getUint8(this.currentOffset++);
      if (e && s === 0) {
        i = new Uint8Array(i.subarray(0, r));
        break;
      }
      i[r] = s;
    }
    return i;
  }
  /**
   * Reads a string of the given length in raw bytes. By default, do NOT zero-stop
   * (matching how we wrote the raw bytes).
   */
  readString(t) {
    const e = new TextDecoder(), i = this.readBytes(t, !1);
    return e.decode(i);
  }
  /**
   * Reads a string that was written as [u16 length][raw bytes].
   */
  readStringWithLength(t = !0) {
    const e = this.readU32(t);
    return this.readString(e);
  }
  /**
   * Reads an address (32 bytes MLDSA key hash only).
   */
  readAddress() {
    const t = Array.from(this.readBytes(D));
    return new K(t);
  }
  /**
   * Reads the tweaked public key portion (32 bytes) and returns it as a raw Uint8Array.
   * Use this when you only need the tweaked key without the full Address object.
   */
  readTweakedPublicKey() {
    return this.verifyEnd(this.currentOffset + D), this.readBytes(D);
  }
  /**
   * Reads a full address with both MLDSA key hash and tweaked public key (64 bytes total).
   * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
   *
   * This is the equivalent of btc-runtime's readExtendedAddress().
   *
   * @returns An Address instance with both keys set
   */
  readExtendedAddress() {
    this.verifyEnd(this.currentOffset + mt);
    const t = Array.from(this.readBytes(D)), e = Array.from(this.readBytes(D));
    return new K(e, t);
  }
  /**
   * Reads a Schnorr signature with its associated full Address.
   * Format: [64 bytes full Address][64 bytes signature]
   *
   * Used for deserializing signed data where both the signer's address
   * and their Schnorr signature are stored together.
   *
   * @returns A SchnorrSignature containing the address and signature
   */
  readSchnorrSignature() {
    this.verifyEnd(
      this.currentOffset + mt + Tt
    );
    const t = this.readExtendedAddress(), e = this.readBytes(Tt);
    return { address: t, signature: e };
  }
  /**
   * Reads bytes written as [u32 length][bytes].
   * @param maxLength if > 0, enforces an upper bound
   * @param be
   */
  readBytesWithLength(t = 0, e = !0) {
    const i = this.readU32(e);
    if (t > 0 && i > t)
      throw new Error("Data length exceeds maximum length.");
    return this.readBytes(i);
  }
  // ------------------ Array readers ------------------ //
  readArrayOfBuffer(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readBytesWithLength();
    return i;
  }
  readAddressArray(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readAddress();
    return i;
  }
  readU256Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU256(t);
    return i;
  }
  readU128Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU128(t);
    return i;
  }
  readU64Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU64(t);
    return i;
  }
  readU32Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU32(t);
    return i;
  }
  readU16Array(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readU16(t);
    return i;
  }
  readU8Array() {
    const t = this.readU16(!0), e = new Array(t);
    for (let i = 0; i < t; i++)
      e[i] = this.readU8();
    return e;
  }
  readStringArray(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readStringWithLength(t);
    return i;
  }
  readBytesArray(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readBytesWithLength(0, t);
    return i;
  }
  /**
   * Reads [u16 length][ (address, u256) pairs ].
   */
  readAddressValueTuple(t = !0) {
    const e = this.readU16(t), i = new $e();
    for (let r = 0; r < e; r++) {
      const s = this.readAddress(), o = this.readU256(t);
      if (i.has(s))
        throw new Error("Duplicate address found in map");
      i.set(s, o);
    }
    return i;
  }
  /**
   * Reads an array of full addresses (64 bytes each).
   * Format: [u16 length][FullAddress 0][FullAddress 1]...
   */
  readExtendedAddressArray(t = !0) {
    const e = this.readU16(t), i = new Array(e);
    for (let r = 0; r < e; r++)
      i[r] = this.readExtendedAddress();
    return i;
  }
  /**
   * Reads a map of full Address -> u256 using the tweaked key for map lookup.
   * Format: [u16 length][FullAddress key][u256 value]...
   *
   * This is the equivalent of btc-runtime's readExtendedAddressMapU256().
   */
  readExtendedAddressMapU256(t = !0) {
    const e = this.readU16(t), i = new Ye();
    for (let r = 0; r < e; r++) {
      const s = this.readExtendedAddress(), o = this.readU256(t);
      if (i.has(s))
        throw new Error("Duplicate tweaked address found in map");
      i.set(s, o);
    }
    return i;
  }
  // --------------------------------------------------- //
  getOffset() {
    return this.currentOffset;
  }
  setOffset(t) {
    this.currentOffset = t;
  }
  /**
   * Verifies we have enough bytes in the buffer to read up to `size`.
   */
  verifyEnd(t) {
    if (t > this.buffer.byteLength)
      throw new Error(
        `Attempt to read beyond buffer length: requested up to byte offset ${t}, but buffer is only ${this.buffer.byteLength} bytes.`
      );
  }
  /**
   * Utility: reverses a byte array in-place or returns a reversed copy.
   */
  reverseBytes(t) {
    const e = new Uint8Array(t.length);
    for (let i = 0; i < t.length; i++)
      e[i] = t[t.length - 1 - i];
    return e;
  }
  /**
   * Utility: turn bytes into a hex string without `0x` prefix.
   */
  toHexString(t) {
    return Array.from(t, (e) => e.toString(16).padStart(2, "0")).join("");
  }
}
class V {
  currentOffset = 0;
  buffer;
  constructor(t = 0) {
    this.buffer = this.getDefaultBuffer(t);
  }
  static estimateArrayOfBufferLength(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    let e = At;
    for (let i = 0; i < t.length; i++)
      e += bt + t[i].length;
    return e;
  }
  writeU8(t) {
    if (t > 255) throw new Error("u8 value is too large.");
    this.allocSafe(Xt), this.buffer.setUint8(this.currentOffset++, t);
  }
  writeU16(t, e = !0) {
    if (t > 65535) throw new Error("u16 value is too large.");
    this.allocSafe(At), this.buffer.setUint16(this.currentOffset, t, !e), this.currentOffset += 2;
  }
  writeU32(t, e = !0) {
    if (t > 4294967295) throw new Error("u32 value is too large.");
    this.allocSafe(bt), this.buffer.setUint32(this.currentOffset, t, !e), this.currentOffset += 4;
  }
  writeU64(t, e = !0) {
    if (t > 18446744073709551615n) throw new Error("u64 value is too large.");
    this.allocSafe(qt), this.buffer.setBigUint64(this.currentOffset, t, !e), this.currentOffset += 8;
  }
  // ------------------- Signed Integer Writers ------------------- //
  /**
   * Writes a signed 8-bit integer.
   */
  writeI8(t) {
    if (t < -128 || t > 127) throw new Error("i8 value is out of range.");
    this.allocSafe(xt), this.buffer.setInt8(this.currentOffset, t), this.currentOffset += xt;
  }
  /**
   * Writes a signed 16-bit integer. By default big-endian (be = true).
   */
  writeI16(t, e = !0) {
    if (t < -32768 || t > 32767) throw new Error("i16 value is out of range.");
    this.allocSafe(Kt), this.buffer.setInt16(this.currentOffset, t, !e), this.currentOffset += Kt;
  }
  /**
   * Writes a signed 32-bit integer. By default big-endian (be = true).
   */
  writeI32(t, e = !0) {
    if (t < -2147483648 || t > 2147483647)
      throw new Error("i32 value is out of range.");
    this.allocSafe(Rt), this.buffer.setInt32(this.currentOffset, t, !e), this.currentOffset += Rt;
  }
  /**
   * Writes a signed 64-bit integer. By default big-endian (be = true).
   */
  writeI64(t, e = !0) {
    if (t < -9223372036854775808n || t > 9223372036854775807n)
      throw new Error("i64 value is out of range.");
    this.allocSafe(Lt), this.buffer.setBigInt64(this.currentOffset, t, !e), this.currentOffset += Lt;
  }
  // ---------------------------------------------------------------- //
  writeSelector(t) {
    this.writeU32(t, !0);
  }
  writeBoolean(t) {
    this.writeU8(t ? 1 : 0);
  }
  writeI128(t, e = !0) {
    if (t > 170141183460469231731687303715884105727n || t < -170141183460469231731687303715884105728n)
      throw new Error("i128 value is too large.");
    this.allocSafe(_t);
    const i = Wt.valueToUint8Array(t, _t);
    if (i.byteLength !== _t)
      throw new Error(`Invalid i128 value: ${t}`);
    if (e)
      for (let r = 0; r < i.byteLength; r++)
        this.writeU8(i[r]);
    else
      for (let r = i.byteLength - 1; r >= 0; r--)
        this.writeU8(i[r]);
  }
  writeU256(t, e = !0) {
    if (t > 115792089237316195423570985008687907853269984665640564039457584007913129639935n && t < 0n)
      throw new Error("u256 value is too large or negative.");
    this.allocSafe(kt);
    const i = Wt.valueToUint8Array(t);
    if (i.byteLength !== kt)
      throw new Error(`Invalid u256 value: ${t}`);
    if (e)
      for (let r = 0; r < i.byteLength; r++)
        this.writeU8(i[r]);
    else
      for (let r = i.byteLength - 1; r >= 0; r--)
        this.writeU8(i[r]);
  }
  writeU128(t, e = !0) {
    if (t > 340282366920938463463374607431768211455n && t < 0n)
      throw new Error("u128 value is too large or negative.");
    this.allocSafe(Ut);
    const i = Wt.valueToUint8Array(t, Ut);
    if (i.byteLength !== Ut)
      throw new Error(`Invalid u128 value: ${t}`);
    if (e)
      for (let r = 0; r < i.byteLength; r++)
        this.writeU8(i[r]);
    else
      for (let r = i.byteLength - 1; r >= 0; r--)
        this.writeU8(i[r]);
  }
  writeBytes(t) {
    this.allocSafe(t.byteLength);
    for (let e = 0; e < t.byteLength; e++)
      this.writeU8(t[e]);
  }
  writeString(t) {
    const i = new TextEncoder().encode(t);
    this.allocSafe(i.length), this.writeBytes(i);
  }
  writeStringWithLength(t) {
    const i = new TextEncoder().encode(t);
    this.allocSafe(bt + i.length), this.writeU32(i.length), this.writeBytes(i);
  }
  /**
   * Writes an address (32 bytes MLDSA key hash only).
   */
  writeAddress(t) {
    this.verifyAddress(t), this.writeBytes(t);
  }
  /**
   * Writes the tweaked public key from an Address (32 bytes).
   * @param value - The Address containing the tweaked public key
   */
  writeTweakedPublicKey(t) {
    const e = t.tweakedPublicKeyToBuffer();
    this.allocSafe(D), this.writeBytes(e);
  }
  /**
   * Writes a full address with both tweaked public key and MLDSA key hash (64 bytes total).
   * Format: [32 bytes tweakedPublicKey][32 bytes MLDSA key hash]
   *
   * This is the equivalent of btc-runtime's writeExtendedAddress().
   *
   * @param value - The Address containing both keys
   */
  writeExtendedAddress(t) {
    this.allocSafe(mt), this.writeTweakedPublicKey(t), this.writeBytes(t);
  }
  /**
   * Writes a Schnorr signature with its associated full Address.
   * Format: [64 bytes full Address][64 bytes signature]
   *
   * Used for serializing signed data where both the signer's address
   * and their Schnorr signature need to be stored together.
   *
   * @param address - The signer's Address (with both MLDSA and tweaked keys)
   * @param signature - The 64-byte Schnorr signature
   * @throws {Error} If signature is not exactly 64 bytes
   */
  writeSchnorrSignature(t, e) {
    if (e.length !== Tt)
      throw new Error(
        `Invalid Schnorr signature length: expected ${Tt}, got ${e.length}`
      );
    this.allocSafe(mt + Tt), this.writeExtendedAddress(t), this.writeBytes(e);
  }
  getBuffer(t = !0) {
    const e = new Uint8Array(this.buffer.byteLength);
    for (let i = 0; i < this.buffer.byteLength; i++)
      e[i] = this.buffer.getUint8(i);
    return t && this.clear(), e;
  }
  reset() {
    this.currentOffset = 0, this.buffer = this.getDefaultBuffer(4);
  }
  toBytesReader() {
    return new ee(this.getBuffer());
  }
  getOffset() {
    return this.currentOffset;
  }
  setOffset(t) {
    this.currentOffset = t;
  }
  clear() {
    this.currentOffset = 0, this.buffer = this.getDefaultBuffer();
  }
  [Symbol.dispose]() {
    this.clear();
  }
  allocSafe(t) {
    this.currentOffset + t > this.buffer.byteLength && this.resize(t);
  }
  writeAddressValueTuple(t, e = !0) {
    if (t.size > 65535) throw new Error("Map size is too large");
    this.writeU16(t.size, e);
    const i = Array.from(t.keys());
    for (let r = 0; r < i.length; r++) {
      const s = i[r], o = t.get(s);
      if (o == null) throw new Error("Value not found");
      this.writeAddress(s), this.writeU256(o, e);
    }
  }
  /**
   * Writes a map of full Address -> u256 using the tweaked key for map lookup.
   * Format: [u16 length][FullAddress key][u256 value]...
   *
   * This is the equivalent of btc-runtime's writeExtendedAddressMapU256().
   */
  writeExtendedAddressMapU256(t, e = !0) {
    if (t.size > 65535) throw new Error("Map size is too large");
    this.writeU16(t.size, e);
    for (const [i, r] of t.entries())
      this.writeExtendedAddress(i), this.writeU256(r, e);
  }
  writeBytesWithLength(t) {
    this.writeU32(t.length), this.writeBytes(t);
  }
  writeArrayOfBuffer(t, e = !0) {
    const i = V.estimateArrayOfBufferLength(t);
    this.allocSafe(i), this.writeU16(t.length, e);
    for (let r = 0; r < t.length; r++)
      this.writeU32(t[r].length, e), this.writeBytes(t[r]);
  }
  writeAddressArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeAddress(t[e]);
  }
  /**
   * Writes an array of full addresses (64 bytes each).
   * Format: [u16 length][FullAddress 0][FullAddress 1]...
   */
  writeExtendedAddressArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.allocSafe(At + t.length * mt), this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeExtendedAddress(t[e]);
  }
  writeU32Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU32(t[i], e);
  }
  writeU256Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU256(t[i], e);
  }
  writeU128Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU128(t[i], e);
  }
  writeStringArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeStringWithLength(t[e]);
  }
  writeU16Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU16(t[i], e);
  }
  writeU8Array(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeU8(t[e]);
  }
  writeU64Array(t, e = !0) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length, e);
    for (let i = 0; i < t.length; i++)
      this.writeU64(t[i], e);
  }
  writeBytesArray(t) {
    if (t.length > 65535) throw new Error("Array size is too large");
    this.writeU16(t.length);
    for (let e = 0; e < t.length; e++)
      this.writeBytesWithLength(t[e]);
  }
  verifyAddress(t) {
    if (t.byteLength > D)
      throw new Error(
        `Address is too long ${t.byteLength} > ${D} bytes`
      );
  }
  resize(t) {
    const e = new Uint8Array(this.buffer.byteLength + t);
    for (let i = 0; i < this.buffer.byteLength; i++)
      e[i] = this.buffer.getUint8(i);
    this.buffer = new DataView(e.buffer, e.byteOffset, e.byteLength);
  }
  getDefaultBuffer(t = 0) {
    return new DataView(new ArrayBuffer(t));
  }
}
class J {
  /**
   * The maximum size of a data chunk
   */
  static DATA_CHUNK_SIZE = 512;
  /**
   * The magic number of OPNet
   */
  static MAGIC = _i("op");
  /**
   * The public key of the sender
   * @protected
   */
  senderPubKey;
  /**
   * The public key of the sender
   * @protected
   */
  xSenderPubKey;
  /**
   * The public key of the contract salt
   * @protected
   */
  contractSaltPubKey;
  /**
   * The network to use
   * @protected
   */
  network = T.bitcoin;
  constructor(t, e, i = T.bitcoin) {
    this.senderPubKey = t, this.contractSaltPubKey = e, this.network = i, this.xSenderPubKey = U(t);
  }
  buildHeader(t) {
    let e = 0;
    for (const r of t)
      e |= r;
    const i = se(3);
    return i[0] = e >> 16 & 255, i[1] = e >> 8 & 255, i[2] = e & 255, Uint8Array.from([this.senderPubKey[0], ...i]);
  }
  getHeader(t, e = []) {
    const i = new V(12);
    return i.writeBytes(this.buildHeader(e)), i.writeU64(t), new Uint8Array(i.getBuffer());
  }
  /**
   * Split a buffer into chunks
   * @param {Uint8Array} buffer - The buffer to split
   * @param {number} chunkSize - The size of each chunk
   * @protected
   * @returns {Array<Uint8Array[]>} - The chunks
   */
  splitBufferIntoChunks(t, e = J.DATA_CHUNK_SIZE) {
    const i = [];
    for (let r = 0; r < t.length; r += e) {
      const s = Math.min(e, t.length - r), o = se(s);
      for (let a = 0; a < s; a++)
        o[a] = t[r + a];
      i.push([o]);
    }
    return i;
  }
  encodeFeature(t, e) {
    switch (t.opcode) {
      case $.ACCESS_LIST:
        return this.encodeAccessListFeature(t, e);
      case $.EPOCH_SUBMISSION:
        return this.encodeChallengeSubmission(
          t,
          e
        );
      case $.MLDSA_LINK_PUBKEY:
        return this.encodeLinkRequest(t, e);
      default:
        throw new Error(`Unknown feature type: ${t.opcode}`);
    }
  }
  encodeAccessListFeature(t, e) {
    const i = new V();
    i.writeU16(Object.keys(t.data).length);
    for (const r in t.data) {
      const s = K.fromString(r), o = t.data[r];
      i.writeAddress(s), i.writeU32(o.length);
      for (const a of o) {
        const c = Uint8Array.from(atob(a), (u) => u.charCodeAt(0));
        if (c.length !== 32)
          throw new Error(`Invalid pointer length: ${c.length}`);
        i.writeBytes(c);
      }
    }
    e.writeBytesWithLength(Y.compress(new Uint8Array(i.getBuffer())));
  }
  encodeChallengeSubmission(t, e) {
    if ("verifySignature" in t.data && !t.data.verifySignature())
      throw new Error("Invalid signature in challenge submission feature");
    const i = new V();
    i.writeBytes(t.data.publicKey.toBuffer()), i.writeBytes(t.data.solution), t.data.graffiti && i.writeBytesWithLength(t.data.graffiti), e.writeBytesWithLength(i.getBuffer());
  }
  encodeLinkRequest(t, e) {
    const i = t.data, r = new V();
    if (r.writeU8(i.level), r.writeBytes(i.hashedPublicKey), r.writeBoolean(i.verifyRequest), i.verifyRequest) {
      if (!i.publicKey || !i.mldsaSignature)
        throw new Error(
          "MLDSA public key and signature required when verifyRequest is true"
        );
      r.writeBytes(i.publicKey), r.writeBytes(i.mldsaSignature);
    }
    if (!i.legacySignature || i.legacySignature.length !== 64)
      throw new Error("Legacy signature must be exactly 64 bytes");
    r.writeBytes(i.legacySignature), e.writeBytesWithLength(r.getBuffer());
  }
}
class fe extends J {
  constructor(t, e, i = T.bitcoin) {
    super(t, e, i);
  }
  /**
   * Get the public key as a buffer
   * @param {Uint8Array[]} witnessKeys - The public keys
   * @param {Network} network - The network to use
   * @private
   * @returns {Uint8Array} - The public key as a buffer
   */
  static getPubKeyAsBuffer(t, e) {
    let i = new Uint8Array(0);
    for (const s of t) {
      if (!P.fromPublicKey(s, e).compressed)
        throw new Error("Public key must be compressed");
      if (s.byteLength !== 33)
        throw new Error(`Public key must be 33 bytes, got ${s.byteLength} bytes.`);
      i = dt([i, s]);
    }
    const r = Y.compress(i);
    return r.byteLength >= i.byteLength ? i : r;
  }
  /**
   * Compile an interaction bitcoin script
   * @param {Uint8Array} calldata - The calldata to use
   * @param {Uint8Array} contractSecret - The contract secret
   * @param {IChallengeSolution} challenge
   * @param maxPriority - Amount of satoshis to spend max on priority fee
   * @param {Feature<Features>[]} featuresRaw - The features to use
   * @returns {Uint8Array} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(t, e, i, r, s = []) {
    if (!this.contractSaltPubKey) throw new Error("Contract salt public key not set");
    const o = this.splitBufferIntoChunks(t);
    if (!o.length) throw new Error("No data chunks found");
    const a = [], c = [];
    if (s && s.length) {
      const p = s.sort(
        (m, A) => m.priority - A.priority
      ), y = new V();
      for (let m = 0; m < p.length; m++) {
        const A = p[m];
        a.push(A.opcode), this.encodeFeature(A, y);
      }
      c.push(
        ...this.splitBufferIntoChunks(new Uint8Array(y.getBuffer()))
      );
    }
    let u = [
      this.getHeader(r, a),
      f.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      i.publicKey.toBuffer(),
      f.OP_TOALTSTACK,
      i.solution,
      f.OP_TOALTSTACK,
      this.xSenderPubKey,
      f.OP_DUP,
      f.OP_HASH256,
      F.hash256(this.xSenderPubKey),
      f.OP_EQUALVERIFY,
      f.OP_CHECKSIGVERIFY,
      this.contractSaltPubKey,
      f.OP_CHECKSIGVERIFY,
      f.OP_HASH160,
      F.hash160(e),
      f.OP_EQUALVERIFY,
      f.OP_DEPTH,
      f.OP_1,
      f.OP_NUMEQUAL,
      f.OP_IF,
      J.MAGIC
    ];
    u = u.concat(
      ...c,
      f.OP_1NEGATE,
      ...o,
      f.OP_ELSE,
      f.OP_1,
      f.OP_ENDIF
    );
    const l = u.flat(), h = O.compile(l);
    if (!O.decompile(h))
      throw new Error("Failed to decompile script??");
    return h;
  }
}
class Ge extends J {
  constructor(t, e = T.bitcoin) {
    super(t, void 0, e);
  }
  /**
   * Compile an interaction bitcoin script
   * @param compiledData - The compiled data
   * @returns {Uint8Array} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(t) {
    const e = t.flat(), i = O.compile(e);
    if (!O.decompile(i))
      throw new Error("Failed to decompile script??");
    return i;
  }
}
const Qe = 0, je = Uint8Array.from([Qe]);
class ge extends J {
  constructor(t, e, i = T.bitcoin) {
    super(t, e, i);
  }
  /**
   * Compile a bitcoin script representing a contract deployment
   * @param {Uint8Array} contractBytecode - The contract bytecode
   * @param {Uint8Array} contractSalt - The contract salt
   * @param {ChallengeSolution} challenge - The challenge for reward
   * @param {bigint} maxPriority - The maximum priority for the contract
   * @param {Uint8Array} [calldata] - The calldata to be passed to the contract
   * @param {Feature<Features>[]} [features] - Optional features to include in the script
   * @returns {Uint8Array} - The compiled script
   */
  compile(t, e, i, r, s, o) {
    const a = this.getAsm(
      t,
      e,
      i,
      r,
      s,
      o
    ), c = O.compile(a);
    if (!O.decompile(c))
      throw new Error("Failed to decompile script??");
    return c;
  }
  getAsm(t, e, i, r, s, o) {
    if (!this.contractSaltPubKey) throw new Error("Contract salt public key not set");
    const a = this.splitBufferIntoChunks(t), c = s ? this.splitBufferIntoChunks(s) : [], u = [], l = [];
    if (o && o.length) {
      const d = o.sort(
        (y, m) => y.priority - m.priority
      ), p = new V();
      for (let y = 0; y < d.length; y++) {
        const m = d[y];
        u.push(m.opcode), this.encodeFeature(m, p);
      }
      l.push(
        ...this.splitBufferIntoChunks(new Uint8Array(p.getBuffer()))
      );
    }
    return [
      this.getHeader(r, u),
      f.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      i.publicKey.toBuffer(),
      f.OP_TOALTSTACK,
      i.solution,
      f.OP_TOALTSTACK,
      this.xSenderPubKey,
      f.OP_DUP,
      f.OP_HASH256,
      F.hash256(this.xSenderPubKey),
      f.OP_EQUALVERIFY,
      f.OP_CHECKSIGVERIFY,
      this.contractSaltPubKey,
      f.OP_CHECKSIGVERIFY,
      f.OP_HASH256,
      F.hash256(e),
      f.OP_EQUALVERIFY,
      f.OP_DEPTH,
      f.OP_1,
      f.OP_NUMEQUAL,
      f.OP_IF,
      J.MAGIC,
      ...l,
      f.OP_0,
      ...c,
      f.OP_1NEGATE,
      ...a,
      f.OP_ELSE,
      f.OP_1,
      f.OP_ENDIF
    ].flat();
  }
}
class I extends Me {
  /**
   * Maximum chunk size per Bitcoin P2WSH stack item limit.
   * See policy.h: MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80
   */
  static MAX_CHUNK_SIZE = 80;
  /**
   * Maximum stack items per P2WSH input.
   * See policy.h: MAX_STANDARD_P2WSH_STACK_ITEMS = 100
   */
  static MAX_STACK_ITEMS = 100;
  /**
   * Maximum total witness size (serialized).
   * See policy.cpp: GetSerializeSize(tx.vin[i].scriptWitness.stack) > g_script_size_policy_limit
   * Default: 1650 bytes
   */
  static MAX_WITNESS_SIZE = 1650;
  /** Maximum weight per standard transaction */
  static MAX_STANDARD_WEIGHT = 4e5;
  /** Minimum satoshis per output (dust limit) */
  static MIN_OUTPUT_VALUE = 330n;
  /**
   * Bytes per hash commitment in witness script.
   * OP_HASH160 (1) + push (1) + hash (20) + OP_EQUALVERIFY (1) = 23 bytes
   */
  static BYTES_PER_COMMITMENT = 23;
  /**
   * Fixed overhead in witness serialization:
   * - Stack item count: 1 byte
   * - Signature: 73 bytes (72 + 1 length prefix)
   * - Script length prefix: 3 bytes (varInt for sizes 253-65535)
   * - Script base (pubkey + checksig): 35 bytes
   */
  static WITNESS_FIXED_OVERHEAD = 112;
  /**
   * Per-chunk overhead in witness:
   * - Data: 81 bytes (80 + 1 length prefix)
   * - Script commitment: 23 bytes
   * Total: 104 bytes per chunk
   */
  static WITNESS_PER_CHUNK_OVERHEAD = I.MAX_CHUNK_SIZE + 1 + I.BYTES_PER_COMMITMENT;
  /**
   * Maximum data chunks per P2WSH output.
   * Limited by total witness size: (1650 - 112) / 104 = 14 chunks
   */
  static MAX_CHUNKS_PER_OUTPUT = Math.floor(
    (I.MAX_WITNESS_SIZE - I.WITNESS_FIXED_OVERHEAD) / I.WITNESS_PER_CHUNK_OVERHEAD
  );
  /** Base weight per input (non-witness): 41 bytes * 4 = 164 */
  static INPUT_BASE_WEIGHT = 164;
  /**
   * Witness weight per input with max chunks:
   * Total witness size is ~1566 bytes (under 1650 limit)
   * Witness bytes count as 1 weight unit each.
   */
  static INPUT_WITNESS_WEIGHT_MAX = I.MAX_WITNESS_SIZE;
  // Use max as upper bound
  /** Total weight per input (with max chunks) */
  static WEIGHT_PER_INPUT = I.INPUT_BASE_WEIGHT + I.INPUT_WITNESS_WEIGHT_MAX;
  logColor = "#4a90d9";
  publicKey;
  network;
  constructor(t, e = T.bitcoin) {
    if (super(), t.length !== 33)
      throw new Error("Public key must be 33 bytes (compressed)");
    this.publicKey = t, this.network = e;
  }
  /**
   * Calculate the maximum number of inputs per standard reveal transaction.
   *
   * Standard tx weight limit: 400,000
   * With max chunks per input (~10,385 weight), only ~38 inputs fit
   *
   * @returns Maximum inputs per reveal tx (~38 with max chunks)
   */
  static calculateMaxInputsPerTx() {
    const i = I.MAX_STANDARD_WEIGHT - 40 - 200;
    return Math.floor(i / I.WEIGHT_PER_INPUT);
  }
  /**
   * Calculate maximum data per standard reveal transaction.
   *
   * @returns Maximum data in bytes (~300KB with batched chunks at 70 chunks/output)
   */
  static calculateMaxDataPerTx() {
    return I.calculateMaxInputsPerTx() * I.MAX_CHUNKS_PER_OUTPUT * I.MAX_CHUNK_SIZE;
  }
  /**
   * Estimate the number of P2WSH outputs needed for a given data size.
   *
   * @param dataSize Data size in bytes
   * @returns Number of P2WSH outputs needed
   */
  static estimateOutputCount(t) {
    return Math.ceil(
      t / (I.MAX_CHUNKS_PER_OUTPUT * I.MAX_CHUNK_SIZE)
    );
  }
  /**
   * Estimate the number of 80-byte chunks for a given data size.
   *
   * @param dataSize Data size in bytes
   * @returns Number of 80-byte chunks needed
   */
  static estimateChunkCount(t) {
    return Math.ceil(t / I.MAX_CHUNK_SIZE);
  }
  /**
   * Validate that a witness script is a valid multi-hash committed script.
   *
   * Script structure: (OP_HASH160 <hash> OP_EQUALVERIFY)+ <pubkey> OP_CHECKSIG
   *
   * @param witnessScript The witness script to validate
   * @returns true if valid hash-committed script
   */
  static validateHashCommittedScript(t) {
    try {
      const e = O.decompile(t);
      if (!e || e.length < 5)
        return !1;
      const i = e.length - 1;
      if (e[i] !== f.OP_CHECKSIG)
        return !1;
      const r = e[i - 1];
      if (!(r instanceof Uint8Array) || r.length !== 33)
        return !1;
      const s = e.slice(0, -2);
      if (s.length % 3 !== 0 || s.length === 0)
        return !1;
      for (let o = 0; o < s.length; o += 3) {
        const a = s[o + 1];
        if (s[o] !== f.OP_HASH160 || !(a instanceof Uint8Array) || a.length !== 20 || s[o + 2] !== f.OP_EQUALVERIFY)
          return !1;
      }
      return !0;
    } catch {
      return !1;
    }
  }
  /**
   * Extract all data hashes from a hash-committed witness script.
   *
   * @param witnessScript The witness script
   * @returns Array of 20-byte data hashes (in data order), or null if invalid
   */
  static extractDataHashes(t) {
    try {
      const e = O.decompile(t);
      if (!e || !I.validateHashCommittedScript(t))
        return null;
      const i = e.slice(0, -2), r = [];
      for (let s = 0; s < i.length; s += 3)
        r.push(i[s + 1]);
      return r.reverse();
    } catch {
      return null;
    }
  }
  /**
   * Extract the public key from a hash-committed witness script.
   *
   * @param witnessScript The witness script
   * @returns The 33-byte public key, or null if invalid script
   */
  static extractPublicKey(t) {
    try {
      const e = O.decompile(t);
      return !e || !I.validateHashCommittedScript(t) ? null : e[e.length - 2];
    } catch {
      return null;
    }
  }
  /**
   * Verify that data chunks match their committed hashes.
   *
   * @param dataChunks Array of data chunks (in order)
   * @param witnessScript The witness script containing the hash commitments
   * @returns true if all chunks match their commitments
   */
  static verifyChunkCommitments(t, e) {
    const i = I.extractDataHashes(e);
    if (!i || i.length !== t.length)
      return !1;
    for (let r = 0; r < t.length; r++) {
      const s = F.hash160(t[r]);
      if (!C(i[r], s))
        return !1;
    }
    return !0;
  }
  /**
   * Estimate fees for a complete CHCT flow (setup + reveal).
   *
   * @param dataSize Data size in bytes (before compression)
   * @param feeRate Fee rate in sat/vB
   * @param compressionRatio Expected compression ratio (default: 0.7)
   * @returns Fee estimates
   */
  static estimateFees(t, e, i = 0.7) {
    const r = Math.ceil(t * i), s = I.estimateOutputCount(r), o = I.estimateChunkCount(r), a = 116, c = s * 43 + 43, l = 11 + a + c, h = 40 + s * I.WEIGHT_PER_INPUT + 200, d = Math.ceil(h / 4), p = BigInt(Math.ceil(l * e)), y = BigInt(Math.ceil(d * e)), m = p + y, A = BigInt(s) * I.MIN_OUTPUT_VALUE, x = m + A;
    return {
      compressedSize: r,
      outputCount: s,
      chunkCount: o,
      setupVBytes: l,
      revealVBytes: d,
      setupFee: p,
      revealFee: y,
      totalFee: m,
      outputsValue: A,
      totalCost: x
    };
  }
  /**
   * Calculate the HASH160 of a data chunk.
   * HASH160 = RIPEMD160(SHA256(data))
   */
  hashChunk(t) {
    return F.hash160(t);
  }
  /**
   * Generate a hash-committed witness script for multiple data chunks.
   *
   * Script structure (for N chunks):
   * OP_HASH160 <hash_N> OP_EQUALVERIFY
   * OP_HASH160 <hash_N-1> OP_EQUALVERIFY
   * ...
   * OP_HASH160 <hash_1> OP_EQUALVERIFY
   * <pubkey> OP_CHECKSIG
   *
   * Hashes are in reverse order because witness stack is LIFO.
   * Witness stack: [sig, data_1, data_2, ..., data_N, witnessScript]
   * Stack before execution: [sig, data_1, data_2, ..., data_N] (data_N on top)
   *
   * @param dataHashes Array of HASH160 values (in data order, will be reversed in script)
   * @returns The compiled witness script
   */
  generateWitnessScript(t) {
    if (t.length === 0)
      throw new Error("At least one data hash is required");
    if (t.length > I.MAX_CHUNKS_PER_OUTPUT)
      throw new Error(
        `Too many chunks: ${t.length} exceeds limit of ${I.MAX_CHUNKS_PER_OUTPUT}`
      );
    for (const i of t)
      if (i.length !== 20)
        throw new Error(`HASH160 requires 20-byte hash, got ${i.length}`);
    const e = [];
    for (let i = t.length - 1; i >= 0; i--)
      e.push(f.OP_HASH160), e.push(t[i]), e.push(f.OP_EQUALVERIFY);
    return e.push(this.publicKey), e.push(f.OP_CHECKSIG), O.compile(e);
  }
  /**
   * Generate a P2WSH address from a witness script.
   *
   * @param witnessScript The witness script
   * @returns P2WSH address info
   */
  generateP2WSHAddress(t) {
    const e = _.p2wsh({
      redeem: { output: t },
      network: this.network
    });
    if (!e.address || !e.output)
      throw new Error("Failed to generate P2WSH address");
    return {
      address: e.address,
      witnessScript: t,
      scriptPubKey: e.output
    };
  }
  /**
   * Split data into chunks and generate hash-committed P2WSH outputs.
   *
   * Each output commits to up to 98 data chunks (80 bytes each = 7,840 bytes).
   * This is MUCH more efficient than one output per chunk.
   *
   * @param data The data to chunk and commit
   * @param maxChunkSize Maximum bytes per stack item (default: 80, P2WSH stack item limit)
   * @returns Array of hash-committed P2WSH outputs
   */
  prepareChunks(t, e = I.MAX_CHUNK_SIZE) {
    if (e > I.MAX_CHUNK_SIZE)
      throw new Error(
        `Chunk size ${e} exceeds P2WSH stack item limit of ${I.MAX_CHUNK_SIZE}`
      );
    if (t.length === 0)
      throw new Error("Data cannot be empty");
    const i = [];
    let r = 0;
    for (; r < t.length; ) {
      const c = Math.min(e, t.length - r);
      i.push(new Uint8Array(t.subarray(r, r + c))), r += c;
    }
    const s = [];
    let o = 0;
    for (; o < i.length; ) {
      const c = i.slice(
        o,
        o + I.MAX_CHUNKS_PER_OUTPUT
      ), u = c, l = u.map((p) => this.hashChunk(p)), h = this.generateWitnessScript(l), d = this.generateP2WSHAddress(h);
      s.push({
        address: d.address,
        witnessScript: d.witnessScript,
        scriptPubKey: d.scriptPubKey,
        dataHashes: l,
        dataChunks: u,
        chunkStartIndex: o
      }), o += c.length;
    }
    const a = i.length;
    return this.log(
      `Prepared ${s.length} P2WSH outputs with ${a} chunks (${t.length} bytes, ~${Math.ceil(t.length / s.length)} bytes/output)`
    ), s;
  }
}
class dr extends J {
  constructor(t, e = T.bitcoin) {
    super(t, new Uint8Array(0), e);
  }
  /**
   * Get the public key as a buffer
   * @param {Uint8Array[]} witnessKeys - The public keys
   * @param {Network} network - The network to use
   * @private
   * @returns {Uint8Array} - The public key as a buffer
   */
  static getPubKeyAsBuffer(t, e) {
    let i = new Uint8Array(0);
    for (const s of t) {
      if (!P.fromPublicKey(s, e).compressed)
        throw new Error("Public key must be compressed");
      if (s.byteLength !== 33)
        throw new Error(`Public key must be 33 bytes, got ${s.byteLength} bytes.`);
      i = dt([i, s]);
    }
    const r = Y.compress(i);
    return r.byteLength >= i.byteLength ? i : r;
  }
  /**
   * Compile an interaction bitcoin script
   * @param {Uint8Array} calldata - The calldata to use
   * @param {Uint8Array} contractSecret - The contract secret
   * @param {Uint8Array} challenge - The challenge to use
   * @param {bigint} maxPriority - The maximum priority
   * @param {number[]} [featuresRaw=[]] - The features to use (optional)
   * @returns {Uint8Array} - The compiled script
   * @throws {Error} - If something goes wrong
   */
  compile(t, e, i, r, s = []) {
    const o = this.splitBufferIntoChunks(t);
    if (!o.length) throw new Error("No data chunks found");
    const a = [], c = [];
    if (s && s.length) {
      const p = s.sort(
        (m, A) => m.priority - A.priority
      ), y = new V();
      for (let m = 0; m < p.length; m++) {
        const A = p[m];
        a.push(A.opcode), this.encodeFeature(A, y);
      }
      c.push(
        ...this.splitBufferIntoChunks(new Uint8Array(y.getBuffer()))
      );
    }
    let u = [
      this.getHeader(r, a),
      f.OP_TOALTSTACK,
      // CHALLENGE PREIMAGE FOR REWARD,
      i,
      f.OP_TOALTSTACK,
      this.senderPubKey,
      f.OP_DUP,
      f.OP_HASH256,
      F.hash256(this.senderPubKey),
      f.OP_EQUALVERIFY,
      f.OP_CHECKSIGVERIFY,
      e,
      f.OP_TOALTSTACK,
      f.OP_DEPTH,
      f.OP_1,
      f.OP_NUMEQUAL,
      f.OP_IF,
      J.MAGIC
    ];
    u = u.concat(
      ...c,
      f.OP_1NEGATE,
      ...o,
      f.OP_ELSE,
      f.OP_1,
      f.OP_ENDIF
    );
    const l = u.flat(), h = O.compile(l);
    if (!O.decompile(h))
      throw new Error("Failed to decompile script??");
    return h;
  }
}
class Dt {
  static MAXIMUM_SUPPORTED_SIGNATURE = 255;
  static compile(t, e = 0, i) {
    if (e < 2)
      throw new Error("Minimum signatures must be greater than 1");
    if (t.length < e)
      throw new Error("The amount of public keys is lower than the minimum required");
    if (e > Dt.MAXIMUM_SUPPORTED_SIGNATURE)
      throw new Error(
        `The maximum amount of signatures is ${Dt.MAXIMUM_SUPPORTED_SIGNATURE}`
      );
    const r = se(1);
    r[0] = e, t = t.filter(
      (h, d, p) => d === p.findIndex((y) => C(h, y))
    ), t = t.sort((h, d) => Bi(h, d));
    let s = !1;
    const o = t.map((h) => {
      const d = U(h);
      return i && !s && (s = C(i, d)), d;
    });
    i && !s && o.push(i);
    const c = [
      // Push the initial 0 (for OP_CHECKSIGADD)
      f.OP_0,
      // For each public key, add CHECKSIGADD operation
      ...o.flatMap((h) => [
        h,
        // Push the public key
        f.OP_CHECKSIGADD
        // Add the public key to the signature set
      ]),
      // Finally, compare the sum with the minimum required signatures
      r,
      f.OP_NUMEQUAL
      // Use NUMEQUALVERIFY to ensure the correct number of signatures
    ].flat(), u = O.compile(c);
    if (!O.decompile(u))
      throw new Error("Failed to decompile script.");
    return u;
  }
}
class Ct extends J {
  static P2WDA_VERSION = 1;
  constructor(t, e, i = T.bitcoin) {
    super(t, e, i);
  }
  /**
   * Validate that operation data will fit in P2WDA witness fields
   *
   * @param dataSize Size of the operation data
   * @param maxWitnessFields Maximum number of witness fields (default 10)
   * @param maxBytesPerWitness Maximum bytes per witness field (default 80)
   * @returns true if data will fit, false otherwise
   */
  static validateWitnessSize(t, e = 10, i = 80) {
    const o = t + 64, a = Math.ceil(o * 0.7);
    return Math.ceil(a / i) <= e;
  }
  /**
   * Compile operation data for P2WDA witness embedding
   *
   * This creates a binary structure containing all operation information
   * without Bitcoin script opcodes. The structure is:
   *
   * [version(1)] [header(12)] [contract(32)] [challenge_pubkey(33)] [challenge_solution(32)]
   * [calldata_length(4)] [calldata] [features_length(2)] [features_data]
   *
   * @param calldata The compressed calldata for the contract interaction
   * @param contractSecret The 32-byte contract secret
   * @param challenge The challenge solution for epoch rewards
   * @param maxPriority Maximum priority fee in satoshis
   * @param featuresRaw Optional features like access lists
   * @returns Raw operation data ready for signing and compression
   */
  compile(t, e, i, r, s = []) {
    if (!this.contractSaltPubKey)
      throw new Error("Contract salt public key not set");
    if (e.length !== 32)
      throw new Error("Contract secret must be exactly 32 bytes");
    const o = new V();
    o.writeU8(Ct.P2WDA_VERSION);
    const a = s.sort((c, u) => c.priority - u.priority);
    return o.writeBytes(
      this.getHeader(
        r,
        a.map((c) => c.opcode)
      )
    ), o.writeBytes(e), o.writeBytes(i.publicKey.toBuffer()), o.writeBytes(i.solution), o.writeU32(t.length), o.writeBytes(t), this.writeFeatures(o, a), new Uint8Array(o.getBuffer());
  }
  getHeader(t, e = []) {
    return super.getHeader(t, e);
  }
  /**
   * Write features section to the operation data
   *
   * Features are encoded as:
   * [feature_count(2)] [feature1_opcode(1)] [feature1_length(4)] [feature1_data] ...
   *
   * @param writer Binary writer to write to
   * @param features Array of features to encode
   */
  writeFeatures(t, e) {
    t.writeU16(e.length);
    for (const i of e)
      t.writeU8(i.opcode), this.encodeFeature(i, t);
  }
}
class Se {
  // Generate a valid SegWit address from random bytes
  static generatePKSH(t, e) {
    if (t.length !== 32) throw new Error("Invalid hash length");
    const i = ki(t);
    return this.toSegwitAddress(i, e);
  }
  // Generate a valid Taproot address from a public key
  static generateTaprootAddress(t, e) {
    if (t.length !== 32) throw new Error("Invalid public key length");
    const i = Mt.bech32m.toWords(t);
    return i.unshift(1), Mt.bech32m.encode(e.bech32, i);
  }
  // Convert a hash to a SegWit address
  static toSegwitAddress(t, e) {
    const i = Mt.bech32.toWords(t);
    return i.unshift(0), Mt.bech32.encode(e.bech32, i);
  }
}
class nt {
  static TAP_SCRIPT_VERSION = 192;
  static getContractAddress(t) {
    const { scriptTree: e } = nt.buildScriptTree(t);
    return nt.generateAddressFromScript(t, e);
  }
  static verifyControlBlock(t, e) {
    const { scriptTree: i, compiledTargetScript: r, network: s } = nt.buildScriptTree(t), a = _.p2tr({
      internalPubkey: U(t.deployerPubKey),
      network: s,
      scriptTree: i,
      redeem: {
        output: r,
        redeemVersion: nt.TAP_SCRIPT_VERSION
      }
    }).witness;
    if (!a || a.length === 0)
      return !1;
    const c = a[a.length - 1];
    return C(c, e);
  }
  static getContractSeed(t, e, i) {
    const r = F.hash256(e), s = dt([t, i, r]);
    return F.hash256(s);
  }
  static generateAddressFromScript(t, e) {
    const i = t.network || T.bitcoin, r = {
      internalPubkey: U(t.deployerPubKey),
      network: i,
      scriptTree: e
    };
    return _.p2tr(r).address;
  }
  static buildScriptTree(t) {
    const e = t.network || T.bitcoin, r = new ge(
      t.deployerPubKey,
      U(t.contractSaltPubKey),
      e
    ).compile(
      t.bytecode,
      t.originalSalt,
      t.challenge,
      t.priorityFee,
      t.calldata,
      t.features
    ), s = O.compile([
      U(t.deployerPubKey),
      f.OP_CHECKSIG
    ]);
    return { scriptTree: [
      {
        output: r,
        version: nt.TAP_SCRIPT_VERSION
      },
      {
        output: s,
        version: nt.TAP_SCRIPT_VERSION
      }
    ], compiledTargetScript: r, network: e };
  }
}
function pt(n) {
  return "privateKey" in n && n.privateKey != null;
}
class we {
  /**
   * Tweak a signer
   * @param {UniversalSigner} signer - The signer to tweak (must have privateKey)
   * @param {TweakSettings} opts - The tweak settings
   * @returns {UniversalSigner} - The tweaked signer
   */
  static tweakSigner(t, e = {}) {
    let i = t.privateKey;
    if (!i)
      throw new Error("Private key is required for tweaking signer!");
    t.publicKey[0] === 3 && (i = N.privateNegate(i));
    const r = N.privateAdd(
      i,
      Li(U(t.publicKey), e.tweakHash)
    );
    if (!r)
      throw new Error("Invalid tweaked private key!");
    return P.fromPrivateKey(r, e.network);
  }
}
function Ze(n) {
  return typeof n == "object" && n !== null && "web3" in n && typeof n.web3 == "object" && "getMLDSAPublicKey" in n.web3 && "signMLDSAMessage" in n.web3;
}
var yt = /* @__PURE__ */ ((n) => (n.Mainnet = "mainnet", n.Testnet = "testnet", n.OpnetTestnet = "opnetTestnet", n.Regtest = "regtest", n))(yt || {}), Je = /* @__PURE__ */ ((n) => (n.BITCOIN_MAINNET = "BITCOIN_MAINNET", n.BITCOIN_TESTNET = "BITCOIN_TESTNET", n.BITCOIN_TESTNET4 = "BITCOIN_TESTNET4", n.BITCOIN_REGTEST = "BITCOIN_REGTEST", n.BITCOIN_SIGNET = "BITCOIN_SIGNET", n.OPNET_TESTNET = "OPNET_TESTNET", n.FRACTAL_BITCOIN_MAINNET = "FRACTAL_BITCOIN_MAINNET", n.FRACTAL_BITCOIN_TESTNET = "FRACTAL_BITCOIN_TESTNET", n.DOGECOIN_MAINNET = "DOGECOIN_MAINNET", n.DOGECOIN_TESTNET = "DOGECOIN_TESTNET", n.DOGECOIN_REGTEST = "DOGECOIN_REGTEST", n.LITECOIN_MAINNET = "LITECOIN_MAINNET", n.LITECOIN_TESTNET = "LITECOIN_TESTNET", n.LITECOIN_REGTEST = "LITECOIN_REGTEST", n.BITCOINCASH_MAINNET = "BITCOINCASH_MAINNET", n.BITCOINCASH_TESTNET = "BITCOINCASH_TESTNET", n.BITCOINCASH_REGTEST = "BITCOINCASH_REGTEST", n.DASH_MAINNET = "DASH_MAINNET", n.DASH_TESTNET = "DASH_TESTNET", n.DASH_REGTEST = "DASH_REGTEST", n))(Je || {}), ti = /* @__PURE__ */ ((n) => (n.ecdsa = "ecdsa", n.bip322 = "bip322-simple", n))(ti || {}), $t = /* @__PURE__ */ ((n) => (n.ecdsa = "ecdsa", n.schnorr = "schnorr", n))($t || {});
class pr {
  sha256(t) {
    return F.sha256(t);
  }
  async trySignSchnorrWithOPWallet(t) {
    const e = this.getOPWallet();
    if (!e)
      return null;
    const i = typeof t == "string" ? new TextEncoder().encode(t) : t, r = this.sha256(i), s = g(r), o = await e.signData(
      s,
      $t.schnorr,
      typeof t == "string" ? t : void 0
    );
    return {
      signature: w(o),
      message: r
    };
  }
  async trySignECDSAWithOPWallet(t) {
    const e = this.getOPWallet();
    if (!e)
      return null;
    const i = typeof t == "string" ? new TextEncoder().encode(t) : t, r = this.sha256(i), s = g(r), o = await e.signData(
      s,
      $t.ecdsa,
      typeof t == "string" ? t : void 0
    );
    return {
      signature: w(o),
      message: r
    };
  }
  async trySignMLDSAWithOPWallet(t) {
    const e = this.getOPWallet();
    if (!e)
      return null;
    const i = typeof t == "string" ? new TextEncoder().encode(t) : t, r = this.sha256(i), s = g(r), o = await e.web3.signMLDSAMessage(
      s,
      typeof t == "string" ? t : void 0
    );
    return {
      signature: w(o.signature),
      message: r,
      publicKey: w(o.publicKey),
      securityLevel: o.securityLevel
    };
  }
  async signMessageAuto(t, e) {
    if (!e) {
      const i = await this.trySignSchnorrWithOPWallet(t);
      if (i)
        return i;
      throw new Error("No keypair provided and OP_WALLET is not available.");
    }
    return this.signMessage(e, t);
  }
  async signMessageECDSAAuto(t, e) {
    if (!e) {
      const i = await this.trySignECDSAWithOPWallet(t);
      if (i)
        return i;
      throw new Error("No keypair provided and OP_WALLET is not available.");
    }
    return this.signECDSA(e, t);
  }
  async tweakAndSignMessageAuto(t, e, i) {
    if (!e) {
      const r = await this.trySignSchnorrWithOPWallet(t);
      if (r)
        return r;
      throw new Error("No keypair provided and OP_WALLET is not available.");
    }
    if (!i)
      throw new Error("Network is required when signing with a local keypair.");
    return this.tweakAndSignMessage(e, t, i);
  }
  async signMLDSAMessageAuto(t, e) {
    if (!e) {
      const i = await this.trySignMLDSAWithOPWallet(t);
      if (i)
        return i;
      throw new Error("No ML-DSA keypair provided and OP_WALLET is not available.");
    }
    return this.signMLDSAMessage(e, t);
  }
  async verifyMLDSAWithOPWallet(t, e) {
    const i = this.getOPWallet();
    if (!i)
      return null;
    const r = typeof t == "string" ? new TextEncoder().encode(t) : t, s = this.sha256(r), o = {
      signature: g(e.signature),
      publicKey: g(e.publicKey),
      securityLevel: e.securityLevel,
      messageHash: g(s)
    };
    return i.web3.verifyMLDSASignature(g(s), o);
  }
  async getMLDSAPublicKeyFromOPWallet() {
    const t = this.getOPWallet();
    if (!t)
      return null;
    const e = await t.web3.getMLDSAPublicKey();
    return w(e);
  }
  tweakAndSignMessage(t, e, i) {
    const r = we.tweakSigner(t, { network: i });
    return this.signMessage(r, e);
  }
  signMessage(t, e) {
    if (typeof e == "string" && (e = new TextEncoder().encode(e)), !t.privateKey)
      throw new Error("Private key not found in keypair.");
    const i = this.sha256(e);
    if (!N.signSchnorr)
      throw new Error("backend.signSchnorr is not available.");
    return {
      signature: N.signSchnorr(i, t.privateKey),
      message: i
    };
  }
  signECDSA(t, e) {
    if (typeof e == "string" && (e = new TextEncoder().encode(e)), !t.privateKey)
      throw new Error("Private key not found in keypair.");
    const i = this.sha256(e);
    if (!N.sign)
      throw new Error("backend.signSchnorr is not available.");
    return {
      signature: N.sign(i, t.privateKey),
      message: i
    };
  }
  verifyECDSASignature(t, e, i) {
    if (typeof e == "string" && (e = new TextEncoder().encode(e)), i.length !== 64)
      throw new Error("Invalid signature length.");
    const r = this.sha256(e);
    if (!N.verify)
      throw new Error("backend.verifySchnorr is not available.");
    return N.verify(
      r,
      t,
      i
    );
  }
  verifySignature(t, e, i) {
    if (typeof e == "string" && (e = new TextEncoder().encode(e)), i.length !== 64)
      throw new Error("Invalid signature length.");
    const r = this.sha256(e);
    if (!N.verifySchnorr)
      throw new Error("backend.verifySchnorr is not available.");
    return N.verifySchnorr(
      r,
      U(t),
      i
    );
  }
  tweakAndVerifySignature(t, e, i) {
    const r = P.tweakPublicKey(t);
    return this.verifySignature(r, e, i);
  }
  signMLDSAMessage(t, e) {
    if (typeof e == "string" && (e = new TextEncoder().encode(e)), !t.privateKey)
      throw new Error("ML-DSA private key not found in keypair.");
    const i = this.sha256(e), r = t.sign(i);
    return {
      signature: new Uint8Array(r),
      message: i,
      publicKey: new Uint8Array(t.publicKey),
      securityLevel: t.securityLevel
    };
  }
  verifyMLDSASignature(t, e, i) {
    typeof e == "string" && (e = new TextEncoder().encode(e));
    const r = this.sha256(e);
    return t.verify(r, i);
  }
  isOPWalletAvailable() {
    return this.getOPWallet() !== null;
  }
  getOPWallet() {
    if (typeof window > "u")
      return null;
    const t = window;
    return !t.opnet || !Ze(t.opnet) ? null : t.opnet;
  }
}
const ct = new pr();
class rt {
  constructor(t, e, i = T.bitcoin, r = B.MLDSASecurityLevel.LEVEL2, s) {
    this.network = i, this._securityLevel = r;
    const o = t.startsWith("0x") ? t.slice(2) : t;
    W.isValidHex(o) ? this._keypair = P.fromPrivateKey(w(o), this.network) : this._keypair = P.fromWIF(o, this.network);
    const a = e.startsWith("0x") ? e.slice(2) : e;
    if (W.isValidHex(a)) {
      const c = w(a), u = B.getMLDSAConfig(r, this.network), l = u.privateKeySize, h = u.publicKeySize, d = l + h;
      let p;
      if (c.length === l)
        p = c;
      else if (c.length === d)
        p = c.subarray(0, l);
      else
        throw new Error(
          `Invalid ML-DSA key length for security level ${r}. Expected ${l} bytes (private only) or ${d} bytes (private+public), got ${c.length} bytes.`
        );
      if (s && s.length !== 32)
        throw new Error("Chain code must be 32 bytes");
      this._chainCode = s || new Uint8Array(32), this._mldsaKeypair = B.QuantumBIP32Factory.fromPrivateKey(
        p,
        this._chainCode,
        this.network,
        r
      );
    } else
      this._mldsaKeypair = B.QuantumBIP32Factory.fromBase58(a), this._chainCode = new Uint8Array(this._mldsaKeypair.chainCode), this._securityLevel = this._mldsaKeypair.securityLevel;
    this._bufferPubKey = this._keypair.publicKey, this._address = new K(this._mldsaKeypair.publicKey, this._keypair.publicKey), this._p2tr = this._address.p2tr(this.network), this._p2wpkh = this._address.p2wpkh(this.network), this._legacy = this._address.p2pkh(this.network), this._segwitLegacy = this._address.p2shp2wpkh(this.network), this._p2wda = this._address.p2wda(this.network), this._tweakedKey = this._address.tweakedPublicKeyToBuffer();
  }
  _keypair;
  _mldsaKeypair;
  _securityLevel;
  _chainCode;
  _p2wpkh;
  _p2tr;
  _p2wda;
  _legacy;
  _segwitLegacy;
  _bufferPubKey;
  _tweakedKey;
  _address;
  get address() {
    return this._address;
  }
  get tweakedPubKeyKey() {
    return this._tweakedKey;
  }
  get keypair() {
    if (!this._keypair) throw new Error("Keypair not set");
    return this._keypair;
  }
  get mldsaKeypair() {
    return this._mldsaKeypair;
  }
  get securityLevel() {
    return this._securityLevel;
  }
  get chainCode() {
    return this._chainCode;
  }
  get p2wpkh() {
    return this._p2wpkh;
  }
  get p2tr() {
    return this._p2tr;
  }
  get p2wda() {
    return this._p2wda;
  }
  get legacy() {
    return this._legacy;
  }
  get addresses() {
    return [this.p2wpkh, this.p2tr, this.legacy, this.segwitLegacy];
  }
  get segwitLegacy() {
    return this._segwitLegacy;
  }
  get publicKey() {
    if (!this._bufferPubKey) throw new Error("Public key not set");
    return this._bufferPubKey;
  }
  get quantumPublicKey() {
    return new Uint8Array(this._mldsaKeypair.publicKey);
  }
  get quantumPrivateKey() {
    if (!this._mldsaKeypair.privateKey)
      throw new Error("Quantum private key not set");
    return new Uint8Array(this._mldsaKeypair.privateKey);
  }
  get quantumPublicKeyHex() {
    return g(new Uint8Array(this._mldsaKeypair.publicKey));
  }
  get quantumPrivateKeyHex() {
    if (!this._mldsaKeypair.privateKey)
      throw new Error("Quantum private key not set");
    return g(new Uint8Array(this._mldsaKeypair.privateKey));
  }
  get xOnly() {
    if (!this.keypair) throw new Error("Keypair not set");
    return U(this._bufferPubKey);
  }
  static fromWif(t, e, i = T.bitcoin, r = B.MLDSASecurityLevel.LEVEL2, s) {
    return new rt(t, e, i, r, s);
  }
  static generate(t = T.bitcoin, e = B.MLDSASecurityLevel.LEVEL2) {
    const i = P.generateWallet(t, e);
    if (!i.quantumPrivateKey)
      throw new Error("Failed to generate quantum keys");
    return new rt(
      i.privateKey,
      i.quantumPrivateKey,
      t,
      e
    );
  }
  static fromPrivateKeys(t, e, i = T.bitcoin, r = B.MLDSASecurityLevel.LEVEL2, s) {
    return new rt(
      t,
      e,
      i,
      r,
      s
    );
  }
  toWIF() {
    return this._keypair.toWIF();
  }
  toPrivateKeyHex() {
    if (!this._keypair.privateKey)
      throw new Error("Private key not available");
    return g(this._keypair.privateKey);
  }
  toPublicKeyHex() {
    return g(this._bufferPubKey);
  }
  toQuantumBase58() {
    return this._mldsaKeypair.toBase58();
  }
  /**
   * Best-effort zeroing of private key material held by this wallet.
   *
   * Zeros classical and quantum private key buffers and the chain code in-place.
   * This cannot guarantee all copies are erased (the JS runtime may have copied
   * buffers internally, and string representations cannot be zeroed), but it
   * eliminates the primary references.
   */
  zeroize() {
    this._keypair.privateKey?.fill(0), this._mldsaKeypair.privateKey?.fill(0), this._chainCode.fill(0);
  }
  [Symbol.dispose]() {
    this.zeroize();
  }
  derivePath(t) {
    const e = this._mldsaKeypair.derivePath(t);
    if (!this._keypair.privateKey)
      throw new Error("Cannot derive from a watch-only wallet (no private key available)");
    const r = P.BIP32.fromPrivateKey(
      this._keypair.privateKey,
      this._chainCode,
      this.network
    ).derivePath(t);
    if (!r.privateKey)
      throw new Error("Failed to derive classical private key");
    if (!r.chainCode)
      throw new Error("Failed to derive classical chain code");
    return new rt(
      g(new Uint8Array(r.privateKey)),
      e.toBase58(),
      this.network,
      this._securityLevel,
      new Uint8Array(r.chainCode)
    );
  }
}
var Yt = /* @__PURE__ */ ((n) => (n[n.MINIMUM = 128] = "MINIMUM", n[n.LOW = 160] = "LOW", n[n.MEDIUM = 192] = "MEDIUM", n[n.HIGH = 224] = "HIGH", n[n.MAXIMUM = 256] = "MAXIMUM", n))(Yt || {}), Bt = /* @__PURE__ */ ((n) => (n[n.BIP44 = 44] = "BIP44", n[n.BIP49 = 49] = "BIP49", n[n.BIP84 = 84] = "BIP84", n[n.BIP86 = 86] = "BIP86", n))(Bt || {});
function fr(n) {
  switch (n) {
    case 44:
      return "BIP44: Legacy addresses (P2PKH), widely used by Unisat and other wallets";
    case 49:
      return "BIP49: Wrapped SegWit addresses (P2SH-P2WPKH)";
    case 84:
      return "BIP84: Native SegWit addresses (P2WPKH) - DEFAULT";
    case 86:
      return "BIP86: Taproot addresses (P2TR)";
    default:
      return "Unknown BIP standard";
  }
}
function ei(n, t, e, i, r) {
  return `m/${n}'/${t}'/${e}'/${i}/${r}`;
}
const gr = B.BIP32Factory(N);
class ye {
  _phrase;
  _passphrase;
  _network;
  _securityLevel;
  _seed;
  _classicalRoot;
  _quantumRoot;
  constructor(t, e = "", i = T.bitcoin, r = B.MLDSASecurityLevel.LEVEL2) {
    if (!Pt.validateMnemonic(t))
      throw new Error("Invalid mnemonic phrase");
    this._phrase = t, this._passphrase = e, this._network = i, this._securityLevel = r, this._seed = Pt.mnemonicToSeedSync(this._phrase, this._passphrase), this._classicalRoot = gr.fromSeed(this._seed, this._network), this._quantumRoot = B.QuantumBIP32Factory.fromSeed(
      this._seed,
      this._network,
      this._securityLevel
    );
  }
  get phrase() {
    return this._phrase;
  }
  get network() {
    return this._network;
  }
  get securityLevel() {
    return this._securityLevel;
  }
  get seed() {
    return new Uint8Array(this._seed);
  }
  static generatePhrase(t = Yt.MAXIMUM) {
    return Pt.generateMnemonic(t);
  }
  static generate(t = Yt.MAXIMUM, e = "", i = T.bitcoin, r = B.MLDSASecurityLevel.LEVEL2) {
    const s = Pt.generateMnemonic(t);
    return new ye(s, e, i, r);
  }
  static validate(t) {
    return Pt.validateMnemonic(t);
  }
  /**
   * Best-effort zeroing of secret material held by this mnemonic.
   *
   * Zeros the seed buffer and root private keys in-place.
   * The mnemonic phrase and passphrase are JS strings and cannot be zeroed.
   */
  zeroize() {
    this._seed.fill(0), this._classicalRoot.privateKey?.fill(0), this._quantumRoot.privateKey?.fill(0);
  }
  [Symbol.dispose]() {
    this.zeroize();
  }
  derive(t = 0, e = 0, i = !1, r = Bt.BIP84) {
    const s = this.buildClassicalPath(e, t, i, r), o = this._classicalRoot.derivePath(s);
    if (!o.privateKey)
      throw new Error(`Failed to derive classical private key at index ${t}`);
    const a = this.buildQuantumPath(e, t, i), c = this._quantumRoot.derivePath(a);
    if (!c.privateKey)
      throw new Error(`Failed to derive quantum private key at index ${t}`);
    return new rt(
      g(new Uint8Array(o.privateKey)),
      g(new Uint8Array(c.privateKey)),
      this._network,
      this._securityLevel,
      new Uint8Array(this._quantumRoot.chainCode)
    );
  }
  deriveOPWallet(t = st.P2TR, e = 0, i = 0, r = !1) {
    let s;
    switch (t) {
      case st.P2PKH:
        s = 44;
        break;
      case st.P2SH_OR_P2SH_P2WPKH:
        s = 49;
        break;
      case st.P2WPKH:
        s = 84;
        break;
      case st.P2TR:
        s = 86;
        break;
      default:
        throw new Error(`Unsupported address type: ${t}`);
    }
    const o = this.getCoinType(), a = r ? 1 : 0, c = `m/${s}'/0'/${i}'/${a}/${e}`, u = this._classicalRoot.derivePath(c);
    if (!u.privateKey)
      throw new Error(`Failed to derive classical private key at path ${c}`);
    const l = `m/360'/${o}'/${i}'/${a}/${e}`, h = this._quantumRoot.derivePath(l);
    if (!h.privateKey)
      throw new Error(`Failed to derive quantum private key at path ${l}`);
    return new rt(
      g(new Uint8Array(u.privateKey)),
      g(new Uint8Array(h.privateKey)),
      this._network,
      this._securityLevel,
      new Uint8Array(this._quantumRoot.chainCode)
    );
  }
  deriveMultipleUnisat(t = st.P2TR, e = 5, i = 0, r = 0, s = !1) {
    const o = [];
    for (let a = 0; a < e; a++)
      o.push(this.deriveOPWallet(t, i + a, r, s));
    return o;
  }
  deriveMultiple(t, e = 0, i = 0, r = !1, s = Bt.BIP84) {
    const o = [];
    for (let a = 0; a < t; a++)
      o.push(this.derive(e + a, i, r, s));
    return o;
  }
  deriveCustomPath(t, e) {
    const i = this._classicalRoot.derivePath(t), r = this._quantumRoot.derivePath(e);
    if (!i.privateKey)
      throw new Error(`Failed to derive classical private key at path ${t}`);
    if (!r.privateKey)
      throw new Error(`Failed to derive quantum private key at path ${e}`);
    return new rt(
      g(new Uint8Array(i.privateKey)),
      g(new Uint8Array(r.privateKey)),
      this._network,
      this._securityLevel,
      new Uint8Array(this._quantumRoot.chainCode)
    );
  }
  getClassicalRoot() {
    return this._classicalRoot;
  }
  getQuantumRoot() {
    return this._quantumRoot;
  }
  buildClassicalPath(t, e, i, r = Bt.BIP84) {
    const s = this.getCoinType();
    return ei(r, s, t, i ? 1 : 0, e);
  }
  buildQuantumPath(t, e, i) {
    return `m/360'/${this.getCoinType()}'/${t}'/${i ? 1 : 0}/${e}`;
  }
  getCoinType() {
    return this._network.bech32 === T.testnet.bech32 || this._network.bech32 === T.opnetTestnet.bech32 || this._network.bech32 === T.regtest.bech32 ? 1 : 0;
  }
}
var ii = /* @__PURE__ */ ((n) => (n[n.MLDSA44 = 1312] = "MLDSA44", n[n.MLDSA65 = 1952] = "MLDSA65", n[n.MLDSA87 = 2592] = "MLDSA87", n))(ii || {});
function ue(n) {
  switch (n) {
    case 1312:
      return B.MLDSASecurityLevel.LEVEL2;
    case 1952:
      return B.MLDSASecurityLevel.LEVEL3;
    case 2592:
      return B.MLDSASecurityLevel.LEVEL5;
    default:
      throw new Error(`Invalid MLDSA public key length: ${n}`);
  }
}
class Sr {
  constructor(t = T.bitcoin) {
    this.network = t;
  }
  /**
   * @description Get the contract address
   * @param {Network} network - The network to get the address for
   */
  static getAddress(t = T.bitcoin) {
    throw new Error("Method not implemented.");
  }
  /**
   * @description Get the contract address
   */
  getAddress() {
    return this.address;
  }
}
var me = /* @__PURE__ */ ((n) => (n[n.Bitcoin = 0] = "Bitcoin", n[n.Fractal = 1] = "Fractal", n))(me || {});
function Te(n) {
  return n && !!(n.tapInternalKey || n.tapMerkleRoot || n.tapLeafScript && n.tapLeafScript.length || n.tapBip32Derivation && n.tapBip32Derivation.length || n.witnessUtxo && (He(n.witnessUtxo.script) || Ve(n.witnessUtxo.script)));
}
function wr(n) {
  return n.redeemScript ? n.redeemScript : n.witnessScript ? n.witnessScript : n.witnessUtxo ? n.witnessUtxo.script : (n.nonWitnessUtxo, null);
}
function be(n, t) {
  if (n.nonWitnessUtxo && !n.redeemScript && !n.witnessScript && !n.witnessUtxo || n.redeemScript)
    return !0;
  const e = wr(n);
  return e ? Ae(t, e) : !1;
}
function Ae(n, t) {
  return Ri(n, t) !== -1;
}
class Ee {
  constructor() {
  }
}
class yr extends Ee {
  isInitialized = !1;
  constructor() {
    if (super(), !window)
      throw new Error("UnisatSigner can only be used in a browser environment");
  }
  _p2tr;
  get p2tr() {
    if (!this._p2tr)
      throw new Error("P2TR address not set");
    return this._p2tr;
  }
  _p2wpkh;
  get p2wpkh() {
    if (!this._p2wpkh)
      throw new Error("P2PKH address not set");
    return this._p2wpkh;
  }
  _addresses;
  get addresses() {
    if (!this._addresses)
      throw new Error("Addresses not set");
    return this._addresses;
  }
  _publicKey;
  get publicKey() {
    if (!this._publicKey)
      throw new Error("Public key not set");
    return this._publicKey;
  }
  _network;
  get network() {
    if (!this._network)
      throw new Error("Network not set");
    return this._network;
  }
  get unisat() {
    if (!window) throw new Error("Window not found");
    const t = window.unisat;
    if (!t)
      throw new Error("Unisat extension not found");
    return t;
  }
  async signData(t, e) {
    const i = g(t), r = await this.unisat.signData(i, e);
    return w(r);
  }
  async init() {
    if (this.isInitialized)
      return;
    const t = await this.unisat.getNetwork();
    switch (t) {
      case yt.Mainnet:
        this._network = T.bitcoin;
        break;
      case yt.Testnet:
        this._network = T.testnet;
        break;
      case yt.OpnetTestnet:
        this._network = T.opnetTestnet;
        break;
      case yt.Regtest:
        this._network = T.regtest;
        break;
      default:
        throw new Error(`Invalid network: ${t}`);
    }
    const e = await this.unisat.getPublicKey();
    if (e === "")
      throw new Error("Unlock your wallet first");
    this._publicKey = pe(w(e)), this._p2wpkh = P.getP2WPKHAddress(this, this.network), this._p2tr = P.getTaprootAddress(this, this.network), this._addresses = [this._p2wpkh, this._p2tr], this.isInitialized = !0;
  }
  getPublicKey() {
    if (!this.isInitialized)
      throw new Error("UnisatSigner not initialized");
    return this.publicKey;
  }
  sign(t, e) {
    throw new Error("Not implemented: sign");
  }
  signSchnorr(t) {
    throw new Error("Not implemented: signSchnorr");
  }
  verify(t, e) {
    throw new Error("Not implemented: verify");
  }
  async signTaprootInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, !1);
    this.combine(t, s, e);
  }
  async signInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, !0);
    this.combine(t, s, e);
  }
  async multiSignPsbt(t) {
    const e = [], i = [];
    for (const o of t) {
      const a = o.toHex();
      e.push(a);
      const c = o.data.inputs.map((u, l) => {
        let h = !1, d = !1;
        if (Te(u)) {
          if (u.tapLeafScript && u.tapLeafScript.length > 0) {
            for (const p of u.tapLeafScript)
              if (mr(this.publicKey, p.script)) {
                h = !0, d = !1;
                break;
              }
          }
          if (!h && u.tapInternalKey) {
            const p = u.tapInternalKey, y = U(this.publicKey);
            C(p, y) && (h = !0, d = !0);
          }
        } else be(u, this.publicKey) && (h = !0, d = !1);
        return h ? {
          index: l,
          publicKey: g(this.publicKey),
          disableTweakSigner: !d
        } : null;
      }).filter((u) => u !== null);
      i.push({
        autoFinalized: !1,
        toSignInputs: c
      });
    }
    const r = await this.unisat.signPsbt(
      e[0],
      i[0]
    ), s = X.fromHex(r);
    t[0].combine(s);
  }
  hasAlreadySignedTapScriptSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = new Uint8Array(i.pubkey);
      if (C(r, this.publicKey) && i.signature)
        return !0;
    }
    return !1;
  }
  hasAlreadyPartialSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = new Uint8Array(i.pubkey);
      if (C(r, this.publicKey) && i.signature)
        return !0;
    }
    return !1;
  }
  combine(t, e, i) {
    const r = e.data.inputs[i], s = t.data.inputs[i];
    if (r.partialSig && t.updateInput(i, { partialSig: r.partialSig }), r.tapKeySig && !s.tapKeySig && t.updateInput(i, { tapKeySig: r.tapKeySig }), r.tapScriptSig?.length) {
      const o = s.tapScriptSig;
      if (o) {
        const a = this.getNonDuplicateScriptSig(
          o,
          r.tapScriptSig
        );
        a.length && t.updateInput(i, { tapScriptSig: a });
      } else
        t.updateInput(i, { tapScriptSig: r.tapScriptSig });
    }
  }
  async signAllTweaked(t, e, i = !1) {
    const r = g(this.publicKey), o = {
      autoFinalized: !1,
      toSignInputs: t.data.inputs.map((u, l) => [
        {
          index: l,
          publicKey: r,
          sighashTypes: e,
          disableTweakSigner: i
        }
      ]).flat()
    }, a = t.toHex(), c = await this.unisat.signPsbt(a, o);
    return X.fromHex(c);
  }
  getNonDuplicateScriptSig(t, e) {
    const i = [];
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      t.find((a) => C(a.pubkey, s.pubkey)) || i.push(s);
    }
    return i;
  }
}
function mr(n, t) {
  return Tr(n, t) !== -1;
}
function Tr(n, t) {
  const e = F.hash160(n), i = U(n), r = O.decompile(t);
  if (r === null) throw new Error("Unknown script error");
  return r.findIndex((s) => typeof s == "number" ? !1 : s instanceof Uint8Array && (C(s, n) || C(s, e) || C(s, i)));
}
function ri(n) {
  return new Map(n);
}
function br(n) {
  return {
    enabled: !0,
    signerMap: n instanceof Map ? n : ri(n)
  };
}
function Ar() {
  return {
    enabled: !1,
    signerMap: /* @__PURE__ */ new Map()
  };
}
function Er(n) {
  return {
    publicKey: n.publicKey,
    getPrivateKey() {
      if (!n.privateKey)
        throw new Error("Signer does not have a private key");
      return We(n.privateKey);
    },
    sign(t, e) {
      return n.sign(t, e);
    },
    signSchnorr(t) {
      if (!n.signSchnorr)
        throw new Error("Signer does not support Schnorr signing");
      return n.signSchnorr(t);
    }
  };
}
function si(n, t) {
  return {
    publicKey: pe(n.publicKey),
    getPrivateKey() {
      if (!t.privateKey)
        throw new Error("Tweaked signer does not have a private key");
      return We(t.privateKey);
    },
    sign(e, i) {
      return t.sign(e, i);
    },
    signSchnorr(e) {
      if (!t.signSchnorr)
        throw new Error("Tweaked signer does not support Schnorr signing");
      return t.signSchnorr(
        e
      );
    }
  };
}
var b = /* @__PURE__ */ ((n) => (n[n.GENERIC = 0] = "GENERIC", n[n.FUNDING = 1] = "FUNDING", n[n.DEPLOYMENT = 2] = "DEPLOYMENT", n[n.INTERACTION = 3] = "INTERACTION", n[n.MULTI_SIG = 4] = "MULTI_SIG", n[n.CUSTOM_CODE = 5] = "CUSTOM_CODE", n[n.CANCEL = 6] = "CANCEL", n[n.CONSOLIDATED_SETUP = 7] = "CONSOLIDATED_SETUP", n[n.CONSOLIDATED_REVEAL = 8] = "CONSOLIDATED_REVEAL", n))(b || {});
function le(n) {
  let t = new Uint8Array(0);
  function e(a, c) {
    const u = new Uint8Array(a.length + c.length);
    return u.set(a, 0), u.set(c, a.length), u;
  }
  function i(a) {
    t = e(t, a);
  }
  function r(a) {
    const c = t.length, u = ne.encodingLength(a), l = new Uint8Array(c + u);
    l.set(t, 0), t = l, ne.encode(a, t, c);
  }
  function s(a) {
    r(a.length), i(a);
  }
  function o(a) {
    r(a.length), a.forEach(s);
  }
  return o(n), t;
}
var ni = /* @__PURE__ */ ((n) => (n[n.REPLACE_BY_FEE = 4294967293] = "REPLACE_BY_FEE", n[n.FINAL = 4294967295] = "FINAL", n))(ni || {}), oi = /* @__PURE__ */ ((n) => (n[n.BLOCKS = 0] = "BLOCKS", n[n.TIMESTAMPS = 1] = "TIMESTAMPS", n))(oi || {});
class Nt extends Me {
  logColor = "#00ffe1";
  finalized = !1;
  /**
   * @description Was the transaction signed?
   */
  signer;
  /**
   * @description Tweaked signer
   */
  tweakedSigner;
  /**
   * @description The network of the transaction
   */
  network;
  /**
   * @description Was the transaction signed?
   */
  signed = !1;
  /**
   * @description The sighash types of the transaction
   * @protected
   */
  sighashTypes;
  /**
   * @description The script data of the transaction
   */
  scriptData = null;
  /**
   * @description The tap data of the transaction
   */
  tapData = null;
  /**
   * @description The inputs of the transaction
   */
  inputs = [];
  /**
   * @description The sequence of the transaction
   * @protected
   */
  sequence = 4294967293;
  /**
   * The tap leaf script
   * @protected
   */
  tapLeafScript = null;
  /**
   * Add a non-witness utxo to the transaction
   * @protected
   */
  nonWitnessUtxo;
  /**
   * Is the transaction being generated inside a browser?
   * @protected
   */
  isBrowser = !1;
  /**
   * Track which inputs contain CSV scripts
   * @protected
   */
  csvInputIndices = /* @__PURE__ */ new Set();
  anchorInputIndices = /* @__PURE__ */ new Set();
  regenerated = !1;
  ignoreSignatureErrors = !1;
  noSignatures = !1;
  unlockScript;
  txVersion = 2;
  _mldsaSigner = null;
  _hashedPublicKey = null;
  /**
   * Whether address rotation mode is enabled.
   * When true, each UTXO can be signed by a different signer.
   */
  addressRotationEnabled = !1;
  /**
   * Map of addresses to their respective signers for address rotation mode.
   */
  signerMap = /* @__PURE__ */ new Map();
  /**
   * Map of input indices to their signers (resolved from UTXOs or signerMap).
   * Populated during input addition.
   */
  inputSignerMap = /* @__PURE__ */ new Map();
  /**
   * Cache of tweaked signers per input for address rotation mode.
   */
  tweakedSignerCache = /* @__PURE__ */ new Map();
  /**
   * Parallel signing configuration using worker threads.
   * When set, key-path taproot inputs are signed in parallel via workers.
   */
  parallelSigningConfig;
  /**
   * Whether to use P2MR (Pay-to-Merkle-Root, BIP 360) instead of P2TR.
   */
  useP2MR = !1;
  constructor(t) {
    super(), this.signer = t.signer, this.network = t.network, this.noSignatures = t.noSignatures || !1, t.nonWitnessUtxo !== void 0 && (this.nonWitnessUtxo = t.nonWitnessUtxo), t.unlockScript !== void 0 && (this.unlockScript = t.unlockScript), this.isBrowser = typeof window < "u", t.txVersion && (this.txVersion = t.txVersion), t.mldsaSigner && (this._mldsaSigner = t.mldsaSigner, this._hashedPublicKey = ct.sha256(this._mldsaSigner.publicKey)), t.addressRotation?.enabled && (this.addressRotationEnabled = !0, this.signerMap = t.addressRotation.signerMap), t.parallelSigning && (this.parallelSigningConfig = t.parallelSigning), t.useP2MR && (this.useP2MR = !0);
  }
  /**
   * Get the MLDSA signer
   * @protected
   */
  get mldsaSigner() {
    if (!this._mldsaSigner)
      throw new Error("MLDSA Signer is not set");
    return this._mldsaSigner;
  }
  /**
   * Get the hashed public key
   * @protected
   */
  get hashedPublicKey() {
    if (!this._hashedPublicKey)
      throw new Error("Hashed public key is not set");
    return this._hashedPublicKey;
  }
  /**
   * Whether parallel signing can be used for this transaction.
   * Requires parallelSigningConfig and excludes browser, address rotation, and no-signature modes.
   */
  get canUseParallelSigning() {
    return !!this.parallelSigningConfig && !this.addressRotationEnabled && !this.noSignatures;
  }
  /**
   * Read witnesses
   * @protected
   */
  static readScriptWitnessToWitnessStack(t) {
    let e = 0;
    function i(a) {
      const c = new Uint8Array(t.subarray(e, e + a));
      return e += a, c;
    }
    function r() {
      const a = ne.decode(t, e);
      return e += a.bytes, a.numberValue || 0;
    }
    function s() {
      const a = r();
      return i(a);
    }
    function o() {
      const a = r(), c = [];
      for (let u = 0; u < a; u++)
        c.push(s());
      return c;
    }
    return o();
  }
  /**
   * Pre-estimate the transaction fees for a Taproot transaction
   * @param {bigint} feeRate - The fee rate in satoshis per virtual byte
   * @param {bigint} numInputs - The number of inputs
   * @param {bigint} numOutputs - The number of outputs
   * @param {bigint} numWitnessElements - The number of witness elements (e.g., number of control blocks and witnesses)
   * @param {bigint} witnessElementSize - The average size of each witness element in bytes
   * @param {bigint} emptyWitness - The amount of empty witnesses
   * @param {bigint} [taprootControlWitnessSize=139n] - The size of the control block witness in bytes
   * @param {bigint} [taprootScriptSize=32n] - The size of the taproot script in bytes
   * @returns {bigint} - The estimated transaction fees
   */
  static preEstimateTaprootTransactionFees(t, e, i, r, s, o, a = 32n, c = 139n) {
    const u = 10n, l = 41n, h = 68n, d = 1n, p = u + l * e + h * i, y = e * d + r * s + a * e + c * e + o;
    return (p * 3n + (p + y)) / 4n * t;
  }
  static signInput(t, e, i, r, s) {
    s && s[0] && (e.sighashType = s[0]), t.signInput(i, r, s.length ? s : void 0);
  }
  /**
   * Calculate the sign hash number
   * @description Calculates the sign hash
   * @protected
   * @returns {number}
   */
  static calculateSignHash(t) {
    if (!t)
      throw new Error("Sighash types are required");
    let e = 0;
    for (const i of t)
      e |= i;
    return e || 0;
  }
  [Symbol.dispose]() {
    this.inputs.length = 0, this.scriptData = null, this.tapData = null, this.tapLeafScript = null, delete this.tweakedSigner, this.csvInputIndices.clear(), this.anchorInputIndices.clear(), this.inputSignerMap.clear(), this.tweakedSignerCache.clear(), delete this.parallelSigningConfig;
  }
  /**
   * Check if address rotation mode is enabled.
   */
  isAddressRotationEnabled() {
    return this.addressRotationEnabled;
  }
  ignoreSignatureError() {
    this.ignoreSignatureErrors = !0;
  }
  /**
   * @description Returns the script address
   * @returns {string}
   */
  getScriptAddress() {
    if (!this.scriptData || !this.scriptData.address)
      throw new Error("Tap data is required");
    return this.scriptData.address;
  }
  /**
   * @description Returns the transaction
   * @returns {Transaction}
   */
  getTransaction() {
    return this.transaction.extractTransaction(!1);
  }
  /**
   * @description Returns the tap address
   * @returns {string}
   * @throws {Error} - If tap data is not set
   */
  getTapAddress() {
    if (!this.tapData || !this.tapData.address)
      throw new Error("Tap data is required");
    return this.tapData.address;
  }
  /**
   * @description Disables replace by fee on the transaction
   */
  disableRBF() {
    if (this.signed) throw new Error("Transaction is already signed");
    this.sequence = 4294967295;
    for (const t of this.inputs)
      this.csvInputIndices.has(this.inputs.indexOf(t)) || (t.sequence = 4294967295);
  }
  /**
   * Get the tweaked hash
   * @private
   *
   * @returns {Uint8Array | undefined} The tweaked hash
   */
  getTweakerHash() {
    return this.tapData?.hash;
  }
  /**
   * Pre-estimate the transaction fees
   * @param {bigint} feeRate - The fee rate
   * @param {bigint} numInputs - The number of inputs
   * @param {bigint} numOutputs - The number of outputs
   * @param {bigint} numSignatures - The number of signatures
   * @param {bigint} numPubkeys - The number of public keys
   * @returns {bigint} - The estimated transaction fees
   */
  preEstimateTransactionFees(t, e, i, r, s) {
    const o = 10n, a = 41n, c = 68n, u = 144n, l = 34n, h = o + a * e + c * i, d = 1n + s * (1n + l) + 1n + r, p = r * u + s * l + d;
    return (h * 3n + (h + p)) / 4n * t;
  }
  /**
   * Get the signer for a specific input index.
   * Returns the input-specific signer if in rotation mode, otherwise the default signer.
   * @param inputIndex - The index of the input
   */
  getSignerForInput(t) {
    if (this.addressRotationEnabled) {
      const e = this.inputSignerMap.get(t);
      if (e)
        return e;
    }
    return this.signer;
  }
  /**
   * Register a signer for a specific input index.
   * Called during UTXO processing to map each input to its signer.
   * @param inputIndex - The index of the input
   * @param utxo - The UTXO being added
   */
  registerInputSigner(t, e) {
    if (!this.addressRotationEnabled)
      return;
    if (e.signer) {
      this.inputSignerMap.set(t, e.signer);
      return;
    }
    const i = e.scriptPubKey?.address;
    if (i && this.signerMap.has(i)) {
      const r = this.signerMap.get(i);
      if (r) {
        this.inputSignerMap.set(t, r);
        return;
      }
    }
  }
  /**
   * Get the x-only public key for a specific input's signer.
   * Used for taproot inputs in address rotation mode.
   * @param inputIndex - The index of the input
   */
  internalPubKeyToXOnlyForInput(t) {
    const e = this.getSignerForInput(t);
    return U(e.publicKey);
  }
  /**
   * Get the tweaked signer for a specific input.
   * Caches the result for efficiency.
   * @param inputIndex - The index of the input
   * @param useTweakedHash - Whether to use the tweaked hash
   */
  getTweakedSignerForInput(t, e = !1) {
    if (!this.addressRotationEnabled)
      return e ? (this.tweakSigner(), this.tweakedSigner) : this.getTweakedSigner(e);
    const i = t * 2 + (e ? 1 : 0);
    if (this.tweakedSignerCache.has(i))
      return this.tweakedSignerCache.get(i);
    const r = this.getSignerForInput(t), s = this.getTweakedSigner(e, r);
    return this.tweakedSignerCache.set(i, s), s;
  }
  generateTapData() {
    return this.useP2MR ? {
      network: this.network,
      name: v.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      name: v.P2TR
    };
  }
  /**
   * Generates the script address.
   * @protected
   * @returns {TapPayment}
   */
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      name: v.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      name: v.P2TR
    };
  }
  /**
   * Returns the signer key.
   * @protected
   * @returns {Signer | UniversalSigner}
   */
  getSignerKey() {
    return this.signer;
  }
  /**
   * Signs an input of the transaction.
   * @param {Psbt} transaction - The transaction to sign
   * @param {PsbtInput} input - The input to sign
   * @param {number} i - The index of the input
   * @param {Signer} signer - The signer to use
   * @param {boolean} [reverse=false] - Should the input be signed in reverse
   * @param {boolean} [errored=false] - Was there an error
   * @protected
   */
  async signInput(t, e, i, r, s = !1, o = !1) {
    if (this.anchorInputIndices.has(i)) return;
    const a = r.publicKey;
    let c = Te(e);
    s && (c = !c);
    let u = !1, l = !1;
    if (c)
      try {
        await this.attemptSignTaproot(t, e, i, r, a), u = !0;
      } catch (h) {
        this.error(
          `Failed to sign Taproot script path input ${i} (reverse: ${s}): ${h.message}`
        ), l = !0;
      }
    else if (s || be(e, a))
      try {
        await this.signNonTaprootInput(r, t, i), u = !0;
      } catch (h) {
        this.error(`Failed to sign non-Taproot input ${i}: ${h.stack}`), l = !0;
      }
    if (!u) {
      if (l && o)
        throw new Error(`Failed to sign input ${i} with the provided signer.`);
      try {
        await this.signInput(t, e, i, r, !0, l);
      } catch {
        throw new Error(`Cannot sign input ${i} with the provided signer.`);
      }
    }
  }
  splitArray(t, e) {
    if (e <= 0)
      throw new Error("Chunk size must be greater than 0.");
    const i = [];
    for (let r = 0; r < t.length; r += e)
      i.push(t.slice(r, r + e));
    return i;
  }
  /**
   * Signs all the inputs of the transaction.
   * @param {Psbt} transaction - The transaction to sign
   * @protected
   * @returns {Promise<void>}
   */
  async signInputs(t) {
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(t);
      return;
    }
    await this.signInputsNonWalletBased(t);
  }
  async signInputsNonWalletBased(t) {
    if (!this.noSignatures)
      if (this.canUseParallelSigning && pt(this.signer)) {
        let e = /* @__PURE__ */ new Set();
        try {
          const i = await this.signKeyPathInputsParallel(t);
          i.success && (e = new Set(i.signatures.keys()));
        } catch (i) {
          this.error(
            `Parallel signing failed, falling back to sequential: ${i.message}`
          );
        }
        await this.signRemainingInputsSequential(t, e);
      } else
        await this.signInputsSequential(t);
    for (let e = 0; e < t.data.inputs.length; e++)
      t.finalizeInput(e, this.customFinalizerP2SH.bind(this));
    this.finalized = !0;
  }
  /**
   * Signs all inputs sequentially in batches of 20.
   * This is the original signing logic, used as fallback when parallel signing is unavailable.
   */
  async signInputsSequential(t) {
    const e = t.data.inputs, i = 20, r = this.splitArray(e, i);
    for (let s = 0; s < r.length; s++) {
      const o = r[s], a = [], c = s * i;
      for (let u = 0; u < o.length; u++) {
        const l = c + u, h = o[u];
        try {
          const d = this.getSignerForInput(l);
          a.push(this.signInput(t, h, l, d));
        } catch (d) {
          this.log(`Failed to sign input ${l}: ${d.stack}`);
        }
      }
      await Promise.all(a);
    }
  }
  /**
   * Signs inputs that were not handled by parallel signing.
   * After parallel key-path signing, script-path taproot inputs, non-taproot inputs,
   * and any inputs that failed parallel signing need sequential signing.
   */
  async signRemainingInputsSequential(t, e) {
    const i = t.data.inputs, r = [];
    for (let a = 0; a < i.length; a++)
      e.has(a) || r.push(a);
    if (r.length === 0) return;
    const o = this.splitArray(r, 20);
    for (const a of o) {
      const c = [];
      for (const u of a) {
        const l = i[u];
        try {
          const h = this.getSignerForInput(u);
          c.push(this.signInput(t, l, u, h));
        } catch (h) {
          this.log(`Failed to sign input ${u}: ${h.stack}`);
        }
      }
      await Promise.all(c);
    }
  }
  /**
   * Converts the public key to x-only.
   * @protected
   * @returns {Uint8Array}
   */
  internalPubKeyToXOnly() {
    return U(this.signer.publicKey);
  }
  /**
   * Internal init.
   * @protected
   */
  internalInit() {
    const t = this.generateScriptAddress(), e = this.generateTapData();
    t.name === v.P2MR ? this.scriptData = _.p2mr(t) : this.scriptData = _.p2tr(t), e.name === v.P2MR ? this.tapData = _.p2mr(e) : this.tapData = _.p2tr(e);
  }
  /**
   * Tweak the signer for the interaction
   * @protected
   */
  tweakSigner() {
    if (this.tweakedSigner) return;
    const t = this.getTweakedSigner(!0);
    t !== void 0 && (this.tweakedSigner = t);
  }
  /**
   * Get the tweaked signer
   * @private
   * @returns {UniversalSigner} The tweaked signer
   */
  getTweakedSigner(t = !1, e = this.signer) {
    const i = {
      network: this.network
    };
    if (t) {
      const r = this.getTweakerHash();
      r !== void 0 && (i.tweakHash = r);
    }
    if (pt(e))
      return we.tweakSigner(e, i);
  }
  /**
   * Signs key-path taproot inputs in parallel using worker threads.
   * @param transaction - The PSBT to sign
   * @param excludeIndices - Input indices to skip (e.g., script-path inputs already signed)
   * @returns The parallel signing result
   */
  async signKeyPathInputsParallel(t, e) {
    const i = this.signer, r = this.getTweakedSigner(!0);
    if (!r)
      throw new Error("Cannot create tweaked signer for parallel signing");
    const s = si(i, r), o = Ki(t, s), a = e ? o.filter((l) => !e.has(l.inputIndex)) : o;
    if (a.length === 0)
      return {
        success: !0,
        signatures: /* @__PURE__ */ new Map(),
        errors: /* @__PURE__ */ new Map(),
        durationMs: 0
      };
    let c, u = !1;
    this.parallelSigningConfig && "signBatch" in this.parallelSigningConfig ? c = this.parallelSigningConfig : (c = xi.getInstance(this.parallelSigningConfig), c.isPreservingWorkers || (u = !0));
    try {
      await c.initialize();
      const l = await c.signBatch(a, s);
      if (l.success)
        Di(t, l, s);
      else {
        const d = [...l.errors.entries()].map(([p, y]) => `Input ${p}: ${y}`).join(", ");
        this.error(`Parallel signing had errors: ${d}`);
      }
      return l;
    } finally {
      u && await c.shutdown();
    }
  }
  generateP2SHRedeemScript(t) {
    const e = _.p2wsh({
      redeem: { output: t },
      network: this.network
    });
    return _.p2sh({
      redeem: e,
      network: this.network
    }).output;
  }
  generateP2SHRedeemScriptLegacy(t) {
    const e = F.hash160(this.signer.publicKey), i = O.compile([
      f.OP_DUP,
      f.OP_HASH160,
      e,
      f.OP_EQUALVERIFY,
      f.OP_CHECKSIG
    ]), r = F.hash160(i), s = O.compile([
      f.OP_HASH160,
      r,
      f.OP_EQUAL
    ]), o = _.p2wsh({
      redeem: { output: i },
      // Use the custom redeem script
      network: this.network
    }), a = _.p2sh({
      redeem: o,
      // The P2WSH is wrapped inside the P2SH
      network: this.network
    });
    if (q.fromOutputScript(s, this.network) === t && a.redeem && a.redeem.output)
      return {
        redeemScript: i,
        outputScript: a.redeem.output
      };
  }
  generateP2SHP2PKHRedeemScript(t, e) {
    const r = (this.addressRotationEnabled && e !== void 0 ? this.getSignerForInput(e) : this.signer).publicKey, s = _.p2wpkh({
      pubkey: r,
      network: this.network
    }), o = _.p2sh({
      redeem: s,
      network: this.network
    }), a = o.address;
    if (!o.redeem?.output)
      throw new Error("Failed to generate P2SH-P2WPKH redeem script");
    if (a === t && o.redeem && o.redeem.output && o.output)
      return {
        redeemScript: o.redeem.output,
        outputScript: o.output
      };
  }
  /**
   * Generate the PSBT input extended, supporting various script types
   * @param {UTXO} utxo The UTXO
   * @param {number} i The index of the input
   * @param {UTXO} _extra Extra UTXO
   * @protected
   * @returns {PsbtInputExtended} The PSBT input extended
   */
  generatePsbtInputExtended(t, e, i = !1) {
    const r = w(t.scriptPubKey.hex), s = {
      hash: t.transactionId,
      index: t.outputIndex,
      sequence: this.sequence,
      witnessUtxo: {
        value: t.value,
        script: r
      }
    };
    if (Ci(r))
      if (t.nonWitnessUtxo)
        s.nonWitnessUtxo = t.nonWitnessUtxo instanceof Uint8Array ? t.nonWitnessUtxo : w(t.nonWitnessUtxo);
      else
        throw new Error("Missing nonWitnessUtxo for P2PKH UTXO");
    else if (!(Re(r) || Ni(r))) if (Ke(r))
      this.processP2WSHInput(t, s, e);
    else if (Fi(r)) {
      let o;
      if (t.redeemScript)
        o = t.redeemScript instanceof Uint8Array ? t.redeemScript : w(t.redeemScript);
      else {
        if (!t.scriptPubKey.address)
          throw new Error(
            "Missing redeemScript and no address to regenerate it for P2SH UTXO"
          );
        const u = this.generateP2SHP2PKHRedeemScript(
          t.scriptPubKey.address,
          e
        );
        if (!u)
          throw new Error("Missing redeemScript for P2SH UTXO and unable to regenerate");
        o = u.redeemScript;
      }
      s.redeemScript = o;
      const a = _.p2sh({ redeem: { output: s.redeemScript } });
      if (!a.redeem)
        throw new Error("Failed to extract redeem script from P2SH UTXO");
      const c = a.redeem.output;
      if (!c)
        throw new Error("Failed to extract redeem output from P2SH UTXO");
      t.nonWitnessUtxo && (s.nonWitnessUtxo = t.nonWitnessUtxo instanceof Uint8Array ? t.nonWitnessUtxo : w(t.nonWitnessUtxo)), Re(c) ? Reflect.deleteProperty(s, "nonWitnessUtxo") : Ke(c) ? (Reflect.deleteProperty(s, "nonWitnessUtxo"), this.processP2WSHInput(t, s, e)) : Reflect.deleteProperty(s, "witnessUtxo");
    } else if (He(r)) {
      if (this.sighashTypes) {
        const o = Nt.calculateSignHash(this.sighashTypes);
        o && (s.sighashType = o);
      }
      this.addressRotationEnabled ? s.tapInternalKey = this.internalPubKeyToXOnlyForInput(e) : (this.tweakSigner(), s.tapInternalKey = this.internalPubKeyToXOnly());
    } else if (Ve(r)) {
      if (this.sighashTypes) {
        const o = Nt.calculateSignHash(this.sighashTypes);
        o && (s.sighashType = o);
      }
      e === 0 && this.tapData?.hash && (s.tapMerkleRoot = this.tapData.hash);
    } else if (Mi(r))
      this.anchorInputIndices.add(e), s.isPayToAnchor = !0;
    else if (Wi(r) || Hi(r))
      if (t.nonWitnessUtxo)
        s.nonWitnessUtxo = t.nonWitnessUtxo instanceof Uint8Array ? t.nonWitnessUtxo : w(t.nonWitnessUtxo);
      else
        throw new Error("Missing nonWitnessUtxo for P2PK or P2MS UTXO");
    else
      this.error(`Unknown or unsupported script type for output: ${t.scriptPubKey.hex}`);
    return e === 0 && (this.tapLeafScript && (s.tapLeafScript = [this.tapLeafScript]), this.nonWitnessUtxo && (s.nonWitnessUtxo = this.nonWitnessUtxo)), s;
  }
  processP2WSHInput(t, e, i) {
    if (!t.witnessScript)
      throw new Error("Missing witnessScript for P2WSH UTXO");
    e.witnessScript = t.witnessScript instanceof Uint8Array ? t.witnessScript : w(t.witnessScript);
    const r = O.decompile(e.witnessScript);
    if (r && this.isCSVScript(r)) {
      const s = O.decompile(e.witnessScript);
      if (s && this.isCSVScript(s)) {
        this.csvInputIndices.add(i);
        const o = this.extractCSVBlocks(s);
        e.sequence = this.setCSVSequence(
          o,
          this.sequence
        );
      }
    }
  }
  secondsToCSVTimeUnits(t) {
    return Math.floor(t / 512);
  }
  createTimeBasedCSV(t) {
    const e = this.secondsToCSVTimeUnits(t);
    if (e > 65535)
      throw new Error(`Time units ${e} exceeds maximum of 65,535`);
    return e | 1 << 22;
  }
  isCSVEnabled(t) {
    return (t & 1 << 31) === 0;
  }
  extractCSVValue(t) {
    return t & 65535;
  }
  customFinalizerP2SH = (t, e, i, r, s, o, a) => {
    const c = this.inputs[t];
    if (s && e.partialSig && c && c.redeemScript) {
      const u = e.partialSig.map((h) => h.signature) || [];
      return {
        finalScriptSig: O.compile([...u, c.redeemScript]),
        finalScriptWitness: void 0
      };
    }
    if (this.anchorInputIndices.has(t))
      return {
        finalScriptSig: void 0,
        finalScriptWitness: Uint8Array.from([0])
      };
    if (o && r && e.witnessScript) {
      if (!e.partialSig || e.partialSig.length === 0)
        throw new Error(`No signatures for P2WSH input #${t}`);
      if (Z.isP2WDAWitnessScript(e.witnessScript))
        return this.finalizeSecondaryP2WDA(t, e);
      if (this.csvInputIndices.has(t)) {
        const h = [
          e.partialSig[0].signature,
          e.witnessScript
        ];
        return {
          finalScriptSig: void 0,
          finalScriptWitness: le(h)
        };
      }
    }
    return ze(
      t,
      e,
      i,
      r,
      s,
      o,
      !0,
      this.unlockScript
    );
  };
  /**
   * Finalize secondary P2WDA inputs with empty data
   */
  finalizeSecondaryP2WDA(t, e) {
    if (!e.partialSig || e.partialSig.length === 0)
      throw new Error(`No signature for P2WDA input #${t}`);
    if (!e.witnessScript)
      throw new Error(`No witness script for P2WDA input #${t}`);
    const i = Z.createSimpleP2WDAWitness(
      e.partialSig[0].signature,
      e.witnessScript
    );
    return {
      finalScriptSig: void 0,
      finalScriptWitness: le(i)
    };
  }
  async signInputsWalletBased(t) {
    await this.signer.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
    this.finalized = !0;
  }
  isCSVScript(t) {
    return t.some((e) => e === f.OP_CHECKSEQUENCEVERIFY);
  }
  setCSVSequence(t, e) {
    if (this.txVersion < 2)
      throw new Error("CSV requires transaction version 2 or higher");
    if (t > 65535)
      throw new Error(`CSV blocks ${t} exceeds maximum of 65,535`);
    const i = (t & 1 << 22) !== 0;
    let r = t & 65535;
    return i && (r |= 1 << 22), e === 4294967293 && (r |= 1 << 25), r = r & 2147483647, r;
  }
  getCSVType(t) {
    return t & 1 << 22 ? 1 : 0;
  }
  extractCSVBlocks(t) {
    for (let e = 0; e < t.length; e++)
      if (t[e] === f.OP_CHECKSEQUENCEVERIFY && e > 0) {
        const i = t[e - 1];
        if (i instanceof Uint8Array)
          return O.number.decode(i);
        if (typeof i == "number") {
          if (i === f.OP_0 || i === f.OP_FALSE)
            return 0;
          if (i === f.OP_1NEGATE)
            return -1;
          if (i >= f.OP_1 && i <= f.OP_16)
            return i - f.OP_1 + 1;
          throw new Error(`Unexpected raw number in script: ${i}`);
        }
      }
    return 0;
  }
  async attemptSignTaproot(t, e, i, r, s) {
    if (this.isTaprootScriptSpend(e, s))
      await this.signTaprootInput(r, t, i);
    else {
      let a;
      if (r !== this.signer ? a = this.getTweakedSigner(!0, r) : (this.tweakedSigner || this.tweakSigner(), a = this.tweakedSigner), a)
        try {
          await this.signTaprootInput(a, t, i);
        } catch (c) {
          if (a = this.getTweakedSigner(!1, this.signer), !a)
            throw new Error(`Failed to obtain tweaked signer for input ${i}.`, {
              cause: c
            });
          await this.signTaprootInput(a, t, i);
        }
      else
        this.error(`Failed to obtain tweaked signer for input ${i}.`);
    }
  }
  isTaprootScriptSpend(t, e) {
    if (t.tapLeafScript && t.tapLeafScript.length > 0) {
      for (const i of t.tapLeafScript)
        if (Ae(e, i.script))
          return !0;
    }
    return !1;
  }
  async signTaprootInput(t, e, i, r) {
    if ("signTaprootInput" in t)
      try {
        await t.signTaprootInput(e, i, r);
      } catch {
        throw new Error("Failed to sign Taproot input with provided signer.");
      }
    else
      e.signTaprootInput(i, t);
  }
  async signNonTaprootInput(t, e, i) {
    "signInput" in t ? await t.signInput(e, i) : e.signInput(i, t);
  }
}
function vt(n) {
  return `${n.messagePrefix}|${n.bech32}`;
}
const Ir = /* @__PURE__ */ new Map([
  [
    vt(T.bitcoin),
    new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      25,
      214,
      104,
      156,
      8,
      90,
      225,
      101,
      131,
      30,
      147,
      79,
      247,
      99,
      174,
      70,
      162,
      166,
      193,
      114,
      179,
      241,
      182,
      10,
      140,
      226,
      111
    ])
  ],
  [
    vt(T.testnet),
    new Uint8Array([
      0,
      0,
      0,
      0,
      9,
      51,
      234,
      1,
      173,
      14,
      233,
      132,
      32,
      151,
      121,
      186,
      174,
      195,
      206,
      217,
      15,
      163,
      244,
      8,
      113,
      149,
      38,
      248,
      215,
      127,
      73,
      67
    ])
  ],
  [
    vt(T.opnetTestnet),
    new Uint8Array([
      0,
      0,
      1,
      127,
      133,
      16,
      107,
      31,
      238,
      175,
      47,
      112,
      241,
      226,
      184,
      5,
      152,
      91,
      181,
      117,
      248,
      143,
      155,
      11,
      165,
      117,
      61,
      47,
      60,
      241,
      50,
      115
    ])
  ],
  [
    vt(T.regtest),
    new Uint8Array([
      15,
      145,
      136,
      241,
      60,
      183,
      178,
      199,
      31,
      42,
      51,
      94,
      58,
      79,
      195,
      40,
      191,
      91,
      235,
      67,
      96,
      18,
      175,
      202,
      89,
      11,
      26,
      17,
      70,
      110,
      34,
      6
    ])
  ]
]);
function Ne(n) {
  const t = Ir.get(vt(n));
  if (!t) throw new Error("Unsupported network for chain ID retrieval");
  return t.slice();
}
const Fe = new Uint8Array([
  231,
  132,
  153,
  90,
  65,
  45,
  119,
  57,
  136,
  196,
  184,
  227,
  51,
  215,
  179,
  157,
  251,
  60,
  171,
  241,
  24,
  208,
  214,
  69,
  65,
  26,
  145,
  108,
  162,
  64,
  121,
  57
]), j = 330n, Ot = 297n, he = w("51024e73");
class E extends Nt {
  static MINIMUM_DUST = 330n;
  logColor = "#785def";
  debugFees = !1;
  // Cancel script
  LOCK_LEAF_SCRIPT;
  /**
   * @description The overflow fees of the transaction
   * @public
   */
  overflowFees = 0n;
  /**
   * @description Cost in satoshis of the transaction fee
   */
  transactionFee = 0n;
  /**
   * @description The estimated fees of the transaction
   */
  estimatedFees = 0n;
  /**
   * @param {ITransactionParameters} parameters - The transaction parameters
   */
  optionalOutputs;
  /**
   * @description The transaction itself.
   */
  transaction;
  /**
   * @description Inputs to update later on.
   */
  updateInputs = [];
  /**
   * @description The outputs of the transaction
   */
  outputs = [];
  /**
   * @description Output that will be used to pay the fees
   */
  feeOutput = null;
  /**
   * @description The total amount of satoshis in the inputs
   */
  totalInputAmount;
  /**
   * @description The signer of the transaction
   */
  signer;
  /**
   * @description The network where the transaction will be broadcasted
   */
  network;
  /**
   * @description The fee rate of the transaction
   */
  feeRate;
  /**
   * @description The opnet priority fee of the transaction
   */
  priorityFee;
  gasSatFee;
  /**
   * @description The utxos used in the transaction
   */
  utxos;
  /**
   * @description The inputs of the transaction
   * @protected
   */
  optionalInputs;
  /**
   * @description The address where the transaction is sent to
   * @protected
   */
  to;
  /**
   * @description The address where the transaction is sent from
   * @protected
   */
  from;
  /**
   * @description The maximum fee rate of the transaction
   */
  _maximumFeeRate = 1e8;
  /**
   * @description Is the destionation P2PK
   * @protected
   */
  isPubKeyDestination;
  /**
   * @description If the transaction need an anchor output
   * @protected
   */
  anchor;
  note;
  optionalOutputsAdded = !1;
  constructor(t) {
    if (super(t), t.estimatedFees && (this.estimatedFees = t.estimatedFees), this.signer = t.signer, this.network = t.network, this.feeRate = t.feeRate, this.priorityFee = t.priorityFee ?? 0n, this.gasSatFee = t.gasSatFee ?? 0n, this.utxos = t.utxos, this.optionalInputs = t.optionalInputs || [], this.to = t.to || void 0, this.debugFees = t.debugFees || !1, this.LOCK_LEAF_SCRIPT = this.defineLockScript(), t.note && (typeof t.note == "string" ? this.note = new TextEncoder().encode(t.note) : this.note = t.note), this.anchor = t.anchor ?? !1, this.isPubKeyDestination = this.to ? Q.isValidPublicKey(this.to, this.network) : !1, this.optionalOutputs = t.optionalOutputs, this.from = E.getFrom(t.from, this.signer, this.network), this.totalInputAmount = this.calculateTotalUTXOAmount(), this.calculateTotalVOutAmount() < this.totalInputAmount)
      throw new Error("Vout value is less than the value to send");
    this.transaction = new X({
      network: this.network,
      version: this.txVersion
    });
  }
  static getFrom(t, e, i) {
    return t || P.getTaprootAddress(e, i);
  }
  /**
   * @description Converts the witness stack to a script witness
   * @param {Uint8Array[]} witness - The witness stack
   * @protected
   * @returns {Uint8Array}
   */
  static witnessStackToScriptWitness(t) {
    return le(t);
  }
  [Symbol.dispose]() {
    super[Symbol.dispose](), this.updateInputs.length = 0, this.outputs.length = 0, this.feeOutput = null, this.optionalOutputs = void 0, this.utxos = [], this.optionalInputs = [];
  }
  addOPReturn(t) {
    const e = O.compile([f.OP_RETURN, t]);
    this.addOutput({
      value: L(0n),
      script: e
    });
  }
  addAnchor() {
    this.addOutput({
      value: L(0n),
      script: he
    });
  }
  async getFundingTransactionParameters() {
    return this.estimatedFees || (this.estimatedFees = await this.estimateTransactionFees()), {
      utxos: this.utxos,
      to: this.getScriptAddress(),
      signer: this.signer,
      network: this.network,
      feeRate: this.feeRate,
      priorityFee: this.priorityFee ?? 0n,
      gasSatFee: this.gasSatFee ?? 0n,
      from: this.from,
      amount: this.estimatedFees,
      optionalInputs: this.optionalInputs,
      mldsaSigner: null,
      ...this.optionalOutputs !== void 0 ? { optionalOutputs: this.optionalOutputs } : {}
    };
  }
  /**
   * Set the destination address of the transaction
   * @param {string} address - The address to set
   */
  setDestinationAddress(t) {
    this.to = t;
  }
  /**
   * Set the maximum fee rate of the transaction in satoshis per byte
   * @param {number} feeRate - The fee rate to set
   * @public
   */
  setMaximumFeeRate(t) {
    this._maximumFeeRate = t;
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Transaction>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signTransaction() {
    if (!this.utxos.length)
      throw new Error("No UTXOs specified");
    if (this.to && !this.isPubKeyDestination && !P.verifyContractAddress(this.to, this.network))
      throw new Error(
        "Invalid contract address. The contract address must be a taproot address."
      );
    if (this.signed) throw new Error("Transaction is already signed");
    if (this.signed = !0, await this.buildTransaction(), await this.internalBuildTransaction(this.transaction)) {
      if (this.regenerated)
        throw new Error("Transaction was regenerated");
      return this.transaction.extractTransaction(!0, !0);
    }
    throw new Error("Could not sign transaction");
  }
  /**
   * @description Generates the transaction minimal signatures
   * @public
   */
  async generateTransactionMinimalSignatures(t = !1) {
    if (this.to && !this.isPubKeyDestination && !P.verifyContractAddress(this.to, this.network))
      throw new Error(
        "Invalid contract address. The contract address must be a taproot address."
      );
    if (await this.buildTransaction(), this.transaction.data.inputs.length === 0) {
      const e = this.getInputs(), i = this.getOutputs();
      this.transaction.setMaximumFeeRate(this._maximumFeeRate), this.transaction.addInputs(e, t);
      for (let r = 0; r < this.updateInputs.length; r++)
        this.transaction.updateInput(r, this.updateInputs[r]);
      this.transaction.addOutputs(i);
    }
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Psbt>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signPSBT() {
    if (await this.signTransaction())
      return this.transaction;
    throw new Error("Could not sign transaction");
  }
  /**
   * Add an input to the transaction.
   * @param {PsbtInputExtended} input - The input to add
   * @public
   * @returns {void}
   */
  addInput(t) {
    this.inputs.push(t);
  }
  /**
   * Add an output to the transaction.
   * @param {PsbtOutputExtended} output - The output to add
   * @param bypassMinCheck
   * @public
   * @returns {void}
   */
  addOutput(t, e = !1) {
    if (t.value === L(0n)) {
      const i = t;
      if (!i.script || i.script.length === 0)
        throw new Error("Output value is 0 and no script provided");
      if (i.script.length < 2)
        throw new Error("Output script is too short");
      if (i.script[0] !== f.OP_RETURN && !C(i.script, he))
        throw new Error(
          "Output script must start with OP_RETURN or be an ANCHOR when value is 0"
        );
    } else if (!e && BigInt(t.value) < E.MINIMUM_DUST)
      throw new Error(
        `Output value is less than the minimum dust ${t.value} < ${E.MINIMUM_DUST}`
      );
    this.outputs.push(t);
  }
  /**
   * Returns the total value of all outputs added so far (excluding the fee/change output).
   * @public
   * @returns {bigint}
   */
  getTotalOutputValue() {
    return this.outputs.reduce((t, e) => t + BigInt(e.value), 0n);
  }
  /**
   * Receiver address.
   * @public
   * @returns {string} - The receiver address
   */
  toAddress() {
    return this.to;
  }
  /**
   * @description Returns the script address
   * @returns {string} - The script address
   */
  address() {
    return this.tapData?.address;
  }
  /**
   * Estimates the transaction fees with accurate size calculation.
   *
   * @note The P2TR estimation is made for a 2-leaf tree with both a tapScriptSig and a tapInternalKey input, which is a common case for many transactions.
   * This provides a more accurate fee estimation for typical P2TR transactions, but may not be perfectly accurate for all possible script configurations.
   * Adjustments may be needed for more complex scripts or different leaf structures.
   *
   * @public
   * @returns {Promise<bigint>}
   */
  async estimateTransactionFees() {
    await Promise.resolve();
    const t = new X({ network: this.network }), e = this.getInputs(), i = this.getOutputs();
    t.addInputs(e), t.addOutputs(i);
    const r = new Uint8Array(64), s = new Uint8Array(72), o = new Uint8Array(33).fill(2), a = (d, p) => {
      if (p.isPayToAnchor || this.anchorInputIndices.has(d))
        return {
          finalScriptSig: void 0,
          finalScriptWitness: Uint8Array.from([0])
        };
      if (p.witnessScript && Z.isP2WDAWitnessScript(p.witnessScript)) {
        const m = [];
        for (let x = 0; x < 10; x++)
          m.push(new Uint8Array(0));
        const A = new Uint8Array(72);
        return {
          finalScriptWitness: E.witnessStackToScriptWitness([
            ...m,
            A,
            p.witnessScript
          ])
        };
      }
      if (d === 0 && this.tapLeafScript) {
        const m = new Uint8Array(32), A = this.tapLeafScript.script, x = this.useP2MR ? 33 : 65, H = new Uint8Array(x);
        return {
          finalScriptWitness: E.witnessStackToScriptWitness([
            m,
            r,
            // It's a tapScriptSig, which is Schnorr
            r,
            // Second Schnorr signature
            A,
            H
          ])
        };
      }
      if (p.witnessUtxo) {
        const m = p.witnessUtxo.script, A = at.script.decompile(m);
        if (A && A.length === 5 && A[0] === f.OP_DUP && A[1] === f.OP_HASH160 && A[3] === f.OP_EQUALVERIFY && A[4] === f.OP_CHECKSIG)
          return {
            finalScriptSig: at.script.compile([
              s,
              o
            ]),
            finalScriptWitness: void 0
          };
      }
      if (p.witnessScript) {
        if (this.csvInputIndices.has(d))
          return {
            finalScriptWitness: E.witnessStackToScriptWitness([
              s,
              p.witnessScript
            ])
          };
        if (p.redeemScript) {
          const A = [s, p.witnessScript];
          return {
            finalScriptSig: p.redeemScript,
            finalScriptWitness: E.witnessStackToScriptWitness(A)
          };
        }
        const m = at.script.decompile(p.witnessScript);
        if (m && m.length >= 4) {
          const A = m[0], x = m[m.length - 1];
          if (typeof A == "number" && A >= f.OP_1 && x === f.OP_CHECKMULTISIG) {
            const H = A - f.OP_1 + 1, ut = [];
            for (let ft = 0; ft < H; ft++)
              ut.push(s);
            return {
              finalScriptWitness: E.witnessStackToScriptWitness([
                new Uint8Array(0),
                // OP_0 due to multisig bug
                ...ut,
                p.witnessScript
              ])
            };
          }
        }
        return {
          finalScriptWitness: E.witnessStackToScriptWitness([
            s,
            p.witnessScript
          ])
        };
      } else if (p.redeemScript) {
        const m = at.script.decompile(p.redeemScript);
        if (m && m.length === 2 && m[0] === f.OP_0 && m[1] instanceof Uint8Array && m[1].length === 20)
          return {
            finalScriptSig: p.redeemScript,
            finalScriptWitness: E.witnessStackToScriptWitness([
              s,
              o
            ])
          };
      }
      if (p.redeemScript && !p.witnessScript && !p.witnessUtxo)
        return {
          finalScriptSig: at.script.compile([s, p.redeemScript]),
          finalScriptWitness: void 0
        };
      const y = p.witnessUtxo?.script;
      return y ? p.tapInternalKey ? {
        finalScriptWitness: E.witnessStackToScriptWitness([
          r
        ])
      } : y.length === 22 && y[0] === f.OP_0 ? {
        finalScriptWitness: E.witnessStackToScriptWitness([
          s,
          o
        ])
      } : p.redeemScript?.length === 22 && p.redeemScript[0] === f.OP_0 ? {
        finalScriptWitness: E.witnessStackToScriptWitness([
          s,
          o
        ])
      } : ze(
        d,
        p,
        y,
        !0,
        !!p.redeemScript,
        !!p.witnessScript
      ) : { finalScriptSig: void 0, finalScriptWitness: void 0 };
    };
    try {
      for (let d = 0; d < t.data.inputs.length; d++) {
        const p = e[d];
        p && t.finalizeInput(d, (y) => a(y, p));
      }
    } catch (d) {
      this.warn(`Could not finalize dummy tx: ${d.message}`);
    }
    const u = t.extractTransaction(!0, !0).virtualSize(), l = this.feeRate * u, h = BigInt(Math.ceil(l));
    return this.debugFees && this.log(
      `Estimating fees: feeRate=${this.feeRate}, accurate_vSize=${u}, fee=${h}n`
    ), h;
  }
  async rebuildFromBase64(t) {
    return this.transaction = X.fromBase64(t, {
      network: this.network,
      version: this.txVersion
    }), this.signed = !1, this.sighashTypes = [oe.SIGHASH_ANYONECANPAY, oe.SIGHASH_ALL], await this.signPSBT();
  }
  setPSBT(t) {
    this.transaction = t;
  }
  /**
   * Returns the inputs of the transaction.
   * @protected
   * @returns {PsbtInputExtended[]}
   */
  getInputs() {
    return this.inputs;
  }
  /**
   * Returns the outputs of the transaction.
   * @protected
   * @returns {PsbtOutputExtended[]}
   */
  getOutputs() {
    const t = [...this.outputs];
    return this.feeOutput && t.push(this.feeOutput), t;
  }
  getOptionalOutputValue() {
    if (!this.optionalOutputs) return 0n;
    let t = 0n;
    for (let e = 0; e < this.optionalOutputs.length; e++)
      t += BigInt(this.optionalOutputs[e].value);
    return t;
  }
  async addRefundOutput(t, e = !1) {
    this.note && this.addOPReturn(this.note), this.anchor && this.addAnchor(), this.feeOutput = this.createChangeOutput(E.MINIMUM_DUST);
    const i = await this.estimateTransactionFees(), r = this.totalInputAmount - t - i;
    if (this.debugFees && this.log(
      `Fee with change: ${i} sats, inputAmount=${this.totalInputAmount}, amountSpent=${t}, sendBackAmount=${r}`
    ), r >= E.MINIMUM_DUST)
      this.feeOutput = this.createChangeOutput(r), this.overflowFees = r, this.transactionFee = i;
    else {
      this.feeOutput = null, this.overflowFees = 0n;
      const s = await this.estimateTransactionFees();
      if (this.transactionFee = s, this.debugFees && this.warn(
        `Amount to send back (${r} sat) is less than minimum dust. Fee without change: ${s} sats`
      ), this.totalInputAmount <= t)
        throw new Error(
          `Insufficient funds: need ${t + s} sats but only have ${this.totalInputAmount} sats`
        );
      if (e && r < 0n)
        throw new Error(
          `Insufficient funds: need at least ${-r} more sats to cover fees.`
        );
    }
    this.debugFees && this.log(
      `Final fee: ${this.transactionFee} sats, Change output: ${this.feeOutput ? `${this.feeOutput.value} sats` : "none"}`
    );
  }
  defineLockScript() {
    return O.compile([U(this.signer.publicKey), f.OP_CHECKSIG]);
  }
  /**
   * @description Adds the value to the output
   * @param {number | bigint} value - The value to add
   * @protected
   * @returns {void}
   */
  addValueToToOutput(t) {
    if (BigInt(t) < E.MINIMUM_DUST)
      throw new Error(
        `Value to send is less than the minimum dust ${t} < ${E.MINIMUM_DUST}`
      );
    for (let e = 0; e < this.outputs.length; e++) {
      const i = this.outputs[e];
      if ("address" in i && i.address === this.to) {
        this.outputs[e] = {
          ...i,
          value: L(BigInt(i.value) + BigInt(t))
        };
        return;
      }
    }
    throw new Error("Output not found");
  }
  generateLegacySignature() {
    if (this.tweakSigner(), !this.tweakedSigner)
      throw new Error("Tweaked signer is not defined");
    const t = U(this.tweakedSigner.publicKey), e = this.signer.publicKey;
    if (e.length !== 33)
      throw new Error("Original public key must be compressed (33 bytes)");
    const i = Ne(this.network), r = new V();
    r.writeU8(B.MLDSASecurityLevel.LEVEL2), r.writeBytes(this.hashedPublicKey), r.writeBytes(t), r.writeBytes(e), r.writeBytes(Fe), r.writeBytes(i);
    const s = r.getBuffer(), o = ct.signMessage(this.tweakedSigner, s);
    if (!ct.verifySignature(t, s, o.signature))
      throw new Error("Could not verify generated legacy signature for MLDSA link request");
    return new Uint8Array(o.signature);
  }
  generateMLDSASignature() {
    if (!this.mldsaSigner)
      throw new Error("MLDSA signer is not defined");
    if (this.tweakSigner(), !this.tweakedSigner)
      throw new Error("Tweaked signer is not defined");
    const t = U(this.tweakedSigner.publicKey), e = this.signer.publicKey;
    if (e.length !== 33)
      throw new Error("Original public key must be compressed (33 bytes)");
    const i = Ne(this.network), r = ue(this.mldsaSigner.publicKey.length);
    if (r !== B.MLDSASecurityLevel.LEVEL2)
      throw new Error("Only MLDSA level 2 is supported for link requests");
    const s = new V();
    s.writeU8(r), s.writeBytes(this.hashedPublicKey), s.writeBytes(this.mldsaSigner.publicKey), s.writeBytes(t), s.writeBytes(e), s.writeBytes(Fe), s.writeBytes(i);
    const o = s.getBuffer(), a = ct.signMLDSAMessage(this.mldsaSigner, o);
    if (!ct.verifyMLDSASignature(
      this.mldsaSigner,
      o,
      a.signature
    ))
      throw new Error("Could not verify generated MLDSA signature for link request");
    return new Uint8Array(a.signature);
  }
  generateMLDSALinkRequest(t, e) {
    const i = this.mldsaSigner, r = this.generateLegacySignature();
    let s = null;
    t.revealMLDSAPublicKey && (s = this.generateMLDSASignature());
    const o = {
      priority: et.MLDSA_LINK_PUBKEY,
      opcode: $.MLDSA_LINK_PUBKEY,
      data: {
        verifyRequest: !!t.revealMLDSAPublicKey,
        publicKey: i.publicKey,
        hashedPublicKey: this.hashedPublicKey,
        level: ue(i.publicKey.length),
        legacySignature: r,
        mldsaSignature: s
      }
    };
    e.push(o);
  }
  /**
   * @description Returns the transaction opnet fee
   * @protected
   * @returns {bigint}
   */
  getTransactionOPNetFee() {
    const t = this.priorityFee + this.gasSatFee;
    return t > E.MINIMUM_DUST ? t : E.MINIMUM_DUST;
  }
  /**
   * @description Returns the total amount of satoshis in the inputs
   * @protected
   * @returns {bigint}
   */
  calculateTotalUTXOAmount() {
    let t = 0n;
    for (const e of this.utxos)
      t += e.value;
    for (const e of this.optionalInputs)
      t += e.value;
    return t;
  }
  /**
   * @description Returns the total amount of satoshis in the outputs
   * @protected
   * @returns {bigint}
   */
  calculateTotalVOutAmount() {
    let t = 0n;
    for (const e of this.utxos)
      t += e.value;
    for (const e of this.optionalInputs)
      t += e.value;
    return t;
  }
  /**
   * @description Adds optional outputs to transaction and returns their total value in satoshi to calculate refund transaction
   * @protected
   * @returns {bigint}
   */
  addOptionalOutputsAndGetAmount() {
    if (!this.optionalOutputs || this.optionalOutputsAdded) return 0n;
    let t = 0n;
    for (let e = 0; e < this.optionalOutputs.length; e++)
      this.addOutput(this.optionalOutputs[e]), t += BigInt(
        this.optionalOutputs[e].value
      );
    return this.optionalOutputsAdded = !0, t;
  }
  /**
   * @description Adds the inputs from the utxos
   * @protected
   * @returns {void}
   */
  addInputsFromUTXO() {
    if (this.utxos.length) {
      if (this.totalInputAmount < E.MINIMUM_DUST)
        throw new Error(
          `Total input amount is ${this.totalInputAmount} sat which is less than the minimum dust ${E.MINIMUM_DUST} sat.`
        );
      for (let t = 0; t < this.utxos.length; t++) {
        const e = this.utxos[t];
        this.registerInputSigner(t, e);
        const i = this.generatePsbtInputExtended(e, t);
        this.addInput(i);
      }
    }
    if (this.optionalInputs)
      for (let t = this.utxos.length; t < this.optionalInputs.length + this.utxos.length; t++) {
        const e = this.optionalInputs[t - this.utxos.length];
        this.registerInputSigner(t, e);
        const i = this.generatePsbtInputExtended(e, t, !0);
        this.addInput(i);
      }
  }
  /**
   * Internal init.
   * @protected
   */
  internalInit() {
    this.verifyUTXOValidity(), super.internalInit();
  }
  /**
   * Add an input update
   * @param {UpdateInput} input - The input to update
   * @protected
   * @returns {void}
   */
  updateInput(t) {
    this.updateInputs.push(t);
  }
  /**
   * Adds the fee to the output.
   * @param amountSpent
   * @param contractAddress
   * @param epochChallenge
   * @param addContractOutput
   * @protected
   */
  addFeeToOutput(t, e, i, r) {
    if (r) {
      let s;
      t > j + Ot ? s = Ot : s = t, this.addOutput(
        {
          value: L(s),
          address: e
        },
        !0
      ), s === Ot && t - Ot > j && this.addOutput(
        {
          value: L(t - s),
          address: i.address
        },
        !0
      );
    } else {
      const s = t < j ? j : t;
      this.addOutput(
        {
          value: L(s),
          address: i.address
        },
        !0
      );
    }
  }
  /**
   * Returns the witness of the tap transaction.
   * @protected
   * @returns {Uint8Array}
   */
  getWitness() {
    if (!this.tapData || !this.tapData.witness)
      throw new Error("Witness is required");
    if (this.tapData.witness.length === 0)
      throw new Error("Witness is empty");
    return this.tapData.witness[this.tapData.witness.length - 1];
  }
  /**
   * Returns the tap output.
   * @protected
   * @returns {Uint8Array}
   */
  getTapOutput() {
    if (!this.tapData || !this.tapData.output)
      throw new Error("Tap data is required");
    return this.tapData.output;
  }
  /**
   * Verifies that the utxos are valid.
   * @protected
   */
  verifyUTXOValidity() {
    for (const t of this.utxos)
      if (!t.scriptPubKey)
        throw new Error("Address is required");
    for (const t of this.optionalInputs)
      if (!t.scriptPubKey)
        throw new Error("Address is required");
  }
  /**
   * Builds the transaction.
   * @param {Psbt} transaction - The transaction to build
   * @param checkPartialSigs
   * @protected
   * @returns {Promise<boolean>}
   * @throws {Error} - If something went wrong while building the transaction
   */
  async internalBuildTransaction(t, e = !1) {
    if (t.data.inputs.length === 0) {
      const i = this.getInputs(), r = this.getOutputs();
      t.setMaximumFeeRate(this._maximumFeeRate), t.addInputs(i, e);
      for (let s = 0; s < this.updateInputs.length; s++)
        t.updateInput(s, this.updateInputs[s]);
      t.addOutputs(r);
    }
    try {
      return await this.signInputs(t), this.finalized && (this.transactionFee = BigInt(t.getFee())), !0;
    } catch (i) {
      const r = i;
      this.error(
        `[internalBuildTransaction] Something went wrong while getting building the transaction: ${r.stack}`
      );
    }
    return !1;
  }
  createChangeOutput(t) {
    if (Q.isValidP2TRAddress(this.from, this.network))
      return {
        value: L(t),
        address: this.from,
        tapInternalKey: this.internalPubKeyToXOnly()
      };
    if (Q.isValidPublicKey(this.from, this.network)) {
      const e = O.compile([
        w(this.from.startsWith("0x") ? this.from.slice(2) : this.from),
        f.OP_CHECKSIG
      ]);
      return {
        value: L(t),
        script: e
      };
    } else
      return {
        value: L(t),
        address: this.from
      };
  }
}
class Gt extends E {
  type = b.CUSTOM_CODE;
  /**
   * The contract address
   * @protected
   */
  _scriptAddress;
  /**
   * The tap leaf script
   * @private
   */
  tapLeafScript = null;
  /**
   * The target script redeem
   * @private
   */
  targetScriptRedeem = null;
  /**
   * The left over funds script redeem
   * @private
   */
  leftOverFundsScriptRedeem = null;
  /**
   * The compiled target script
   * @private
   */
  compiledTargetScript;
  /**
   * The script tree
   * @private
   */
  scriptTree;
  /**
   * The deployment bitcoin generator
   * @private
   */
  generator;
  /**
   * The contract seed
   * @private
   */
  scriptSeed;
  /**
   * The contract signer
   * @private
   */
  contractSigner;
  /**
   * The contract salt random bytes
   * @private
   */
  randomBytes;
  /**
   * The witnesses
   * @private
   */
  witnesses;
  annexData;
  constructor(t) {
    if (super(t), !t.script) throw new Error("Bitcoin script is required");
    if (!t.witnesses) throw new Error("Witness(es) are required");
    this.witnesses = t.witnesses, this.randomBytes = t.randomBytes || W.rndBytes(), this.LOCK_LEAF_SCRIPT = this.defineLockScript(), this.scriptSeed = this.getContractSeed(), this.contractSigner = P.fromSeedKeyPair(this.scriptSeed, this.network), this.generator = new Ge(this.internalPubKeyToXOnly(), this.network), this.compiledTargetScript = this.generator.compile(t.script), this.scriptTree = this.getScriptTree(), this.internalInit(), this._scriptAddress = Se.generatePKSH(this.scriptSeed, this.network);
  }
  /**
   * @description Get the contract address (PKSH)
   */
  get scriptAddress() {
    return this._scriptAddress;
  }
  /**
   * @description Get the P2TR address
   */
  get p2trAddress() {
    return this.to || this.getScriptAddress();
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Uint8Array} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the contract signer public key
   * @protected
   */
  contractSignerXOnlyPubKey() {
    return U(this.contractSigner.publicKey);
  }
  /**
   * Build the transaction
   * @protected
   */
  async buildTransaction() {
    this.to || (this.to = this.getScriptAddress());
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO();
    const e = this.getTransactionOPNetFee();
    this.addOutput({
      value: L(e),
      address: this.to
    }), await this.addRefundOutput(e + this.addOptionalOutputsAndGetAmount());
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(t) {
    if (!this.contractSigner) {
      await super.signInputs(t);
      return;
    }
    try {
      t.signInput(0, this.contractSigner);
    } catch {
    }
    t.signInput(0, this.getSignerKey()), t.finalizeInput(0, this.customFinalizer);
    const e = /* @__PURE__ */ new Set([0]);
    if (this.canUseParallelSigning && pt(this.signer))
      try {
        const i = await this.signKeyPathInputsParallel(t, /* @__PURE__ */ new Set([0]));
        if (i.success)
          for (const r of i.signatures.keys()) e.add(r);
      } catch (i) {
        this.error(`Parallel signing failed: ${i.message}`);
      }
    for (let i = 1; i < t.data.inputs.length; i++)
      e.has(i) || t.signInput(i, this.getSignerKey());
    for (let i = 1; i < t.data.inputs.length; i++)
      try {
        t.finalizeInput(
          i,
          this.customFinalizerP2SH.bind(this)
        );
      } catch {
        t.finalizeInput(i);
      }
  }
  /**
   * Get the tap output
   * @protected
   */
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2TR
    };
  }
  /**
   * Generate the tap data
   * @protected
   */
  generateTapData() {
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2TR
    };
  }
  getScriptSolution(t) {
    if (!t.tapScriptSig)
      throw new Error("Tap script signature is required");
    const e = [...this.witnesses];
    if (t.tapScriptSig)
      for (const i of t.tapScriptSig)
        e.push(i.signature);
    return e;
  }
  /**
   * Generate the contract seed for the deployment
   * @private
   */
  getContractSeed() {
    return F.hash256(this.randomBytes);
  }
  /**
   * Finalize the transaction
   * @param _inputIndex
   * @param input
   */
  customFinalizer = (t, e) => {
    if (!this.tapLeafScript)
      throw new Error("Tap leaf script is required");
    const r = this.getScriptSolution(e).concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
    if (this.annexData && this.annexData.length > 0) {
      let s;
      if (this.annexData[0] === 80)
        s = this.annexData;
      else {
        const o = new Uint8Array(this.annexData.length + 1);
        o[0] = 80, o.set(this.annexData, 1), s = o;
      }
      r.push(s);
    }
    return {
      finalScriptWitness: E.witnessStackToScriptWitness(r)
    };
  };
  /**
   * Generate the redeem scripts
   * @private
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: v.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.getLeafScript(),
      redeemVersion: 192
    };
  }
  /**
   * Get the second leaf script
   * @private
   */
  getLeafScript() {
    return this.LOCK_LEAF_SCRIPT;
  }
  /**
   * Get the script tree
   * @private
   */
  getScriptTree() {
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.getLeafScript(),
        version: 192
      }
    ];
  }
}
class Ie extends E {
  static MAXIMUM_CALLDATA_SIZE = 1024 * 1024;
  // 1MB
  /**
   * Random salt for the interaction
   * @type {Uint8Array}
   */
  randomBytes;
  targetScriptRedeem = null;
  leftOverFundsScriptRedeem = null;
  challenge;
  epochChallenge;
  calldataGenerator;
  /**
   * Calldata for the interaction
   * @protected
   */
  calldata;
  /**
   * Script signer for the interaction
   * @protected
   */
  scriptSigner;
  /**
   * Disable auto refund
   * @protected
   */
  disableAutoRefund;
  constructor(t) {
    if (super(t), !t.calldata)
      throw new Error("Calldata is required");
    if (!t.challenge)
      throw new Error("Challenge solution is required");
    this.challenge = t.challenge, this.LOCK_LEAF_SCRIPT = this.defineLockScript(), this.disableAutoRefund = t.disableAutoRefund || !1, this.epochChallenge = z.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.calldata = Y.compress(t.calldata), this.randomBytes = t.randomBytes || W.rndBytes(), this.scriptSigner = this.generateKeyPairFromSeed(), this.calldataGenerator = new fe(
      this.signer.publicKey,
      this.scriptSignerXOnlyPubKey(),
      this.network
    );
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the contract secret
   * @returns {Uint8Array} The contract secret
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Uint8Array} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the preimage
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get the internal pubkey as an x-only key
   * @protected
   * @returns {Uint8Array} The internal pubkey as an x-only key
   */
  scriptSignerXOnlyPubKey() {
    return U(this.scriptSigner.publicKey);
  }
  /**
   * Generate a key pair from the seed
   * @protected
   *
   * @returns {UniversalSigner} The key pair
   */
  generateKeyPairFromSeed() {
    return P.fromSeedKeyPair(this.randomBytes, this.network);
  }
  /**
   * Build the transaction
   * @protected
   *
   * @throws {Error} If the left over funds script redeem is required
   * @throws {Error} If the left over funds script redeem version is required
   * @throws {Error} If the left over funds script redeem output is required
   * @throws {Error} If the to address is required
   */
  async buildTransaction() {
    const t = this.scriptSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.regenerated || this.addInputsFromUTXO(), await this.createMineableRewardOutputs();
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(t) {
    if (!this.scriptSigner) {
      await super.signInputs(t);
      return;
    }
    "multiSignPsbt" in this.signer ? await this.signInputsWalletBased(t) : await this.signInputsNonWalletBased(t);
  }
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2TR
    };
  }
  generateTapData() {
    const t = this.scriptSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2TR
    };
  }
  /**
   * Generate the script solution
   * @param {PsbtInput} input The input
   * @protected
   *
   * @returns {Uint8Array[]} The script solution
   */
  getScriptSolution(t) {
    if (!t.tapScriptSig)
      throw new Error("Tap script signature is required");
    return [
      this.contractSecret,
      t.tapScriptSig[0].signature,
      t.tapScriptSig[1].signature
    ];
  }
  /**
   * Get the script tree
   * @private
   *
   * @returns {Taptree} The script tree
   */
  getScriptTree() {
    if (!this.calldata)
      throw new Error("Calldata is required");
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.LOCK_LEAF_SCRIPT,
        version: 192
      }
    ];
  }
  /**
   * Transaction finalizer
   * @param {number} _inputIndex The input index
   * @param {PsbtInput} input The input
   */
  customFinalizer = (t, e) => {
    if (!this.tapLeafScript)
      throw new Error("Tap leaf script is required");
    if (!this.contractSecret)
      throw new Error("Contract secret is required");
    const r = this.getScriptSolution(e).concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
    return {
      finalScriptWitness: E.witnessStackToScriptWitness(r)
    };
  };
  // custom for interactions
  async signInputsWalletBased(t) {
    const e = this.signer;
    await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.scriptSigner
    ), await e.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      if (i === 0)
        t.finalizeInput(i, this.customFinalizer.bind(this));
      else
        try {
          t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(i);
        }
  }
  async signInputsNonWalletBased(t) {
    if (await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.scriptSigner
    ), await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.getSignerKey()
    ), t.finalizeInput(0, this.customFinalizer.bind(this)), this.canUseParallelSigning && pt(this.signer)) {
      let e = /* @__PURE__ */ new Set();
      try {
        const i = await this.signKeyPathInputsParallel(t, /* @__PURE__ */ new Set([0]));
        i.success && (e = new Set(i.signatures.keys()));
      } catch (i) {
        this.error(
          `Parallel signing failed, falling back to sequential: ${i.message}`
        );
      }
      for (let i = 1; i < t.data.inputs.length; i++)
        e.has(i) || await this.signInput(
          t,
          t.data.inputs[i],
          i,
          this.signer
        );
    } else
      for (let e = 1; e < t.data.inputs.length; e++)
        await this.signInput(
          t,
          t.data.inputs[e],
          e,
          this.signer
        );
    for (let e = 1; e < t.data.inputs.length; e++)
      try {
        t.finalizeInput(
          e,
          this.customFinalizerP2SH.bind(this)
        );
      } catch {
        t.finalizeInput(e);
      }
    this.finalized = !0;
  }
  async createMineableRewardOutputs() {
    if (!this.to) throw new Error("To address is required");
    const t = this.getTransactionOPNetFee();
    this.addFeeToOutput(t, this.to, this.epochChallenge, !1);
    const e = t < j ? j : t, i = this.addOptionalOutputsAndGetAmount();
    this.disableAutoRefund || await this.addRefundOutput(e + i);
  }
  /**
   * Generate the redeem scripts
   * @private
   *
   * @throws {Error} If the public keys are required
   * @throws {Error} If the leaf script is required
   * @throws {Error} If the leaf script version is required
   * @throws {Error} If the leaf script output is required
   * @throws {Error} If the target script redeem is required
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: v.P2TR,
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      output: this.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
}
class Et extends E {
  static MAXIMUM_CONTRACT_SIZE = 128 * 1024;
  type = b.DEPLOYMENT;
  challenge;
  epochChallenge;
  /**
   * The contract address
   * @protected
   */
  _contractAddress;
  /**
   * The tap leaf script
   * @private
   */
  tapLeafScript = null;
  deploymentVersion = 0;
  /**
   * The target script redeem
   * @private
   */
  targetScriptRedeem = null;
  /**
   * The left over funds script redeem
   * @private
   */
  leftOverFundsScriptRedeem = null;
  /**
   * The compiled target script
   * @private
   */
  compiledTargetScript;
  /**
   * The script tree
   * @private
   */
  scriptTree;
  /**
   * The deployment bitcoin generator
   * @private
   */
  deploymentGenerator;
  /**
   * The contract seed
   * @private
   */
  contractSeed;
  /**
   * The contract bytecode
   * @private
   */
  bytecode;
  /**
   * Constructor calldata
   * @private
   */
  calldata;
  /**
   * The contract signer
   * @private
   */
  contractSigner;
  /**
   * The contract public key
   * @private
   */
  _contractPubKey;
  /**
   * The contract salt random bytes
   * @private
   */
  randomBytes;
  _computedAddress;
  constructor(t) {
    if (super(t), !this.hashedPublicKey)
      throw new Error("MLDSA signer must be defined to deploy a contract.");
    if (this.bytecode = Y.compress(
      new Uint8Array([...je, ...t.bytecode])
    ), this.verifyBytecode(), t.calldata && (this.calldata = t.calldata, this.verifyCalldata()), !t.challenge) throw new Error("Challenge solution is required");
    if (this.randomBytes = t.randomBytes || W.rndBytes(), this.challenge = t.challenge, this.LOCK_LEAF_SCRIPT = this.defineLockScript(), this.epochChallenge = z.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.contractSeed = this.getContractSeed(), this.contractSigner = P.fromSeedKeyPair(this.contractSeed, this.network), this.deploymentGenerator = new ge(
      this.signer.publicKey,
      this.contractSignerXOnlyPubKey(),
      this.network
    ), t.compiledTargetScript)
      if (t.compiledTargetScript instanceof Uint8Array)
        this.compiledTargetScript = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledTargetScript = w(t.compiledTargetScript);
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledTargetScript = this.deploymentGenerator.compile(
        this.bytecode,
        this.randomBytes,
        this.challenge,
        this.priorityFee,
        this.calldata,
        this.generateFeatures(t)
      );
    this.scriptTree = this.getScriptTree(), this.internalInit(), this._contractPubKey = "0x" + g(this.contractSeed), this._contractAddress = new K(this.contractSeed);
  }
  /**
   * Get the contract public key
   */
  get contractPubKey() {
    return this._contractPubKey;
  }
  /**
   * @description Get the contract address (PKSH)
   */
  get contractAddress() {
    return this._contractAddress;
  }
  /**
   * @description Get the P2TR address
   */
  get p2trAddress() {
    return this.to || this.getScriptAddress();
  }
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the random bytes used for the interaction
   * @returns {Uint8Array} The random bytes
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the contract bytecode
   * @returns {Uint8Array} The contract bytecode
   */
  getChallenge() {
    return this.challenge;
  }
  getContractAddress() {
    return this._computedAddress ? this._computedAddress : (this._computedAddress = P.p2op(
      this.contractSeed,
      this.network,
      this.deploymentVersion
    ), this._computedAddress);
  }
  /**
   * Get the contract signer public key
   * @protected
   */
  contractSignerXOnlyPubKey() {
    return U(this.contractSigner.publicKey);
  }
  /**
   * Build the transaction
   * @protected
   */
  async buildTransaction() {
    this.to || (this.to = this.getScriptAddress());
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO();
    const e = this.getTransactionOPNetFee();
    this.addFeeToOutput(e, this.getContractAddress(), this.epochChallenge, !0), await this.addRefundOutput(e + this.addOptionalOutputsAndGetAmount());
  }
  async signInputsWalletBased(t) {
    const e = this.signer;
    await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.contractSigner
    ), await e.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      if (i === 0)
        t.finalizeInput(i, this.customFinalizer.bind(this));
      else
        try {
          t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(i);
        }
  }
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  async signInputs(t) {
    if (!this.contractSigner) {
      await super.signInputs(t);
      return;
    }
    if ("multiSignPsbt" in this.signer) {
      await this.signInputsWalletBased(t);
      return;
    }
    t.signInput(0, this.contractSigner), t.signInput(0, this.getSignerKey()), t.finalizeInput(0, this.customFinalizer.bind(this));
    const e = /* @__PURE__ */ new Set([0]);
    if (this.canUseParallelSigning && pt(this.signer))
      try {
        const i = await this.signKeyPathInputsParallel(t, /* @__PURE__ */ new Set([0]));
        if (i.success)
          for (const r of i.signatures.keys()) e.add(r);
      } catch (i) {
        this.error(`Parallel signing failed: ${i.message}`);
      }
    for (let i = 1; i < t.data.inputs.length; i++)
      e.has(i) || t.signInput(i, this.getSignerKey());
    for (let i = 1; i < t.data.inputs.length; i++)
      try {
        t.finalizeInput(
          i,
          this.customFinalizerP2SH.bind(this)
        );
      } catch {
        t.finalizeInput(i);
      }
  }
  /**
   * Get the tap output
   * @protected
   */
  generateScriptAddress() {
    return this.useP2MR ? {
      name: v.P2MR,
      network: this.network,
      scriptTree: this.scriptTree
    } : {
      name: v.P2TR,
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree
    };
  }
  /**
   * Generate the tap data
   * @protected
   */
  generateTapData() {
    const t = this.contractSigner ? this.targetScriptRedeem : this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      name: v.P2MR,
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t
    } : {
      name: v.P2TR,
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t
    };
  }
  generateFeatures(t) {
    const e = [], i = t.challenge.getSubmission();
    if (i && e.push({
      priority: et.MLDSA_LINK_PUBKEY,
      opcode: $.EPOCH_SUBMISSION,
      data: i
    }), t.revealMLDSAPublicKey && !t.linkMLDSAPublicKeyToAddress)
      throw new Error(
        "To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true."
      );
    return t.linkMLDSAPublicKeyToAddress && this.generateMLDSALinkRequest(t, e), e;
  }
  verifyCalldata() {
    if (this.calldata && this.calldata.length > Ie.MAXIMUM_CALLDATA_SIZE)
      throw new Error("Calldata size overflow.");
  }
  verifyBytecode() {
    if (!this.bytecode) throw new Error("Bytecode is required");
    if (this.bytecode.length > Et.MAXIMUM_CONTRACT_SIZE)
      throw new Error("Contract size overflow.");
  }
  /**
   * Generate the contract seed for the deployment
   * @private
   */
  getContractSeed() {
    if (!this.bytecode)
      throw new Error("Bytecode is required");
    const t = this.internalPubKeyToXOnly(), e = F.hash256(this.randomBytes), i = F.hash256(this.bytecode), r = dt([t, e, i]);
    return F.hash256(r);
  }
  /**
   * Finalize the transaction
   * @param _inputIndex
   * @param input
   */
  customFinalizer = (t, e) => {
    if (!this.tapLeafScript)
      throw new Error("Tap leaf script is required");
    if (!e.tapScriptSig)
      throw new Error("Tap script signature is required");
    const r = [
      this.randomBytes,
      e.tapScriptSig[0].signature,
      e.tapScriptSig[1].signature
    ].concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
    return {
      finalScriptWitness: E.witnessStackToScriptWitness(r)
    };
  };
  /**
   * Generate the redeem scripts
   * @private
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: v.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      //pubkeys: this.getPubKeys(),
      output: this.getLeafScript(),
      redeemVersion: 192
    };
  }
  /**
   * Get the second leaf script
   * @private
   */
  getLeafScript() {
    return this.LOCK_LEAF_SCRIPT;
  }
  /**
   * Get the script tree
   * @private
   */
  getScriptTree() {
    if (!this.bytecode)
      throw new Error("Contract bytecode is required");
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.getLeafScript(),
        version: 192
      }
    ];
  }
}
class Qt extends E {
  type = b.FUNDING;
  amount;
  splitInputsInto;
  autoAdjustAmount;
  constructor(t) {
    const e = t.feeUtxos?.length ? { ...t, utxos: [...t.utxos, ...t.feeUtxos] } : t;
    super(e), this.amount = t.amount, this.splitInputsInto = t.splitInputsInto ?? 1, this.autoAdjustAmount = t.autoAdjustAmount ?? !1, this.internalInit();
  }
  async buildTransaction() {
    if (!this.to)
      throw new Error("Recipient address is required");
    if (this.addInputsFromUTXO(), this.autoAdjustAmount && this.amount >= this.totalInputAmount) {
      if (this.isPubKeyDestination) {
        const r = this.to.startsWith("0x") ? this.to.slice(2) : this.to, s = O.compile([
          w(r),
          f.OP_CHECKSIG
        ]);
        this.addOutput({
          value: L(this.amount),
          script: s
        });
      } else
        this.addOutput({
          value: L(this.amount),
          address: this.to
        });
      const e = await this.estimateTransactionFees();
      this.outputs.pop();
      const i = this.totalInputAmount - e;
      if (i < E.MINIMUM_DUST)
        throw new Error(
          `Insufficient funds: after deducting fee of ${e} sats, remaining amount ${i} sats is below minimum dust`
        );
      this.amount = i;
    }
    if (this.splitInputsInto > 1)
      this.splitInputs(this.amount);
    else if (this.isPubKeyDestination) {
      const e = this.to.startsWith("0x") ? this.to.slice(2) : this.to, i = O.compile([
        w(e),
        f.OP_CHECKSIG
      ]);
      this.addOutput({
        value: L(this.amount),
        script: i
      });
    } else
      this.addOutput({
        value: L(this.amount),
        address: this.to
      });
    const t = this.amount + this.addOptionalOutputsAndGetAmount();
    await this.addRefundOutput(t);
  }
  splitInputs(t) {
    if (!this.to)
      throw new Error("Recipient address is required");
    const e = t / BigInt(this.splitInputsInto);
    for (let i = 0; i < this.splitInputsInto; i++)
      this.isPubKeyDestination ? this.addOutput({
        value: L(e),
        script: w(this.to.slice(2))
      }) : this.addOutput({
        value: L(e),
        address: this.to
      });
  }
  getSignerKey() {
    return this.signer;
  }
}
class jt extends Ie {
  type = b.INTERACTION;
  compiledTargetScript;
  scriptTree;
  tapLeafScript = null;
  /**
   * Contract secret for the interaction
   * @protected
   */
  contractSecret;
  constructor(t) {
    if (super(t), !t.contract)
      throw new Error("parameters.contract is required for interaction transaction.");
    if (this.contractSecret = w(t.contract.startsWith("0x") ? t.contract.slice(2) : t.contract), this.contractSecret.length !== 32)
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    if (t.compiledTargetScript)
      if (t.compiledTargetScript instanceof Uint8Array)
        this.compiledTargetScript = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledTargetScript = w(t.compiledTargetScript);
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledTargetScript = this.calldataGenerator.compile(
        this.calldata,
        this.contractSecret,
        this.challenge,
        this.priorityFee,
        this.generateFeatures(t)
      );
    this.scriptTree = this.getScriptTree(), this.internalInit();
  }
  generateFeatures(t) {
    const e = [];
    t.loadedStorage && e.push({
      priority: et.ACCESS_LIST,
      opcode: $.ACCESS_LIST,
      data: t.loadedStorage
    });
    const i = t.challenge.getSubmission();
    if (i && e.push({
      priority: et.EPOCH_SUBMISSION,
      opcode: $.EPOCH_SUBMISSION,
      data: i
    }), t.revealMLDSAPublicKey && !t.linkMLDSAPublicKeyToAddress)
      throw new Error(
        "To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true."
      );
    return t.linkMLDSAPublicKeyToAddress && this.generateMLDSALinkRequest(t, e), e;
  }
}
class it extends E {
  static MAX_WITNESS_FIELDS = 10;
  static MAX_BYTES_PER_WITNESS = 80;
  type = b.INTERACTION;
  epochChallenge;
  /**
   * Disable auto refund
   * @protected
   */
  disableAutoRefund;
  contractSecret;
  calldata;
  challenge;
  randomBytes;
  p2wdaGenerator;
  scriptSigner;
  p2wdaInputIndices = /* @__PURE__ */ new Set();
  /**
   * The compiled operation data from CalldataGenerator
   * This is exactly what would go in a taproot script, but we put it in witness instead
   */
  compiledOperationData = null;
  constructor(t) {
    if (super(t), !t.to)
      throw new Error("Contract address (to) is required");
    if (!t.contract)
      throw new Error("Contract secret is required");
    if (!t.calldata)
      throw new Error("Calldata is required");
    if (!t.challenge)
      throw new Error("Challenge solution is required");
    if (this.disableAutoRefund = t.disableAutoRefund || !1, this.contractSecret = w(t.contract.startsWith("0x") ? t.contract.slice(2) : t.contract), this.calldata = Y.compress(t.calldata), this.challenge = t.challenge, this.randomBytes = t.randomBytes || W.rndBytes(), this.scriptSigner = this.generateKeyPairFromSeed(), this.p2wdaGenerator = new Ct(
      this.signer.publicKey,
      this.scriptSignerXOnlyPubKey(),
      this.network
    ), this.contractSecret.length !== 32)
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    if (this.epochChallenge = z.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.validateP2WDAInputs(), t.compiledTargetScript)
      if (t.compiledTargetScript instanceof Uint8Array)
        this.compiledOperationData = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledOperationData = w(t.compiledTargetScript);
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledOperationData = this.p2wdaGenerator.compile(
        this.calldata,
        this.contractSecret,
        this.challenge,
        this.priorityFee,
        this.generateFeatures(t)
      );
    this.validateOperationDataSize(), this.internalInit();
  }
  /**
   * Get random bytes (for compatibility if needed elsewhere)
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the challenge (for compatibility if needed elsewhere)
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get contract secret (for compatibility if needed elsewhere)
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Build the transaction
   */
  async buildTransaction() {
    this.regenerated || this.addInputsFromUTXO(), await this.createMineableRewardOutputs();
  }
  async createMineableRewardOutputs() {
    if (!this.to) throw new Error("To address is required");
    const t = this.getTransactionOPNetFee();
    this.addFeeToOutput(t, this.to, this.epochChallenge, !1);
    const e = this.addOptionalOutputsAndGetAmount();
    this.disableAutoRefund || await this.addRefundOutput(t + e);
  }
  /**
   * Sign inputs with P2WDA-specific handling
   */
  async signInputs(t) {
    for (let e = 0; e < t.data.inputs.length; e++)
      await this.signInput(
        t,
        t.data.inputs[e],
        e,
        this.signer
      );
    for (let e = 0; e < t.data.inputs.length; e++)
      this.p2wdaInputIndices.has(e) ? e === 0 ? t.finalizeInput(e, this.finalizePrimaryP2WDA.bind(this)) : t.finalizeInput(e, this.finalizeSecondaryP2WDA.bind(this)) : t.finalizeInput(e, this.customFinalizerP2SH.bind(this));
    this.finalized = !0;
  }
  /**
   * Generate features array (same as InteractionTransaction)
   */
  generateFeatures(t) {
    const e = [];
    t.loadedStorage && e.push({
      priority: et.ACCESS_LIST,
      opcode: $.ACCESS_LIST,
      data: t.loadedStorage
    });
    const i = t.challenge.getSubmission();
    return i && e.push({
      priority: et.EPOCH_SUBMISSION,
      opcode: $.EPOCH_SUBMISSION,
      data: i
    }), e;
  }
  /**
   * Generate keypair from seed (same as SharedInteractionTransaction)
   */
  generateKeyPairFromSeed() {
    return P.fromSeedKeyPair(this.randomBytes, this.network);
  }
  /**
   * Get script signer x-only pubkey (same as SharedInteractionTransaction)
   */
  scriptSignerXOnlyPubKey() {
    return U(this.scriptSigner.publicKey);
  }
  /**
   * Validate that input 0 is P2WDA
   */
  validateP2WDAInputs() {
    if (this.utxos.length === 0 || !Z.isP2WDAUTXO(this.utxos[0]))
      throw new Error("Input 0 must be a P2WDA UTXO");
    for (let t = 0; t < this.utxos.length; t++)
      Z.isP2WDAUTXO(this.utxos[t]) && this.p2wdaInputIndices.add(t);
    for (let t = 0; t < this.optionalInputs.length; t++) {
      const e = this.utxos.length + t;
      Z.isP2WDAUTXO(this.optionalInputs[t]) && this.p2wdaInputIndices.add(e);
    }
  }
  /**
   * Validate the compiled operation data will fit in witness fields
   */
  validateOperationDataSize() {
    if (!this.compiledOperationData)
      throw new Error("Operation data not compiled");
    const t = this.compiledOperationData.length;
    if (!Ct.validateWitnessSize(t)) {
      const i = t + 64, r = Math.ceil(i * 0.7), s = Math.ceil(
        r / it.MAX_BYTES_PER_WITNESS
      );
      throw new Error(
        `Please dont use P2WDA for this operation. Data too large. Raw size: ${t} bytes, estimated compressed: ${r} bytes, needs ${s} witness fields, max is ${it.MAX_WITNESS_FIELDS}`
      );
    }
  }
  /**
   * Finalize primary P2WDA input with the operation data
   * This is where we create the signature and compress everything
   */
  finalizePrimaryP2WDA(t, e) {
    if (!e.partialSig || e.partialSig.length === 0)
      throw new Error(`No signature for P2WDA input #${t}`);
    if (!e.witnessScript)
      throw new Error(`No witness script for P2WDA input #${t}`);
    if (!this.compiledOperationData)
      throw new Error("Operation data not compiled");
    const i = e.partialSig[0].signature, r = dt([i, this.compiledOperationData]), o = ct.signMessage(
      this.signer,
      r
    ).signature, a = dt([o, this.compiledOperationData]), c = Y.compress(a), u = this.splitIntoWitnessChunks(c);
    if (u.length > it.MAX_WITNESS_FIELDS)
      throw new Error(
        `Compressed data needs ${u.length} witness fields, max is ${it.MAX_WITNESS_FIELDS}`
      );
    const l = [i];
    for (let h = 0; h < it.MAX_WITNESS_FIELDS; h++)
      l.push(h < u.length ? u[h] : new Uint8Array(0));
    return l.push(e.witnessScript), {
      finalScriptSig: void 0,
      finalScriptWitness: E.witnessStackToScriptWitness(l)
    };
  }
  /**
   * Split data into 80-byte chunks
   */
  splitIntoWitnessChunks(t) {
    const e = [];
    let i = 0;
    for (; i < t.length; ) {
      const r = Math.min(
        it.MAX_BYTES_PER_WITNESS,
        t.length - i
      );
      e.push(t.slice(i, i + r)), i += r;
    }
    return e;
  }
}
class Pe extends E {
  type = b.CANCEL;
  /**
   * The tap leaf script for spending
   */
  tapLeafScript = null;
  compiledTargetScript;
  scriptTree;
  contractSecret;
  leftOverFundsScriptRedeem = null;
  constructor(t) {
    super({
      ...t,
      gasSatFee: 1n,
      isCancellation: !0,
      priorityFee: 1n,
      calldata: new Uint8Array(0)
    }), this.contractSecret = new Uint8Array(0), t.compiledTargetScript instanceof Uint8Array ? this.compiledTargetScript = t.compiledTargetScript : this.compiledTargetScript = w(t.compiledTargetScript), this.scriptTree = this.getMinimalScriptTree(), this.internalInit();
  }
  async buildTransaction() {
    if (!this.from)
      throw new Error("From address is required");
    if (!this.leftOverFundsScriptRedeem)
      throw new Error("Left over funds script redeem is required");
    if (!this.leftOverFundsScriptRedeem.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!this.leftOverFundsScriptRedeem.output)
      throw new Error("Left over funds script redeem output is required");
    if (this.tapLeafScript = {
      leafVersion: this.leftOverFundsScriptRedeem.redeemVersion,
      script: this.leftOverFundsScriptRedeem.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO(), await this.addRefundOutput(0n, !0), !this.feeOutput)
      throw new Error("Must add extra UTXOs to cancel this transaction");
  }
  /*protected override async buildTransaction(): Promise<void> {
          if (!this.from) {
              throw new Error('From address is required');
          }
  
          // For key-path spend, we don't need the tap leaf script
          this.tapLeafScript = null;
  
          this.addInputsFromUTXO();
          await this.addRefundOutput(0n);
      }*/
  /**
   * Sign the inputs
   * @param {Psbt} transaction The transaction to sign
   * @protected
   */
  /*protected async signInputs(transaction: Psbt): Promise<void> {
          for (let i = 0; i < transaction.data.inputs.length; i++) {
              if (i === 0) {
                  transaction.signInput(0, this.getSignerKey());
  
                  transaction.finalizeInput(0, this.customFinalizer.bind(this));
              } else {
                  await super.signInputs(transaction);
              }
          }
      }*/
  /**
   * Generate the script address (for verification purposes)
   */
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2TR
    };
  }
  /**
   * Generate the tap data for spending
   */
  generateTapData() {
    const t = this.leftOverFundsScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2MR
    } : {
      internalPubkey: this.internalPubKeyToXOnly(),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2TR
    };
  }
  /**
   * Custom finalizer for the tap script spend
   */
  customFinalizer = (t, e) => {
    if (!this.tapLeafScript)
      throw new Error("Tap leaf script is required");
    if (!e.tapScriptSig || e.tapScriptSig.length === 0)
      throw new Error("Tap script signature is required");
    const r = [e.tapScriptSig[0].signature].concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
    return {
      finalScriptWitness: E.witnessStackToScriptWitness(r)
    };
  };
  async signInputs(t) {
    "multiSignPsbt" in this.signer ? await this.signInputsWalletBased(t) : await this.signInputsNonWalletBased(t);
  }
  async signInputsWalletBased(t) {
    await this.signer.multiSignPsbt([t]);
    for (let i = 0; i < t.data.inputs.length; i++)
      if (i === 0)
        t.finalizeInput(i, this.customFinalizer.bind(this));
      else
        try {
          t.finalizeInput(i, this.customFinalizerP2SH.bind(this));
        } catch {
          t.finalizeInput(i);
        }
  }
  async signInputsNonWalletBased(t) {
    await this.signInput(
      t,
      t.data.inputs[0],
      0,
      this.getSignerKey()
    ), t.finalizeInput(0, this.customFinalizer.bind(this));
    let e = /* @__PURE__ */ new Set();
    if (this.canUseParallelSigning && pt(this.signer))
      try {
        const i = await this.signKeyPathInputsParallel(t, /* @__PURE__ */ new Set([0]));
        i.success && (e = new Set(i.signatures.keys()));
      } catch (i) {
        this.error(
          `Parallel signing failed, falling back to sequential: ${i.message}`
        );
      }
    for (let i = 1; i < t.data.inputs.length; i++)
      e.has(i) || await this.signInput(
        t,
        t.data.inputs[i],
        i,
        this.signer
      );
    for (let i = 1; i < t.data.inputs.length; i++)
      try {
        t.finalizeInput(
          i,
          this.customFinalizerP2SH.bind(this)
        );
      } catch {
        t.finalizeInput(i);
      }
  }
  /**
   * Generate the minimal script tree needed for recovery
   * This only includes the leftover funds script
   */
  getMinimalScriptTree() {
    if (this.generateLeftoverFundsRedeem(), !this.leftOverFundsScriptRedeem || !this.leftOverFundsScriptRedeem.output)
      throw new Error("Failed to generate leftover funds redeem script");
    return [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: this.leftOverFundsScriptRedeem.output,
        version: 192
      }
    ];
  }
  /**
   * Generate the leftover funds redeem script
   */
  generateLeftoverFundsRedeem() {
    this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      output: this.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
}
class ai extends E {
  type = b.INTERACTION;
  /** Random bytes for interaction (same as InteractionTransaction) */
  randomBytes;
  /** The contract address (same as InteractionTransaction.to) */
  contractAddress;
  /** The contract secret - 32 bytes (same as InteractionTransaction) */
  contractSecret;
  /** The compressed calldata (same as InteractionTransaction) */
  calldata;
  /** Challenge solution for epoch (same as InteractionTransaction) */
  challenge;
  /** Epoch challenge P2WSH address (same as InteractionTransaction) */
  epochChallenge;
  /** Script signer for interaction (same as InteractionTransaction) */
  scriptSigner;
  /** Calldata generator - produces same output as InteractionTransaction */
  calldataGenerator;
  /** Hash commitment generator for CHCT */
  hashCommitmentGenerator;
  /** The compiled operation data - SAME as InteractionTransaction's compiledTargetScript */
  compiledTargetScript;
  /** Generated hash-committed P2WSH outputs */
  commitmentOutputs;
  /** Disable auto refund (same as InteractionTransaction) */
  disableAutoRefund;
  /** Maximum chunk size (default: 80 bytes per P2WSH stack item limit) */
  maxChunkSize;
  /** Cached value per output (calculated once, used by setup and reveal) */
  cachedValuePerOutput = null;
  constructor(t) {
    if (super(t), !t.to)
      throw new Error("Contract address (to) is required");
    if (!t.contract)
      throw new Error("Contract secret (contract) is required");
    if (!t.calldata)
      throw new Error("Calldata is required");
    if (!t.challenge)
      throw new Error("Challenge solution is required");
    if (this.contractAddress = t.to, this.contractSecret = w(t.contract.startsWith("0x") ? t.contract.slice(2) : t.contract), this.disableAutoRefund = t.disableAutoRefund || !1, this.maxChunkSize = t.maxChunkSize ?? I.MAX_CHUNK_SIZE, this.contractSecret.length !== 32)
      throw new Error("Invalid contract secret length. Expected 32 bytes.");
    if (this.calldata = Y.compress(t.calldata), this.randomBytes = t.randomBytes || W.rndBytes(), this.scriptSigner = P.fromSeedKeyPair(this.randomBytes, this.network), this.challenge = t.challenge, this.epochChallenge = z.generateTimeLockAddress(
      this.challenge.publicKey.originalPublicKeyBuffer(),
      this.network
    ), this.calldataGenerator = new fe(
      this.signer.publicKey,
      U(this.scriptSigner.publicKey),
      this.network
    ), t.compiledTargetScript)
      if (t.compiledTargetScript instanceof Uint8Array)
        this.compiledTargetScript = t.compiledTargetScript;
      else if (typeof t.compiledTargetScript == "string")
        this.compiledTargetScript = w(t.compiledTargetScript);
      else
        throw new Error("Invalid compiled target script format.");
    else
      this.compiledTargetScript = this.calldataGenerator.compile(
        this.calldata,
        this.contractSecret,
        this.challenge,
        this.priorityFee,
        this.generateFeatures(t)
      );
    this.hashCommitmentGenerator = new I(
      this.signer.publicKey,
      this.network
    ), this.commitmentOutputs = this.hashCommitmentGenerator.prepareChunks(
      this.compiledTargetScript,
      this.maxChunkSize
    ), this.validateOutputCount();
    const e = this.commitmentOutputs.reduce(
      (i, r) => i + r.dataChunks.length,
      0
    );
    this.log(
      `ConsolidatedInteractionTransaction: ${this.commitmentOutputs.length} outputs, ${e} chunks from ${this.compiledTargetScript.length} bytes compiled data`
    ), this.internalInit();
  }
  /**
   * Get the compiled target script (same as InteractionTransaction).
   */
  exportCompiledTargetScript() {
    return this.compiledTargetScript;
  }
  /**
   * Get the contract secret (same as InteractionTransaction).
   */
  getContractSecret() {
    return this.contractSecret;
  }
  /**
   * Get the random bytes (same as InteractionTransaction).
   */
  getRndBytes() {
    return this.randomBytes;
  }
  /**
   * Get the challenge solution (same as InteractionTransaction).
   */
  getChallenge() {
    return this.challenge;
  }
  /**
   * Get the commitment outputs for the setup transaction.
   */
  getCommitmentOutputs() {
    return this.commitmentOutputs;
  }
  /**
   * Get the number of P2WSH outputs.
   */
  getOutputCount() {
    return this.commitmentOutputs.length;
  }
  /**
   * Get the total number of 80-byte chunks across all outputs.
   */
  getTotalChunkCount() {
    return this.commitmentOutputs.reduce((t, e) => t + e.dataChunks.length, 0);
  }
  /**
   * Build both setup and reveal transactions.
   *
   * @returns Complete result with both transactions
   */
  async build() {
    const t = await this.signTransaction(), e = t.getId(), i = {
      txHex: t.toHex(),
      txId: e,
      outputs: this.commitmentOutputs,
      feesPaid: this.transactionFee,
      chunkCount: this.getTotalChunkCount(),
      totalDataSize: this.compiledTargetScript.length
    };
    this.log(`Setup transaction: ${i.txId}`);
    const r = this.buildRevealTransaction(e);
    return {
      setup: i,
      reveal: r,
      totalFees: i.feesPaid + r.feesPaid
    };
  }
  /**
   * Build the reveal transaction.
   * Spends the P2WSH commitment outputs, revealing the compiled data in witnesses.
   *
   * Output structure matches InteractionTransaction:
   * - Output to epochChallenge.address (miner reward)
   * - Change output (if any)
   *
   * @param setupTxId The transaction ID of the setup transaction
   */
  buildRevealTransaction(t) {
    const e = new X({ network: this.network }), i = this.calculateValuePerOutput();
    for (let d = 0; d < this.commitmentOutputs.length; d++) {
      const p = this.commitmentOutputs[d];
      e.addInput({
        hash: t,
        index: d,
        witnessUtxo: {
          script: p.scriptPubKey,
          value: L(i)
        },
        witnessScript: p.witnessScript
      });
    }
    const r = BigInt(this.commitmentOutputs.length) * i, s = this.getTransactionOPNetFee(), o = s < j ? j : s;
    e.addOutput({
      address: this.epochChallenge.address,
      value: L(o)
    });
    const a = this.estimateRevealVBytes(), c = BigInt(Math.ceil(a * this.feeRate)), u = r - o - c;
    if (u > E.MINIMUM_DUST) {
      const d = this.getRefundAddress();
      e.addOutput({
        address: d,
        value: L(u)
      });
    }
    for (let d = 0; d < this.commitmentOutputs.length; d++)
      e.signInput(d, this.signer);
    for (let d = 0; d < this.commitmentOutputs.length; d++) {
      const p = this.commitmentOutputs[d];
      e.finalizeInput(d, (y, m) => this.finalizeCommitmentInput(m, p));
    }
    const l = e.extractTransaction(), h = {
      txHex: l.toHex(),
      txId: l.getId(),
      dataSize: this.compiledTargetScript.length,
      feesPaid: c,
      inputCount: this.commitmentOutputs.length
    };
    return this.log(`Reveal transaction: ${h.txId}`), h;
  }
  /**
   * Get the value per commitment output (for external access).
   */
  getValuePerOutput() {
    return this.calculateValuePerOutput();
  }
  /**
   * Build the setup transaction.
   * Creates P2WSH outputs with hash commitments to the compiled data chunks.
   * This is called by signTransaction() in the base class.
   */
  async buildTransaction() {
    this.addInputsFromUTXO();
    const t = this.calculateValuePerOutput();
    for (const r of this.commitmentOutputs)
      this.addOutput({
        value: L(t),
        address: r.address
      });
    const e = BigInt(this.commitmentOutputs.length) * t, i = this.addOptionalOutputsAndGetAmount();
    await this.addRefundOutput(e + i);
  }
  /**
   * Finalize a commitment input.
   *
   * Witness stack: [signature, data_1, data_2, ..., data_N, witnessScript]
   *
   * The witness script verifies each data chunk against its committed hash.
   * If any data is wrong or missing, the transaction is INVALID at consensus level.
   */
  finalizeCommitmentInput(t, e) {
    if (!t.partialSig || t.partialSig.length === 0)
      throw new Error("No signature for commitment input");
    if (!t.witnessScript)
      throw new Error("No witness script for commitment input");
    const i = [
      t.partialSig[0].signature,
      // Signature for OP_CHECKSIG
      ...e.dataChunks,
      // All data chunks for OP_HASH160 verification
      t.witnessScript
      // The witness script
    ];
    return {
      finalScriptSig: void 0,
      finalScriptWitness: E.witnessStackToScriptWitness(i)
    };
  }
  /**
   * Estimate reveal transaction vBytes.
   */
  estimateRevealVBytes() {
    let t = 0;
    for (const i of this.commitmentOutputs) {
      const r = i.dataChunks.length, s = r * 80, o = r * 23 + 35;
      t += 164 + s + o + 72 + 20;
    }
    const e = 40 + t + 200;
    return Math.ceil(e / 4);
  }
  /**
   * Calculate the required value per commitment output.
   * This must cover: dust minimum + share of reveal fee + share of OPNet fee
   */
  calculateValuePerOutput() {
    if (this.cachedValuePerOutput !== null)
      return this.cachedValuePerOutput;
    const t = this.commitmentOutputs.length, e = this.getTransactionOPNetFee(), i = e < j ? j : e, r = this.estimateRevealVBytes(), s = BigInt(Math.ceil(r * this.feeRate)), o = i + s + E.MINIMUM_DUST, a = BigInt(Math.ceil(Number(o) / t)), c = I.MIN_OUTPUT_VALUE;
    return this.cachedValuePerOutput = a > c ? a : c, this.cachedValuePerOutput;
  }
  /**
   * Get refund address.
   */
  getRefundAddress() {
    return this.from ? this.from : Se.generatePKSH(this.signer.publicKey, this.network);
  }
  /**
   * Generate features (same as InteractionTransaction).
   */
  generateFeatures(t) {
    const e = [];
    t.loadedStorage && e.push({
      priority: et.ACCESS_LIST,
      opcode: $.ACCESS_LIST,
      data: t.loadedStorage
    });
    const i = t.challenge.getSubmission();
    if (i && e.push({
      priority: et.EPOCH_SUBMISSION,
      opcode: $.EPOCH_SUBMISSION,
      data: i
    }), t.revealMLDSAPublicKey && !t.linkMLDSAPublicKeyToAddress)
      throw new Error(
        "To reveal the MLDSA public key, you must set linkMLDSAPublicKeyToAddress to true."
      );
    return t.linkMLDSAPublicKeyToAddress && this.generateMLDSALinkRequest(t, e), e;
  }
  /**
   * Validate output count is within standard tx limits.
   */
  validateOutputCount() {
    const t = I.calculateMaxInputsPerTx();
    if (this.commitmentOutputs.length > t) {
      const e = I.calculateMaxDataPerTx();
      throw new Error(
        `Data too large: ${this.commitmentOutputs.length} P2WSH outputs needed, max ${t} per standard transaction (~${Math.floor(e / 1024)}KB). Compiled data: ${this.compiledTargetScript.length} bytes.`
      );
    }
  }
}
class ci {
  debug = !1;
  DUMMY_PUBKEY = new Uint8Array(32).fill(1);
  P2TR_SCRIPT = Uint8Array.from([81, 32, ...this.DUMMY_PUBKEY]);
  INITIAL_FUNDING_ESTIMATE = 2000n;
  MAX_ITERATIONS = 10;
  /**
   * @description Creates a cancellable transaction.
   * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} params - The cancel transaction parameters
   * @returns {Promise<CancelledTransaction>} - The cancelled transaction result
   */
  async createCancellableTransaction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    const e = await this.detectCancelOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const r = await new Pe(t).signTransaction();
    return {
      transaction: r.toHex(),
      nextUTXOs: this.getUTXOAsTransaction(r, t.from, 0),
      inputUtxos: t.utxos
    };
  }
  /**
   * @description Generate a transaction with a custom script.
   * @param {ICustomTransactionParameters | ICustomTransactionWithoutSigner} interactionParameters - The custom transaction parameters
   * @returns {Promise<[string, string, UTXO[], UTXO[]]>} - The signed transaction tuple [fundingTx, customTx, nextUTXOs, inputUtxos]
   */
  async createCustomScriptTransaction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const e = this.parseOptionalInputs(t.optionalInputs), { finalTransaction: i, estimatedAmount: r } = await this.iterateFundingAmount(
      { ...t, optionalInputs: e },
      Gt,
      async (h) => {
        const d = await h.estimateTransactionFees(), p = this.getPriorityFee(t), y = h.getOptionalOutputValue();
        return d + p + y;
      },
      "CustomScript"
    ), s = await i.getFundingTransactionParameters();
    s.utxos = t.utxos, s.amount = r;
    const o = await this.createFundTransaction({
      ...s,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!o)
      throw new Error("Could not sign funding transaction.");
    s.estimatedFees = o.estimatedFees;
    const a = await this.createFundTransaction({
      ...s,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!a)
      throw new Error("Could not sign funding transaction.");
    const c = {
      ...t,
      utxos: this.getUTXOAsTransaction(a.tx, t.to, 0),
      randomBytes: i.getRndBytes(),
      nonWitnessUtxo: a.tx.toBuffer(),
      estimatedFees: i.estimatedFees,
      compiledTargetScript: i.exportCompiledTargetScript(),
      optionalInputs: e
    }, l = await new Gt(c).signTransaction();
    return [
      a.tx.toHex(),
      l.toHex(),
      this.getUTXOAsTransaction(a.tx, t.from, 1),
      t.utxos
    ];
  }
  /**
   * @description Generates the required transactions.
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse>} - The signed transaction
   */
  async signInteraction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    const e = await this.detectInteractionOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    if (this.hasP2WDAInputs(t.utxos))
      return this.signP2WDAInteraction(t);
    const r = this.parseOptionalInputs(t.optionalInputs), { finalTransaction: s, estimatedAmount: o, challenge: a } = await this.iterateFundingAmount(
      { ...t, optionalInputs: r },
      jt,
      async (m) => {
        const A = await m.estimateTransactionFees(), x = m.getTotalOutputValue(), H = A + x;
        if (t.subtractExtraUTXOFromAmountRequired && t.optionalInputs && t.optionalInputs.length > 0) {
          const ut = t.optionalInputs.reduce(
            (ft, ie) => ft + ie.value,
            0n
          );
          return H > ut ? H - ut : 0n;
        }
        return H;
      },
      "Interaction"
    );
    if (!a)
      throw new Error("Failed to get challenge from interaction transaction");
    const c = await s.getFundingTransactionParameters();
    c.utxos = t.utxos, c.amount = o;
    const u = await this.createFundTransaction({
      ...c,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!u)
      throw new Error("Could not sign funding transaction.");
    c.estimatedFees = u.estimatedFees;
    const l = await this.createFundTransaction({
      ...c,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!l)
      throw new Error("Could not sign funding transaction.");
    const h = this.getUTXOAsTransaction(
      l.tx,
      s.getScriptAddress(),
      0
    ), d = {
      ...t,
      utxos: h,
      randomBytes: s.getRndBytes(),
      challenge: a,
      compiledTargetScript: s.exportCompiledTargetScript(),
      nonWitnessUtxo: l.tx.toBuffer(),
      estimatedFees: s.estimatedFees,
      optionalInputs: r
    }, p = new jt(d), y = await p.signTransaction();
    return {
      interactionAddress: s.getScriptAddress(),
      fundingTransaction: l.tx.toHex(),
      interactionTransaction: y.toHex(),
      estimatedFees: p.transactionFee,
      nextUTXOs: this.getUTXOAsTransaction(
        l.tx,
        t.from,
        1
      ),
      challenge: a.toRaw(),
      fundingUTXOs: h,
      fundingInputUtxos: t.utxos,
      compiledTargetScript: g(p.exportCompiledTargetScript())
    };
  }
  /**
   * @description Generates a consolidated interaction transaction (CHCT system).
   *
   * Drop-in replacement for signInteraction that bypasses BIP110/Bitcoin Knots censorship.
   * Uses P2WSH with HASH160 commitments instead of Tapscript (which uses OP_IF and gets censored).
   *
   * Returns two transactions:
   * - Setup: Creates P2WSH outputs with hash commitments to data chunks
   * - Reveal: Spends those outputs, revealing data in witnesses
   *
   * Data integrity is consensus-enforced - if data is stripped/modified,
   * HASH160(data) != committed_hash and the transaction is INVALID.
   *
   * @param {IConsolidatedInteractionParameters} interactionParameters - Same parameters as signInteraction
   * @returns {Promise<ConsolidatedInteractionResponse>} - Both setup and reveal transactions
   */
  async signConsolidatedInteraction(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!t.utxos[0])
      throw new Error("Missing at least one UTXO.");
    if (!("signer" in t))
      throw new Error('Field "signer" not provided.');
    if (!t.challenge)
      throw new Error('Field "challenge" not provided.');
    const e = this.parseOptionalInputs(t.optionalInputs), i = new ai({
      ...t,
      optionalInputs: e
    }), r = await i.build();
    return {
      setupTransaction: r.setup.txHex,
      revealTransaction: r.reveal.txHex,
      setupTxId: r.setup.txId,
      revealTxId: r.reveal.txId,
      totalFees: r.totalFees,
      chunkCount: r.setup.chunkCount,
      dataSize: r.setup.totalDataSize,
      challenge: i.getChallenge().toRaw(),
      inputUtxos: t.utxos,
      compiledTargetScript: g(i.exportCompiledTargetScript())
    };
  }
  /**
   * @description Generates the required transactions.
   * @param {IDeploymentParameters} deploymentParameters - The deployment parameters
   * @returns {Promise<DeploymentResult>} - The signed transaction
   */
  async signDeployment(t) {
    const e = await this.detectDeploymentOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const i = this.parseOptionalInputs(t.optionalInputs), { finalTransaction: r, estimatedAmount: s, challenge: o } = await this.iterateFundingAmount(
      { ...t, optionalInputs: i },
      Et,
      async (H) => {
        const ut = await H.estimateTransactionFees(), ft = this.getPriorityFee(t), ie = H.getOptionalOutputValue();
        return ut + ft + ie;
      },
      "Deployment"
    );
    if (!o)
      throw new Error("Failed to get challenge from deployment transaction");
    const a = await r.getFundingTransactionParameters();
    a.utxos = t.utxos, a.amount = s;
    const c = await this.createFundTransaction({
      ...a,
      optionalOutputs: [],
      optionalInputs: []
    });
    if (!c)
      throw new Error("Could not sign funding transaction.");
    a.estimatedFees = c.estimatedFees;
    const l = await new Qt({
      ...a,
      optionalInputs: [],
      optionalOutputs: []
    }).signTransaction();
    if (!l)
      throw new Error("Could not sign funding transaction.");
    const h = l.outs[0], d = {
      transactionId: l.getId(),
      outputIndex: 0,
      scriptPubKey: {
        hex: g(h.script),
        address: r.getScriptAddress()
      },
      value: BigInt(h.value)
    }, p = {
      ...t,
      utxos: [d],
      randomBytes: r.getRndBytes(),
      compiledTargetScript: r.exportCompiledTargetScript(),
      challenge: o,
      nonWitnessUtxo: l.toBuffer(),
      estimatedFees: r.estimatedFees,
      optionalInputs: i
    }, y = new Et(p), m = await y.signTransaction(), A = l.outs[1], x = {
      transactionId: l.getId(),
      outputIndex: 1,
      scriptPubKey: {
        hex: g(A.script),
        address: t.from
      },
      value: BigInt(A.value)
    };
    return {
      transaction: [l.toHex(), m.toHex()],
      contractAddress: y.getContractAddress(),
      contractPubKey: y.contractPubKey,
      utxos: [x],
      challenge: o.toRaw(),
      inputUtxos: t.utxos
    };
  }
  /**
   * @description Creates a funding transaction.
   * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
   * @returns {Promise<BitcoinTransferBase>} - The signed transaction
   */
  async createBTCTransfer(t) {
    if (!t.to)
      throw new Error('Field "to" not provided.');
    if (!t.from)
      throw new Error('Field "from" not provided.');
    const e = await this.detectFundingOPWallet(t);
    if (e)
      return e;
    if (!("signer" in t))
      throw new Error('Field "signer" not provided, OP_WALLET not detected.');
    const i = await this.createFundTransaction(t);
    return {
      estimatedFees: i.estimatedFees,
      tx: i.tx.toHex(),
      nextUTXOs: this.getAllNewUTXOs(i.original, i.tx, t.from),
      inputUtxos: t.utxos
    };
  }
  /**
   * Get all new UTXOs of a generated transaction.
   * @param {TransactionBuilder<TransactionType>} original - The original transaction
   * @param {Transaction} tx - The transaction
   * @param {string} to - The address to filter
   * @returns {UTXO[]} - The new UTXOs belonging to the specified address
   */
  getAllNewUTXOs(t, e, i) {
    const r = t.getOutputs(), s = [];
    for (let o = 0; o < e.outs.length; o++) {
      const a = r[o];
      if ("address" in a) {
        if (a.address !== i) continue;
      } else
        continue;
      s.push(...this.getUTXOAsTransaction(e, i, o));
    }
    return s;
  }
  /**
   * Parse optional inputs and normalize nonWitnessUtxo format.
   * @param {UTXO[]} optionalInputs - The optional inputs to parse
   * @returns {UTXO[]} - The parsed inputs with normalized nonWitnessUtxo
   */
  parseOptionalInputs(t) {
    return (t || []).map((e) => {
      let i = e.nonWitnessUtxo;
      return i && !(i instanceof Uint8Array) && typeof i == "object" && (i = Uint8Array.from(Object.values(i))), {
        ...e,
        nonWitnessUtxo: i
      };
    });
  }
  /**
   * Detect and use OP_WALLET for funding transactions if available.
   *
   * @param {IFundingTransactionParameters | IFundingTransactionParametersWithoutSigner} fundingParams - The funding transaction parameters
   * @return {Promise<BitcoinTransferBase | null>} - The funding transaction response or null if OP_WALLET not available
   */
  async detectFundingOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.sendBitcoin({
      ...t,
      // @ts-expect-error signer is stripped by the wallet
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign funding transaction.");
    return {
      ...r,
      inputUtxos: r.inputUtxos ?? t.utxos
    };
  }
  /**
   * Detect and use OP_WALLET for cancel transactions if available.
   * @param {ICancelTransactionParameters | ICancelTransactionParametersWithoutSigner} interactionParameters - The cancel parameters
   * @returns {Promise<CancelledTransaction | null>} - The cancelled transaction or null if OP_WALLET not available
   */
  async detectCancelOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.cancelTransaction({
      ...t,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign interaction transaction.");
    return {
      ...r,
      inputUtxos: r.inputUtxos ?? t.utxos
    };
  }
  /**
   * Detect and use OP_WALLET for interaction transactions if available.
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse | null>} - The interaction response or null if OP_WALLET not available
   */
  async detectInteractionOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.signInteraction({
      ...t,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign interaction transaction.");
    return {
      ...r,
      fundingInputUtxos: r.fundingInputUtxos ?? t.utxos
    };
  }
  /**
   * Detect and use OP_WALLET for deployment transactions if available.
   * @param {IDeploymentParameters | IDeploymentParametersWithoutSigner} deploymentParameters - The deployment parameters
   * @returns {Promise<DeploymentResult | null>} - The deployment result or null if OP_WALLET not available
   */
  async detectDeploymentOPWallet(t) {
    if (typeof window > "u")
      return null;
    const e = window;
    if (!e || !e.opnet || !e.opnet.web3)
      return null;
    const r = await e.opnet.web3.deployContract({
      ...t,
      // @ts-expect-error no, this is ok
      signer: void 0
    });
    if (!r)
      throw new Error("Could not sign interaction transaction.");
    return {
      ...r,
      inputUtxos: r.inputUtxos ?? t.utxos
    };
  }
  /**
   * Create and sign a funding transaction.
   * @param {IFundingTransactionParameters} parameters - The funding transaction parameters
   * @returns {Promise<FundingTransactionResponse>} - The funding transaction response
   */
  async createFundTransaction(t) {
    if (!t.to) throw new Error('Field "to" not provided.');
    const e = new Qt(t), i = await e.signTransaction();
    if (!i)
      throw new Error("Could not sign funding transaction.");
    return {
      tx: i,
      original: e,
      estimatedFees: e.estimatedFees,
      nextUTXOs: this.getUTXOAsTransaction(i, t.to, 0),
      inputUtxos: t.utxos
    };
  }
  /**
   * Check if the UTXOs contain any P2WDA inputs
   *
   * This method examines both main UTXOs and optional inputs to determine
   * if any of them are P2WDA addresses. P2WDA detection is based on the
   * witness script pattern: (OP_2DROP * 5) <pubkey> OP_CHECKSIG
   *
   * @param {UTXO[]} utxos - The main UTXOs to check
   * @returns {boolean} - true if any UTXO is P2WDA, false otherwise
   */
  hasP2WDAInputs(t) {
    return t.some((e) => Z.isP2WDAUTXO(e));
  }
  /**
   * Sign a P2WDA interaction transaction
   *
   * P2WDA interactions are fundamentally different from standard OP_NET interactions.
   * Instead of using a two-transaction model (funding + interaction), P2WDA embeds
   * the operation data directly in the witness field of a single transaction.
   * This achieves significant cost savings through the witness discount.
   *
   * Key differences:
   * - Single transaction instead of two
   * - Operation data in witness field instead of taproot script
   * - 75% cost reduction for data storage
   * - No separate funding transaction needed
   *
   * @param {IInteractionParameters | InteractionParametersWithoutSigner} interactionParameters - The interaction parameters
   * @returns {Promise<InteractionResponse>} - The signed P2WDA interaction response
   */
  async signP2WDAInteraction(t) {
    if (!t.from)
      throw new Error('Field "from" not provided.');
    if (!("signer" in t))
      throw new Error(
        "P2WDA interactions require a signer. OP_WALLET is not supported for P2WDA."
      );
    const e = this.parseOptionalInputs(t.optionalInputs), i = new it({
      ...t,
      optionalInputs: e
    }), r = await i.signTransaction();
    return {
      interactionAddress: null,
      fundingTransaction: null,
      interactionTransaction: r.toHex(),
      estimatedFees: i.estimatedFees,
      nextUTXOs: this.getUTXOAsTransaction(
        r,
        t.from,
        r.outs.length - 1
      ),
      fundingUTXOs: [...t.utxos, ...e],
      fundingInputUtxos: t.utxos,
      challenge: t.challenge.toRaw(),
      compiledTargetScript: null
    };
  }
  /**
   * Get the priority fee from transaction parameters.
   * @param {ITransactionParameters} params - The transaction parameters
   * @returns {bigint} - The priority fee, minimum dust if below threshold
   */
  getPriorityFee(t) {
    const e = t.priorityFee + t.gasSatFee;
    return e < E.MINIMUM_DUST ? E.MINIMUM_DUST : e;
  }
  /**
   * Common iteration logic for finding the correct funding amount.
   *
   * This method iteratively estimates the required funding amount by simulating
   * transactions until the amount converges or max iterations is reached.
   *
   * @param {P extends IInteractionParameters | IDeploymentParameters | ICustomTransactionParameters} params - The transaction parameters
   * @param {new (params: P) => T} TransactionClass - The transaction class constructor
   * @param {(tx: T extends InteractionTransaction | DeploymentTransaction | CustomScriptTransaction) => Promise<bigint>} calculateAmount - Function to calculate required amount
   * @param {string} debugPrefix - Prefix for debug logging
   * @returns {Promise<{finalTransaction: T extends InteractionTransaction | DeploymentTransaction | CustomScriptTransaction, estimatedAmount: bigint, challenge: IChallengeSolution | null}>} - The final transaction and estimated amount
   */
  async iterateFundingAmount(t, e, i, r) {
    const s = "randomBytes" in t ? t.randomBytes ?? W.rndBytes() : W.rndBytes(), o = K.dead().p2tr(t.network);
    let a = this.INITIAL_FUNDING_ESTIMATE, c = 0n, u = 0, l = null, h = null;
    for (; u < this.MAX_ITERATIONS && a !== c; ) {
      c = a;
      const d = new oe();
      d.addOutput(this.P2TR_SCRIPT, L(a));
      const p = {
        transactionId: g(new Uint8Array(32)),
        outputIndex: 0,
        scriptPubKey: {
          hex: g(this.P2TR_SCRIPT),
          address: o
        },
        value: a,
        nonWitnessUtxo: d.toBuffer()
      };
      let y;
      "challenge" in t && t.challenge ? y = {
        ...t,
        utxos: [p],
        randomBytes: s,
        challenge: h ?? t.challenge
      } : y = {
        ...t,
        utxos: [p],
        randomBytes: s
      };
      const m = new e(y);
      try {
        await m.generateTransactionMinimalSignatures(), a = await i(m);
      } catch (A) {
        if (A instanceof Error) {
          const x = A.message.match(/need (\d+) sats but only have (\d+) sats/);
          if (x)
            a = BigInt(x[1]), this.debug && console.log(
              `${r}: Caught insufficient funds, updating to ${a}`
            );
          else
            throw A;
        } else
          throw new Error("Unknown error during fee estimation", { cause: A });
      }
      l = m, "getChallenge" in m && typeof m.getChallenge == "function" && (h = m.getChallenge()), u++, this.debug && console.log(
        `${r} Iteration ${u}: Previous=${c}, New=${a}`
      );
    }
    if (!l)
      throw new Error(`Failed to converge on ${r} funding amount`);
    return {
      finalTransaction: l,
      estimatedAmount: a,
      challenge: h
    };
  }
  /**
   * Convert a transaction output to a UTXO.
   * @param {Transaction} tx - The transaction
   * @param {string} to - The address
   * @param {number} index - The output index
   * @returns {UTXO[]} - The UTXO array (empty if output doesn't exist)
   */
  getUTXOAsTransaction(t, e, i) {
    if (!t.outs[i]) return [];
    const r = t.outs[i];
    return [{
      transactionId: t.getId(),
      outputIndex: i,
      scriptPubKey: {
        hex: g(r.script),
        address: e
      },
      value: BigInt(r.value)
    }];
  }
}
class R extends E {
  static LOCK_LEAF_SCRIPT = O.compile([
    f.OP_XOR,
    f.OP_NOP,
    f.OP_CODESEPARATOR
  ]);
  static signHashTypesArray = [
    //Transaction.SIGHASH_ALL,
    //Transaction.SIGHASH_ANYONECANPAY,
  ];
  static numsPoint = w(
    "50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0"
  );
  type = b.MULTI_SIG;
  targetScriptRedeem = null;
  leftOverFundsScriptRedeem = null;
  compiledTargetScript;
  scriptTree;
  publicKeys;
  minimumSignatures;
  originalInputCount = 0;
  requestedAmount;
  receiver;
  refundVault;
  /**
   * @description Sign hash types
   * @protected
   */
  sighashTypes = R.signHashTypesArray;
  constructor(t) {
    if (!t.refundVault)
      throw new Error("Refund vault is required");
    if (!t.requestedAmount)
      throw new Error("Requested amount is required");
    if (!t.receiver)
      throw new Error("Receiver is required");
    if (super({
      ...t,
      signer: P.fromPrivateKey(
        F.sha256(new TextEncoder().encode("aaaaaaaa"))
      ),
      priorityFee: 0n,
      gasSatFee: 0n
    }), !t.pubkeys)
      throw new Error("Pubkeys are required");
    t.psbt && (this.log("Using provided PSBT."), this.transaction = t.psbt, this.originalInputCount = this.transaction.data.inputs.length), this.refundVault = t.refundVault, this.requestedAmount = t.requestedAmount, this.receiver = t.receiver, this.publicKeys = t.pubkeys, this.minimumSignatures = t.minimumSignatures, this.compiledTargetScript = Dt.compile(
      t.pubkeys,
      this.minimumSignatures
    ), this.scriptTree = this.getScriptTree(), this.internalInit();
  }
  /**
   * Generate a multisig transaction from a base64 psbt.
   * @param {MultiSignFromBase64Params} params The parameters
   * @returns {MultiSignTransaction} The multisig transaction
   */
  static fromBase64(t) {
    const e = X.fromBase64(t.psbt, { network: t.network });
    return new R({
      ...t,
      psbt: e
    });
  }
  /**
   * Verify if that public key already signed the transaction
   * @param {Psbt} psbt The psbt
   * @param {Uint8Array} signerPubKey The signer public key
   * @returns {boolean} True if the public key signed the transaction
   */
  static verifyIfSigned(t, e) {
    let i = !1;
    for (let r = 1; r < t.data.inputs.length; r++) {
      const s = t.data.inputs[r];
      if (!s.finalScriptWitness)
        continue;
      const o = E.readScriptWitnessToWitnessStack(
        s.finalScriptWitness
      );
      if (!(o.length < 3))
        for (let a = 0; a < o.length - 2; a += 3) {
          const c = o[a + 2];
          if (C(c, e)) {
            i = !0;
            break;
          }
        }
    }
    return i;
  }
  /**
   * Partially sign the transaction
   * @returns {boolean} True if the transaction was signed
   * @public
   */
  static signPartial(t, e, i, r) {
    let s = !1, o = !0;
    for (let a = i; a < t.data.inputs.length; a++) {
      const c = t.data.inputs[a];
      c.tapInternalKey || (c.tapInternalKey = U(R.numsPoint));
      const u = [];
      if (c.finalScriptWitness) {
        const h = E.readScriptWitnessToWitnessStack(
          c.finalScriptWitness
        );
        c.tapLeafScript = [
          {
            leafVersion: 192,
            script: h[h.length - 2],
            controlBlock: h[h.length - 1]
          }
        ];
        for (let d = 0; d < h.length - 2; d += 3)
          u.push({
            signature: h[d],
            leafHash: h[d + 1],
            pubkey: h[d + 2]
          });
        c.tapScriptSig = (c.tapScriptSig || []).concat(u);
      }
      Reflect.deleteProperty(c, "finalScriptWitness");
      const l = R.signHashTypesArray ? [R.calculateSignHash(R.signHashTypesArray)] : [];
      try {
        R.signInput(t, c, a, e, l), s = !0;
      } catch (h) {
        console.log(h);
      }
      if (s) {
        if (!c.tapScriptSig) throw new Error("No new signatures for input");
        c.tapScriptSig.length !== r[a - i] && (o = !1);
      }
    }
    return {
      signed: s,
      final: s ? o : !1
    };
  }
  /**
   * Partially finalize a P2TR MS transaction
   * @param {number} inputIndex The input index
   * @param {PsbtInput} input The input
   * @param {Uint8Array[]} partialSignatures The partial signatures
   * @param {Uint8Array[]} orderedPubKeys The ordered public keys
   * @param {boolean} isFinal If the transaction is final
   */
  static partialFinalizer = (t, e, i, r, s) => {
    if (!e.tapLeafScript || !e.tapLeafScript[0]?.script || !e.tapLeafScript[0]?.controlBlock)
      throw new Error("Tap leaf script is required");
    if (!e.tapScriptSig)
      throw new Error(`No new signatures for input ${t}.`);
    let o = [];
    if (!s)
      o = e.tapScriptSig.map((u) => [u.signature, u.leafHash, u.pubkey]).flat();
    else {
      for (const u of r) {
        let l = !1;
        for (const h of e.tapScriptSig)
          C(h.pubkey, U(u)) && (o.push(h.signature), l = !0);
        l || o.push(new Uint8Array(0));
      }
      o = o.reverse();
    }
    i.length > 0 && (o = o.concat(i));
    const a = e.tapLeafScript[0], c = o.concat(a.script).concat(a.controlBlock);
    return {
      finalScriptWitness: E.witnessStackToScriptWitness(c)
    };
  };
  /**
   * Dedupe signatures
   * @param {TapScriptSig[]} original The original signatures
   * @param {TapScriptSig[]} partial The partial signatures
   * @returns {TapScriptSig[]} The deduped signatures
   */
  static dedupeSignatures(t, e) {
    const i = /* @__PURE__ */ new Map();
    for (const r of t)
      i.set(g(r.pubkey), r);
    for (const r of e)
      i.has(g(r.pubkey)) || i.set(g(r.pubkey), r);
    return Array.from(i.values());
  }
  /**
   * Attempt to finalize the inputs
   * @param {Psbt} psbt The psbt
   * @param {number} startIndex The start index
   * @param {Uint8Array[]} orderedPubKeys The ordered public keys
   * @param {boolean} isFinal If the transaction is final
   * @returns {boolean} True if the inputs were finalized
   */
  static attemptFinalizeInputs(t, e, i, r) {
    let s = 0;
    for (let o = e; o < t.data.inputs.length; o++)
      try {
        const a = t.data.inputs[o];
        a.tapInternalKey || (a.tapInternalKey = U(R.numsPoint));
        const c = [];
        if (a.finalScriptWitness) {
          const u = E.readScriptWitnessToWitnessStack(
            a.finalScriptWitness
          );
          for (let l = 0; l < u.length - 2; l += 3)
            c.push({
              signature: u[l],
              leafHash: u[l + 1],
              pubkey: u[l + 2]
            });
          a.tapLeafScript = [
            {
              leafVersion: 192,
              script: u[u.length - 2],
              controlBlock: u[u.length - 1]
            }
          ], a.tapScriptSig = R.dedupeSignatures(
            a.tapScriptSig || [],
            c
          );
        }
        Reflect.deleteProperty(a, "finalScriptWitness"), t.finalizeInput(
          o,
          (u, l) => R.partialFinalizer(
            u,
            l,
            [],
            i[o - e],
            r
          )
        ), s++;
      } catch {
      }
    return s === t.data.inputs.length - e;
  }
  /**
   * Finalize the psbt multisig transaction
   */
  finalizeTransactionInputs() {
    let t = !1;
    try {
      for (let e = this.originalInputCount; e < this.transaction.data.inputs.length; e++)
        this.transaction.finalizeInput(e, this.customFinalizer.bind(this));
      t = !0;
    } catch (e) {
      this.error(`Error finalizing transaction inputs: ${e.stack}`);
    }
    return t;
  }
  /**
   * @description Signs the transaction
   * @public
   * @returns {Promise<Psbt>} - The signed transaction in hex format
   * @throws {Error} - If something went wrong
   */
  async signPSBT() {
    if (await this.signTransaction())
      return this.transaction;
    throw new Error("Could not sign transaction");
  }
  /**
   * Build the transaction
   * @protected
   *
   * @throws {Error} If the left over funds script redeem is required
   * @throws {Error} If the left over funds script redeem version is required
   * @throws {Error} If the left over funds script redeem output is required
   */
  // eslint-disable-next-line @typescript-eslint/require-await
  async buildTransaction() {
    const t = this.targetScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!t.redeemVersion)
      throw new Error("Left over funds script redeem version is required");
    if (!t.output)
      throw new Error("Left over funds script redeem output is required");
    this.tapLeafScript = {
      leafVersion: t.redeemVersion,
      script: t.output,
      controlBlock: this.getWitness()
    }, this.addInputsFromUTXO();
    const e = this.calculateOutputLeftAmountFromVaults(this.utxos);
    if (e < 0)
      throw new Error(`Output value left is negative ${e}.`);
    this.addOutput({
      address: this.refundVault,
      value: L(e)
    }), this.addOutput({
      address: this.receiver,
      value: L(this.requestedAmount)
    });
  }
  /**
   * Builds the transaction.
   * @param {Psbt} transaction - The transaction to build
   * @param checkPartialSigs
   * @protected
   * @returns {Promise<boolean>}
   * @throws {Error} - If something went wrong while building the transaction
   */
  async internalBuildTransaction(t, e = !1) {
    const i = this.getInputs(), r = this.getOutputs();
    t.setMaximumFeeRate(this._maximumFeeRate), t.addInputs(i, e);
    for (let s = 0; s < this.updateInputs.length; s++)
      t.updateInput(s, this.updateInputs[s]);
    t.addOutputs(r);
    try {
      return await this.signInputs(t), this.finalizeTransactionInputs();
    } catch (s) {
      const o = s;
      this.error(
        `[internalBuildTransaction] Something went wrong while getting building the transaction: ${o.stack}`
      );
    }
    return !1;
  }
  /**
   * Sign the inputs
   * @protected
   */
  async signInputs(t) {
  }
  generateScriptAddress() {
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2MR
    } : {
      internalPubkey: U(R.numsPoint),
      network: this.network,
      scriptTree: this.scriptTree,
      name: v.P2TR
    };
  }
  generateTapData() {
    const t = this.targetScriptRedeem;
    if (!t)
      throw new Error("Left over funds script redeem is required");
    if (!this.scriptTree)
      throw new Error("Script tree is required");
    return this.useP2MR ? {
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2MR
    } : {
      internalPubkey: U(R.numsPoint),
      network: this.network,
      scriptTree: this.scriptTree,
      redeem: t,
      name: v.P2TR
    };
  }
  /**
   * Generate the script solution
   * @param {PsbtInput} input The input
   * @protected
   *
   * @returns {Uint8Array[]} The script solution
   */
  getScriptSolution(t) {
    return t.tapScriptSig ? t.tapScriptSig.map((e) => e.signature) : [];
  }
  /**
   * Get the script tree
   * @private
   *
   * @returns {Taptree} The script tree
   */
  getScriptTree() {
    return this.generateRedeemScripts(), [
      {
        output: this.compiledTargetScript,
        version: 192
      },
      {
        output: R.LOCK_LEAF_SCRIPT,
        version: 192
      }
    ];
  }
  getTotalOutputAmount(t) {
    let e = 0n;
    for (const i of t)
      e += i.value;
    return e;
  }
  /**
   * @description Calculate the amount left to refund to the first vault.
   * @private
   * @returns {bigint} The amount left
   */
  calculateOutputLeftAmountFromVaults(t) {
    return this.getTotalOutputAmount(t) - this.requestedAmount;
  }
  /**
   * Transaction finalizer
   * @param {number} _inputIndex The input index
   * @param {PsbtInput} input The input
   */
  customFinalizer = (t, e) => {
    if (!this.tapLeafScript)
      throw new Error("Tap leaf script is required");
    const r = this.getScriptSolution(e).concat(this.tapLeafScript.script).concat(this.tapLeafScript.controlBlock);
    return {
      finalScriptWitness: E.witnessStackToScriptWitness(r)
    };
  };
  /**
   * Generate the redeem scripts
   * @private
   *
   * @throws {Error} If the public keys are required
   * @throws {Error} If the leaf script is required
   * @throws {Error} If the leaf script version is required
   * @throws {Error} If the leaf script output is required
   * @throws {Error} If the target script redeem is required
   */
  generateRedeemScripts() {
    this.targetScriptRedeem = {
      name: v.P2TR,
      output: this.compiledTargetScript,
      redeemVersion: 192
    }, this.leftOverFundsScriptRedeem = {
      name: v.P2TR,
      output: R.LOCK_LEAF_SCRIPT,
      redeemVersion: 192
    };
  }
}
const ve = 1, Ht = 66;
function ui(n) {
  return n.type === b.FUNDING;
}
function li(n) {
  return n.type === b.DEPLOYMENT;
}
function hi(n) {
  return n.type === b.INTERACTION;
}
function ot(n) {
  return n.type === b.MULTI_SIG;
}
function di(n) {
  return n.type === b.CUSTOM_CODE;
}
function pi(n) {
  return n.type === b.CANCEL;
}
function G(n) {
  return n.startsWith("0x") ? n.slice(2) : n;
}
class k {
  /**
   * Serialize transaction state to binary format
   * @param state - The transaction state to serialize
   * @returns Uint8Array containing serialized state with checksum
   */
  static serialize(t) {
    const e = new V();
    this.writeHeader(e, t.header), this.writeBaseParams(e, t.baseParams), this.writeUTXOArray(e, t.utxos), this.writeUTXOArray(e, t.optionalInputs), this.writeOutputArray(e, t.optionalOutputs), e.writeBoolean(t.addressRotationEnabled), this.writeSignerMappings(e, t.signerMappings), this.writeTypeSpecificData(e, t.typeSpecificData), this.writePrecomputedData(e, t.precomputedData);
    const i = e.getBuffer(), r = this.calculateChecksum(i), s = new Uint8Array(i.length + r.length);
    return s.set(i, 0), s.set(r, i.length), s;
  }
  /**
   * Deserialize binary format to transaction state
   * @param data - Uint8Array containing serialized state
   * @returns Deserialized transaction state
   * @throws Error if checksum validation fails or format is invalid
   */
  static deserialize(t) {
    if (t.length < 32)
      throw new Error("Invalid serialized data: too short");
    const e = t.subarray(-32), i = t.subarray(0, -32), r = this.calculateChecksum(i);
    if (!this.bytesEqual(e, r))
      throw new Error("Invalid checksum - data may be corrupted");
    const s = new ee(i), o = this.readHeader(s);
    if (o.formatVersion > ve)
      throw new Error(`Unsupported format version: ${o.formatVersion}`);
    const a = this.readBaseParams(s), c = this.readUTXOArray(s), u = this.readUTXOArray(s), l = this.readOutputArray(s), h = s.readBoolean(), d = this.readSignerMappings(s), p = this.readTypeSpecificData(s, o.transactionType), y = this.readPrecomputedData(s);
    return {
      header: o,
      baseParams: a,
      utxos: c,
      optionalInputs: u,
      optionalOutputs: l,
      addressRotationEnabled: h,
      signerMappings: d,
      typeSpecificData: p,
      precomputedData: y
    };
  }
  /**
   * Export state as base64 string (for transport)
   * @param state - Transaction state to export
   * @returns Base64-encoded string
   */
  static toBase64(t) {
    const e = this.serialize(t);
    return this.uint8ArrayToBase64(e);
  }
  /**
   * Import state from base64 string
   * @param base64 - Base64-encoded state
   * @returns Deserialized transaction state
   */
  static fromBase64(t) {
    return this.deserialize(this.base64ToUint8Array(t));
  }
  /**
   * Export state as hex string
   * @param state - Transaction state to export
   * @returns Hex-encoded string
   */
  static toHex(t) {
    return g(this.serialize(t));
  }
  /**
   * Import state from hex string
   * @param hex - Hex-encoded state
   * @returns Deserialized transaction state
   */
  static fromHex(t) {
    return this.deserialize(w(t));
  }
  static writeHeader(t, e) {
    t.writeU8(Ht), t.writeU8(e.formatVersion), t.writeU8(e.consensusVersion), t.writeU8(e.transactionType), t.writeU32(e.chainId), t.writeU64(BigInt(e.timestamp));
  }
  static readHeader(t) {
    const e = t.readU8();
    if (e !== Ht)
      throw new Error(
        `Invalid magic byte: expected 0x${Ht.toString(16)}, got 0x${e.toString(16)}`
      );
    return {
      formatVersion: t.readU8(),
      consensusVersion: t.readU8(),
      transactionType: t.readU8(),
      chainId: t.readU32(),
      timestamp: Number(t.readU64())
    };
  }
  static writeBaseParams(t, e) {
    t.writeStringWithLength(e.from), t.writeBoolean(e.to !== void 0), e.to !== void 0 && t.writeStringWithLength(e.to), t.writeU32(Math.floor(e.feeRate * 1e3)), t.writeU64(BigInt(e.priorityFee)), t.writeU64(BigInt(e.gasSatFee)), t.writeU8(this.networkNameToU8(e.networkName)), t.writeU8(e.txVersion), t.writeBoolean(e.note !== void 0), e.note !== void 0 && t.writeBytesWithLength(w(e.note)), t.writeBoolean(e.anchor), t.writeBoolean(e.debugFees ?? !1);
  }
  static readBaseParams(t) {
    const e = t.readStringWithLength(), r = t.readBoolean() ? t.readStringWithLength() : void 0, s = t.readU32() / 1e3, o = t.readU64().toString(), a = t.readU64().toString(), c = this.u8ToNetworkName(t.readU8()), u = t.readU8(), h = t.readBoolean() ? g(t.readBytesWithLength()) : void 0, d = t.readBoolean(), p = t.readBoolean();
    return {
      from: e,
      feeRate: s,
      priorityFee: o,
      gasSatFee: a,
      networkName: c,
      txVersion: u,
      anchor: d,
      debugFees: p,
      ...r !== void 0 ? { to: r } : {},
      ...h !== void 0 ? { note: h } : {}
    };
  }
  static writeUTXOArray(t, e) {
    t.writeU16(e.length);
    for (const i of e)
      this.writeUTXO(t, i);
  }
  static writeUTXO(t, e) {
    t.writeBytes(w(e.transactionId)), t.writeU32(e.outputIndex), t.writeU64(BigInt(e.value)), t.writeBytesWithLength(w(e.scriptPubKeyHex)), t.writeBoolean(e.scriptPubKeyAddress !== void 0), e.scriptPubKeyAddress !== void 0 && t.writeStringWithLength(e.scriptPubKeyAddress), t.writeBoolean(e.redeemScript !== void 0), e.redeemScript !== void 0 && t.writeBytesWithLength(w(e.redeemScript)), t.writeBoolean(e.witnessScript !== void 0), e.witnessScript !== void 0 && t.writeBytesWithLength(w(e.witnessScript)), t.writeBoolean(e.nonWitnessUtxo !== void 0), e.nonWitnessUtxo !== void 0 && t.writeBytesWithLength(w(e.nonWitnessUtxo));
  }
  static readUTXOArray(t) {
    const e = t.readU16(), i = [];
    for (let r = 0; r < e; r++)
      i.push(this.readUTXO(t));
    return i;
  }
  static readUTXO(t) {
    const e = g(t.readBytes(32)), i = t.readU32(), r = t.readU64().toString(), s = g(t.readBytesWithLength()), a = t.readBoolean() ? t.readStringWithLength() : void 0, u = t.readBoolean() ? g(t.readBytesWithLength()) : void 0, h = t.readBoolean() ? g(t.readBytesWithLength()) : void 0, p = t.readBoolean() ? g(t.readBytesWithLength()) : void 0;
    return {
      transactionId: e,
      outputIndex: i,
      value: r,
      scriptPubKeyHex: s,
      ...a !== void 0 ? { scriptPubKeyAddress: a } : {},
      ...u !== void 0 ? { redeemScript: u } : {},
      ...h !== void 0 ? { witnessScript: h } : {},
      ...p !== void 0 ? { nonWitnessUtxo: p } : {}
    };
  }
  static writeOutputArray(t, e) {
    t.writeU16(e.length);
    for (const i of e)
      this.writeOutput(t, i);
  }
  static writeOutput(t, e) {
    t.writeU64(BigInt(e.value)), t.writeBoolean(e.address !== void 0), e.address !== void 0 && t.writeStringWithLength(e.address), t.writeBoolean(e.script !== void 0), e.script !== void 0 && t.writeBytesWithLength(w(e.script)), t.writeBoolean(e.tapInternalKey !== void 0), e.tapInternalKey !== void 0 && t.writeBytesWithLength(w(e.tapInternalKey));
  }
  static readOutputArray(t) {
    const e = t.readU16(), i = [];
    for (let r = 0; r < e; r++)
      i.push(this.readOutput(t));
    return i;
  }
  static readOutput(t) {
    const e = Number(t.readU64()), r = t.readBoolean() ? t.readStringWithLength() : void 0, o = t.readBoolean() ? g(t.readBytesWithLength()) : void 0, c = t.readBoolean() ? g(t.readBytesWithLength()) : void 0;
    return {
      value: e,
      ...r !== void 0 ? { address: r } : {},
      ...o !== void 0 ? { script: o } : {},
      ...c !== void 0 ? { tapInternalKey: c } : {}
    };
  }
  static writeSignerMappings(t, e) {
    t.writeU16(e.length);
    for (const i of e) {
      t.writeStringWithLength(i.address), t.writeU16(i.inputIndices.length);
      for (const r of i.inputIndices)
        t.writeU16(r);
    }
  }
  static readSignerMappings(t) {
    const e = t.readU16(), i = [];
    for (let r = 0; r < e; r++) {
      const s = t.readStringWithLength(), o = t.readU16(), a = [];
      for (let c = 0; c < o; c++)
        a.push(t.readU16());
      i.push({ address: s, inputIndices: a });
    }
    return i;
  }
  static writeTypeSpecificData(t, e) {
    switch (e.type) {
      case b.FUNDING:
        this.writeFundingData(t, e);
        break;
      case b.DEPLOYMENT:
        this.writeDeploymentData(t, e);
        break;
      case b.INTERACTION:
        this.writeInteractionData(t, e);
        break;
      case b.MULTI_SIG:
        this.writeMultiSigData(t, e);
        break;
      case b.CUSTOM_CODE:
        this.writeCustomScriptData(t, e);
        break;
      case b.CANCEL:
        this.writeCancelData(t, e);
        break;
      default:
        throw new Error(`Unsupported transaction type: ${e.type}`);
    }
  }
  static readTypeSpecificData(t, e) {
    switch (e) {
      case b.FUNDING:
        return this.readFundingData(t);
      case b.DEPLOYMENT:
        return this.readDeploymentData(t);
      case b.INTERACTION:
        return this.readInteractionData(t);
      case b.MULTI_SIG:
        return this.readMultiSigData(t);
      case b.CUSTOM_CODE:
        return this.readCustomScriptData(t);
      case b.CANCEL:
        return this.readCancelData(t);
      default:
        throw new Error(`Unsupported transaction type: ${e}`);
    }
  }
  // Funding
  static writeFundingData(t, e) {
    t.writeU64(BigInt(e.amount)), t.writeU16(e.splitInputsInto);
  }
  static readFundingData(t) {
    return {
      type: b.FUNDING,
      amount: t.readU64().toString(),
      splitInputsInto: t.readU16()
    };
  }
  // Deployment
  static writeDeploymentData(t, e) {
    t.writeBytesWithLength(w(e.bytecode)), t.writeBoolean(e.calldata !== void 0), e.calldata !== void 0 && t.writeBytesWithLength(w(e.calldata)), this.writeChallenge(t, e.challenge), t.writeBoolean(e.revealMLDSAPublicKey ?? !1), t.writeBoolean(e.linkMLDSAPublicKeyToAddress ?? !1), t.writeBoolean(e.hashedPublicKey !== void 0), e.hashedPublicKey !== void 0 && t.writeBytesWithLength(w(e.hashedPublicKey));
  }
  static readDeploymentData(t) {
    const e = g(t.readBytesWithLength()), r = t.readBoolean() ? g(t.readBytesWithLength()) : void 0, s = this.readChallenge(t), o = t.readBoolean(), a = t.readBoolean(), u = t.readBoolean() ? g(t.readBytesWithLength()) : void 0;
    return {
      type: b.DEPLOYMENT,
      bytecode: e,
      challenge: s,
      revealMLDSAPublicKey: o,
      linkMLDSAPublicKeyToAddress: a,
      ...r !== void 0 ? { calldata: r } : {},
      ...u !== void 0 ? { hashedPublicKey: u } : {}
    };
  }
  // Interaction
  static writeInteractionData(t, e) {
    t.writeBytesWithLength(w(e.calldata)), t.writeBoolean(e.contract !== void 0), e.contract !== void 0 && t.writeStringWithLength(e.contract), this.writeChallenge(t, e.challenge), t.writeBoolean(e.loadedStorage !== void 0), e.loadedStorage !== void 0 && this.writeLoadedStorage(t, e.loadedStorage), t.writeBoolean(e.isCancellation ?? !1), t.writeBoolean(e.disableAutoRefund ?? !1), t.writeBoolean(e.revealMLDSAPublicKey ?? !1), t.writeBoolean(e.linkMLDSAPublicKeyToAddress ?? !1), t.writeBoolean(e.hashedPublicKey !== void 0), e.hashedPublicKey !== void 0 && t.writeBytesWithLength(w(e.hashedPublicKey));
  }
  static readInteractionData(t) {
    const e = g(t.readBytesWithLength()), r = t.readBoolean() ? t.readStringWithLength() : void 0, s = this.readChallenge(t), a = t.readBoolean() ? this.readLoadedStorage(t) : void 0, c = t.readBoolean(), u = t.readBoolean(), l = t.readBoolean(), h = t.readBoolean(), p = t.readBoolean() ? g(t.readBytesWithLength()) : void 0;
    return {
      type: b.INTERACTION,
      calldata: e,
      challenge: s,
      isCancellation: c,
      disableAutoRefund: u,
      revealMLDSAPublicKey: l,
      linkMLDSAPublicKeyToAddress: h,
      ...r !== void 0 ? { contract: r } : {},
      ...a !== void 0 ? { loadedStorage: a } : {},
      ...p !== void 0 ? { hashedPublicKey: p } : {}
    };
  }
  // MultiSig
  static writeMultiSigData(t, e) {
    t.writeU16(e.pubkeys.length);
    for (const i of e.pubkeys)
      t.writeBytesWithLength(w(i));
    t.writeU8(e.minimumSignatures), t.writeStringWithLength(e.receiver), t.writeU64(BigInt(e.requestedAmount)), t.writeStringWithLength(e.refundVault), t.writeU16(e.originalInputCount), t.writeBoolean(e.existingPsbtBase64 !== void 0), e.existingPsbtBase64 !== void 0 && t.writeStringWithLength(e.existingPsbtBase64);
  }
  static readMultiSigData(t) {
    const e = t.readU16(), i = [];
    for (let h = 0; h < e; h++)
      i.push(g(t.readBytesWithLength()));
    const r = t.readU8(), s = t.readStringWithLength(), o = t.readU64().toString(), a = t.readStringWithLength(), c = t.readU16(), l = t.readBoolean() ? t.readStringWithLength() : void 0;
    return {
      type: b.MULTI_SIG,
      pubkeys: i,
      minimumSignatures: r,
      receiver: s,
      requestedAmount: o,
      refundVault: a,
      originalInputCount: c,
      ...l !== void 0 ? { existingPsbtBase64: l } : {}
    };
  }
  // Custom Script
  static writeCustomScriptData(t, e) {
    t.writeU16(e.scriptElements.length);
    for (const i of e.scriptElements)
      this.writeScriptElement(t, i);
    t.writeU16(e.witnesses.length);
    for (const i of e.witnesses)
      t.writeBytesWithLength(w(i));
    t.writeBoolean(e.annex !== void 0), e.annex !== void 0 && t.writeBytesWithLength(w(e.annex));
  }
  static writeScriptElement(t, e) {
    t.writeU8(e.elementType === "buffer" ? 0 : 1), e.elementType === "buffer" ? t.writeBytesWithLength(w(e.value)) : t.writeU32(e.value);
  }
  static readCustomScriptData(t) {
    const e = t.readU16(), i = [];
    for (let c = 0; c < e; c++)
      i.push(this.readScriptElement(t));
    const r = t.readU16(), s = [];
    for (let c = 0; c < r; c++)
      s.push(g(t.readBytesWithLength()));
    const a = t.readBoolean() ? g(t.readBytesWithLength()) : void 0;
    return {
      type: b.CUSTOM_CODE,
      scriptElements: i,
      witnesses: s,
      ...a !== void 0 ? { annex: a } : {}
    };
  }
  static readScriptElement(t) {
    return t.readU8() === 0 ? {
      elementType: "buffer",
      value: g(t.readBytesWithLength())
    } : {
      elementType: "opcode",
      value: t.readU32()
    };
  }
  // Cancel
  static writeCancelData(t, e) {
    t.writeBytesWithLength(w(e.compiledTargetScript));
  }
  static readCancelData(t) {
    return {
      type: b.CANCEL,
      compiledTargetScript: g(t.readBytesWithLength())
    };
  }
  static writeChallenge(t, e) {
    t.writeU64(BigInt(e.epochNumber)), t.writeStringWithLength(e.mldsaPublicKey), t.writeStringWithLength(e.legacyPublicKey), t.writeBytesWithLength(w(G(e.solution))), t.writeBytesWithLength(w(G(e.salt))), t.writeBytesWithLength(w(G(e.graffiti))), t.writeU8(e.difficulty), this.writeChallengeVerification(t, e.verification), t.writeBoolean(e.submission !== void 0), e.submission !== void 0 && (t.writeStringWithLength(e.submission.mldsaPublicKey), t.writeStringWithLength(e.submission.legacyPublicKey), t.writeBytesWithLength(w(G(e.submission.solution))), t.writeBoolean(e.submission.graffiti !== void 0), e.submission.graffiti !== void 0 && t.writeBytesWithLength(
      w(G(e.submission.graffiti))
    ), t.writeBytesWithLength(w(G(e.submission.signature))));
  }
  static writeChallengeVerification(t, e) {
    t.writeBytesWithLength(w(G(e.epochHash))), t.writeBytesWithLength(w(G(e.epochRoot))), t.writeBytesWithLength(w(G(e.targetHash))), t.writeBytesWithLength(w(G(e.targetChecksum))), t.writeU64(BigInt(e.startBlock)), t.writeU64(BigInt(e.endBlock)), t.writeU16(e.proofs.length);
    for (const i of e.proofs)
      t.writeBytesWithLength(w(G(i)));
  }
  static readChallenge(t) {
    const e = t.readU64().toString(), i = t.readStringWithLength(), r = t.readStringWithLength(), s = "0x" + g(t.readBytesWithLength()), o = "0x" + g(t.readBytesWithLength()), a = "0x" + g(t.readBytesWithLength()), c = t.readU8(), u = this.readChallengeVerification(t), l = t.readBoolean();
    let h;
    if (l) {
      const d = t.readStringWithLength(), p = t.readStringWithLength(), y = "0x" + g(t.readBytesWithLength()), A = t.readBoolean() ? "0x" + g(t.readBytesWithLength()) : void 0, x = "0x" + g(t.readBytesWithLength());
      h = {
        mldsaPublicKey: d,
        legacyPublicKey: p,
        solution: y,
        signature: x,
        ...A !== void 0 ? { graffiti: A } : {}
      };
    }
    return {
      epochNumber: e,
      mldsaPublicKey: i,
      legacyPublicKey: r,
      solution: s,
      salt: o,
      graffiti: a,
      difficulty: c,
      verification: u,
      ...h !== void 0 ? { submission: h } : {}
    };
  }
  static readChallengeVerification(t) {
    const e = "0x" + g(t.readBytesWithLength()), i = "0x" + g(t.readBytesWithLength()), r = "0x" + g(t.readBytesWithLength()), s = "0x" + g(t.readBytesWithLength()), o = t.readU64().toString(), a = t.readU64().toString(), c = t.readU16(), u = [];
    for (let l = 0; l < c; l++)
      u.push("0x" + g(t.readBytesWithLength()));
    return {
      epochHash: e,
      epochRoot: i,
      targetHash: r,
      targetChecksum: s,
      startBlock: o,
      endBlock: a,
      proofs: u
    };
  }
  static writeLoadedStorage(t, e) {
    const i = Object.keys(e);
    t.writeU16(i.length);
    for (const r of i)
      t.writeStringWithLength(r), t.writeStringArray(e[r]);
  }
  static readLoadedStorage(t) {
    const e = t.readU16(), i = {};
    for (let r = 0; r < e; r++) {
      const s = t.readStringWithLength();
      i[s] = t.readStringArray();
    }
    return i;
  }
  static writePrecomputedData(t, e) {
    t.writeBoolean(e.compiledTargetScript !== void 0), e.compiledTargetScript !== void 0 && t.writeBytesWithLength(w(e.compiledTargetScript)), t.writeBoolean(e.randomBytes !== void 0), e.randomBytes !== void 0 && t.writeBytesWithLength(w(e.randomBytes)), t.writeBoolean(e.estimatedFees !== void 0), e.estimatedFees !== void 0 && t.writeU64(BigInt(e.estimatedFees)), t.writeBoolean(e.contractSeed !== void 0), e.contractSeed !== void 0 && t.writeStringWithLength(e.contractSeed), t.writeBoolean(e.contractAddress !== void 0), e.contractAddress !== void 0 && t.writeStringWithLength(e.contractAddress);
  }
  static readPrecomputedData(t) {
    const i = t.readBoolean() ? g(t.readBytesWithLength()) : void 0, s = t.readBoolean() ? g(t.readBytesWithLength()) : void 0, a = t.readBoolean() ? t.readU64().toString() : void 0, u = t.readBoolean() ? t.readStringWithLength() : void 0, h = t.readBoolean() ? t.readStringWithLength() : void 0;
    return {
      ...i !== void 0 ? { compiledTargetScript: i } : {},
      ...s !== void 0 ? { randomBytes: s } : {},
      ...a !== void 0 ? { estimatedFees: a } : {},
      ...u !== void 0 ? { contractSeed: u } : {},
      ...h !== void 0 ? { contractAddress: h } : {}
    };
  }
  /**
   * Calculate double SHA256 checksum (Bitcoin standard)
   */
  static calculateChecksum(t) {
    const e = ae("sha256").update(t).digest();
    return new Uint8Array(ae("sha256").update(e).digest());
  }
  /**
   * Compare two Uint8Arrays for equality
   */
  static bytesEqual(t, e) {
    if (t.length !== e.length) return !1;
    for (let i = 0; i < t.length; i++)
      if (t[i] !== e[i]) return !1;
    return !0;
  }
  /**
   * Encode Uint8Array to base64 string
   */
  static uint8ArrayToBase64(t) {
    let e = "";
    for (let i = 0; i < t.length; i++)
      e += String.fromCharCode(t[i]);
    return btoa(e);
  }
  /**
   * Decode base64 string to Uint8Array
   */
  static base64ToUint8Array(t) {
    const e = atob(t), i = new Uint8Array(e.length);
    for (let r = 0; r < e.length; r++)
      i[r] = e.charCodeAt(r);
    return i;
  }
  static networkNameToU8(t) {
    switch (t) {
      case "mainnet":
        return 0;
      case "testnet":
        return 1;
      case "regtest":
        return 2;
      case "opnetTestnet":
        return 3;
      default:
        throw new Error(`Unknown network: ${t}`);
    }
  }
  static u8ToNetworkName(t) {
    switch (t) {
      case 0:
        return "mainnet";
      case 1:
        return "testnet";
      case 2:
        return "regtest";
      case 3:
        return "opnetTestnet";
      default:
        throw new Error(`Unknown network value: ${t}`);
    }
  }
}
var Ft = /* @__PURE__ */ ((n) => (n[n.Roswell = 0] = "Roswell", n[n.Rachel = 1] = "Rachel", n[n.Kecksburg = 2] = "Kecksburg", n[n.Phoenix = 3] = "Phoenix", n[n.Aurora = 4] = "Aurora", n[n.Rendlesham = 5] = "Rendlesham", n[n.Lazar = 6] = "Lazar", n[n.ShagHarbor = 7] = "ShagHarbor", n[n.Exeter = 8] = "Exeter", n[n.Stephenville = 9] = "Stephenville", n[n.Valensole = 10] = "Valensole", n[n.Socorro = 11] = "Socorro", n[n.Pascagoula = 12] = "Pascagoula", n[n.Tehran = 13] = "Tehran", n[n.Westall = 14] = "Westall", n[n.Hopkinsville = 15] = "Hopkinsville", n[n.Belgium = 16] = "Belgium", n[n.Breeze = 17] = "Breeze", n[n.Flatwoods = 18] = "Flatwoods", n[n.Maury = 20] = "Maury", n[n.Varginha = 21] = "Varginha", n[n.Trindade = 22] = "Trindade", n[n.Levelland = 23] = "Levelland", n[n.Wanaque = 24] = "Wanaque", n[n.Coyame = 25] = "Coyame", n[n.Delphos = 26] = "Delphos", n))(Ft || {});
const fi = {
  CONSENSUS: Ft.Roswell,
  CONSENSUS_NAME: "Roswell",
  // The block height at which this consensus was enabled.
  ENABLED_AT_BLOCK: 0n
}, gi = {
  [Ft.Roswell]: fi
}, Oe = Ft.Roswell, Pr = gi[Oe];
class tt {
  /**
   * Capture state from a FundingTransaction
   */
  static fromFunding(t, e) {
    return this.captureState({
      params: t,
      type: b.FUNDING,
      ...e !== void 0 ? { precomputed: e } : {}
    });
  }
  /**
   * Capture state from a DeploymentTransaction
   */
  static fromDeployment(t, e) {
    return this.captureState({
      params: t,
      type: b.DEPLOYMENT,
      precomputed: e
    });
  }
  /**
   * Capture state from an InteractionTransaction
   */
  static fromInteraction(t, e) {
    return this.captureState({
      params: t,
      type: b.INTERACTION,
      precomputed: e
    });
  }
  /**
   * Capture state from a MultiSignTransaction
   */
  static fromMultiSig(t, e) {
    return this.captureState({
      params: t,
      type: b.MULTI_SIG,
      ...e !== void 0 ? { precomputed: e } : {}
    });
  }
  /**
   * Capture state from a CustomScriptTransaction
   */
  static fromCustomScript(t, e) {
    return this.captureState({
      params: t,
      type: b.CUSTOM_CODE,
      ...e !== void 0 ? { precomputed: e } : {}
    });
  }
  /**
   * Capture state from a CancelTransaction
   */
  static fromCancel(t, e) {
    return this.captureState({
      params: t,
      type: b.CANCEL,
      ...e !== void 0 ? { precomputed: e } : {}
    });
  }
  /**
   * Main state capture method
   */
  static captureState(t) {
    const { params: e, type: i, precomputed: r } = t;
    return {
      header: this.createHeader(i, e.network, e.chainId),
      baseParams: this.extractBaseParams(e),
      utxos: this.serializeUTXOs(e.utxos),
      optionalInputs: this.serializeUTXOs(e.optionalInputs || []),
      optionalOutputs: this.serializeOutputs(e.optionalOutputs || []),
      addressRotationEnabled: e.addressRotation?.enabled ?? !1,
      signerMappings: this.extractSignerMappings(e),
      typeSpecificData: this.extractTypeSpecificData(i, e),
      precomputedData: this.buildPrecomputedData(r)
    };
  }
  /**
   * Create serialization header
   */
  static createHeader(t, e, i) {
    return {
      formatVersion: ve,
      consensusVersion: Oe,
      transactionType: t,
      chainId: i ?? this.networkToChainId(e),
      timestamp: Date.now()
    };
  }
  /**
   * Extract base parameters common to all transaction types
   */
  static extractBaseParams(t) {
    const e = t.note ? t.note instanceof Uint8Array ? g(t.note) : g(new TextEncoder().encode(t.note)) : void 0, i = t.priorityFee ?? 0n, r = t.gasSatFee ?? 0n;
    return {
      from: t.from || "",
      feeRate: t.feeRate,
      priorityFee: i.toString(),
      gasSatFee: r.toString(),
      networkName: this.networkToName(t.network),
      txVersion: t.txVersion ?? 2,
      anchor: t.anchor ?? !1,
      ...t.to !== void 0 ? { to: t.to } : {},
      ...e !== void 0 ? { note: e } : {},
      ...t.debugFees !== void 0 ? { debugFees: t.debugFees } : {}
    };
  }
  /**
   * Extract signer mappings for address rotation mode
   */
  static extractSignerMappings(t) {
    if (!t.addressRotation?.enabled)
      return [];
    const e = [], i = /* @__PURE__ */ new Map();
    t.utxos.forEach((s, o) => {
      const a = s.scriptPubKey?.address;
      if (a) {
        const c = i.get(a);
        c ? c.push(o) : i.set(a, [o]);
      }
    });
    const r = t.utxos.length;
    return (t.optionalInputs || []).forEach((s, o) => {
      const a = s.scriptPubKey?.address;
      if (a) {
        const c = i.get(a);
        c ? c.push(r + o) : i.set(a, [r + o]);
      }
    }), i.forEach((s, o) => {
      e.push({ address: o, inputIndices: s });
    }), e;
  }
  /**
   * Extract type-specific data based on transaction type
   */
  static extractTypeSpecificData(t, e) {
    switch (t) {
      case b.FUNDING:
        return this.extractFundingData(e);
      case b.DEPLOYMENT:
        return this.extractDeploymentData(e);
      case b.INTERACTION:
        return this.extractInteractionData(e);
      case b.MULTI_SIG:
        return this.extractMultiSigData(e);
      case b.CUSTOM_CODE:
        return this.extractCustomScriptData(e);
      case b.CANCEL:
        return this.extractCancelData(e);
      default:
        throw new Error(`Unsupported transaction type: ${t}`);
    }
  }
  static extractFundingData(t) {
    return {
      type: b.FUNDING,
      amount: t.amount.toString(),
      splitInputsInto: t.splitInputsInto ?? 1
    };
  }
  static extractDeploymentData(t) {
    return {
      type: b.DEPLOYMENT,
      bytecode: g(t.bytecode),
      challenge: t.challenge.toRaw(),
      ...t.calldata ? { calldata: g(t.calldata) } : {},
      ...t.revealMLDSAPublicKey !== void 0 ? { revealMLDSAPublicKey: t.revealMLDSAPublicKey } : {},
      ...t.linkMLDSAPublicKeyToAddress !== void 0 ? { linkMLDSAPublicKeyToAddress: t.linkMLDSAPublicKeyToAddress } : {}
    };
  }
  static extractInteractionData(t) {
    return {
      type: b.INTERACTION,
      calldata: g(t.calldata),
      challenge: t.challenge.toRaw(),
      ...t.contract !== void 0 ? { contract: t.contract } : {},
      ...t.loadedStorage !== void 0 ? { loadedStorage: t.loadedStorage } : {},
      ...t.isCancellation !== void 0 ? { isCancellation: t.isCancellation } : {},
      ...t.disableAutoRefund !== void 0 ? { disableAutoRefund: t.disableAutoRefund } : {},
      ...t.revealMLDSAPublicKey !== void 0 ? { revealMLDSAPublicKey: t.revealMLDSAPublicKey } : {},
      ...t.linkMLDSAPublicKeyToAddress !== void 0 ? { linkMLDSAPublicKeyToAddress: t.linkMLDSAPublicKeyToAddress } : {}
    };
  }
  static extractMultiSigData(t) {
    return {
      type: b.MULTI_SIG,
      pubkeys: (t.pubkeys || []).map((e) => g(e)),
      minimumSignatures: t.minimumSignatures || 0,
      receiver: t.receiver || "",
      requestedAmount: (t.requestedAmount || 0n).toString(),
      refundVault: t.refundVault || "",
      originalInputCount: t.originalInputCount || t.utxos.length,
      ...t.existingPsbtBase64 !== void 0 ? { existingPsbtBase64: t.existingPsbtBase64 } : {}
    };
  }
  static extractCustomScriptData(t) {
    const e = (t.scriptElements || []).map(
      (i) => i instanceof Uint8Array ? {
        elementType: "buffer",
        value: g(i)
      } : {
        elementType: "opcode",
        value: i
      }
    );
    return {
      type: b.CUSTOM_CODE,
      scriptElements: e,
      witnesses: (t.witnesses || []).map((i) => g(i)),
      ...t.annex ? { annex: g(t.annex) } : {}
    };
  }
  static extractCancelData(t) {
    const e = t.compiledTargetScript, i = e ? e instanceof Uint8Array ? g(e) : e : "";
    return {
      type: b.CANCEL,
      compiledTargetScript: i
    };
  }
  /**
   * Build precomputed data object
   */
  static buildPrecomputedData(t) {
    return {
      ...t?.compiledTargetScript !== void 0 ? { compiledTargetScript: t.compiledTargetScript } : {},
      ...t?.randomBytes !== void 0 ? { randomBytes: t.randomBytes } : {},
      ...t?.estimatedFees !== void 0 ? { estimatedFees: t.estimatedFees } : {},
      ...t?.contractSeed !== void 0 ? { contractSeed: t.contractSeed } : {},
      ...t?.contractAddress !== void 0 ? { contractAddress: t.contractAddress } : {}
    };
  }
  /**
   * Serialize UTXOs array
   */
  static serializeUTXOs(t) {
    return t.map((e) => {
      const i = e.redeemScript ? e.redeemScript instanceof Uint8Array ? g(e.redeemScript) : e.redeemScript : void 0, r = e.witnessScript ? e.witnessScript instanceof Uint8Array ? g(e.witnessScript) : e.witnessScript : void 0, s = e.nonWitnessUtxo ? e.nonWitnessUtxo instanceof Uint8Array ? g(e.nonWitnessUtxo) : e.nonWitnessUtxo : void 0;
      return {
        transactionId: e.transactionId,
        outputIndex: e.outputIndex,
        value: e.value.toString(),
        scriptPubKeyHex: e.scriptPubKey.hex,
        ...e.scriptPubKey.address !== void 0 ? { scriptPubKeyAddress: e.scriptPubKey.address } : {},
        ...i !== void 0 ? { redeemScript: i } : {},
        ...r !== void 0 ? { witnessScript: r } : {},
        ...s !== void 0 ? { nonWitnessUtxo: s } : {}
      };
    });
  }
  /**
   * Serialize outputs array
   */
  static serializeOutputs(t) {
    return t.map((e) => {
      const i = "address" in e ? e.address : void 0, r = "script" in e ? e.script : void 0, s = r ? g(r) : void 0, o = e.tapInternalKey ? g(e.tapInternalKey) : void 0;
      return {
        value: Number(e.value),
        ...i !== void 0 ? { address: i } : {},
        ...s !== void 0 ? { script: s } : {},
        ...o !== void 0 ? { tapInternalKey: o } : {}
      };
    });
  }
  /**
   * Convert network to name string
   */
  static networkToName(t) {
    return t.bech32 === "bc" ? "mainnet" : t.bech32 === "tb" ? "testnet" : t.bech32 === "opt" ? "opnetTestnet" : "regtest";
  }
  /**
   * Convert network to chain ID
   */
  static networkToChainId(t) {
    return me.Bitcoin;
  }
}
function M(n) {
  return w(n.startsWith("0x") ? n.slice(2) : n);
}
class St {
  static BLOCKS_PER_EPOCH = 5n;
  /**
   * Calculate SHA-1 hash
   */
  static sha1(t) {
    return F.sha1(t);
  }
  /**
   * Calculate mining preimage
   */
  static calculatePreimage(t, e, i) {
    if (t.length !== 32 || e.length !== 32 || i.length !== 32)
      throw new Error("All inputs must be 32 bytes");
    const r = new Uint8Array(32);
    for (let s = 0; s < 32; s++)
      r[s] = t[s] ^ e[s] ^ i[s];
    return r;
  }
  /**
   * Count matching bits between two hashes
   */
  static countMatchingBits(t, e) {
    let i = 0;
    if (t.length !== e.length)
      throw new Error("Hashes must be of the same length");
    const r = Math.min(t.length, e.length);
    for (let s = 0; s < r; s++) {
      const o = t[s], a = e[s];
      if (o === a)
        i += 8;
      else
        for (let c = 7; c >= 0; c--)
          if ((o >> c & 1) === (a >> c & 1))
            i++;
          else
            return i;
    }
    return i;
  }
  /**
   * Verify an epoch solution using IPreimage
   */
  static verifySolution(t, e = !1) {
    try {
      const i = t.verification, r = this.calculatePreimage(
        i.targetChecksum,
        t.publicKey.toBuffer(),
        t.salt
      ), s = this.sha1(r);
      if (!C(s, t.solution) || this.countMatchingBits(s, i.targetHash) !== t.difficulty)
        return !1;
      const a = t.epochNumber * this.BLOCKS_PER_EPOCH, c = a + this.BLOCKS_PER_EPOCH - 1n;
      return !(i.startBlock !== a || i.endBlock !== c);
    } catch (i) {
      return e && console.error("Verification error:", i), !1;
    }
  }
  /**
   * Get the mining target block for an epoch
   */
  static getMiningTargetBlock(t) {
    return t === 0n ? null : t * this.BLOCKS_PER_EPOCH - 1n;
  }
  /**
   * Validate epoch winner from raw data
   */
  static validateEpochWinner(t) {
    try {
      const e = BigInt(t.epochNumber), i = K.fromString(
        t.mldsaPublicKey,
        t.legacyPublicKey
      ), r = M(t.solution), s = M(t.salt), o = t.difficulty, a = {
        epochHash: M(t.verification.epochHash),
        epochRoot: M(t.verification.epochRoot),
        targetHash: M(t.verification.targetHash),
        targetChecksum: M(t.verification.targetChecksum),
        startBlock: BigInt(t.verification.startBlock),
        endBlock: BigInt(t.verification.endBlock),
        proofs: Object.freeze(t.verification.proofs.map((p) => M(p)))
      }, c = this.calculatePreimage(
        a.targetChecksum,
        i.toBuffer(),
        s
      ), u = this.sha1(c);
      if (!C(u, r) || this.countMatchingBits(u, a.targetHash) !== o)
        return !1;
      const h = e * this.BLOCKS_PER_EPOCH, d = h + this.BLOCKS_PER_EPOCH - 1n;
      return !(a.startBlock !== h || a.endBlock !== d);
    } catch {
      return !1;
    }
  }
  /**
   * Validate epoch winner from Preimage instance
   */
  static validateChallengeSolution(t) {
    return this.verifySolution(t);
  }
  /**
   * Calculate solution hash from preimage components
   * @param targetChecksum The target checksum (32 bytes)
   * @param publicKey The public key buffer (32 bytes)
   * @param salt The salt buffer (32 bytes)
   * @returns The SHA-1 hash of the preimage
   */
  static calculateSolution(t, e, i) {
    const r = this.calculatePreimage(t, e, i);
    return this.sha1(r);
  }
  /**
   * Check if a solution meets the minimum difficulty requirement
   */
  static checkDifficulty(t, e, i) {
    const r = this.countMatchingBits(t, e);
    return {
      valid: r >= i,
      difficulty: r
    };
  }
}
class Si {
  epochHash;
  epochRoot;
  targetHash;
  targetChecksum;
  startBlock;
  endBlock;
  proofs;
  constructor(t) {
    this.epochHash = M(t.epochHash), this.epochRoot = M(t.epochRoot), this.targetHash = M(t.targetHash), this.targetChecksum = M(t.targetChecksum), this.startBlock = BigInt(t.startBlock), this.endBlock = BigInt(t.endBlock), this.proofs = Object.freeze(t.proofs.map((e) => M(e)));
  }
}
class wi {
  constructor(t, e) {
    this.epochNumber = e, this.publicKey = K.fromString(t.mldsaPublicKey, t.legacyPublicKey), this.solution = M(t.solution), this.graffiti = t.graffiti ? M(t.graffiti) : void 0, this.signature = M(t.signature);
  }
  publicKey;
  solution;
  graffiti;
  signature;
  verifySignature() {
    const t = new V();
    t.writeAddress(this.publicKey), t.writeU64(this.epochNumber), t.writeBytes(this.solution), this.graffiti && t.writeBytes(this.graffiti);
    const e = t.getBuffer();
    return ct.verifySignature(
      this.publicKey.tweakedPublicKeyToBuffer(),
      e,
      this.signature
    );
  }
}
class de {
  epochNumber;
  publicKey;
  solution;
  salt;
  graffiti;
  difficulty;
  verification;
  submission;
  constructor(t) {
    this.epochNumber = BigInt(t.epochNumber), this.publicKey = K.fromString(t.mldsaPublicKey, t.legacyPublicKey), this.solution = M(t.solution), this.salt = M(t.salt), this.graffiti = M(t.graffiti), this.difficulty = t.difficulty, this.verification = new Si(t.verification), this.submission = t.submission ? new wi(t.submission, this.epochNumber + 2n) : t.submission;
  }
  /**
   * Static method to validate from raw data directly
   */
  static validateRaw(t) {
    return St.validateEpochWinner(t);
  }
  verifySubmissionSignature() {
    if (!this.submission)
      throw new Error("No submission provided in request.");
    return this.submission.verifySignature();
  }
  getSubmission() {
    if (this.submission) {
      if (!this.verifySubmissionSignature())
        throw new Error("Invalid submission signature.");
      return this.submission;
    }
  }
  /**
   * Verify this challenge
   * @returns {boolean} True if the challenge is valid
   */
  verify() {
    return St.validateChallengeSolution(this);
  }
  /**
   * Get the preimage challenge
   * @returns {Uint8Array} The solution/challenge as a Uint8Array
   */
  toBuffer() {
    return this.solution;
  }
  /**
   * Get the solution as a hex string
   * @returns {string} The solution as a hex string with 0x prefix
   */
  toHex() {
    return "0x" + g(this.solution);
  }
  /**
   * Convert to raw format for serialization
   */
  toRaw() {
    return {
      epochNumber: this.epochNumber.toString(),
      mldsaPublicKey: this.publicKey.toHex(),
      legacyPublicKey: this.publicKey.tweakedToHex(),
      solution: this.toHex(),
      salt: "0x" + g(this.salt),
      graffiti: "0x" + g(this.graffiti),
      difficulty: this.difficulty,
      verification: {
        epochHash: "0x" + g(this.verification.epochHash),
        epochRoot: "0x" + g(this.verification.epochRoot),
        targetHash: "0x" + g(this.verification.targetHash),
        targetChecksum: "0x" + g(this.verification.targetChecksum),
        startBlock: this.verification.startBlock.toString(),
        endBlock: this.verification.endBlock.toString(),
        proofs: this.verification.proofs.map((t) => "0x" + g(t))
      }
    };
  }
  /**
   * Calculate the expected solution hash for this challenge
   * @returns {Uint8Array} The calculated solution hash
   */
  calculateSolution() {
    return St.calculateSolution(
      this.verification.targetChecksum,
      this.publicKey.toBuffer(),
      this.salt
    );
  }
  /**
   * Check if the challenge meets a specific difficulty requirement
   * @param {number} minDifficulty The minimum difficulty required
   * @returns {Promise<{valid: boolean; difficulty: number}>} Validation result
   */
  checkDifficulty(t) {
    return St.checkDifficulty(
      this.solution,
      this.verification.targetHash,
      t
    );
  }
  /**
   * Get the mining target block for this epoch
   * @returns {bigint | null} The target block number or null if epoch 0
   */
  getMiningTargetBlock() {
    return St.getMiningTargetBlock(this.epochNumber);
  }
}
class wt {
  /**
   * Reconstruct and optionally rebuild transaction with new parameters
   * @param state - Serialized transaction state
   * @param options - Signer(s) and optional fee overrides
   * @returns Reconstructed transaction builder ready for signing
   */
  static reconstruct(t, e) {
    const i = this.nameToNetwork(t.baseParams.networkName), r = this.deserializeUTXOs(t.utxos), s = this.deserializeUTXOs(t.optionalInputs), o = this.deserializeOutputs(t.optionalOutputs), a = this.buildAddressRotationConfig(
      t.addressRotationEnabled,
      e.signerMap
    ), c = e.newFeeRate ?? t.baseParams.feeRate, u = e.newPriorityFee ?? BigInt(t.baseParams.priorityFee), l = e.newGasSatFee ?? BigInt(t.baseParams.gasSatFee), h = {
      signer: e.signer,
      mldsaSigner: e.mldsaSigner ?? null,
      network: i,
      utxos: r,
      optionalInputs: s,
      optionalOutputs: o,
      from: t.baseParams.from,
      feeRate: c,
      priorityFee: u,
      gasSatFee: l,
      anchor: t.baseParams.anchor,
      ...t.header.chainId !== void 0 ? { chainId: t.header.chainId } : {},
      ...t.baseParams.to !== void 0 ? { to: t.baseParams.to } : {},
      ...t.baseParams.txVersion !== void 0 ? { txVersion: t.baseParams.txVersion } : {},
      ...t.baseParams.note !== void 0 ? { note: w(t.baseParams.note) } : {},
      ...t.baseParams.debugFees !== void 0 ? { debugFees: t.baseParams.debugFees } : {},
      ...a !== void 0 ? { addressRotation: a } : {},
      ...t.precomputedData.estimatedFees !== void 0 ? { estimatedFees: BigInt(t.precomputedData.estimatedFees) } : {},
      ...t.precomputedData.compiledTargetScript !== void 0 ? { compiledTargetScript: w(t.precomputedData.compiledTargetScript) } : {}
    }, d = t.typeSpecificData;
    if (ui(d))
      return this.reconstructFunding(h, d);
    if (li(d))
      return this.reconstructDeployment(h, d, t);
    if (hi(d))
      return this.reconstructInteraction(h, d, t);
    if (ot(d))
      return this.reconstructMultiSig(h, d);
    if (di(d))
      return this.reconstructCustomScript(h, d, t);
    if (pi(d))
      return this.reconstructCancel(h, d);
    throw new Error(`Unsupported transaction type: ${t.header.transactionType}`);
  }
  /**
   * Reconstruct a FundingTransaction
   */
  static reconstructFunding(t, e) {
    const i = {
      ...t,
      amount: BigInt(e.amount),
      splitInputsInto: e.splitInputsInto
    };
    return new Qt(i);
  }
  /**
   * Reconstruct a DeploymentTransaction
   */
  static reconstructDeployment(t, e, i) {
    const r = new de(e.challenge), s = {
      ...t,
      bytecode: w(e.bytecode),
      challenge: r,
      ...e.calldata !== void 0 ? { calldata: w(e.calldata) } : {},
      ...i.precomputedData.randomBytes !== void 0 ? { randomBytes: w(i.precomputedData.randomBytes) } : {},
      ...e.revealMLDSAPublicKey !== void 0 ? { revealMLDSAPublicKey: e.revealMLDSAPublicKey } : {},
      ...e.linkMLDSAPublicKeyToAddress !== void 0 ? { linkMLDSAPublicKeyToAddress: e.linkMLDSAPublicKeyToAddress } : {}
    };
    return new Et(s);
  }
  /**
   * Reconstruct an InteractionTransaction
   */
  static reconstructInteraction(t, e, i) {
    const r = new de(e.challenge);
    if (!t.to)
      throw new Error('InteractionTransaction requires a "to" address');
    const s = {
      ...t,
      to: t.to,
      calldata: w(e.calldata),
      challenge: r,
      ...e.contract !== void 0 ? { contract: e.contract } : {},
      ...i.precomputedData.randomBytes !== void 0 ? { randomBytes: w(i.precomputedData.randomBytes) } : {},
      ...e.loadedStorage !== void 0 ? { loadedStorage: e.loadedStorage } : {},
      ...e.isCancellation !== void 0 ? { isCancellation: e.isCancellation } : {},
      ...e.disableAutoRefund !== void 0 ? { disableAutoRefund: e.disableAutoRefund } : {},
      ...e.revealMLDSAPublicKey !== void 0 ? { revealMLDSAPublicKey: e.revealMLDSAPublicKey } : {},
      ...e.linkMLDSAPublicKeyToAddress !== void 0 ? { linkMLDSAPublicKeyToAddress: e.linkMLDSAPublicKeyToAddress } : {}
    };
    return new jt(s);
  }
  /**
   * Reconstruct a MultiSignTransaction
   */
  static reconstructMultiSig(t, e) {
    const i = e.pubkeys.map((s) => w(s));
    if (e.existingPsbtBase64)
      return R.fromBase64({
        mldsaSigner: t.mldsaSigner,
        network: t.network,
        utxos: t.utxos,
        feeRate: t.feeRate,
        pubkeys: i,
        minimumSignatures: e.minimumSignatures,
        receiver: e.receiver,
        requestedAmount: BigInt(e.requestedAmount),
        refundVault: e.refundVault,
        psbt: e.existingPsbtBase64,
        ...t.chainId !== void 0 ? { chainId: t.chainId } : {},
        ...t.optionalInputs !== void 0 ? { optionalInputs: t.optionalInputs } : {},
        ...t.optionalOutputs !== void 0 ? { optionalOutputs: t.optionalOutputs } : {}
      });
    const r = {
      mldsaSigner: t.mldsaSigner,
      network: t.network,
      utxos: t.utxos,
      feeRate: t.feeRate,
      pubkeys: i,
      minimumSignatures: e.minimumSignatures,
      receiver: e.receiver,
      requestedAmount: BigInt(e.requestedAmount),
      refundVault: e.refundVault,
      ...t.chainId !== void 0 ? { chainId: t.chainId } : {},
      ...t.optionalInputs !== void 0 ? { optionalInputs: t.optionalInputs } : {},
      ...t.optionalOutputs !== void 0 ? { optionalOutputs: t.optionalOutputs } : {}
    };
    return new R(r);
  }
  /**
   * Reconstruct a CustomScriptTransaction
   */
  static reconstructCustomScript(t, e, i) {
    const r = e.scriptElements.map((a) => a.elementType === "buffer" ? w(a.value) : [a.value]), s = e.witnesses.map((a) => w(a));
    if (!t.to)
      throw new Error('CustomScriptTransaction requires a "to" address');
    const o = {
      ...t,
      to: t.to,
      script: r,
      witnesses: s,
      ...e.annex !== void 0 ? { annex: w(e.annex) } : {},
      ...i.precomputedData.randomBytes !== void 0 ? { randomBytes: w(i.precomputedData.randomBytes) } : {}
    };
    return new Gt(o);
  }
  /**
   * Reconstruct a CancelTransaction
   */
  static reconstructCancel(t, e) {
    const i = {
      ...t,
      compiledTargetScript: w(e.compiledTargetScript)
    };
    return new Pe(i);
  }
  /**
   * Build address rotation config from options
   */
  static buildAddressRotationConfig(t, e) {
    if (t) {
      if (!e || e.size === 0)
        throw new Error(
          "Address rotation enabled but no signerMap provided in reconstruction options"
        );
      return {
        enabled: !0,
        signerMap: e
      };
    }
  }
  /**
   * Deserialize UTXOs from serialized format
   */
  static deserializeUTXOs(t) {
    return t.map((e) => {
      const i = {
        transactionId: e.transactionId,
        outputIndex: e.outputIndex,
        value: BigInt(e.value),
        scriptPubKey: {
          hex: e.scriptPubKeyHex,
          ...e.scriptPubKeyAddress !== void 0 ? { address: e.scriptPubKeyAddress } : {}
        }
      };
      return e.redeemScript !== void 0 && (i.redeemScript = w(e.redeemScript)), e.witnessScript !== void 0 && (i.witnessScript = w(e.witnessScript)), e.nonWitnessUtxo !== void 0 && (i.nonWitnessUtxo = w(e.nonWitnessUtxo)), i;
    });
  }
  /**
   * Deserialize outputs from serialized format
   */
  static deserializeOutputs(t) {
    return t.map((e) => {
      const i = { value: L(BigInt(e.value)) }, r = e.tapInternalKey !== void 0 ? { tapInternalKey: w(e.tapInternalKey) } : {};
      return e.address ? { ...i, address: e.address, ...r } : e.script ? { ...i, script: w(e.script), ...r } : { ...i, address: "", ...r };
    });
  }
  /**
   * Convert network name to Network object
   */
  static nameToNetwork(t) {
    switch (t) {
      case "mainnet":
        return T.bitcoin;
      case "testnet":
        return T.testnet;
      case "opnetTestnet":
        return T.opnetTestnet;
      case "regtest":
        return T.regtest;
      default:
        throw new Error(`Unknown network: ${t}`);
    }
  }
}
class vr {
  /**
   * Export a FundingTransaction for offline signing
   * @param params - Funding transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportFunding(t, e) {
    const i = tt.fromFunding(t, e);
    return k.toBase64(i);
  }
  /**
   * Export a DeploymentTransaction for offline signing
   * @param params - Deployment transaction parameters
   * @param precomputed - Required precomputed data (randomBytes, compiledTargetScript)
   * @returns Base64-encoded serialized state
   */
  static exportDeployment(t, e) {
    const i = tt.fromDeployment(t, e);
    return k.toBase64(i);
  }
  /**
   * Export an InteractionTransaction for offline signing
   * @param params - Interaction transaction parameters
   * @param precomputed - Required precomputed data (randomBytes, compiledTargetScript)
   * @returns Base64-encoded serialized state
   */
  static exportInteraction(t, e) {
    const i = tt.fromInteraction(t, e);
    return k.toBase64(i);
  }
  /**
   * Export a MultiSignTransaction for offline signing
   * @param params - MultiSig transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportMultiSig(t, e) {
    const i = tt.fromMultiSig(t, e);
    return k.toBase64(i);
  }
  /**
   * Export a CustomScriptTransaction for offline signing
   * @param params - Custom script transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportCustomScript(t, e) {
    const i = tt.fromCustomScript(t, e);
    return k.toBase64(i);
  }
  /**
   * Export a CancelTransaction for offline signing
   * @param params - Cancel transaction parameters
   * @param precomputed - Optional precomputed data
   * @returns Base64-encoded serialized state
   */
  static exportCancel(t, e) {
    const i = tt.fromCancel(t, e);
    return k.toBase64(i);
  }
  /**
   * Export transaction state from a builder instance.
   * The builder must have been built but not yet signed.
   * @param builder - Transaction builder instance
   * @param params - Original construction parameters
   * @param precomputed - Precomputed data from the builder
   * @returns Base64-encoded serialized state
   */
  static exportFromBuilder(t, e, i) {
    const r = t.type;
    let s;
    switch (r) {
      case b.FUNDING:
        s = tt.fromFunding(
          e,
          i
        );
        break;
      case b.DEPLOYMENT:
        s = tt.fromDeployment(
          e,
          i
        );
        break;
      case b.INTERACTION:
        s = tt.fromInteraction(
          e,
          i
        );
        break;
      default:
        throw new Error(`Unsupported transaction type for export: ${r}`);
    }
    return k.toBase64(s);
  }
  /**
   * Import and reconstruct transaction for signing
   * @param serializedState - Base64-encoded state from Phase 1
   * @param options - Signer(s) and optional fee overrides
   * @returns Reconstructed transaction builder ready for signing
   */
  static importForSigning(t, e) {
    const i = k.fromBase64(t);
    return wt.reconstruct(i, e);
  }
  /**
   * Complete signing and export signed transaction
   * @param builder - Reconstructed builder from importForSigning
   * @returns Signed transaction hex ready for broadcast
   */
  static async signAndExport(t) {
    return (await t.signTransaction()).toHex();
  }
  /**
   * Convenience: Full Phase 2 in one call - import, sign, and export
   * @param serializedState - Base64-encoded state
   * @param options - Signer(s) and optional fee overrides
   * @returns Signed transaction hex ready for broadcast
   */
  static async importSignAndExport(t, e) {
    const i = this.importForSigning(t, e);
    return this.signAndExport(i);
  }
  /**
   * Rebuild transaction with new fee rate (fee bumping)
   * @param serializedState - Original state
   * @param newFeeRate - New fee rate in sat/vB
   * @returns New serialized state with updated fees (not signed yet)
   */
  static rebuildWithNewFees(t, e) {
    const i = k.fromBase64(t), r = {
      ...i,
      baseParams: {
        ...i.baseParams,
        feeRate: e
      }
    };
    return k.toBase64(r);
  }
  /**
   * Rebuild and immediately sign with new fee rate
   * @param serializedState - Original state
   * @param newFeeRate - New fee rate in sat/vB
   * @param options - Signer options
   * @returns Signed transaction hex with new fees
   */
  static async rebuildSignAndExport(t, e, i) {
    const r = this.importForSigning(t, {
      ...i,
      newFeeRate: e
    });
    return this.signAndExport(r);
  }
  /**
   * Inspect serialized state without signing
   * @param serializedState - Base64-encoded state
   * @returns Parsed state object for inspection
   */
  static inspect(t) {
    return k.fromBase64(t);
  }
  /**
   * Validate serialized state integrity
   * @param serializedState - Base64-encoded state
   * @returns True if checksum and format are valid
   */
  static validate(t) {
    try {
      return k.fromBase64(t), !0;
    } catch {
      return !1;
    }
  }
  /**
   * Get transaction type from serialized state
   * @param serializedState - Base64-encoded state
   * @returns Transaction type enum value
   */
  static getType(t) {
    return k.fromBase64(t).header.transactionType;
  }
  /**
   * Parse base64-encoded state into state object
   * @param base64State - Base64-encoded state
   * @returns Parsed state object
   */
  static fromBase64(t) {
    return k.fromBase64(t);
  }
  /**
   * Serialize state object to base64
   * @param state - State object to serialize
   * @returns Base64-encoded state
   */
  static toBase64(t) {
    return k.toBase64(t);
  }
  /**
   * Convert serialized state to hex format
   * @param serializedState - Base64-encoded state
   * @returns Hex-encoded state
   */
  static toHex(t) {
    const e = k.fromBase64(t);
    return k.toHex(e);
  }
  /**
   * Convert hex format back to base64
   * @param hexState - Hex-encoded state
   * @returns Base64-encoded state
   */
  static fromHex(t) {
    const e = k.fromHex(t);
    return k.toBase64(e);
  }
  /**
   * Add a partial signature to a multisig transaction state.
   * This method signs the transaction with the provided signer and returns
   * updated state with the new signature included.
   *
   * @param serializedState - Base64-encoded multisig state
   * @param signer - The signer to add a signature with
   * @returns Updated state with new signature, and signing result
   */
  static async multiSigAddSignature(t, e) {
    const i = k.fromBase64(t);
    if (!ot(i.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const r = i.typeSpecificData, s = r.pubkeys.map((p) => w(p));
    let o;
    const a = wt.nameToNetwork(i.baseParams.networkName);
    r.existingPsbtBase64 ? o = X.fromBase64(r.existingPsbtBase64, { network: a }) : o = await this.importForSigning(t, {
      signer: e
    }).signPSBT();
    const c = [];
    for (let p = r.originalInputCount; p < o.data.inputs.length; p++)
      c.push(r.minimumSignatures);
    const u = R.signPartial(
      o,
      e,
      r.originalInputCount,
      c
    ), l = [];
    for (let p = r.originalInputCount; p < o.data.inputs.length; p++)
      l.push(s);
    R.attemptFinalizeInputs(
      o,
      r.originalInputCount,
      l,
      u.final
    );
    const h = o.toBase64(), d = {
      ...i,
      typeSpecificData: {
        ...r,
        existingPsbtBase64: h
      }
    };
    return {
      state: k.toBase64(d),
      signed: u.signed,
      final: u.final,
      psbtBase64: h
    };
  }
  /**
   * Check if a public key has already signed a multisig transaction
   *
   * @param serializedState - Base64-encoded multisig state
   * @param signerPubKey - Public key to check (Uint8Array or hex string)
   * @returns True if the public key has already signed
   */
  static multiSigHasSigned(t, e) {
    const i = k.fromBase64(t);
    if (!ot(i.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const r = i.typeSpecificData;
    if (!r.existingPsbtBase64)
      return !1;
    const s = wt.nameToNetwork(i.baseParams.networkName), o = X.fromBase64(r.existingPsbtBase64, { network: s }), a = e instanceof Uint8Array ? e : w(e);
    return R.verifyIfSigned(o, a);
  }
  /**
   * Get the current signature count for a multisig transaction
   *
   * @param serializedState - Base64-encoded multisig state
   * @returns Object with signature count info
   */
  static multiSigGetSignatureStatus(t) {
    const e = k.fromBase64(t);
    if (!ot(e.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const i = e.typeSpecificData, r = i.minimumSignatures;
    if (!i.existingPsbtBase64)
      return {
        required: r,
        collected: 0,
        isComplete: !1,
        signers: []
      };
    const s = wt.nameToNetwork(e.baseParams.networkName), o = X.fromBase64(i.existingPsbtBase64, { network: s }), a = /* @__PURE__ */ new Set();
    for (let u = i.originalInputCount; u < o.data.inputs.length; u++) {
      const l = o.data.inputs[u];
      if (l.tapScriptSig)
        for (const h of l.tapScriptSig)
          a.add(g(h.pubkey));
      if (l.finalScriptWitness) {
        const h = E.readScriptWitnessToWitnessStack(
          l.finalScriptWitness
        );
        for (let d = 0; d < h.length - 2; d += 3) {
          const p = h[d + 2];
          a.add(g(p));
        }
      }
    }
    const c = Array.from(a);
    return {
      required: r,
      collected: c.length,
      isComplete: c.length >= r,
      signers: c
    };
  }
  /**
   * Finalize a multisig transaction and extract the signed transaction hex.
   * Only call this when all required signatures have been collected.
   *
   * @param serializedState - Base64-encoded multisig state with all signatures
   * @returns Signed transaction hex ready for broadcast
   */
  static multiSigFinalize(t) {
    const e = k.fromBase64(t);
    if (!ot(e.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const i = e.typeSpecificData;
    if (!i.existingPsbtBase64)
      throw new Error("No PSBT found in state - transaction has not been signed");
    const r = wt.nameToNetwork(e.baseParams.networkName), s = X.fromBase64(i.existingPsbtBase64, { network: r }), o = i.pubkeys.map((u) => w(u)), a = [];
    for (let u = i.originalInputCount; u < s.data.inputs.length; u++)
      a.push(o);
    if (!R.attemptFinalizeInputs(
      s,
      i.originalInputCount,
      a,
      !0
      // isFinal = true
    ))
      throw new Error("Failed to finalize multisig transaction - not enough signatures");
    return s.extractTransaction(!0, !0).toHex();
  }
  /**
   * Get the PSBT from a multisig state (for external signing tools)
   *
   * @param serializedState - Base64-encoded multisig state
   * @returns PSBT in base64 format, or null if not yet built
   */
  static multiSigGetPsbt(t) {
    const e = k.fromBase64(t);
    if (!ot(e.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    return e.typeSpecificData.existingPsbtBase64 || null;
  }
  /**
   * Update the PSBT in a multisig state (after external signing)
   *
   * @param serializedState - Base64-encoded multisig state
   * @param psbtBase64 - New PSBT with additional signatures
   * @returns Updated state
   */
  static multiSigUpdatePsbt(t, e) {
    const i = k.fromBase64(t);
    if (!ot(i.typeSpecificData))
      throw new Error("State is not a multisig transaction");
    const r = {
      ...i,
      typeSpecificData: {
        ...i.typeSpecificData,
        existingPsbtBase64: e
      }
    };
    return k.toBase64(r);
  }
}
class Or {
  constructor(t) {
    this.opnetAPIUrl = t;
  }
  utxoPath = "address/utxos";
  rpc = "json-rpc";
  /**
   * Fetches UTXO data from the OPNET node
   * @param {FetchUTXOParams} settings - The settings to fetch UTXO data
   * @returns {Promise<UTXO[]>} - The UTXOs fetched
   * @throws {Error} - If UTXOs could not be fetched
   */
  async fetchUTXO(t) {
    t.usePendingUTXO === void 0 && (t.usePendingUTXO = !0), t.optimized === void 0 && (t.optimized = !0);
    const e = {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    }, i = `${this.opnetAPIUrl}/api/v1/${this.utxoPath}?address=${t.address}&optimize=${t.optimized ?? !1}`, r = await fetch(i, e);
    if (!r.ok)
      throw new Error(`Failed to fetch UTXO data: ${r.statusText}`);
    const s = await r.json(), o = s.raw ?? [], a = t.usePendingUTXO ? [...s.confirmed, ...s.pending] : s.confirmed, c = [];
    for (const y of a)
      s.spentTransactions.some(
        (m) => m.transactionId === y.transactionId && m.outputIndex === y.outputIndex
      ) || c.push(y);
    if (c.length === 0)
      throw new Error("No UTXO found");
    const u = c.filter((y) => BigInt(y.value) >= t.minAmount);
    if (u.length === 0)
      throw new Error("No UTXO found (minAmount)");
    const l = [];
    let h = 0n;
    const d = t.requestedAmount, p = /* @__PURE__ */ new Map();
    for (const y of u) {
      const m = BigInt(y.value);
      if (m <= 0n)
        continue;
      const A = Number(y.raw);
      if (!Number.isInteger(A) || A < 0 || A >= o.length)
        throw new Error(
          `Invalid raw index for UTXO ${y.transactionId}:${y.outputIndex}`
        );
      const x = o[A];
      if (!x)
        throw new Error(
          `Invalid raw index ${A} - not found in raw transactions array`
        );
      let H = p.get(A);
      if (H === void 0 && (H = Vi(x), p.set(A, H)), h += m, l.push({
        transactionId: y.transactionId,
        outputIndex: y.outputIndex,
        value: m,
        scriptPubKey: y.scriptPubKey,
        nonWitnessUtxo: H
      }), h > d)
        break;
    }
    return p.clear(), l;
  }
  /**
   * Fetches UTXO data from the OPNET node for multiple addresses
   * @param {FetchUTXOParamsMultiAddress} settings - The settings to fetch UTXO data
   * @returns {Promise<UTXO[]>} - The UTXOs fetched
   * @throws {Error} - If UTXOs could not be fetched
   */
  async fetchUTXOMultiAddr(t) {
    const e = [];
    for (const a of t.addresses) {
      const c = {
        address: a,
        minAmount: t.minAmount,
        requestedAmount: t.requestedAmount,
        optimized: t.optimized,
        usePendingUTXO: t.usePendingUTXO
      }, u = this.fetchUTXO(c).catch(() => []);
      e.push(u);
    }
    const r = (await Promise.all(e)).flat(), s = [];
    let o = 0n;
    for (let a = 0; a < r.length; a++) {
      const c = r[a];
      if (o >= t.requestedAmount)
        break;
      o += c.value, s.push(c);
    }
    return s;
  }
  /**
   * Broadcasts a transaction to the OPNET node
   * @param {string} transaction - The transaction to broadcast
   * @param {boolean} psbt - Whether the transaction is a PSBT
   * @returns {Promise<BroadcastResponse>} - The response from the OPNET node
   */
  async broadcastTransaction(t, e) {
    const i = [t, e], r = await this.rpcMethod("btc_sendRawTransaction", i);
    if (r)
      return r;
  }
  /**
   * Splits UTXOs into smaller UTXOs
   * @param {Wallet} wallet - The wallet to split UTXOs
   * @param {Network} network - The network to split UTXOs
   * @param {number} splitInputsInto - The number of UTXOs to split into
   * @param {bigint} amountPerUTXO - The amount per UTXO
   * @returns {Promise<BroadcastResponse | { error: string }>} - The response from the OPNET node or an error
   */
  async splitUTXOs(t, e, i, r) {
    const s = {
      addresses: [t.p2wpkh, t.p2tr],
      minAmount: 330n,
      requestedAmount: 1000000000000000n
    }, o = await this.fetchUTXOMultiAddr(s);
    if (!o || !o.length) return { error: "No UTXOs found" };
    const c = {
      amount: BigInt(i) * r,
      feeRate: 500,
      from: t.p2tr,
      utxos: o,
      signer: t.keypair,
      network: e,
      to: t.p2tr,
      splitInputsInto: i,
      priorityFee: 0n,
      gasSatFee: 330n,
      mldsaSigner: null
    }, l = await new ci().createBTCTransfer(c), h = await this.broadcastTransaction(l.tx, !1);
    return h || { error: "Could not broadcast transaction" };
  }
  /**
   * Fetches to the OPNET node
   * @param {string} method
   * @param {unknown[]} paramsMethod
   * @returns {Promise<unknown>}
   */
  async rpcMethod(t, e) {
    const i = {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: t,
        params: e,
        id: 1
      })
    }, r = `${this.opnetAPIUrl}/api/v1/${this.rpc}`, s = await fetch(r, i);
    if (!s.ok)
      throw new Error(`Failed to fetch to rpc: ${s.statusText}`);
    const o = await s.json();
    if (!o)
      throw new Error("No data fetched");
    const a = o.result;
    if (!a)
      throw new Error("No rpc parameters found");
    if ("error" in a)
      throw new Error(`Error in fetching to rpc ${a.error}`);
    return a;
  }
  /**
   * Fetches the wrap parameters from the OPNET node
   * @param {bigint} amount - The amount to wrap
   * @returns {Promise<WrappedGeneration | undefined>} - The wrap parameters fetched
   * @throws {Error} - If wrap parameters could not be fetched
   */
  /*public async fetchWrapParameters(amount: bigint): Promise<WrappedGeneration | undefined> {
          if (amount < currentConsensusConfig.VAULT_MINIMUM_AMOUNT) {
              throw new Error(
                  `Amount must be greater than the minimum consolidation amount ${currentConsensusConfig.VAULT_MINIMUM_AMOUNT}sat.`,
              );
          }
  
          const params = [0, amount.toString()];
          const result = await this.rpcMethod('btc_generate', params);
  
          if (!result) {
              return;
          }
  
          return new WrappedGeneration(result as WrappedGenerationParameters);
      }*/
  /**
   * Fetches the wrap parameters from the OPNET node
   * @param {bigint} amount - The amount to wrap
   * @param {string} receiver - The receiver address
   * @returns {Promise<UnwrapGeneration | undefined>} - The wrap parameters fetched
   * @throws {Error} - If wrap parameters could not be fetched
   */
  /*public async fetchUnWrapParameters(
          amount: bigint,
          receiver: Address,
      ): Promise<UnwrapGeneration | undefined> {
          if (amount < 330n) {
              throw new Error(
                  `Amount must be greater than the minimum consolidation amount ${currentConsensusConfig.VAULT_MINIMUM_AMOUNT}sat.`,
              );
          }
  
          if (receiver.length < 50) {
              throw new Error('Invalid receiver address');
          }
  
          const params = [1, amount.toString(), receiver.toHex()];
          const result = await this.rpcMethod('btc_generate', params);
  
          if (!result) {
              return;
          }
  
          return new UnwrapGeneration(result as UnwrappedGenerationParameters);
      }*/
}
var yi = /* @__PURE__ */ ((n) => (n[n.UNWRAP = 0] = "UNWRAP", n))(yi || {});
class Ur {
  /**
   * Generate a multi-sig address
   * @param {Uint8Array[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(t, e, i = T.bitcoin) {
    if (P.verifyPubKeys(t, i).length !== t.length) throw new Error("Contains invalid public keys");
    const s = {
      network: i,
      utxos: [],
      pubkeys: t,
      minimumSignatures: e,
      feeRate: 100,
      receiver: "a",
      requestedAmount: 1n,
      refundVault: "a",
      mldsaSigner: null
    }, o = new R(s).getScriptAddress();
    if (!o)
      throw new Error("Failed to generate address");
    return o;
  }
}
class _r {
  /**
   * Generate a multi-sig P2MR address
   * @param {Uint8Array[]} pubKeys - The public keys to use
   * @param {number} minimumSignatureRequired - The minimum number of signatures required
   * @param {Network} network - The network to use
   * @returns {string} - The generated address
   * @throws {Error} - If the address cannot be generated
   */
  static generateMultiSigAddress(t, e, i = T.bitcoin) {
    const r = P.verifyPubKeys(t, i);
    if (r.length !== t.length) throw new Error("Contains invalid public keys");
    const s = {
      network: i,
      utxos: [],
      pubkeys: r,
      minimumSignatures: e,
      feeRate: 100,
      receiver: "a",
      requestedAmount: 1n,
      refundVault: "a",
      mldsaSigner: null,
      useP2MR: !0
    }, o = new R(s).getScriptAddress();
    if (!o)
      throw new Error("Failed to generate address");
    return o;
  }
}
var S = /* @__PURE__ */ ((n) => (n.UINT8 = "UINT8", n.UINT16 = "UINT16", n.UINT32 = "UINT32", n.UINT64 = "UINT64", n.UINT128 = "UINT128", n.UINT256 = "UINT256", n.INT8 = "INT8", n.INT16 = "INT16", n.INT32 = "INT32", n.INT64 = "INT64", n.INT128 = "INT128", n.BOOL = "BOOL", n.ADDRESS = "ADDRESS", n.EXTENDED_ADDRESS = "EXTENDED_ADDRESS", n.STRING = "STRING", n.BYTES4 = "BYTES4", n.BYTES32 = "BYTES32", n.BYTES = "BYTES", n.ADDRESS_UINT256_TUPLE = "ADDRESS_UINT256_TUPLE", n.EXTENDED_ADDRESS_UINT256_TUPLE = "EXTENDED_ADDRESS_UINT256_TUPLE", n.SCHNORR_SIGNATURE = "SCHNORR_SIGNATURE", n.ARRAY_OF_ADDRESSES = "ARRAY_OF_ADDRESSES", n.ARRAY_OF_EXTENDED_ADDRESSES = "ARRAY_OF_EXTENDED_ADDRESSES", n.ARRAY_OF_UINT256 = "ARRAY_OF_UINT256", n.ARRAY_OF_UINT128 = "ARRAY_OF_UINT128", n.ARRAY_OF_UINT64 = "ARRAY_OF_UINT64", n.ARRAY_OF_UINT32 = "ARRAY_OF_UINT32", n.ARRAY_OF_UINT16 = "ARRAY_OF_UINT16", n.ARRAY_OF_UINT8 = "ARRAY_OF_UINT8", n.ARRAY_OF_STRING = "ARRAY_OF_STRING", n.ARRAY_OF_BYTES = "ARRAY_OF_BYTES", n.ARRAY_OF_BUFFERS = "ARRAY_OF_BUFFERS", n))(S || {});
const Br = {
  address: S.ADDRESS,
  extendedAddress: S.EXTENDED_ADDRESS,
  bool: S.BOOL,
  bytes: S.BYTES,
  uint256: S.UINT256,
  uint128: S.UINT128,
  uint64: S.UINT64,
  uint32: S.UINT32,
  uint16: S.UINT16,
  uint8: S.UINT8,
  int128: S.INT128,
  int64: S.INT64,
  int32: S.INT32,
  int16: S.INT16,
  int8: S.INT8,
  string: S.STRING,
  bytes4: S.BYTES4,
  bytes32: S.BYTES32,
  schnorrSignature: S.SCHNORR_SIGNATURE,
  "tuple(address,uint256)[]": S.ADDRESS_UINT256_TUPLE,
  "tuple(extendedAddress,uint256)[]": S.EXTENDED_ADDRESS_UINT256_TUPLE,
  "address[]": S.ARRAY_OF_ADDRESSES,
  "extendedAddress[]": S.ARRAY_OF_EXTENDED_ADDRESSES,
  "uint256[]": S.ARRAY_OF_UINT256,
  "uint128[]": S.ARRAY_OF_UINT128,
  "uint64[]": S.ARRAY_OF_UINT64,
  "uint32[]": S.ARRAY_OF_UINT32,
  "uint16[]": S.ARRAY_OF_UINT16,
  "uint8[]": S.ARRAY_OF_UINT8,
  "bytes[]": S.ARRAY_OF_BYTES,
  "buffer[]": S.ARRAY_OF_BUFFERS,
  "string[]": S.ARRAY_OF_STRING,
  boolean: S.BOOL
}, mi = {
  [S.ADDRESS]: "address",
  [S.EXTENDED_ADDRESS]: "extendedAddress",
  [S.BOOL]: "bool",
  [S.BYTES]: "bytes",
  [S.BYTES32]: "bytes32",
  [S.BYTES4]: "bytes4",
  [S.UINT256]: "uint256",
  [S.UINT128]: "uint128",
  [S.UINT64]: "uint64",
  [S.UINT32]: "uint32",
  [S.UINT16]: "uint16",
  [S.UINT8]: "uint8",
  [S.INT128]: "int128",
  [S.INT64]: "int64",
  [S.INT32]: "int32",
  [S.INT16]: "int16",
  [S.INT8]: "int8",
  [S.STRING]: "string",
  [S.ADDRESS_UINT256_TUPLE]: "tuple(address,uint256)[]",
  [S.EXTENDED_ADDRESS_UINT256_TUPLE]: "tuple(extendedAddress,uint256)[]",
  [S.SCHNORR_SIGNATURE]: "schnorrSignature",
  [S.ARRAY_OF_ADDRESSES]: "address[]",
  [S.ARRAY_OF_EXTENDED_ADDRESSES]: "extendedAddress[]",
  [S.ARRAY_OF_UINT256]: "uint256[]",
  [S.ARRAY_OF_UINT128]: "uint128[]",
  [S.ARRAY_OF_UINT64]: "uint64[]",
  [S.ARRAY_OF_UINT32]: "uint32[]",
  [S.ARRAY_OF_UINT16]: "uint16[]",
  [S.ARRAY_OF_UINT8]: "uint8[]",
  [S.ARRAY_OF_BYTES]: "bytes[]",
  [S.ARRAY_OF_STRING]: "string[]",
  [S.ARRAY_OF_BUFFERS]: "buffer[]"
};
function Ti(n) {
  return Array.isArray(n);
}
function Ue(n) {
  return typeof n == "object" && n !== null && !Array.isArray(n);
}
function bi(n) {
  return typeof n == "string";
}
function Vt(n) {
  if (bi(n)) {
    const i = mi[n];
    if (!i)
      throw new Error(`Unknown ABI type: ${n}`);
    return i;
  }
  if (Ue(n))
    return `tuple(${Object.values(n).map((r) => Vt(r)).join(",")})`;
  const t = n[0];
  return n.length === 1 && t !== void 0 ? `${Vt(t)}[]` : `tuple(${n.map((i) => Vt(i)).join(",")})[]`;
}
class kr {
  decodeData(t, e) {
    const i = new ee(t), r = [];
    for (const s of e)
      r.push(this.decodeSingleValue(i, s));
    return r;
  }
  encodeSelector(t) {
    const i = this.sha256(t).subarray(0, 4);
    return Array.from(i, (r) => r.toString(16).padStart(2, "0")).join("");
  }
  numericSelectorToHex(t) {
    return t.toString(16);
  }
  /**
   * Decodes a single value from the reader based on the ABI type.
   * Supports ABIDataTypes enum values, tuple arrays, and struct objects.
   */
  decodeSingleValue(t, e) {
    if (Ti(e)) {
      const i = e[0];
      return e.length === 1 && i !== void 0 ? this.decodeArray(t, i) : this.decodeTuple(t, e);
    }
    if (Ue(e))
      return this.decodeStruct(t, e);
    switch (e) {
      case S.UINT8:
        return t.readU8();
      case S.UINT16:
        return t.readU16();
      case S.UINT32:
        return t.readU32();
      case S.BYTES4:
        return t.readBytes(4);
      case S.BYTES32:
        return t.readBytes(32);
      case S.BOOL:
        return t.readBoolean();
      case S.ADDRESS:
        return t.readAddress();
      case S.STRING:
        return t.readStringWithLength();
      case S.UINT128:
        return t.readU128();
      case S.UINT256:
        return t.readU256();
      case S.INT8:
        return t.readI8();
      case S.INT16:
        return t.readI16();
      case S.INT32:
        return t.readI32();
      case S.INT64:
        return t.readI64();
      case S.INT128:
        return t.readI128();
      case S.EXTENDED_ADDRESS:
        return t.readExtendedAddress();
      case S.ADDRESS_UINT256_TUPLE:
        return t.readAddressValueTuple();
      case S.EXTENDED_ADDRESS_UINT256_TUPLE:
        return t.readExtendedAddressMapU256();
      case S.SCHNORR_SIGNATURE:
        return t.readSchnorrSignature();
      case S.BYTES:
        return t.readBytesWithLength();
      case S.UINT64:
        return t.readU64();
      case S.ARRAY_OF_ADDRESSES:
        return t.readAddressArray();
      case S.ARRAY_OF_EXTENDED_ADDRESSES:
        return t.readExtendedAddressArray();
      case S.ARRAY_OF_UINT256:
        return t.readU256Array();
      case S.ARRAY_OF_UINT128:
        return t.readU128Array();
      case S.ARRAY_OF_UINT64:
        return t.readU64Array();
      case S.ARRAY_OF_UINT32:
        return t.readU32Array();
      case S.ARRAY_OF_UINT16:
        return t.readU16Array();
      case S.ARRAY_OF_UINT8:
        return t.readU8Array();
      case S.ARRAY_OF_STRING:
        return t.readStringArray();
      case S.ARRAY_OF_BYTES:
        return t.readBytesArray();
      case S.ARRAY_OF_BUFFERS:
        return t.readArrayOfBuffer();
      default:
        throw new Error(`Unsupported ABI type: ${e}`);
    }
  }
  /** Decodes a single-element tuple as a flat typed array (u16 count + values). */
  decodeArray(t, e) {
    const i = t.readU16(), r = [];
    for (let s = 0; s < i; s++)
      r.push(this.decodeSingleValue(t, e));
    return r;
  }
  /** Decodes a multi-element tuple as array of tuple entries (u16 count + entries). */
  decodeTuple(t, e) {
    const i = t.readU16(), r = [];
    for (let s = 0; s < i; s++) {
      const o = [];
      for (const a of e)
        o.push(this.decodeSingleValue(t, a));
      r.push(o);
    }
    return r;
  }
  /** Decodes a struct as a single object with named fields (inline, no count prefix). */
  decodeStruct(t, e) {
    const i = {};
    for (const [r, s] of Object.entries(e))
      i[r] = this.decodeSingleValue(t, s);
    return i;
  }
  sha256(t) {
    return new Uint8Array(new Pi.sha256().update(t).digest());
  }
}
class _e {
  items;
  keys;
  constructor(t = []) {
    this.items = /* @__PURE__ */ new Set(), this.keys = [];
    for (const e of t)
      this.add(e);
  }
  get size() {
    return this.keys.length;
  }
  add(t) {
    const e = t.toBigInt();
    this.items.has(e) || (this.items.add(e), this.keys.push(t));
  }
  has(t) {
    return this.items.has(t.toBigInt());
  }
  remove(t) {
    const e = t.toBigInt();
    this.items.delete(e) && (this.keys = this.keys.filter((i) => i.toBigInt() !== e));
  }
  clone() {
    return new _e(this.keys);
  }
  clear() {
    this.items.clear(), this.keys = [];
  }
  [Symbol.dispose]() {
    this.clear();
  }
  combine(t) {
    const e = this.clone();
    for (const i of t.keys)
      e.add(i);
    return e;
  }
  *[Symbol.iterator]() {
    yield* this.keys;
  }
}
class Be {
  constructor(t) {
    this.compareFn = t, this.map = new It(), this.#t = [];
  }
  map;
  #t;
  get size() {
    return this.map.size;
  }
  static fromMap(t, e) {
    const i = new Be(e);
    for (const [r, s] of t)
      i.set(r, s);
    return i;
  }
  set(t, e) {
    if (!this.map.has(t)) {
      let i = 0, r = this.#t.length;
      for (; i < r; ) {
        const s = Math.floor((i + r) / 2);
        this.compareFn(this.#t[s], t) < 0 ? i = s + 1 : r = s;
      }
      this.#t.splice(i, 0, t);
    }
    this.map.set(t, e);
  }
  get(t) {
    return this.map.get(t);
  }
  *entries() {
    for (const t of this.#t)
      yield [t, this.map.get(t)];
  }
  *keys() {
    yield* this.#t;
  }
  *values() {
    for (const t of this.#t) {
      const e = this.map.get(t);
      if (e === void 0 && !this.map.has(t))
        throw new Error("Value not found");
      yield e;
    }
  }
  has(t) {
    return this.map.has(t);
  }
  delete(t) {
    if (this.map.has(t)) {
      this.map.delete(t);
      let e = 0, i = this.#t.length - 1;
      for (; e <= i; ) {
        const r = Math.floor((e + i) / 2), s = this.compareFn(this.#t[r], t);
        if (s === 0)
          return this.#t.splice(r, 1), !0;
        s < 0 ? e = r + 1 : i = r - 1;
      }
    }
    return !1;
  }
  clear() {
    this.map.clear(), this.#t = [];
  }
  [Symbol.dispose]() {
    this.clear();
  }
  forEach(t) {
    for (const e of this.#t) {
      const i = this.map.get(e);
      t(i, e, this);
    }
  }
  *[Symbol.iterator]() {
    for (const t of this.#t)
      yield [t, this.map.get(t)];
  }
}
class ke {
  constructor(t) {
    this.compareFn = t, this.elements = [];
  }
  elements;
  get size() {
    return this.elements.length;
  }
  static fromSet(t, e) {
    const i = new ke(e);
    for (const r of t)
      i.add(r);
    return i;
  }
  add(t) {
    const { found: e, index: i } = this.binarySearch(t);
    e || this.elements.splice(i, 0, t);
  }
  delete(t) {
    const { found: e, index: i } = this.binarySearch(t);
    return e ? (this.elements.splice(i, 1), !0) : !1;
  }
  has(t) {
    return this.binarySearch(t).found;
  }
  clear() {
    this.elements = [];
  }
  [Symbol.dispose]() {
    this.clear();
  }
  forEach(t) {
    for (const e of this.elements)
      t(e, this);
  }
  *values() {
    yield* this.elements;
  }
  *[Symbol.iterator]() {
    yield* this.elements;
  }
  binarySearch(t) {
    let e = 0, i = this.elements.length;
    for (; e < i; ) {
      const r = Math.floor((e + i) / 2), s = this.compareFn(this.elements[r], t);
      if (s === 0)
        return { found: !0, index: r };
      s < 0 ? e = r + 1 : i = r;
    }
    return { found: !1, index: e };
  }
}
class Lr {
  constructor(t, e) {
    this.type = t, this.data = e;
  }
}
var Ai = /* @__PURE__ */ ((n) => (n.mainnet = "mainnet", n.testnet = "testnet", n.signet = "Signet", n))(Ai || {}), Ei = /* @__PURE__ */ ((n) => (n.ECDSA = "ECDSA", n.BIP322 = "BIP322", n))(Ei || {});
class Rr extends Ee {
  isInitialized = !1;
  constructor() {
    if (super(), !window)
      throw new Error("XverseSigner can only be used in a browser environment");
  }
  _p2tr;
  get p2tr() {
    if (!this._p2tr)
      throw new Error("P2TR address not set");
    return this._p2tr;
  }
  _p2wpkh;
  get p2wpkh() {
    if (!this._p2wpkh)
      throw new Error("P2PKH address not set");
    return this._p2wpkh;
  }
  _addresses;
  get addresses() {
    if (!this._addresses)
      throw new Error("Addresses not set");
    return this._addresses;
  }
  _publicKey;
  get publicKey() {
    if (!this._publicKey)
      throw new Error("Public key not set");
    return this._publicKey;
  }
  _network;
  get network() {
    if (!this._network)
      throw new Error("Network not set");
    return this._network;
  }
  get BitcoinProvider() {
    const t = window.BitcoinProvider;
    if (!t)
      throw new Error("Xverse Wallet extension not found");
    return t;
  }
  async init() {
    if (this.isInitialized) return;
    const t = await this.BitcoinProvider.request("wallet_connect", null);
    if ("error" in t) throw new Error(t.error.message);
    const e = t.result.addresses.find(
      (r) => r.purpose === "payment"
    );
    if (!e)
      throw new Error("Payment address not found");
    const i = e.address.startsWith("opt") ? T.opnetTestnet : e.address.startsWith("tb") ? T.testnet : e.address.startsWith("bc") ? T.bitcoin : null;
    if (!i) throw new Error("Network not supported");
    this._network = i, this._publicKey = pe(w(e.publicKey)), this._p2wpkh = P.getP2WPKHAddress(this, this.network), this._p2tr = P.getTaprootAddress(this, this.network), this._addresses = [this._p2wpkh, this._p2tr], this.isInitialized = !0;
  }
  async signData(t, e, i) {
    if (!this.isInitialized)
      throw new Error("UnisatSigner not initialized");
    const r = await this.BitcoinProvider.request("signMessage", {
      address: e,
      message: new TextDecoder().decode(t),
      protocol: i
    });
    if ("error" in r) throw new Error(r.error.message);
    const s = r.result;
    if (!s.signature)
      throw new Error("Signature not found");
    return w(s.signature);
  }
  getPublicKey() {
    if (!this.isInitialized)
      throw new Error("UnisatSigner not initialized");
    return this.publicKey;
  }
  sign(t, e) {
    throw new Error("Not implemented: sign");
  }
  signSchnorr(t) {
    throw new Error("Not implemented: signSchnorr");
  }
  verify(t, e) {
    throw new Error("Not implemented: verify");
  }
  async signTaprootInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, !1);
    this.combine(t, s, e);
  }
  async signInput(t, e, i) {
    const r = t.data.inputs[e];
    if (r.tapKeySig || r.finalScriptSig || Array.isArray(r.partialSig) && r.partialSig.length && this.hasAlreadyPartialSig(r.partialSig) || Array.isArray(r.tapScriptSig) && r.tapScriptSig.length && this.hasAlreadySignedTapScriptSig(r.tapScriptSig))
      return;
    const s = await this.signAllTweaked(t, i, !0);
    this.combine(t, s, e);
  }
  async multiSignPsbt(t) {
    const e = [], i = [];
    for (const a of t) {
      const c = a.toBase64();
      e.push(c);
      const u = a.data.inputs.map((l, h) => {
        let d = !1, p = !1;
        if (Te(l)) {
          if (l.tapLeafScript && l.tapLeafScript.length > 0) {
            for (const y of l.tapLeafScript)
              if (Ae(this.publicKey, y.script)) {
                d = !0, p = !1;
                break;
              }
          }
          if (!d && l.tapInternalKey) {
            const y = l.tapInternalKey, m = U(this.publicKey);
            C(y, m) && (d = !0, p = !0);
          }
        } else be(l, this.publicKey) && (d = !0, p = !1);
        return d ? {
          index: h,
          publicKey: g(this.publicKey),
          disableTweakSigner: !p
        } : null;
      }).filter((l) => l !== null);
      i.push({
        autoFinalized: !1,
        toSignInputs: u
      });
    }
    const r = {
      [this.p2wpkh]: i[0].toSignInputs?.map((a) => a.index) || []
    }, s = await this.BitcoinProvider.request("signPsbt", {
      psbt: e[0],
      signInputs: r
    });
    if ("error" in s) throw new Error(s.error.message);
    const o = X.fromBase64(s.result.psbt);
    t[0].combine(o);
  }
  hasAlreadySignedTapScriptSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = new Uint8Array(i.pubkey);
      if (C(r, this.publicKey) && i.signature)
        return !0;
    }
    return !1;
  }
  hasAlreadyPartialSig(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e], r = new Uint8Array(i.pubkey);
      if (C(r, this.publicKey) && i.signature)
        return !0;
    }
    return !1;
  }
  combine(t, e, i) {
    const r = e.data.inputs[i], s = t.data.inputs[i];
    if (r.partialSig && t.updateInput(i, { partialSig: r.partialSig }), r.tapKeySig && !s.tapKeySig && t.updateInput(i, { tapKeySig: r.tapKeySig }), r.tapScriptSig?.length) {
      const o = s.tapScriptSig;
      if (o) {
        const a = this.getNonDuplicateScriptSig(
          o,
          r.tapScriptSig
        );
        a.length && t.updateInput(i, { tapScriptSig: a });
      } else
        t.updateInput(i, { tapScriptSig: r.tapScriptSig });
    }
  }
  async signAllTweaked(t, e, i = !1) {
    const r = g(this.publicKey), o = {
      toSignInputs: t.data.inputs.map((l, h) => [
        {
          index: h,
          publicKey: r,
          sighashTypes: e,
          disableTweakSigner: i
        }
      ]).flat()
    }, a = t.toBase64(), c = {
      [this.p2wpkh]: o.toSignInputs?.map((l) => l.index) || []
    }, u = await this.BitcoinProvider.request("signPsbt", {
      psbt: a,
      signInputs: c
    });
    if ("error" in u) throw new Error(u.error.message);
    return X.fromBase64(u.result.psbt);
  }
  getNonDuplicateScriptSig(t, e) {
    const i = [];
    for (let r = 0; r < e.length; r++) {
      const s = e[r];
      t.find((a) => C(a.pubkey, s.pubkey)) || i.push(s);
    }
    return i;
  }
}
class Zt {
  static INITIAL_CAPACITY = 16;
  static LOAD_FACTOR = 0.75;
  #t;
  #e;
  deleted;
  capacity;
  constructor() {
    this.capacity = Zt.INITIAL_CAPACITY, this.#t = new Array(this.capacity), this.#e = new Array(this.capacity), this.deleted = new Array(this.capacity).fill(!1);
  }
  _size = 0;
  get size() {
    return this._size;
  }
  set(t, e) {
    let i = !0;
    const r = this.findInsertIndex(t);
    return (this.#t[r] === void 0 || this.deleted[r]) && (this._size++, i = !1), this.#t[r] = t, this.#e[r] = e, this.deleted[r] = !1, this._size > this.capacity * Zt.LOAD_FACTOR && this.resize(), i;
  }
  get(t) {
    const e = this.findIndex(t);
    return e === -1 ? void 0 : this.#e[e];
  }
  has(t) {
    return this.findIndex(t) !== -1;
  }
  indexOf(t) {
    return this.findIndex(t);
  }
  delete(t) {
    const e = this.findIndex(t);
    return e === -1 ? !1 : (this.#t[e] = void 0, this.#e[e] = void 0, this.deleted[e] = !0, this._size--, !0);
  }
  clear() {
    this.#t = new Array(this.capacity), this.#e = new Array(this.capacity), this.deleted = new Array(this.capacity).fill(!1), this._size = 0;
  }
  [Symbol.dispose]() {
    this.clear();
  }
  *entries() {
    for (let t = 0; t < this.capacity; t++)
      this.#t[t] !== void 0 && !this.deleted[t] && (yield [this.#t[t], this.#e[t]]);
  }
  *keys() {
    for (let t = 0; t < this.capacity; t++)
      this.#t[t] !== void 0 && !this.deleted[t] && (yield this.#t[t]);
  }
  *values() {
    for (let t = 0; t < this.capacity; t++)
      this.#t[t] !== void 0 && !this.deleted[t] && (yield this.#e[t]);
  }
  *[Symbol.iterator]() {
    yield* this.entries();
  }
  hashBigInt(t) {
    if (t >= -2147483648n && t <= 2147483647n)
      return Number(t) | 0;
    let e = 2166136261, i = t < 0n ? -t : t;
    for (; i > 0n; ) {
      const r = Number(i & 0xffffffffn);
      e ^= r, e = Math.imul(e, 16777619), i = i >> 32n;
    }
    return t < 0n && (e ^= 2147483648, e = Math.imul(e, 16777619)), Math.abs(e);
  }
  hash(t) {
    let e = 0;
    switch (typeof t) {
      case "number":
        if (t !== t) return 9221120237041091e3;
        if (!isFinite(t)) return t > 0 ? 9218868437227405e3 : 18442240474082181e3;
        e = t | 0;
        break;
      case "string":
        e = 2166136261;
        for (let i = 0; i < t.length; i++)
          e ^= t.charCodeAt(i), e = Math.imul(e, 16777619);
        break;
      case "boolean":
        e = t ? 1231 : 1237;
        break;
      case "symbol": {
        const i = t.description || "";
        e = this.hash(i);
        break;
      }
      case "bigint":
        e = this.hashBigInt(t);
        break;
      case "undefined":
        e = 0;
        break;
      case "object":
        if (t === null)
          e = 0;
        else if (t instanceof Date)
          e = t.getTime() | 0;
        else if (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
          e = this.hashBuffer(t);
        else if (Array.isArray(t)) {
          e = 1;
          for (const i of t)
            e = Math.imul(e, 31) + this.hash(i);
        } else
          throw new Error("Raw object not supported.");
        break;
      case "function":
        e = this.hash(t.toString());
        break;
    }
    return Math.abs(e) % this.capacity;
  }
  hashBuffer(t) {
    let e;
    if (t instanceof ArrayBuffer)
      e = new Uint8Array(t);
    else if (ArrayBuffer.isView(t))
      e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    else
      return 0;
    let i = 2166136261;
    for (let r = 0; r < Math.min(e.length, 100); r++)
      i ^= e[r], i = Math.imul(i, 16777619);
    return i;
  }
  equals(t, e) {
    return t === e || typeof t == "number" && typeof e == "number" && t !== t && e !== e ? !0 : (ArrayBuffer.isView(t) || t instanceof ArrayBuffer) && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer) ? this.buffersEqual(t, e) : !1;
  }
  buffersEqual(t, e) {
    const i = this.getBytes(t), r = this.getBytes(e);
    if (i.length !== r.length) return !1;
    for (let s = 0; s < i.length; s++)
      if (i[s] !== r[s]) return !1;
    return !0;
  }
  getBytes(t) {
    return t instanceof ArrayBuffer ? new Uint8Array(t) : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(0);
  }
  findIndex(t) {
    let e = this.hash(t);
    for (; this.#t[e] !== void 0 || this.deleted[e]; ) {
      if (this.#t[e] !== void 0 && this.equals(this.#t[e], t))
        return e;
      e = (e + 1) % this.capacity;
    }
    return -1;
  }
  findInsertIndex(t) {
    let e = this.hash(t);
    for (; this.#t[e] !== void 0 && !this.deleted[e]; ) {
      if (this.equals(this.#t[e], t))
        return e;
      e = (e + 1) % this.capacity;
    }
    return e;
  }
  resize() {
    const t = this.#t, e = this.#e;
    this.capacity *= 2, this.#t = new Array(this.capacity), this.#e = new Array(this.capacity), this.deleted = new Array(this.capacity).fill(!1), this._size = 0;
    for (let i = 0; i < t.length; i++)
      t[i] !== void 0 && !this.deleted[i] && this.set(t[i], e[i]);
  }
}
const Nr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ABICoder: kr,
  ABIDataTypes: S,
  ADDRESS_BYTE_LENGTH: D,
  ANCHOR_SCRIPT: he,
  AbiTypeToStr: mi,
  Address: K,
  AddressGenerator: Se,
  AddressMap: $e,
  AddressSet: _e,
  AddressTypes: st,
  AddressVerificator: Q,
  BIPStandard: Bt,
  BOOLEAN_BYTE_LENGTH: or,
  BinaryReader: ee,
  BinaryWriter: V,
  BitcoinUtils: W,
  BufferHelper: Wt,
  CSVModes: oi,
  CalldataGenerator: fe,
  CancelTransaction: Pe,
  ChainId: me,
  ChallengeSolution: de,
  ChallengeSubmission: wi,
  ChallengeVerification: Si,
  Compressor: Y,
  Consensus: Ft,
  ConsolidatedInteractionTransaction: ai,
  ContractAddress: ce,
  ContractBaseMetadata: Sr,
  CustomGenerator: Ge,
  CustomKeypair: Ee,
  CustomMap: Zt,
  CustomScriptTransaction: Gt,
  DeploymentGenerator: ge,
  DeploymentTransaction: Et,
  DeterministicMap: Be,
  DeterministicSet: ke,
  EXTENDED_ADDRESS_BYTE_LENGTH: mt,
  EcKeyPair: P,
  EpochValidator: St,
  ExtendedAddressMap: Ye,
  FastMap: It,
  FeaturePriority: et,
  Features: $,
  FundingTransaction: Qt,
  Generator: J,
  HashCommitmentGenerator: I,
  I128_BYTE_LENGTH: _t,
  I16_BYTE_LENGTH: Kt,
  I256_BYTE_LENGTH: nr,
  I32_BYTE_LENGTH: Rt,
  I64_BYTE_LENGTH: Lt,
  I8_BYTE_LENGTH: xt,
  InteractionTransaction: jt,
  InteractionTransactionP2WDA: it,
  LegacyCalldataGenerator: dr,
  MINIMUM_AMOUNT_CA: Ot,
  MINIMUM_AMOUNT_REWARD: j,
  MLDSAPublicKeyMetadata: ii,
  MLDSASecurityLevel: B.MLDSASecurityLevel,
  MessageSigner: ct,
  MessageType: ti,
  Mnemonic: ye,
  MnemonicStrength: Yt,
  MultiSignGenerator: Dt,
  MultiSignTransaction: R,
  NetEvent: Lr,
  OPNET_DEPLOYMENT_VERSION: Qe,
  OPNetConsensusConfig: gi,
  OPNetLimitedProvider: Or,
  OfflineTransactionManager: vr,
  P2MR_MS: _r,
  P2TR_MS: Ur,
  P2WDADetector: Z,
  P2WDAGenerator: Ct,
  PSBTTypes: yi,
  QuantumBIP32Factory: B.QuantumBIP32Factory,
  QuantumDerivationPath: B.QuantumDerivationPath,
  RoswellConsensus: fi,
  SCHNORR_SIGNATURE_BYTE_LENGTH: Tt,
  SELECTOR_BYTE_LENGTH: sr,
  SERIALIZATION_FORMAT_VERSION: ve,
  SERIALIZATION_MAGIC_BYTE: Ht,
  Secp256k1PointDeriver: Xe,
  SharedInteractionTransaction: Ie,
  SignatureType: $t,
  SigningProtocol: Ei,
  StrToAbiType: Br,
  TapscriptVerificator: nt,
  TimeLockGenerator: z,
  TransactionBuilder: E,
  TransactionFactory: ci,
  TransactionReconstructor: wt,
  TransactionSequence: ni,
  TransactionSerializer: k,
  TransactionStateCapture: tt,
  TransactionType: b,
  TweakedSigner: we,
  TweakedTransaction: Nt,
  U128_BYTE_LENGTH: Ut,
  U16_BYTE_LENGTH: At,
  U256_BYTE_LENGTH: kt,
  U32_BYTE_LENGTH: bt,
  U64_BYTE_LENGTH: qt,
  U8_BYTE_LENGTH: Xt,
  UnisatChainType: Je,
  UnisatSigner: yr,
  Wallet: rt,
  WalletNetworks: yt,
  XverseNetwork: Ai,
  XverseSigner: Rr,
  abiTypeToSelectorString: Vt,
  buildBIPPath: ei,
  createAddressRotation: br,
  createSignerMap: ri,
  currentConsensus: Oe,
  currentConsensusConfig: Pr,
  disabledAddressRotation: Ar,
  getBIPDescription: fr,
  getLevelFromPublicKeyLength: ue,
  isAbiStruct: Ue,
  isAbiTuple: Ti,
  isCancelSpecificData: pi,
  isCustomScriptSpecificData: di,
  isDeploymentSpecificData: li,
  isFundingSpecificData: ui,
  isInteractionSpecificData: hi,
  isMultiSigSpecificData: ot,
  isOPWallet: Ze,
  isSimpleAbiType: bi,
  isUniversalSigner: pt,
  toParallelKeyPair: Er,
  toTweakedParallelKeyPair: si,
  version: Gi,
  versionBuffer: je
}, Symbol.toStringTag, { value: "Module" })), Fr = B.MLDSASecurityLevel, Mr = B.QuantumBIP32Factory, Wr = B.QuantumDerivationPath;
export {
  kr as ABICoder,
  S as ABIDataTypes,
  D as ADDRESS_BYTE_LENGTH,
  he as ANCHOR_SCRIPT,
  mi as AbiTypeToStr,
  K as Address,
  Se as AddressGenerator,
  $e as AddressMap,
  _e as AddressSet,
  st as AddressTypes,
  Q as AddressVerificator,
  Bt as BIPStandard,
  or as BOOLEAN_BYTE_LENGTH,
  ee as BinaryReader,
  V as BinaryWriter,
  W as BitcoinUtils,
  Wt as BufferHelper,
  oi as CSVModes,
  fe as CalldataGenerator,
  Pe as CancelTransaction,
  me as ChainId,
  de as ChallengeSolution,
  wi as ChallengeSubmission,
  Si as ChallengeVerification,
  Y as Compressor,
  Ft as Consensus,
  ai as ConsolidatedInteractionTransaction,
  ce as ContractAddress,
  Sr as ContractBaseMetadata,
  Ge as CustomGenerator,
  Ee as CustomKeypair,
  Zt as CustomMap,
  Gt as CustomScriptTransaction,
  ge as DeploymentGenerator,
  Et as DeploymentTransaction,
  Be as DeterministicMap,
  ke as DeterministicSet,
  mt as EXTENDED_ADDRESS_BYTE_LENGTH,
  P as EcKeyPair,
  St as EpochValidator,
  Ye as ExtendedAddressMap,
  It as FastMap,
  et as FeaturePriority,
  $ as Features,
  Qt as FundingTransaction,
  J as Generator,
  I as HashCommitmentGenerator,
  _t as I128_BYTE_LENGTH,
  Kt as I16_BYTE_LENGTH,
  nr as I256_BYTE_LENGTH,
  Rt as I32_BYTE_LENGTH,
  Lt as I64_BYTE_LENGTH,
  xt as I8_BYTE_LENGTH,
  jt as InteractionTransaction,
  it as InteractionTransactionP2WDA,
  dr as LegacyCalldataGenerator,
  Ot as MINIMUM_AMOUNT_CA,
  j as MINIMUM_AMOUNT_REWARD,
  ii as MLDSAPublicKeyMetadata,
  Fr as MLDSASecurityLevel,
  ct as MessageSigner,
  ti as MessageType,
  ye as Mnemonic,
  Yt as MnemonicStrength,
  Dt as MultiSignGenerator,
  R as MultiSignTransaction,
  Lr as NetEvent,
  Qe as OPNET_DEPLOYMENT_VERSION,
  gi as OPNetConsensusConfig,
  Or as OPNetLimitedProvider,
  vr as OfflineTransactionManager,
  _r as P2MR_MS,
  Ur as P2TR_MS,
  Z as P2WDADetector,
  Ct as P2WDAGenerator,
  yi as PSBTTypes,
  Mr as QuantumBIP32Factory,
  Wr as QuantumDerivationPath,
  fi as RoswellConsensus,
  Tt as SCHNORR_SIGNATURE_BYTE_LENGTH,
  sr as SELECTOR_BYTE_LENGTH,
  ve as SERIALIZATION_FORMAT_VERSION,
  Ht as SERIALIZATION_MAGIC_BYTE,
  Xe as Secp256k1PointDeriver,
  Ie as SharedInteractionTransaction,
  $t as SignatureType,
  Ei as SigningProtocol,
  Br as StrToAbiType,
  nt as TapscriptVerificator,
  z as TimeLockGenerator,
  E as TransactionBuilder,
  ci as TransactionFactory,
  wt as TransactionReconstructor,
  ni as TransactionSequence,
  k as TransactionSerializer,
  tt as TransactionStateCapture,
  b as TransactionType,
  we as TweakedSigner,
  Nt as TweakedTransaction,
  Ut as U128_BYTE_LENGTH,
  At as U16_BYTE_LENGTH,
  kt as U256_BYTE_LENGTH,
  bt as U32_BYTE_LENGTH,
  qt as U64_BYTE_LENGTH,
  Xt as U8_BYTE_LENGTH,
  Je as UnisatChainType,
  yr as UnisatSigner,
  rt as Wallet,
  yt as WalletNetworks,
  Ai as XverseNetwork,
  Rr as XverseSigner,
  Vt as abiTypeToSelectorString,
  ei as buildBIPPath,
  br as createAddressRotation,
  ri as createSignerMap,
  Oe as currentConsensus,
  Pr as currentConsensusConfig,
  Ar as disabledAddressRotation,
  fr as getBIPDescription,
  ue as getLevelFromPublicKeyLength,
  Ue as isAbiStruct,
  Ti as isAbiTuple,
  pi as isCancelSpecificData,
  di as isCustomScriptSpecificData,
  li as isDeploymentSpecificData,
  ui as isFundingSpecificData,
  hi as isInteractionSpecificData,
  ot as isMultiSigSpecificData,
  Ze as isOPWallet,
  bi as isSimpleAbiType,
  pt as isUniversalSigner,
  Nr as opnet,
  Er as toParallelKeyPair,
  si as toTweakedParallelKeyPair,
  Gi as version,
  je as versionBuffer
};
