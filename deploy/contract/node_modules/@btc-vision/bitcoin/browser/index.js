import { d as Me, a as _, t as De, i as Ge, b as Ve, c as le, e as ze, o as M, f as G, p as dt, g as gt, h as fe, j as Ft, k as je, l as yt, m as zt, n as Bt, q as pe, r as de, s as ge, P as Ht, u as D, v as Xe, L as Ye, M as qe, w as Ze, x as Je, y as Qe, z as tn, A as en, B as nn, C as rn, D as sn, E as on, F as an, G as wt, H as ye, I as cn, J as un, K as hn, N as we, O as ln, Q as fn, R as pn, S as St, T as At, U as k, V, W as B, X as st, Y as dn, Z as It, _ as b, $ as Y, a0 as z, a1 as O, a2 as gn, a3 as yn, a4 as et, a5 as it, a6 as Et, a7 as Se, a8 as jt, a9 as wn, aa as Sn, ab as En, ac as mn, ad as bn, ae as Tn, af as nt, ag as rt, ah as Xt, ai as Yt, aj as qt, ak as Zt, al as An, am as Q, an as In, ao as kn, ap as vn, aq as xn } from "./chunks/psbt-parallel-jZ6QcCnM.js";
import { ar as ci, as as ui, at as hi, au as li, av as fi, aw as pi, ax as di, ay as gi, az as yi, aA as wi, aB as Si, aC as Ei, aD as mi, aE as bi, aF as Ti, aG as Ai, aH as Ii, aI as ki, aJ as vi, aK as xi, aL as _i, aM as Ui, aN as Pi, aO as Ni, aP as Hi, aQ as Oi, aR as Ri, aS as Ki, aT as Ci, aU as Fi, aV as Bi, aW as Wi, aX as $i, aY as Li, aZ as Mi, a_ as Di, a$ as Gi, b0 as Vi, b1 as zi, b2 as ji, b3 as Xi, b4 as Yi, b5 as qi, b6 as Zi, b7 as Ji, b8 as Qi, b9 as to, ba as eo, bb as no, bc as ro } from "./chunks/psbt-parallel-jZ6QcCnM.js";
function _n(e) {
  const t = atob(e), n = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    n[r] = t.charCodeAt(r);
  return n;
}
function ei(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += String.fromCharCode(e[n]);
  return btoa(t);
}
const q = 40, Z = 2, J = 15, Ee = 16, ot = 16, mt = 2, bt = 80, Un = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.", me = (e) => {
  try {
    const t = e.subarray(2);
    if (t.length < Z || t.length > q)
      throw new TypeError("Invalid program length for segwit address");
    const n = e[0];
    if (n === void 0) throw new TypeError("Empty output");
    const r = n - bt;
    if (r < mt || r > J + 1)
      throw new TypeError("Invalid version for segwit address");
    if (r === 1) throw new TypeError("taproot");
    return !0;
  } catch {
  }
  return !1;
};
function be(e, t) {
  if (!(e instanceof Uint8Array)) throw new TypeError("output must be a Uint8Array");
  if (!t.bech32Opnet) throw new Error("Network does not support opnet");
  const n = e[0];
  let r = 1, s;
  const i = e[1], o = e[2];
  if (i !== void 0 && i < 76)
    s = i, r = 2;
  else if (i === 76 && o !== void 0)
    s = o, r = 3;
  else
    throw new TypeError("Unsupported push opcode in script");
  const a = e.subarray(r, r + s);
  if (a.length < Z || a.length > q)
    throw new TypeError("Invalid program length for segwit address");
  const u = n === M.OP_0 ? 0 : n !== void 0 && n >= M.OP_1 && n <= M.OP_16 ? n - (M.OP_1 - 1) : -1;
  if (u < J || u > Ee)
    throw new TypeError(`Invalid segwit version ${u}`);
  const l = [u, ..._.bech32m.toWords(a)];
  return _.bech32m.encode(t.bech32Opnet, l);
}
function Te(e, t) {
  const n = e.subarray(2);
  if (n.length < Z || n.length > q)
    throw new TypeError("Invalid program length for segwit address");
  const r = e[0];
  if (r === void 0) throw new TypeError("Empty output");
  const s = r - bt;
  if (s < mt || s > J)
    throw new TypeError("Invalid version for segwit address");
  if (e[1] !== n.length)
    throw new TypeError(`Invalid script for segwit address ${e[1]} !== ${n.length}`);
  return at(n, s, t.bech32, t.bech32Opnet);
}
function Ae(e) {
  const t = new Uint8Array(Me(e));
  if (t.length < 21) throw new TypeError(e + " is too short");
  if (t.length > 21) throw new TypeError(e + " is too long");
  const n = t[0], r = t.subarray(1);
  return { version: n, hash: r };
}
function Ot(e, t) {
  if (!Ge(e)) throw new TypeError("Expected 20 bytes hash");
  if (!Ve(t)) throw new TypeError("Expected UInt8 version");
  const n = le(21);
  return n[0] = t, n.set(e, 1), ze(n);
}
function at(e, t, n, r) {
  const s = _.bech32.toWords(e);
  return s.unshift(t), t === ot && r ? _.bech32m.encode(r, s) : t === 0 ? _.bech32.encode(n, s) : _.bech32m.encode(n, s);
}
function Ie(e, t) {
  t = t || G;
  const n = e.length;
  if (n === 25 && e[0] === 118 && e[1] === 169 && e[2] === 20 && e[23] === 136 && e[24] === 172)
    return Ot(e.subarray(3, 23), t.pubKeyHash);
  if (n === 23 && e[0] === 169 && e[1] === 20 && e[22] === 135)
    return Ot(e.subarray(2, 22), t.scriptHash);
  if (n === 22 && e[0] === 0 && e[1] === 20)
    return at(e.subarray(2, 22), 0, t.bech32);
  if (n === 34 && e[0] === 0 && e[1] === 32)
    return at(e.subarray(2, 34), 0, t.bech32);
  if (n === 34 && e[0] === 81 && e[1] === 32) {
    const r = _.bech32m.toWords(e.subarray(2, 34));
    return r.unshift(1), _.bech32m.encode(t.bech32, r);
  }
  if (n === 34 && e[0] === 82 && e[1] === 32) {
    const r = _.bech32m.toWords(e.subarray(2, 34));
    return r.unshift(2), _.bech32m.encode(t.bech32, r);
  }
  try {
    return be(e, t);
  } catch {
  }
  try {
    return Te(e, t);
  } catch {
  }
  throw new Error(De(e) + " has no matching Address");
}
function ke(e, t) {
  let n, r;
  t && "bech32" in t ? n = t : t && typeof t == "object" ? (n = t.network || G, r = t.onFutureSegwitWarning) : n = G;
  let s, i;
  try {
    s = Ae(e);
  } catch {
  }
  if (s) {
    if (s.version === n.pubKeyHash)
      return dt({ hash: s.hash }).output;
    if (s.version === n.scriptHash)
      return gt({ hash: s.hash }).output;
  } else {
    try {
      i = fe(e);
    } catch {
    }
    if (i) {
      if (i.prefix !== n.bech32 && n.bech32Opnet && i.prefix !== n.bech32Opnet)
        throw new Error(e + " has an invalid prefix");
      if (i.version === 0) {
        if (i.data.length === 20)
          return Ft({ hash: je(i.data) }).output;
        if (i.data.length === 32)
          return yt({ hash: zt(i.data) }).output;
      } else if (i.version === 1) {
        if (i.data.length === 32)
          return Bt({ pubkey: i.data }).output;
      } else {
        if (i.version === 2 && i.data.length === 32)
          return pe({ hash: zt(i.data) }).output;
        if (i.version === ot) {
          if (!n.bech32Opnet) throw new Error(e + " has an invalid prefix");
          return de({
            program: i.data,
            network: n
          }).output;
        } else if (i.version >= mt && i.version <= J && i.data.length >= Z && i.data.length <= q)
          return i.version !== ot && r && r(Un), ge([
            i.version + bt,
            i.data
          ]);
      }
    }
  }
  throw new TypeError(e + " has no matching Script");
}
const Pn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FUTURE_MAX_VERSION: Ee,
  FUTURE_OPNET_VERSION: ot,
  FUTURE_SEGWIT_MAX_SIZE: q,
  FUTURE_SEGWIT_MAX_VERSION: J,
  FUTURE_SEGWIT_MIN_SIZE: Z,
  FUTURE_SEGWIT_MIN_VERSION: mt,
  FUTURE_SEGWIT_VERSION_DIFF: bt,
  _toFutureSegwitAddress: Te,
  fromBase58Check: Ae,
  fromBech32: fe,
  fromOutputScript: Ie,
  isUnknownSegwitVersion: me,
  toBase58Check: Ot,
  toBech32: at,
  toFutureOPNetAddress: be,
  toOutputScript: ke
}, Symbol.toStringTag, { value: "Module" })), Jt = M;
class j {
  // Static public fields
  static NAME = Ht.Embed;
  // Private instance fields
  #t;
  #e;
  // Input data (provided by user)
  #s;
  #n;
  // Cached computed values
  #r;
  #o;
  // Cache flags
  #a = !1;
  #i = !1;
  /**
   * Creates a new Embed payment instance.
   *
   * @param params - Payment parameters
   * @param params.data - Array of data chunks to embed
   * @param params.output - The scriptPubKey
   * @param params.network - Network parameters (defaults to mainnet)
   * @param opts - Payment options
   * @param opts.validate - Whether to validate inputs (default: true)
   *
   * @throws {TypeError} If validation is enabled and data is invalid
   */
  constructor(t, n) {
    this.#t = t.network ?? G, this.#e = {
      validate: n?.validate ?? !0,
      allowIncomplete: n?.allowIncomplete ?? !1
    }, this.#s = t.data, this.#n = t.output, this.#e.validate && this.#h();
  }
  // Public getters
  /**
   * Payment type discriminant.
   */
  get name() {
    return Ht.Embed;
  }
  /**
   * Network parameters.
   */
  get network() {
    return this.#t;
  }
  /**
   * The embedded data chunks.
   */
  get data() {
    return this.#a || (this.#r = this.#c(), this.#a = !0), this.#r ?? [];
  }
  /**
   * The scriptPubKey: `OP_RETURN {data...}`
   */
  get output() {
    return this.#i || (this.#o = this.#u(), this.#i = !0), this.#o;
  }
  // Static factory methods
  /**
   * Creates an Embed payment from data chunks.
   *
   * @param data - Array of data chunks to embed
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new Embed payment instance
   *
   * @example
   * ```typescript
   * const payment = Embed.fromData([
   *   new TextEncoder().encode('Hello'),
   *   new TextEncoder().encode('Bitcoin')
   * ]);
   * ```
   */
  static fromData(t, n) {
    return new j({ data: t, network: n });
  }
  /**
   * Creates an Embed payment from a scriptPubKey.
   *
   * @param output - The scriptPubKey
   * @param network - Network parameters (defaults to mainnet)
   * @returns A new Embed payment instance
   */
  static fromOutput(t, n) {
    return new j({ output: t, network: n });
  }
  // Private computation methods
  /**
   * Converts to a plain EmbedPayment object for backwards compatibility.
   *
   * @returns An EmbedPayment object
   */
  toPayment() {
    return {
      name: this.name,
      network: this.network,
      data: this.data,
      output: this.output
    };
  }
  #c() {
    if (this.#s)
      return this.#s;
    if (this.#n) {
      const t = D(this.#n);
      return t?.slice(1);
    }
  }
  // Validation
  #u() {
    if (this.#n)
      return this.#n;
    if (this.#s)
      return ge([Jt.OP_RETURN].concat(this.#s));
  }
  #h() {
    if (this.#n) {
      const t = D(this.#n);
      if (!t)
        throw new TypeError("Output is invalid");
      if (t[0] !== Jt.OP_RETURN)
        throw new TypeError("Output is invalid");
      if (!t.slice(1).every((n) => n instanceof Uint8Array))
        throw new TypeError("Output is invalid");
      if (this.#s && !Xe(this.#s, this.data))
        throw new TypeError("Data mismatch");
    }
  }
}
function Nn(e, t) {
  if (!e.data && !e.output)
    throw new TypeError("Not enough data");
  const n = new j(
    {
      data: e.data,
      output: e.output,
      network: e.network
    },
    t
  );
  return Object.assign(n.toPayment(), e);
}
const Hn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Embed: j,
  LEAF_VERSION_TAPSCRIPT: Ye,
  MAX_TAPTREE_DEPTH: qe,
  P2MR: Ze,
  P2MS: Je,
  P2OP: Qe,
  P2PK: tn,
  P2PKH: en,
  P2SH: nn,
  P2TR: rn,
  P2WPKH: sn,
  P2WSH: on,
  PaymentType: Ht,
  findScriptPath: an,
  p2data: Nn,
  p2mr: pe,
  p2ms: wt,
  p2op: de,
  p2pk: ye,
  p2pkh: dt,
  p2sh: gt,
  p2tr: Bt,
  p2wpkh: Ft,
  p2wsh: yt,
  rootHashFromPath: cn,
  rootHashFromPathP2MR: un,
  tapBranchHash: hn,
  tapleafHash: we,
  toHashTree: ln,
  tweakKey: fn
}, Symbol.toStringTag, { value: "Module" }));
class v extends Error {
  constructor(t) {
    super(t), this.name = "BitcoinError", Error.captureStackTrace && Error.captureStackTrace(this, v);
  }
}
class On extends v {
  constructor(t) {
    super(t), this.name = "ValidationError";
  }
}
class Rn extends v {
  constructor(t) {
    super(t), this.name = "InvalidInputError";
  }
}
class Kn extends v {
  constructor(t) {
    super(t), this.name = "InvalidOutputError";
  }
}
class Cn extends v {
  constructor(t) {
    super(t), this.name = "ScriptError";
  }
}
class Fn extends v {
  constructor(t) {
    super(t), this.name = "PsbtError";
  }
}
class Bn extends v {
  constructor(t) {
    super(t), this.name = "EccError";
  }
}
class Wn extends v {
  constructor(t) {
    super(t), this.name = "AddressError";
  }
}
class $n extends v {
  constructor(t) {
    super(t), this.name = "SignatureError";
  }
}
function Ln(e, t) {
  if (!Array.isArray(e)) throw TypeError("Expected values Array");
  if (typeof t != "function") throw TypeError("Expected digest Function");
  let n = e.length;
  const r = e.concat();
  for (; n > 1; ) {
    let s = 0;
    for (let i = 0; i < n; i += 2, ++s) {
      const o = r[i], a = i + 1 === n ? o : r[i + 1], u = new Uint8Array(o.length + a.length);
      u.set(o), u.set(a, o.length), r[s] = t(u);
    }
    n = s;
  }
  return r[0];
}
const kt = new TypeError("Cannot compute merkle root for zero transactions"), vt = new TypeError("Cannot compute witness commit for non-segwit block"), Mn = St("6a24aa21a9ed");
class F {
  /** Block version number */
  version = 1;
  /** Hash of the previous block (32 bytes) */
  prevHash = void 0;
  /** Merkle root of the transactions (32 bytes) */
  merkleRoot = void 0;
  /** Block timestamp (Unix time) */
  timestamp = 0;
  /** Witness commitment for SegWit blocks (32 bytes) */
  witnessCommit = void 0;
  /** Compact representation of the target threshold */
  bits = 0;
  /** Nonce used for proof of work */
  nonce = 0;
  /** Array of transactions included in the block */
  transactions = void 0;
  /**
   * Parses a Block from a Uint8Array.
   * @param buffer - The raw block data (minimum 80 bytes for header only)
   * @returns Parsed Block instance
   * @throws Error if buffer is too small
   */
  static fromBuffer(t) {
    if (t.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const n = new pn(t), r = new F();
    if (r.version = n.readInt32LE(), r.prevHash = n.readBytes(32), r.merkleRoot = n.readBytes(32), r.timestamp = n.readUInt32LE(), r.bits = n.readUInt32LE(), r.nonce = n.readUInt32LE(), t.length === 80) return r;
    const s = () => {
      const a = b.fromBuffer(n.data.subarray(n.offset), !0);
      return n.offset += a.byteLength(), a;
    }, i = n.readVarInt();
    r.transactions = [];
    for (let a = 0; a < i; ++a) {
      const u = s();
      r.transactions.push(u);
    }
    const o = r.getWitnessCommit();
    return o && (r.witnessCommit = o), r;
  }
  /**
   * Parses a Block from a hex string.
   * @param hex - Hexadecimal representation of the block
   * @returns Parsed Block instance
   */
  static fromHex(t) {
    return F.fromBuffer(St(t));
  }
  /**
   * Calculates the target threshold from the compact bits representation.
   * @param bits - Compact bits value from block header
   * @returns 32-byte target threshold
   */
  static calculateTarget(t) {
    const n = ((t & 4278190080) >> 24) - 3, r = t & 8388607, s = le(32), i = 29 - n;
    return s[i] = r >> 16 & 255, s[i + 1] = r >> 8 & 255, s[i + 2] = r & 255, s;
  }
  /**
   * Calculates the merkle root for a list of transactions.
   * @param transactions - Array of transactions
   * @param forWitness - If true, calculate witness merkle root (for SegWit)
   * @returns 32-byte merkle root hash
   * @throws TypeError if transactions is empty or not an array
   */
  static calculateMerkleRoot(t, n) {
    if (!Array.isArray(t))
      throw new TypeError("Expected an array of transactions");
    if (t.length === 0) throw kt;
    if (n && !Qt(t)) throw vt;
    const r = t.map((i) => i.getHash(n)), s = Ln(r, At);
    if (n) {
      const a = t[0]?.ins[0]?.witness[0];
      if (!a) throw new TypeError("Missing witness in coinbase");
      const u = new Uint8Array(s.length + a.length);
      return u.set(s), u.set(a, s.length), At(u);
    }
    return s;
  }
  /**
   * Extracts the witness commitment from the coinbase transaction.
   * @returns 32-byte witness commitment or null if not found
   */
  getWitnessCommit() {
    if (!this.transactions || !Qt(this.transactions)) return null;
    const t = this.transactions[0];
    if (!t) return null;
    const n = t.outs.filter(
      (s) => k(s.script.subarray(0, 6), Mn)
    ).map((s) => s.script.subarray(6, 38));
    if (n.length === 0) return null;
    const r = n[n.length - 1];
    return r instanceof Uint8Array && r.length === 32 ? r : null;
  }
  /**
   * Checks if this block has a witness commitment.
   * @returns True if the block has a witness commitment
   */
  hasWitnessCommit() {
    return this.witnessCommit instanceof Uint8Array && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  /**
   * Checks if any transaction in this block has witness data.
   * @returns True if any transaction has witness data
   */
  hasWitness() {
    return this.transactions ? Dn(this.transactions) : !1;
  }
  /**
   * Calculates the weight of this block.
   * Weight = (base size * 3) + total size
   * @returns Block weight in weight units
   */
  weight() {
    const t = this.byteLength(!1, !1), n = this.byteLength(!1, !0);
    return t * 3 + n;
  }
  /**
   * Calculates the serialized byte length of this block.
   * @param headersOnly - If true, return only header size (80 bytes)
   * @param allowWitness - If true, include witness data in calculation
   * @returns Byte length of the serialized block
   */
  byteLength(t, n = !0) {
    return t || !this.transactions ? 80 : 80 + V(this.transactions.length) + this.transactions.reduce((r, s) => r + s.byteLength(n), 0);
  }
  /**
   * Computes the double-SHA256 hash of the block header.
   * @returns 32-byte block hash
   */
  getHash() {
    return At(this.toBuffer(!0));
  }
  /**
   * Returns the block ID (hash in reversed hex format, as displayed in block explorers).
   * @returns Block ID as hex string
   */
  getId() {
    return B(st(this.getHash()));
  }
  /**
   * Converts the block timestamp to a Date object.
   * @returns UTC date of the block
   */
  getUTCDate() {
    const t = /* @__PURE__ */ new Date(0);
    return t.setUTCSeconds(this.timestamp), t;
  }
  /**
   * Serializes the block to a Uint8Array.
   * @param headersOnly - If true, only serialize the 80-byte header
   * @returns Serialized block data
   */
  toBuffer(t) {
    if (!this.prevHash) throw new TypeError("Block prevHash is required");
    if (!this.merkleRoot) throw new TypeError("Block merkleRoot is required");
    const n = new Uint8Array(this.byteLength(t)), r = new dn(n);
    return r.writeInt32LE(this.version), r.writeBytes(this.prevHash), r.writeBytes(this.merkleRoot), r.writeUInt32LE(this.timestamp), r.writeUInt32LE(this.bits), r.writeUInt32LE(this.nonce), t || !this.transactions || (r.writeVarInt(this.transactions.length), this.transactions.forEach((s) => {
      const i = s.byteLength();
      s.toBuffer(n.subarray(r.offset)), r.offset += i;
    })), n;
  }
  /**
   * Serializes the block to a hex string.
   * @param headersOnly - If true, only serialize the 80-byte header
   * @returns Hex string representation of the block
   */
  toHex(t) {
    return B(this.toBuffer(t));
  }
  /**
   * Validates the merkle root and witness commitment (if present).
   * @returns True if the transaction roots are valid
   */
  checkTxRoots() {
    const t = this.hasWitnessCommit();
    return !t && this.hasWitness() ? !1 : this.#t() && (t ? this.#e() : !0);
  }
  /**
   * Validates that the block hash meets the target threshold (proof of work).
   * @returns True if the block's proof of work is valid
   */
  checkProofOfWork() {
    const t = st(this.getHash()), n = F.calculateTarget(this.bits);
    return It(t, n) <= 0;
  }
  #t() {
    if (!this.transactions) throw kt;
    if (!this.merkleRoot) throw new TypeError("Block merkleRoot is required");
    const t = F.calculateMerkleRoot(this.transactions);
    return It(this.merkleRoot, t) === 0;
  }
  #e() {
    if (!this.transactions) throw kt;
    if (!this.hasWitnessCommit() || !this.witnessCommit) throw vt;
    const t = F.calculateMerkleRoot(this.transactions, !0);
    return It(this.witnessCommit, t) === 0;
  }
}
function Qt(e) {
  const t = e[0];
  return t?.ins?.[0]?.witness ? t.ins[0].witness.length > 0 : !1;
}
function Dn(e) {
  return e.some(
    (t) => t.ins?.some((n) => n.witness && n.witness.length > 0)
  );
}
var U;
(function(e) {
  e[e.UNSIGNED_TX = 0] = "UNSIGNED_TX", e[e.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
})(U || (U = {}));
var p;
(function(e) {
  e[e.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", e[e.WITNESS_UTXO = 1] = "WITNESS_UTXO", e[e.PARTIAL_SIG = 2] = "PARTIAL_SIG", e[e.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", e[e.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", e[e.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", e[e.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", e[e.POR_COMMITMENT = 9] = "POR_COMMITMENT", e[e.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", e[e.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", e[e.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", e[e.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", e[e.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
})(p || (p = {}));
var E;
(function(e) {
  e[e.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", e[e.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", e[e.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", e[e.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", e[e.TAP_TREE = 6] = "TAP_TREE", e[e.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})(E || (E = {}));
const ct = "0123456789abcdefABCDEF", ut = ct.split("").map((e) => e.codePointAt(0)), ht = Array(256).fill(!0).map((e, t) => {
  const n = String.fromCodePoint(t), r = ct.indexOf(n);
  return r < 0 ? void 0 : r < 16 ? r : r - 6;
}), ve = new TextEncoder(), xe = new TextDecoder();
function Gn(e) {
  return xe.decode(e);
}
function Vn(e) {
  return ve.encode(e);
}
function P(e) {
  const t = e.reduce((s, i) => s + i.length, 0), n = new Uint8Array(t);
  let r = 0;
  for (const s of e)
    n.set(s, r), r += s.length;
  return n;
}
function d(e) {
  const t = e || new Uint8Array();
  return t.length > 512 ? jn(t) : zn(t);
}
function zn(e) {
  let t = "";
  for (let n = 0; n < e.length; ++n)
    t += ct[ht[ut[e[n] >> 4]]], t += ct[ht[ut[e[n] & 15]]];
  return t;
}
function jn(e) {
  const t = new Uint8Array(e.length * 2);
  for (let n = 0; n < e.length; ++n)
    t[n * 2] = ut[e[n] >> 4], t[n * 2 + 1] = ut[e[n] & 15];
  return xe.decode(t);
}
function Xn(e) {
  const t = ve.encode(e || ""), n = new Uint8Array(Math.floor(t.length / 2));
  let r;
  for (r = 0; r < n.length; r++) {
    const s = ht[t[r * 2]], i = ht[t[r * 2 + 1]];
    if (s === void 0 || i === void 0)
      break;
    n[r] = s << 4 | i;
  }
  return r === n.length ? n : n.slice(0, r);
}
function Yn(e) {
  return btoa(String.fromCharCode(...e));
}
function qn(e) {
  const t = atob(e), n = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    n[r] = t.charCodeAt(r);
  return n;
}
function N(e, t) {
  const n = Math.min(e.length, t.length);
  for (let r = 0; r < n; ++r)
    if (e[r] !== t[r])
      return e[r] < t[r] ? -1 : 1;
  return e.length === t.length ? 0 : e.length > t.length ? 1 : -1;
}
function Wt(e, t, n, r) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (r = r.toUpperCase(), n > 4294967295)
    throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${4294967295}. Received ${n}`);
  return r === "LE" ? (e[t] = n & 255, e[t + 1] = n >> 8 & 255, e[t + 2] = n >> 16 & 255, e[t + 3] = n >> 24 & 255) : (e[t] = n >> 24 & 255, e[t + 1] = n >> 16 & 255, e[t + 2] = n >> 8 & 255, e[t + 3] = n & 255), t + 4;
}
function te(e, t) {
  if (t + 1 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  return e[t];
}
function Tt(e, t, n) {
  if (t + 4 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n = n.toUpperCase(), n === "LE") {
    let r = 0;
    return r = (r << 8) + e[t + 3] >>> 0, r = (r << 8) + e[t + 2] >>> 0, r = (r << 8) + e[t + 1] >>> 0, r = (r << 8) + e[t] >>> 0, r;
  } else {
    let r = 0;
    return r = (r << 8) + e[t] >>> 0, r = (r << 8) + e[t + 1] >>> 0, r = (r << 8) + e[t + 2] >>> 0, r = (r << 8) + e[t + 3] >>> 0, r;
  }
}
function Zn(e, t, n, r) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  if (n > 0x7fffffffffffffffn || n < -0x8000000000000000n)
    throw new Error(`The value of "value" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${n}`);
  return r = r.toUpperCase(), r === "LE" ? (e[t] = Number(n & 0xffn), e[t + 1] = Number(n >> 8n & 0xffn), e[t + 2] = Number(n >> 16n & 0xffn), e[t + 3] = Number(n >> 24n & 0xffn), e[t + 4] = Number(n >> 32n & 0xffn), e[t + 5] = Number(n >> 40n & 0xffn), e[t + 6] = Number(n >> 48n & 0xffn), e[t + 7] = Number(n >> 56n & 0xffn)) : (e[t] = Number(n >> 56n & 0xffn), e[t + 1] = Number(n >> 48n & 0xffn), e[t + 2] = Number(n >> 40n & 0xffn), e[t + 3] = Number(n >> 32n & 0xffn), e[t + 4] = Number(n >> 24n & 0xffn), e[t + 5] = Number(n >> 16n & 0xffn), e[t + 6] = Number(n >> 8n & 0xffn), e[t + 7] = Number(n & 0xffn)), t + 8;
}
function Jn(e, t, n) {
  if (t + 8 > e.length)
    throw new Error("Offset is outside the bounds of Uint8Array");
  n = n.toUpperCase();
  let r = 0n;
  if (n === "LE")
    return r = (r << 8n) + BigInt(e[t + 7]), r = (r << 8n) + BigInt(e[t + 6]), r = (r << 8n) + BigInt(e[t + 5]), r = (r << 8n) + BigInt(e[t + 4]), r = (r << 8n) + BigInt(e[t + 3]), r = (r << 8n) + BigInt(e[t + 2]), r = (r << 8n) + BigInt(e[t + 1]), r = (r << 8n) + BigInt(e[t]), e[t + 7] <= 127 ? r : r - 0x10000000000000000n;
  {
    let s = 0n;
    return s = (s << 8n) + BigInt(e[t]), s = (s << 8n) + BigInt(e[t + 1]), s = (s << 8n) + BigInt(e[t + 2]), s = (s << 8n) + BigInt(e[t + 3]), s = (s << 8n) + BigInt(e[t + 4]), s = (s << 8n) + BigInt(e[t + 5]), s = (s << 8n) + BigInt(e[t + 6]), s = (s << 8n) + BigInt(e[t + 7]), e[t] <= 127 ? s : s - 0x10000000000000000n;
  }
}
const Qn = (e) => [...Array(e).keys()];
function tr(e) {
  if (e.key[0] !== U.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + d(e.key)
    );
  if (e.key.length !== 79 || ![2, 3].includes(e.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + d(e.key)
    );
  if (e.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const t = e.key.slice(1), n = {
    masterFingerprint: e.value.slice(0, 4),
    extendedPubkey: t,
    path: "m"
  };
  for (const r of Qn(e.value.length / 4 - 1)) {
    const s = Tt(e.value, r * 4 + 4, "LE"), i = !!(s & 2147483648), o = s & 2147483647;
    n.path += "/" + o.toString(10) + (i ? "'" : "");
  }
  return n;
}
function er(e) {
  const t = new Uint8Array([U.GLOBAL_XPUB]), n = P([t, e.extendedPubkey]), r = e.path.split("/"), s = new Uint8Array(r.length * 4);
  s.set(e.masterFingerprint, 0);
  let i = 4;
  return r.slice(1).forEach((o) => {
    const a = o.slice(-1) === "'";
    let u = 2147483647 & parseInt(a ? o.slice(0, -1) : o, 10);
    a && (u += 2147483648), Wt(s, i, u, "LE"), i += 4;
  }), {
    key: n,
    value: s
  };
}
const nr = "{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }";
function rr(e) {
  const t = e.extendedPubkey, n = e.masterFingerprint, r = e.path;
  return t instanceof Uint8Array && t.length === 78 && [2, 3].indexOf(t[45]) > -1 && n instanceof Uint8Array && n.length === 4 && typeof r == "string" && !!r.match(/^m(\/\d+'?)*$/);
}
function sr(e, t, n) {
  const r = d(t.extendedPubkey);
  return n.has(r) ? !1 : (n.add(r), e.filter((s) => N(s.extendedPubkey, t.extendedPubkey)).length === 0);
}
const ir = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: sr,
  check: rr,
  decode: tr,
  encode: er,
  expected: nr
}, Symbol.toStringTag, { value: "Module" }));
function or(e) {
  return {
    key: new Uint8Array([U.UNSIGNED_TX]),
    value: e.toBuffer()
  };
}
const ar = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  encode: or
}, Symbol.toStringTag, { value: "Module" }));
function cr(e) {
  if (e.key[0] !== p.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + d(e.key)
    );
  return e.value;
}
function ur(e) {
  return {
    key: new Uint8Array([p.FINAL_SCRIPTSIG]),
    value: e
  };
}
const hr = "Uint8Array";
function lr(e) {
  return e instanceof Uint8Array;
}
function fr(e, t) {
  return !!e && !!t && e.finalScriptSig === void 0;
}
const pr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: fr,
  check: lr,
  decode: cr,
  encode: ur,
  expected: hr
}, Symbol.toStringTag, { value: "Module" }));
function dr(e) {
  if (e.key[0] !== p.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + d(e.key)
    );
  return e.value;
}
function gr(e) {
  return {
    key: new Uint8Array([p.FINAL_SCRIPTWITNESS]),
    value: e
  };
}
const yr = "Uint8Array";
function wr(e) {
  return e instanceof Uint8Array;
}
function Sr(e, t) {
  return !!e && !!t && e.finalScriptWitness === void 0;
}
const Er = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Sr,
  check: wr,
  decode: dr,
  encode: gr,
  expected: yr
}, Symbol.toStringTag, { value: "Module" }));
function mr(e) {
  if (e.key[0] !== p.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + d(e.key)
    );
  return e.value;
}
function br(e) {
  return {
    key: new Uint8Array([p.NON_WITNESS_UTXO]),
    value: e
  };
}
const Tr = "Uint8Array";
function Ar(e) {
  return e instanceof Uint8Array;
}
function Ir(e, t) {
  return !!e && !!t && e.nonWitnessUtxo === void 0;
}
const kr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Ir,
  check: Ar,
  decode: mr,
  encode: br,
  expected: Tr
}, Symbol.toStringTag, { value: "Module" }));
function vr(e) {
  if (e.key[0] !== p.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + d(e.key)
    );
  if (!(e.key.length === 34 || e.key.length === 66) || ![2, 3, 4].includes(e.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + d(e.key)
    );
  return {
    pubkey: e.key.slice(1),
    signature: e.value
  };
}
function xr(e) {
  const t = new Uint8Array([p.PARTIAL_SIG]);
  return {
    key: P([t, e.pubkey]),
    value: e.signature
  };
}
const _r = "{ pubkey: Uint8Array; signature: Uint8Array; }";
function Ur(e) {
  return e.pubkey instanceof Uint8Array && e.signature instanceof Uint8Array && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && Pr(e.signature);
}
function Pr(e) {
  if (!(e instanceof Uint8Array) || e.length < 9 || e[0] !== 48 || e.length !== e[1] + 3 || e[2] !== 2) return !1;
  const t = e[3];
  if (t > 33 || t < 1 || e[3 + t + 1] !== 2) return !1;
  const n = e[3 + t + 2];
  return !(n > 33 || n < 1 || e.length !== 3 + t + 2 + n + 2);
}
function Nr(e, t, n) {
  const r = d(t.pubkey);
  return n.has(r) ? !1 : (n.add(r), e.filter((s) => N(s.pubkey, t.pubkey) === 0).length === 0);
}
const Hr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: Nr,
  check: Ur,
  decode: vr,
  encode: xr,
  expected: _r
}, Symbol.toStringTag, { value: "Module" }));
function Or(e) {
  if (e.key[0] !== p.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + d(e.key)
    );
  return Gn(e.value);
}
function Rr(e) {
  return {
    key: new Uint8Array([p.POR_COMMITMENT]),
    value: Vn(e)
  };
}
const Kr = "string";
function Cr(e) {
  return typeof e == "string";
}
function Fr(e, t) {
  return !!e && !!t && e.porCommitment === void 0;
}
const Br = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Fr,
  check: Cr,
  decode: Or,
  encode: Rr,
  expected: Kr
}, Symbol.toStringTag, { value: "Module" }));
function Wr(e) {
  if (e.key[0] !== p.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + d(e.key)
    );
  return Number(Tt(e.value, 0, "LE"));
}
function $r(e) {
  const t = Uint8Array.from([p.SIGHASH_TYPE]), n = new Uint8Array(4);
  return Wt(n, 0, e, "LE"), {
    key: t,
    value: n
  };
}
const Lr = "number";
function Mr(e) {
  return typeof e == "number";
}
function Dr(e, t) {
  return !!e && !!t && e.sighashType === void 0;
}
const Gr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Dr,
  check: Mr,
  decode: Wr,
  encode: $r,
  expected: Lr
}, Symbol.toStringTag, { value: "Module" }));
function Vr(e) {
  if (e.key[0] !== p.TAP_KEY_SIG || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + d(e.key)
    );
  if (!_e(e.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return e.value;
}
function zr(e) {
  return { key: Uint8Array.from([p.TAP_KEY_SIG]), value: e };
}
const jr = "Uint8Array";
function _e(e) {
  return e instanceof Uint8Array && (e.length === 64 || e.length === 65);
}
function Xr(e, t) {
  return !!e && !!t && e.tapKeySig === void 0;
}
const Yr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: Xr,
  check: _e,
  decode: Vr,
  encode: zr,
  expected: jr
}, Symbol.toStringTag, { value: "Module" }));
function qr(e) {
  if (e.key[0] !== p.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + d(e.key)
    );
  if ((e.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + d(e.key)
    );
  const t = e.value[e.value.length - 1];
  if ((e.key[1] & 254) !== t)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + d(e.key)
    );
  const n = e.value.slice(0, -1);
  return { controlBlock: e.key.slice(1), script: n, leafVersion: t };
}
function Zr(e) {
  const t = Uint8Array.from([p.TAP_LEAF_SCRIPT]), n = Uint8Array.from([e.leafVersion]);
  return {
    key: P([t, e.controlBlock]),
    value: P([e.script, n])
  };
}
const Jr = "{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }";
function Qr(e) {
  return e.controlBlock instanceof Uint8Array && (e.controlBlock.length - 1) % 32 === 0 && (e.controlBlock[0] & 254) === e.leafVersion && e.script instanceof Uint8Array;
}
function ts(e, t, n) {
  const r = d(t.controlBlock);
  return n.has(r) ? !1 : (n.add(r), e.filter((s) => N(s.controlBlock, t.controlBlock) === 0).length === 0);
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: ts,
  check: Qr,
  decode: qr,
  encode: Zr,
  expected: Jr
}, Symbol.toStringTag, { value: "Module" }));
function ns(e) {
  if (e.key[0] !== p.TAP_MERKLE_ROOT || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + d(e.key)
    );
  if (!Ue(e.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return e.value;
}
function rs(e) {
  return { key: Uint8Array.from([p.TAP_MERKLE_ROOT]), value: e };
}
const ss = "Uint8Array";
function Ue(e) {
  return e instanceof Uint8Array && e.length === 32;
}
function is(e, t) {
  return !!e && !!t && e.tapMerkleRoot === void 0;
}
const os = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: is,
  check: Ue,
  decode: ns,
  encode: rs,
  expected: ss
}, Symbol.toStringTag, { value: "Module" }));
function as(e) {
  if (e.key[0] !== p.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + d(e.key)
    );
  if (e.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + d(e.key)
    );
  if (e.value.length !== 64 && e.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + d(e.key)
    );
  const t = e.key.slice(1, 33), n = e.key.slice(33);
  return {
    pubkey: t,
    leafHash: n,
    signature: e.value
  };
}
function cs(e) {
  const t = Uint8Array.from([p.TAP_SCRIPT_SIG]);
  return {
    key: P([t, e.pubkey, e.leafHash]),
    value: e.signature
  };
}
const us = "{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }";
function hs(e) {
  return e.pubkey instanceof Uint8Array && e.leafHash instanceof Uint8Array && e.signature instanceof Uint8Array && e.pubkey.length === 32 && e.leafHash.length === 32 && (e.signature.length === 64 || e.signature.length === 65);
}
function ls(e, t, n) {
  const r = d(t.pubkey) + d(t.leafHash);
  return n.has(r) ? !1 : (n.add(r), e.filter(
    (s) => N(s.pubkey, t.pubkey) === 0 && N(s.leafHash, t.leafHash) === 0
  ).length === 0);
}
const fs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAddToArray: ls,
  check: hs,
  decode: as,
  encode: cs,
  expected: us
}, Symbol.toStringTag, { value: "Module" }));
function ps(e) {
  if (e.key[0] !== p.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + d(e.key)
    );
  const t = Jn(e.value, 0, "LE");
  let n = 8;
  const { numberValue: r, bytes: s } = Y(
    e.value,
    n
  );
  n += s;
  const i = e.value.slice(n);
  if (i.length !== r)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: i,
    value: t
  };
}
function ds(e) {
  const { script: t, value: n } = e, r = V(t.length), s = new Uint8Array(8 + r + t.length);
  return Zn(s, 0, BigInt(n), "LE"), z(t.length, s, 8), s.set(t, 8 + r), {
    key: Uint8Array.from([p.WITNESS_UTXO]),
    value: s
  };
}
const gs = "{ script: Uint8Array; value: bigint; }";
function ys(e) {
  return e.script instanceof Uint8Array && typeof e.value == "bigint";
}
function ws(e, t) {
  return !!e && !!t && e.witnessUtxo === void 0;
}
const Ss = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: ws,
  check: ys,
  decode: ps,
  encode: ds,
  expected: gs
}, Symbol.toStringTag, { value: "Module" }));
function Es(e) {
  if (e.key[0] !== E.TAP_TREE || e.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + d(e.key)
    );
  let t = 0;
  const n = [];
  for (; t < e.value.length; ) {
    const r = e.value[t++], s = e.value[t++], { numberValue: i, bytes: o } = Y(
      e.value,
      t
    );
    t += o, n.push({
      depth: r,
      leafVersion: s,
      script: e.value.slice(t, t + i)
    }), t += i;
  }
  return { leaves: n };
}
function ms(e) {
  const t = Uint8Array.from([E.TAP_TREE]), n = [].concat(
    ...e.leaves.map((r) => [
      Uint8Array.of(r.depth, r.leafVersion),
      z(BigInt(r.script.length)).buffer,
      r.script
    ])
  );
  return {
    key: t,
    value: P(n)
  };
}
const bs = "{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }";
function Ts(e) {
  return Array.isArray(e.leaves) && e.leaves.every(
    (t) => t.depth >= 0 && t.depth <= 128 && (t.leafVersion & 254) === t.leafVersion && t.script instanceof Uint8Array
  );
}
function As(e, t) {
  return !!e && !!t && e.tapTree === void 0;
}
const Is = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  canAdd: As,
  check: Ts,
  decode: Es,
  encode: ms,
  expected: bs
}, Symbol.toStringTag, { value: "Module" })), ks = (e) => [...Array(e).keys()], vs = (e) => e.length === 33 && [2, 3].includes(e[0]) || e.length === 65 && e[0] === 4;
function $t(e, t = vs) {
  function n(a) {
    if (a.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + d(a.key)
      );
    const u = a.key.slice(1);
    if (!t(u))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + d(a.key)
      );
    if (a.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const l = {
      masterFingerprint: a.value.slice(0, 4),
      pubkey: u,
      path: "m"
    };
    for (const f of ks(a.value.length / 4 - 1)) {
      const c = Tt(a.value, f * 4 + 4, "LE"), h = !!(c & 2147483648), S = c & 2147483647;
      l.path += "/" + S.toString(10) + (h ? "'" : "");
    }
    return l;
  }
  function r(a) {
    const u = Uint8Array.from([e]), l = P([u, a.pubkey]), f = a.path.split("/"), c = new Uint8Array(f.length * 4);
    c.set(a.masterFingerprint, 0);
    let h = 4;
    return f.slice(1).forEach((S) => {
      const g = S.slice(-1) === "'";
      let y = 2147483647 & parseInt(g ? S.slice(0, -1) : S, 10);
      g && (y += 2147483648), Wt(c, h, y, "LE"), h += 4;
    }), {
      key: l,
      value: c
    };
  }
  const s = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }";
  function i(a) {
    return a.pubkey instanceof Uint8Array && a.masterFingerprint instanceof Uint8Array && typeof a.path == "string" && t(a.pubkey) && a.masterFingerprint.length === 4;
  }
  function o(a, u, l) {
    const f = d(u.pubkey);
    return l.has(f) ? !1 : (l.add(f), a.filter((c) => N(c.pubkey, u.pubkey) === 0).length === 0);
  }
  return {
    decode: n,
    encode: r,
    check: i,
    expected: s,
    canAddToArray: o
  };
}
function Lt(e) {
  return t;
  function t(n) {
    let r;
    if (e.includes(n.key[0]) && (r = n.key.slice(1), !(r.length === 33 || r.length === 65) || ![2, 3, 4].includes(r[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + d(n.key)
      );
    return r;
  }
}
function Pe(e) {
  function t(o) {
    if (o.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + d(o.key)
      );
    return o.value;
  }
  function n(o) {
    return {
      key: Uint8Array.from([e]),
      value: o
    };
  }
  const r = "Uint8Array";
  function s(o) {
    return o instanceof Uint8Array;
  }
  function i(o, a) {
    return !!o && !!a && o.redeemScript === void 0;
  }
  return {
    decode: t,
    encode: n,
    check: s,
    expected: r,
    canAdd: i
  };
}
const xs = (e) => e.length === 32;
function Ne(e) {
  const t = $t(e, xs);
  function n(o) {
    const { numberValue: a, bytes: u } = Y(
      o.value
    ), l = t.decode({
      key: o.key,
      value: o.value.slice(u + Number(a) * 32)
    }), f = new Array(Number(a));
    for (let c = 0, h = u; c < a; c++, h += 32)
      f[c] = o.value.slice(h, h + 32);
    return { ...l, leafHashes: f };
  }
  function r(o) {
    const a = t.encode(o), u = V(o.leafHashes.length), l = new Uint8Array(u);
    z(o.leafHashes.length, l);
    const f = P([l, ...o.leafHashes, a.value]);
    return { ...a, value: f };
  }
  const s = "{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; leafHashes: Uint8Array[]; }";
  function i(o) {
    return Array.isArray(o.leafHashes) && o.leafHashes.every(
      (a) => a instanceof Uint8Array && a.length === 32
    ) && t.check(o);
  }
  return {
    decode: n,
    encode: r,
    check: i,
    expected: s,
    canAddToArray: t.canAddToArray
  };
}
function He(e) {
  function t(o) {
    if (o.key[0] !== e || o.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + d(o.key)
      );
    if (o.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return o.value;
  }
  function n(o) {
    return { key: Uint8Array.from([e]), value: o };
  }
  const r = "Uint8Array";
  function s(o) {
    return o instanceof Uint8Array && o.length === 32;
  }
  function i(o, a) {
    return !!o && !!a && o.tapInternalKey === void 0;
  }
  return {
    decode: t,
    encode: n,
    check: s,
    expected: r,
    canAdd: i
  };
}
function Oe(e) {
  function t(o) {
    if (o.key[0] !== e)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + d(o.key)
      );
    return o.value;
  }
  function n(o) {
    return {
      key: Uint8Array.from([e]),
      value: o
    };
  }
  const r = "Uint8Array";
  function s(o) {
    return o instanceof Uint8Array;
  }
  function i(o, a) {
    return !!o && !!a && o.witnessScript === void 0;
  }
  return {
    decode: t,
    encode: n,
    check: s,
    expected: r,
    canAdd: i
  };
}
const Mt = {
  unsignedTx: ar,
  globalXpub: ir,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: Lt([])
}, m = {
  nonWitnessUtxo: kr,
  partialSig: Hr,
  sighashType: Gr,
  finalScriptSig: pr,
  finalScriptWitness: Er,
  porCommitment: Br,
  witnessUtxo: Ss,
  bip32Derivation: $t(p.BIP32_DERIVATION),
  redeemScript: Pe(p.REDEEM_SCRIPT),
  witnessScript: Oe(p.WITNESS_SCRIPT),
  checkPubkey: Lt([
    p.PARTIAL_SIG,
    p.BIP32_DERIVATION
  ]),
  tapKeySig: Yr,
  tapScriptSig: fs,
  tapLeafScript: es,
  tapBip32Derivation: Ne(
    p.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: He(p.TAP_INTERNAL_KEY),
  tapMerkleRoot: os
}, H = {
  bip32Derivation: $t(E.BIP32_DERIVATION),
  redeemScript: Pe(E.REDEEM_SCRIPT),
  witnessScript: Oe(E.WITNESS_SCRIPT),
  checkPubkey: Lt([E.BIP32_DERIVATION]),
  tapBip32Derivation: Ne(
    E.TAP_BIP32_DERIVATION
  ),
  tapTree: Is,
  tapInternalKey: He(E.TAP_INTERNAL_KEY)
}, _s = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  globals: Mt,
  inputs: m,
  outputs: H
}, Symbol.toStringTag, { value: "Module" })), lt = (e) => [...Array(e).keys()];
function ee(e) {
  const t = e.map(Us);
  return t.push(Uint8Array.from([0])), P(t);
}
function Us(e) {
  const t = e.key.length, n = e.value.length, r = V(t), s = V(n), i = new Uint8Array(r + t + s + n);
  return z(t, i, 0), i.set(e.key, r), z(n, i, r + t), i.set(e.value, r + t + s), i;
}
function Ps(e, t) {
  let n = 0;
  function r() {
    const { numberValue: w, bytes: I } = Y(e, n);
    n += I;
    const R = e.slice(n, n + Number(w));
    return n += Number(w), R;
  }
  function s() {
    const w = Tt(e, n, "BE");
    return n += 4, w;
  }
  function i() {
    const w = te(e, n);
    return n += 1, w;
  }
  function o() {
    const w = r(), I = r();
    return {
      key: w,
      value: I
    };
  }
  function a() {
    if (n >= e.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const w = te(e, n) === 0;
    return w && n++, w;
  }
  if (s() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (i() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const u = [], l = {};
  for (; !a(); ) {
    const w = o(), I = d(w.key);
    if (l[I])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + I
      );
    l[I] = 1, u.push(w);
  }
  const f = u.filter(
    (w) => w.key[0] === U.UNSIGNED_TX
  );
  if (f.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const c = t(f[0].value), { inputCount: h, outputCount: S } = c.getInputOutputCounts(), g = [], y = [];
  for (const w of lt(h)) {
    const I = {}, R = [];
    for (; !a(); ) {
      const W = o(), K = d(W.key);
      if (I[K])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + w + " key " + K
        );
      I[K] = 1, R.push(W);
    }
    g.push(R);
  }
  for (const w of lt(S)) {
    const I = {}, R = [];
    for (; !a(); ) {
      const W = o(), K = d(W.key);
      if (I[K])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + w + " key " + K
        );
      I[K] = 1, R.push(W);
    }
    y.push(R);
  }
  return Re(c, {
    globalMapKeyVals: u,
    inputKeyVals: g,
    outputKeyVals: y
  });
}
function A(e, t, n) {
  if (N(t, Uint8Array.from([n])))
    throw new Error(
      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,
      `Format Error: Invalid ${e} key: ${d(t)}`
    );
}
function Re(e, { globalMapKeyVals: t, inputKeyVals: n, outputKeyVals: r }) {
  const s = {
    unsignedTx: e
  };
  let i = 0;
  for (const f of t)
    switch (f.key[0]) {
      case U.UNSIGNED_TX:
        if (A("global", f.key, U.UNSIGNED_TX), i > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        i++;
        break;
      case U.GLOBAL_XPUB:
        s.globalXpub === void 0 && (s.globalXpub = []), s.globalXpub.push(Mt.globalXpub.decode(f));
        break;
      default:
        s.unknownKeyVals || (s.unknownKeyVals = []), s.unknownKeyVals.push(f);
    }
  const o = n.length, a = r.length, u = [], l = [];
  for (const f of lt(o)) {
    const c = {};
    for (const h of n[f])
      switch (m.checkPubkey(h), h.key[0]) {
        case p.NON_WITNESS_UTXO:
          if (A("input", h.key, p.NON_WITNESS_UTXO), c.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          c.nonWitnessUtxo = m.nonWitnessUtxo.decode(h);
          break;
        case p.WITNESS_UTXO:
          if (A("input", h.key, p.WITNESS_UTXO), c.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          c.witnessUtxo = m.witnessUtxo.decode(h);
          break;
        case p.PARTIAL_SIG:
          c.partialSig === void 0 && (c.partialSig = []), c.partialSig.push(m.partialSig.decode(h));
          break;
        case p.SIGHASH_TYPE:
          if (A("input", h.key, p.SIGHASH_TYPE), c.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          c.sighashType = m.sighashType.decode(h);
          break;
        case p.REDEEM_SCRIPT:
          if (A("input", h.key, p.REDEEM_SCRIPT), c.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          c.redeemScript = m.redeemScript.decode(h);
          break;
        case p.WITNESS_SCRIPT:
          if (A("input", h.key, p.WITNESS_SCRIPT), c.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          c.witnessScript = m.witnessScript.decode(h);
          break;
        case p.BIP32_DERIVATION:
          c.bip32Derivation === void 0 && (c.bip32Derivation = []), c.bip32Derivation.push(
            m.bip32Derivation.decode(h)
          );
          break;
        case p.FINAL_SCRIPTSIG:
          A("input", h.key, p.FINAL_SCRIPTSIG), c.finalScriptSig = m.finalScriptSig.decode(h);
          break;
        case p.FINAL_SCRIPTWITNESS:
          A("input", h.key, p.FINAL_SCRIPTWITNESS), c.finalScriptWitness = m.finalScriptWitness.decode(
            h
          );
          break;
        case p.POR_COMMITMENT:
          A("input", h.key, p.POR_COMMITMENT), c.porCommitment = m.porCommitment.decode(h);
          break;
        case p.TAP_KEY_SIG:
          A("input", h.key, p.TAP_KEY_SIG), c.tapKeySig = m.tapKeySig.decode(h);
          break;
        case p.TAP_SCRIPT_SIG:
          c.tapScriptSig === void 0 && (c.tapScriptSig = []), c.tapScriptSig.push(m.tapScriptSig.decode(h));
          break;
        case p.TAP_LEAF_SCRIPT:
          c.tapLeafScript === void 0 && (c.tapLeafScript = []), c.tapLeafScript.push(m.tapLeafScript.decode(h));
          break;
        case p.TAP_BIP32_DERIVATION:
          c.tapBip32Derivation === void 0 && (c.tapBip32Derivation = []), c.tapBip32Derivation.push(
            m.tapBip32Derivation.decode(h)
          );
          break;
        case p.TAP_INTERNAL_KEY:
          A("input", h.key, p.TAP_INTERNAL_KEY), c.tapInternalKey = m.tapInternalKey.decode(h);
          break;
        case p.TAP_MERKLE_ROOT:
          A("input", h.key, p.TAP_MERKLE_ROOT), c.tapMerkleRoot = m.tapMerkleRoot.decode(h);
          break;
        default:
          c.unknownKeyVals || (c.unknownKeyVals = []), c.unknownKeyVals.push(h);
      }
    u.push(c);
  }
  for (const f of lt(a)) {
    const c = {};
    for (const h of r[f])
      switch (H.checkPubkey(h), h.key[0]) {
        case E.REDEEM_SCRIPT:
          if (A("output", h.key, E.REDEEM_SCRIPT), c.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          c.redeemScript = H.redeemScript.decode(h);
          break;
        case E.WITNESS_SCRIPT:
          if (A("output", h.key, E.WITNESS_SCRIPT), c.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          c.witnessScript = H.witnessScript.decode(h);
          break;
        case E.BIP32_DERIVATION:
          c.bip32Derivation === void 0 && (c.bip32Derivation = []), c.bip32Derivation.push(
            H.bip32Derivation.decode(h)
          );
          break;
        case E.TAP_INTERNAL_KEY:
          A("output", h.key, E.TAP_INTERNAL_KEY), c.tapInternalKey = H.tapInternalKey.decode(h);
          break;
        case E.TAP_TREE:
          A("output", h.key, E.TAP_TREE), c.tapTree = H.tapTree.decode(h);
          break;
        case E.TAP_BIP32_DERIVATION:
          c.tapBip32Derivation === void 0 && (c.tapBip32Derivation = []), c.tapBip32Derivation.push(
            H.tapBip32Derivation.decode(h)
          );
          break;
        default:
          c.unknownKeyVals || (c.unknownKeyVals = []), c.unknownKeyVals.push(h);
      }
    l.push(c);
  }
  return { globalMap: s, inputs: u, outputs: l };
}
function Ns({ globalMap: e, inputs: t, outputs: n }) {
  const { globalKeyVals: r, inputKeyVals: s, outputKeyVals: i } = Rt({
    globalMap: e,
    inputs: t,
    outputs: n
  }), o = ee(r), a = (c) => c.length === 0 ? [Uint8Array.from([0])] : c.map(ee), u = a(s), l = a(i), f = new Uint8Array(5);
  return f.set([112, 115, 98, 116, 255], 0), P(
    [f, o].concat(u, l)
  );
}
const Hs = (e, t) => N(e.key, t.key);
function xt(e, t) {
  const n = /* @__PURE__ */ new Set(), r = Object.entries(e).reduce((i, [o, a]) => {
    if (o === "unknownKeyVals") return i;
    const u = t[o];
    if (u === void 0) return i;
    const l = (Array.isArray(a) ? a : [a]).map(
      u.encode
    );
    return l.map((c) => d(c.key)).forEach((c) => {
      if (n.has(c))
        throw new Error("Serialize Error: Duplicate key: " + c);
      n.add(c);
    }), i.concat(l);
  }, []), s = e.unknownKeyVals ? e.unknownKeyVals.filter((i) => !n.has(d(i.key))) : [];
  return r.concat(s).sort(Hs);
}
function Rt({ globalMap: e, inputs: t, outputs: n }) {
  return {
    globalKeyVals: xt(e, Mt),
    inputKeyVals: t.map((r) => xt(r, m)),
    outputKeyVals: n.map((r) => xt(r, H))
  };
}
function Os(e) {
  const t = e[0], n = Rt(t), r = e.slice(1);
  if (r.length === 0) throw new Error("Combine: Nothing to combine");
  const s = ne(t);
  if (s === void 0)
    throw new Error("Combine: Self missing transaction");
  const i = C(n.globalKeyVals), o = n.inputKeyVals.map(C), a = n.outputKeyVals.map(C);
  for (const u of r) {
    const l = ne(u);
    if (l === void 0 || N(l.toBuffer(), s.toBuffer()) !== 0)
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const f = Rt(u);
    C(f.globalKeyVals).forEach(
      _t(
        i,
        n.globalKeyVals,
        f.globalKeyVals
      )
    ), f.inputKeyVals.map(C).forEach(
      (g, y) => g.forEach(
        _t(
          o[y],
          n.inputKeyVals[y],
          f.inputKeyVals[y]
        )
      )
    ), f.outputKeyVals.map(C).forEach(
      (g, y) => g.forEach(
        _t(
          a[y],
          n.outputKeyVals[y],
          f.outputKeyVals[y]
        )
      )
    );
  }
  return Re(s, {
    globalMapKeyVals: n.globalKeyVals,
    inputKeyVals: n.inputKeyVals,
    outputKeyVals: n.outputKeyVals
  });
}
function _t(e, t, n) {
  return (r) => {
    if (e.has(r)) return;
    const s = n.filter((i) => d(i.key) === r)[0];
    t.push(s), e.add(r);
  };
}
function ne(e) {
  return e.globalMap.unsignedTx;
}
function C(e) {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((n) => {
    const r = d(n.key);
    if (t.has(r))
      throw new Error("Combine: KeyValue Map keys should be unique");
    t.add(r);
  }), t;
}
function T(e, t) {
  const n = e[t];
  if (n === void 0) throw new Error(`No input #${t}`);
  return n;
}
function X(e, t) {
  const n = e[t];
  if (n === void 0) throw new Error(`No output #${t}`);
  return n;
}
function Ut(e, t, n) {
  if (e.key[0] < n)
    throw new Error(
      "Use the method for your specific key instead of addUnknownKeyVal*"
    );
  if (t && t.filter((r) => N(r.key, e.key) === 0).length !== 0)
    throw new Error(`Duplicate Key: ${d(e.key)}`);
}
function Pt(e) {
  let t = 0;
  return Object.keys(e).forEach((n) => {
    Number(isNaN(Number(n))) && t++;
  }), t;
}
function Rs(e, t) {
  let n = !1;
  if (t.nonWitnessUtxo || t.witnessUtxo) {
    const r = !!t.redeemScript, s = !!t.witnessScript, i = !r || !!t.finalScriptSig, o = !s || !!t.finalScriptWitness, a = !!t.finalScriptSig || !!t.finalScriptWitness;
    n = i && o && a;
  }
  if (n === !1)
    throw new Error(
      `Input #${e} has too much or too little data to clean`
    );
}
function re(e, t, n, r) {
  throw new Error(
    `Data for ${e} key ${t} is incorrect: Expected ${n} and got ${JSON.stringify(r)}`
  );
}
function Dt(e) {
  return (t, n) => {
    for (const r of Object.keys(t)) {
      const s = t[r], { canAdd: i, canAddToArray: o, check: a, expected: u } = (
        // @ts-ignore
        _s[e + "s"][r] || {}
      ), l = !!o;
      if (a)
        if (l) {
          if (!Array.isArray(s) || // @ts-ignore
          n[r] && !Array.isArray(n[r]))
            throw new Error(`Key type ${r} must be an array`);
          s.every(a) || re(e, r, u, s);
          const f = n[r] || [], c = /* @__PURE__ */ new Set();
          if (!s.every((h) => o(f, h, c)))
            throw new Error("Can not add duplicate data to array");
          n[r] = f.concat(s);
        } else {
          if (a(s) || re(e, r, u, s), !i(n, s))
            throw new Error(`Can not add duplicate data to ${e}`);
          n[r] = s;
        }
    }
  };
}
const Ks = Dt("global"), Ke = Dt("input"), Ce = Dt("output");
function Cs(e, t) {
  const n = e.length - 1, r = T(e, n);
  Ke(t, r);
}
function Fs(e, t) {
  const n = e.length - 1, r = X(e, n);
  Ce(t, r);
}
let se = class {
  constructor(t) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: t
    };
  }
  static fromBase64(t, n) {
    const r = qn(t);
    return this.fromBuffer(r, n);
  }
  static fromHex(t, n) {
    const r = Xn(t);
    return this.fromBuffer(r, n);
  }
  static fromBuffer(t, n) {
    const r = Ps(t, n), s = new this(r.globalMap.unsignedTx);
    return Object.assign(s, r), s;
  }
  toBase64() {
    const t = this.toBuffer();
    return Yn(t);
  }
  toHex() {
    const t = this.toBuffer();
    return d(t);
  }
  toBuffer() {
    return Ns(this);
  }
  updateGlobal(t) {
    return Ks(t, this.globalMap), this;
  }
  updateInput(t, n) {
    const r = T(this.inputs, t);
    return Ke(n, r), this;
  }
  updateOutput(t, n) {
    const r = X(this.outputs, t);
    return Ce(n, r), this;
  }
  addUnknownKeyValToGlobal(t) {
    return Ut(
      t,
      this.globalMap.unknownKeyVals,
      Pt(U)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(t), this;
  }
  addUnknownKeyValToInput(t, n) {
    const r = T(this.inputs, t);
    return Ut(n, r.unknownKeyVals, Pt(p)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(n), this;
  }
  addUnknownKeyValToOutput(t, n) {
    const r = X(this.outputs, t);
    return Ut(n, r.unknownKeyVals, Pt(E)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(n), this;
  }
  addInput(t) {
    this.globalMap.unsignedTx.addInput(t), this.inputs.push({
      unknownKeyVals: []
    });
    const n = t.unknownKeyVals || [], r = this.inputs.length - 1;
    if (!Array.isArray(n))
      throw new Error("unknownKeyVals must be an Array");
    return n.forEach(
      (s) => this.addUnknownKeyValToInput(r, s)
    ), Cs(this.inputs, t), this;
  }
  addOutput(t) {
    this.globalMap.unsignedTx.addOutput(t), this.outputs.push({
      unknownKeyVals: []
    });
    const n = t.unknownKeyVals || [], r = this.outputs.length - 1;
    if (!Array.isArray(n))
      throw new Error("unknownKeyVals must be an Array");
    return n.forEach(
      (s) => this.addUnknownKeyValToOutput(r, s)
    ), Fs(this.outputs, t), this;
  }
  clearFinalizedInput(t) {
    const n = T(this.inputs, t);
    Rs(t, n);
    for (const r of Object.keys(n))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(r) || delete n[r];
    return this;
  }
  combine(...t) {
    const n = Os([this].concat(t));
    return Object.assign(this, n), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
function tt(e) {
  if (typeof e != "number" || e !== Math.floor(e) || e > 4294967295 || e < 0)
    throw new Error("Invalid 32 bit integer");
}
function Nt(e) {
  if (e.unsafeSignNonSegwit)
    throw new Error("Not BIP174 compliant, can not export");
}
function Kt(e) {
  return !!e.finalScriptSig || !!e.finalScriptWitness;
}
function Bs(e) {
  if (!e.ins.every(
    (n) => n.script && n.script.length === 0 && n.witness && n.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function Fe(e, t) {
  const n = st(new Uint8Array(t.hash)), r = `${B(n)}:${t.index}`;
  if (e.txInCache[r]) throw new Error("Duplicate input detected.");
  e.txInCache[r] = 1;
}
function Ws(e, t) {
  e.ins.forEach((n) => {
    Fe(t, n);
  });
}
function $(e, t, n) {
  n !== !1 && e.forEach((r) => {
    if (O(r) ? gn(r, t) : yn(r, t)) throw new Error("Can not modify transaction, signatures exist.");
  });
}
function $s(e) {
  if (!e.sighashType || !e.partialSig) return;
  const { partialSig: t, sighashType: n } = e;
  t.forEach((r) => {
    const { hashType: s } = et.decode(r.signature);
    if (n !== s)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function Be(e, t, n) {
  if (!it(e, t))
    throw new Error(`Can not ${n} for this input with the key ${B(e)}`);
}
function We(e, t) {
  return (n, r, s, i) => {
    const o = e({
      redeem: { output: s }
    }).output;
    if (!k(r, o))
      throw new Error(
        `${t} for ${i} #${n} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const ie = We(gt, "Redeem script"), oe = We(yt, "Witness script");
function ae(e) {
  let t = 0;
  function n(o) {
    return t += o, e.subarray(t - o, t);
  }
  function r() {
    const o = Y(e, t);
    return t += o.bytes, o.numberValue || 0;
  }
  function s() {
    return n(r());
  }
  function i() {
    const o = r(), a = [];
    for (let u = 0; u < o; u++) a.push(s());
    return a;
  }
  return i();
}
function Ls(e) {
  let t = e & b.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (e & 31) {
    case b.SIGHASH_ALL:
      t += "SIGHASH_ALL";
      break;
    case b.SIGHASH_SINGLE:
      t += "SIGHASH_SINGLE";
      break;
    case b.SIGHASH_NONE:
      t += "SIGHASH_NONE";
      break;
  }
  return t;
}
function Ms(e) {
  if (e.length === 65) {
    const t = e[64] & 1, n = new Uint8Array(e.subarray(0, 33));
    return n[0] = 2 | t, n;
  }
  return new Uint8Array(e);
}
function ce(e) {
  return e.length === 33 && mn(e);
}
function Ds(e) {
  return bn(e);
}
function Gt(e) {
  return Et(e) ? "witnesspubkeyhash" : wn(e) ? "pubkeyhash" : Sn(e) ? "multisig" : En(e) ? "pubkey" : "nonstandard";
}
function L(e) {
  return [...Array(e).keys()];
}
function ft(e) {
  if (Et(e) || Se(e))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function pt(e, t, n, r, s) {
  const i = Se(e), o = i && r && jt(r), a = jt(e);
  if (i && r === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  let u;
  if (o) {
    if (!s)
      throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    if (!r) throw new Error("P2SH-P2WSH requires redeemScript");
    u = s, ie(t, e, r, n), oe(t, r, s, n), ft(u);
  } else if (a) {
    if (!s)
      throw new Error("scriptPubkey or redeemScript is P2WSH but witnessScript missing");
    u = s, oe(t, e, s, n), ft(u);
  } else if (i) {
    if (!r) throw new Error("P2SH requires redeemScript");
    u = r, ie(t, e, r, n);
  } else
    u = e;
  return {
    meaningfulScript: u,
    type: o ? "p2sh-p2wsh" : i ? "p2sh" : a ? "p2wsh" : "raw"
  };
}
class Gs {
  nonWitnessUtxoTxCache;
  nonWitnessUtxoBufCache;
  txInCache;
  tx;
  unsafeSignNonSegwit;
  hasSignatures;
  fee;
  feeRate;
  extractedTx;
  prevOuts;
  signingScripts;
  values;
  taprootHashCache;
  constructor(t) {
    this.nonWitnessUtxoTxCache = [], this.nonWitnessUtxoBufCache = [], this.txInCache = {}, this.tx = t, this.unsafeSignNonSegwit = !1, this.hasSignatures = !1;
  }
  /**
   * Invalidates cached computed values.
   * @param scope - 'full' clears everything (for input changes), 'outputs' clears fee/extract/taproot caches
   */
  invalidate(t) {
    this.fee = void 0, this.feeRate = void 0, this.extractedTx = void 0, this.taprootHashCache = void 0, t === "full" && (this.prevOuts = void 0, this.signingScripts = void 0, this.values = void 0);
  }
  addNonWitnessTxCache(t, n, r) {
    if (!t.nonWitnessUtxo) throw new Error("nonWitnessUtxo is required");
    if (t === null || t === Object.prototype)
      throw new Error("Invalid input object");
    const s = t.nonWitnessUtxo;
    this.nonWitnessUtxoBufCache[n] = s, this.nonWitnessUtxoTxCache[n] = r(s);
  }
  getNonWitnessUtxoTx(t, n, r) {
    return this.nonWitnessUtxoTxCache[n] || this.addNonWitnessTxCache(t, n, r), this.nonWitnessUtxoTxCache[n];
  }
  getScriptFromUtxo(t, n, r) {
    const { script: s } = this.getScriptAndAmountFromUtxo(t, n, r);
    return s;
  }
  getScriptAndAmountFromUtxo(t, n, r) {
    if (n.witnessUtxo !== void 0)
      return {
        script: n.witnessUtxo.script,
        value: n.witnessUtxo.value
      };
    if (n.nonWitnessUtxo !== void 0) {
      const s = this.getNonWitnessUtxoTx(n, t, r), i = this.tx.ins[t], o = s.outs[i.index];
      return { script: o.script, value: o.value };
    } else
      throw new Error("Can't find pubkey in input without Utxo data");
  }
  computeFee(t, n = !1, r) {
    if (!t.every(Kt)) throw new Error("PSBT must be finalized to calculate fee");
    if (this.fee !== void 0) return this.fee;
    let s, i = !0;
    this.extractedTx ? (s = this.extractedTx, i = !1) : s = this.tx.clone();
    const { fee: o } = this.finalizeAndComputeAmounts(
      t,
      s,
      i,
      n,
      r
    );
    return o;
  }
  computeFeeRate(t, n = !1, r) {
    if (!t.every(Kt))
      throw new Error("PSBT must be finalized to calculate fee rate");
    if (this.feeRate !== void 0) return this.feeRate;
    let s, i = !0;
    this.extractedTx ? (s = this.extractedTx, i = !1) : s = this.tx.clone();
    const { feeRate: o } = this.finalizeAndComputeAmounts(
      t,
      s,
      i,
      n,
      r
    );
    return o;
  }
  checkFees(t) {
    const n = this.feeRate;
    if (!this.extractedTx) throw new Error("Transaction not extracted");
    if (n === void 0) throw new Error("Fee rate not computed");
    const r = this.extractedTx.virtualSize(), s = n * r;
    if (n >= t.maximumFeeRate)
      throw new Error(
        `Warning: You are paying around ${(s / 1e8).toFixed(8)} in fees, which is ${n} satoshi per byte for a transaction with a VSize of ${r} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
      );
  }
  pubkeyInInput(t, n, r, s) {
    const i = this.getScriptFromUtxo(r, n, s), { meaningfulScript: o } = pt(
      i,
      r,
      "input",
      n.redeemScript,
      n.witnessScript
    );
    return it(t, o);
  }
  pubkeyInOutput(t, n, r) {
    const s = this.tx.outs[r].script, { meaningfulScript: i } = pt(
      s,
      r,
      "output",
      n.redeemScript,
      n.witnessScript
    );
    return it(t, i);
  }
  redeemFromFinalScriptSig(t) {
    if (!t) return;
    const n = D(t);
    if (!n) return;
    const r = n[n.length - 1];
    if (!(!(r instanceof Uint8Array) || ce(r) || Ds(r) || !D(r)))
      return r;
  }
  redeemFromFinalWitnessScript(t) {
    if (!t) return;
    const n = ae(t), r = n[n.length - 1];
    if (!(!r || ce(r) || !D(r)))
      return r;
  }
  /**
   * Finalize transaction inputs and compute fee amounts.
   * Returns computed values instead of mutating cache parameters directly.
   */
  finalizeAndComputeAmounts(t, n, r, s, i) {
    let o = 0n;
    t.forEach((h, S) => {
      const g = n.ins[S];
      if (r && h.finalScriptSig && (g.script = h.finalScriptSig), r && h.finalScriptWitness && (g.witness = ae(h.finalScriptWitness)), h.witnessUtxo)
        o += h.witnessUtxo.value;
      else if (h.nonWitnessUtxo) {
        if (!i)
          throw new Error("txFromBuffer is required for nonWitnessUtxo inputs");
        const y = this.getNonWitnessUtxoTx(h, S, i), w = g.index, I = y.outs[w];
        o += I.value;
      }
    });
    const a = n.outs.reduce((h, S) => h + S.value, 0n), u = o - a;
    if (!s && u < 0n)
      throw new Error(
        `Outputs are spending more than Inputs ${o} < ${a}`
      );
    const l = n.virtualSize(), f = Number(u), c = Math.floor(f / l);
    return this.fee = f, this.extractedTx = n, this.feeRate = c, { fee: f, feeRate: c };
  }
  getScriptFromInput(t, n, r) {
    const s = {
      script: null,
      isSegwit: !1,
      isP2SH: !1,
      isP2WSH: !1
    };
    if (s.isP2SH = !!n.redeemScript, s.isP2WSH = !!n.witnessScript, n.witnessScript)
      s.script = n.witnessScript;
    else if (n.redeemScript)
      s.script = n.redeemScript;
    else if (n.nonWitnessUtxo) {
      const i = this.getNonWitnessUtxoTx(n, t, r), o = this.tx.ins[t].index;
      s.script = i.outs[o].script;
    } else n.witnessUtxo && (s.script = n.witnessUtxo.script);
    return (n.witnessScript || s.script && Et(s.script) || s.script && me(s.script)) && (s.isSegwit = !0), s;
  }
  getPrevoutTaprootKey(t, n, r) {
    const { script: s } = this.getScriptAndAmountFromUtxo(t, n, r);
    return Tn(s) ? s.subarray(2, 34) : null;
  }
}
class Vs {
  #t;
  #e;
  constructor(t, n) {
    this.#t = t, this.#e = n;
  }
  getHashAndSighashType(t, n, r, s) {
    const i = T(t, n), { hash: o, sighashType: a, script: u } = this.getHashForSig(
      n,
      i,
      !1,
      s
    );
    return Be(r, u, "sign"), { hash: o, sighashType: a };
  }
  getHashForSig(t, n, r, s) {
    const i = this.#t.tx, o = n.sighashType || b.SIGHASH_ALL;
    ue(o, s);
    let a, u;
    if (n.nonWitnessUtxo) {
      const h = this.#t.getNonWitnessUtxoTx(
        n,
        t,
        this.#e
      ), S = i.ins[t], g = S.hash, y = h.getHash();
      if (!k(g, y))
        throw new Error(
          `Non-witness UTXO hash for input #${t} doesn't match the hash specified in the prevout`
        );
      const w = S.index;
      u = h.outs[w];
    } else if (n.witnessUtxo)
      u = {
        script: n.witnessUtxo.script,
        value: n.witnessUtxo.value
      };
    else
      throw new Error("Need a Utxo input item for signing");
    const { meaningfulScript: l, type: f } = pt(
      u.script,
      t,
      "input",
      n.redeemScript,
      n.witnessScript
    ), c = l;
    if (["p2sh-p2wsh", "p2wsh"].includes(f))
      a = i.hashForWitnessV0(t, c, u.value, o);
    else if (Et(l)) {
      const h = dt({
        hash: l.subarray(2)
      });
      if (!h.output) throw new Error("Unable to create signing script");
      a = i.hashForWitnessV0(
        t,
        h.output,
        u.value,
        o
      );
    } else {
      if (n.nonWitnessUtxo === void 0 && !this.#t.unsafeSignNonSegwit)
        throw new Error(
          `Input #${t} has witnessUtxo but non-segwit script: ` + B(l)
        );
      !r && this.#t.unsafeSignNonSegwit && console.warn(
        `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
      ), a = i.hashForSignature(t, c, o);
    }
    return { script: c, sighashType: o, hash: a };
  }
  getTaprootHashesForSig(t, n, r, s, i, o) {
    const a = this.#t.tx, u = n.sighashType || b.SIGHASH_DEFAULT;
    if (ue(u, o), !this.#t.prevOuts) {
      const g = r.map(
        (y, w) => this.#t.getScriptAndAmountFromUtxo(w, y, this.#e)
      );
      this.#t.prevOuts = g, this.#t.signingScripts = g.map((y) => y.script), this.#t.values = g.map((y) => y.value);
    }
    const l = this.#t.signingScripts, f = this.#t.values;
    this.#t.taprootHashCache || (this.#t.taprootHashCache = a.getTaprootHashCache(l, f));
    const c = this.#t.taprootHashCache, h = [];
    if (n.tapInternalKey && !i) {
      const g = this.#t.getPrevoutTaprootKey(t, n, this.#e) || new Uint8Array(0);
      if (k(nt(s), g)) {
        const y = a.hashForWitnessV1(
          t,
          l,
          f,
          u,
          void 0,
          void 0,
          c
        );
        h.push({ pubkey: s, hash: y });
      }
    }
    const S = (n.tapLeafScript || []).filter((g) => it(s, g.script)).map((g) => {
      const y = we({
        output: g.script,
        version: g.leafVersion
      });
      return Object.assign({ hash: y }, g);
    }).filter((g) => !i || k(i, g.hash)).map((g) => {
      const y = a.hashForWitnessV1(
        t,
        l,
        f,
        u,
        g.hash,
        void 0,
        c
      );
      return {
        pubkey: s,
        hash: y,
        leafHash: g.hash
      };
    });
    return h.concat(S);
  }
  getAllTaprootHashesForSig(t, n, r) {
    const s = [];
    if (n.tapInternalKey) {
      const o = this.#t.getPrevoutTaprootKey(t, n, this.#e);
      o && s.push(o);
    }
    if (n.tapScriptSig) {
      const o = n.tapScriptSig.map((a) => a.pubkey);
      s.push(...o);
    }
    return s.map(
      (o) => this.getTaprootHashesForSig(t, n, r, o)
    ).flat();
  }
  trimTaprootSig(t) {
    return t.length === 64 ? t : t.subarray(0, 64);
  }
  getSignersFromHD(t, n, r) {
    const s = T(n, t);
    if (!s.bip32Derivation || s.bip32Derivation.length === 0)
      throw new Error("Need bip32Derivation to sign with HD");
    const i = s.bip32Derivation.map((o) => {
      if (k(o.masterFingerprint, r.fingerprint))
        return o;
    }).filter((o) => !!o);
    if (i.length === 0)
      throw new Error(
        "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
      );
    return i.map((o) => {
      const a = r.derivePath(o.path);
      if (!k(o.pubkey, a.publicKey))
        throw new Error("pubkey did not match bip32Derivation");
      return a;
    });
  }
  bip32DerivationIsMine(t) {
    return (n) => {
      const r = t.fingerprint instanceof Uint8Array ? t.fingerprint : new Uint8Array(t.fingerprint);
      if (!k(n.masterFingerprint, r)) return !1;
      const s = t.derivePath(n.path).publicKey, i = s instanceof Uint8Array ? s : new Uint8Array(s);
      return !!k(i, n.pubkey);
    };
  }
}
function ue(e, t) {
  if (t && !t.includes(e)) {
    const n = Ls(e);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${n}`
    );
  }
}
class zs {
  #t;
  #e;
  constructor(t, n) {
    this.#t = t, this.#e = n;
  }
  getFinalScripts(t, n, r, s, i, o, a = !0, u) {
    const l = Gt(r);
    if (!$e(n, r, l) && a)
      throw new Error(`Can not finalize input #${t}`);
    if (!n.partialSig) throw new Error("Input missing partial signatures");
    return Vt(
      r,
      l,
      n.partialSig,
      s,
      i,
      o,
      u
    );
  }
  getScriptFromInput(t, n) {
    return this.#t.getScriptFromInput(t, n, this.#e);
  }
}
function js(e, t, n, r, s, i, o = !0, a) {
  const u = Gt(n);
  if (!$e(t, n, u) && o)
    throw new Error(`Can not finalize input #${e}`);
  if (!t.partialSig) throw new Error("Input missing partial signatures");
  return Vt(
    n,
    u,
    t.partialSig,
    r,
    s,
    i,
    a
  );
}
function Vt(e, t, n, r, s, i, o) {
  let a, u;
  const l = Xs(e, t, n), f = i ? yt({ redeem: l }) : null, c = s ? gt({ redeem: f || l }) : null;
  return r ? (f && f.witness ? u = rt(f.witness) : l && l.witness ? u = rt(l.witness) : u = rt(o ?? [new Uint8Array([0])]), c && (a = c?.input)) : c ? a = c?.input : l ? a = l.input : a = Array.isArray(o) && o[0] ? o[0] : new Uint8Array([1]), { finalScriptSig: a, finalScriptWitness: u };
}
function $e(e, t, n) {
  switch (n) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return he(1, e.partialSig);
    case "multisig": {
      const r = wt({
        output: t
      });
      if (r.m === void 0) throw new Error("Cannot determine m for multisig");
      return he(r.m, e.partialSig, r.pubkeys);
    }
    case "nonstandard":
      return !0;
    default:
      return !1;
  }
}
function he(e, t, n) {
  if (!t) return !1;
  let r;
  if (n ? r = n.map((s) => {
    const i = Ms(s);
    return t.find((o) => k(o.pubkey, i));
  }).filter((s) => !!s) : r = t, r.length > e) throw new Error("Too many signatures");
  return r.length === e;
}
function Xs(e, t, n) {
  const r = e;
  switch (t) {
    case "multisig": {
      const s = Ys(e, n);
      return wt({
        output: r,
        signatures: s
      });
    }
    case "pubkey": {
      const s = n[0];
      return ye({
        output: r,
        signature: s.signature
      });
    }
    case "pubkeyhash": {
      const s = n[0];
      return dt({
        output: r,
        pubkey: s.pubkey,
        signature: s.signature
      });
    }
    case "witnesspubkeyhash": {
      const s = n[0];
      return Ft({
        output: r,
        pubkey: s.pubkey,
        signature: s.signature
      });
    }
    default:
      throw new Error(`Unknown script type: ${t}`);
  }
}
function Ys(e, t) {
  const n = wt({ output: e });
  if (!n.pubkeys) throw new Error("Cannot extract pubkeys from multisig script");
  const r = [];
  for (const s of n.pubkeys) {
    const i = t.filter((o) => k(o.pubkey, s))[0];
    i && r.push(new Uint8Array(i.signature));
  }
  return r;
}
const qs = new Uint8Array([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
class Le {
  tx;
  constructor(t = qs) {
    this.tx = b.fromBuffer(t), Bs(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(t) {
    if (t.hash === void 0 || t.index === void 0 || !(t.hash instanceof Uint8Array) && typeof t.hash != "string" || typeof t.index != "number")
      throw new Error("Error adding input.");
    const n = typeof t.hash == "string" ? st(St(t.hash)) : t.hash;
    this.tx.addInput(n, t.index, t.sequence);
  }
  addOutput(t) {
    if (t.script === void 0 || t.value === void 0 || !(t.script instanceof Uint8Array) || typeof t.value != "bigint")
      throw new Error("Error adding output.");
    this.tx.addOutput(t.script, t.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
const Zs = (e) => new Le(e), Js = {
  network: G,
  maximumFeeRate: 5e3
};
function x(e) {
  return b.fromBuffer(e);
}
function Qs(e, t, n, r, s, i, o = !0, a) {
  return js(
    e,
    t,
    n,
    r,
    s,
    i,
    o,
    a
  );
}
function ri(e, t, n, r, s, i, o) {
  return Vt(
    e,
    t,
    n,
    r,
    s,
    i,
    o
  );
}
class Ct {
  constructor(t = {}, n = new se(new Le())) {
    this.data = n, this.#n = Object.assign({}, Js, t);
    const r = this.data.globalMap.unsignedTx.tx;
    this.#t = new Gs(r), t.version === 3 ? this.setVersionTRUC() : this.data.inputs.length === 0 && this.setVersion(2);
  }
  #t;
  #e;
  #s;
  #n;
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.#t.tx.version;
  }
  set version(t) {
    this.setVersion(t);
  }
  get locktime() {
    return this.#t.tx.locktime;
  }
  set locktime(t) {
    this.setLocktime(t);
  }
  get txInputs() {
    return this.#t.tx.ins.map((t) => ({
      hash: Xt(t.hash),
      index: t.index,
      sequence: t.sequence
    }));
  }
  get txOutputs() {
    return this.#t.tx.outs.map((t) => {
      let n;
      try {
        n = Ie(t.script, this.#n.network);
      } catch {
      }
      return {
        script: Xt(t.script),
        value: t.value,
        address: n
      };
    });
  }
  /** Lazily initialized signer - created on first access */
  get #r() {
    return this.#e || (this.#e = new Vs(this.#t, x)), this.#e;
  }
  /** Lazily initialized finalizer - created on first access */
  get #o() {
    return this.#s || (this.#s = new zs(this.#t, x)), this.#s;
  }
  static fromBase64(t, n = {}) {
    const r = _n(t);
    return this.fromBuffer(r, n);
  }
  static fromHex(t, n = {}) {
    const r = St(t);
    return this.fromBuffer(r, n);
  }
  static fromBuffer(t, n = {}) {
    const r = se.fromBuffer(t, Zs), s = new Ct(n, r);
    return Ws(s.#t.tx, s.#t), s.#t.hasSignatures = s.data.inputs.some(
      (i) => i.partialSig?.length || i.tapKeySig || i.tapScriptSig?.length || i.finalScriptSig || i.finalScriptWitness
    ), s;
  }
  combine(...t) {
    return this.data.combine(...t.map((n) => n.data)), this;
  }
  clone() {
    const t = structuredClone(this.#n);
    return Ct.fromBuffer(new Uint8Array(this.data.toBuffer()), t);
  }
  get maximumFeeRate() {
    return this.#n.maximumFeeRate;
  }
  setMaximumFeeRate(t) {
    tt(t), this.#n.maximumFeeRate = t;
  }
  setVersion(t) {
    return tt(t), $(this.data.inputs, "setVersion", this.#t.hasSignatures), this.#t.tx.version = t, this.#t.invalidate("outputs"), this;
  }
  setVersionTRUC() {
    return this.setVersion(b.TRUC_VERSION);
  }
  setLocktime(t) {
    return tt(t), $(this.data.inputs, "setLocktime", this.#t.hasSignatures), this.#t.tx.locktime = t, this.#t.invalidate("outputs"), this;
  }
  setInputSequence(t, n) {
    if (tt(n), $(this.data.inputs, "setInputSequence", this.#t.hasSignatures), this.#t.tx.ins.length <= t)
      throw new Error("Input index too high");
    return this.#t.tx.ins[t].sequence = n, this.#t.invalidate("outputs"), this;
  }
  addInputs(t, n = !0) {
    return t.forEach((r) => this.addInput(r, n)), this;
  }
  addInput(t, n = !0) {
    if (!t || t.hash === void 0 || t.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    Yt(t, t, "addInput"), n && $(this.data.inputs, "addInput", this.#t.hasSignatures), t.witnessScript && ft(t.witnessScript);
    const r = t.witnessUtxo ? {
      ...t,
      witnessUtxo: {
        script: t.witnessUtxo.script,
        value: typeof t.witnessUtxo.value == "bigint" ? t.witnessUtxo.value : BigInt(t.witnessUtxo.value)
      }
    } : t;
    this.data.addInput(r);
    const s = this.#t.tx.ins[this.#t.tx.ins.length - 1];
    Fe(this.#t, s);
    const i = this.data.inputs.length - 1, o = this.data.inputs[i];
    return o.nonWitnessUtxo && this.#t.addNonWitnessTxCache(o, i, x), this.#t.invalidate("full"), this;
  }
  addOutputs(t, n = !0) {
    return t.forEach((r) => this.addOutput(r, n)), this;
  }
  addOutput(t, n = !0) {
    const r = "address" in t, s = "script" in t;
    if (!t || t.value === void 0 || !r && !s)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    if (n && $(this.data.inputs, "addOutput", this.#t.hasSignatures), r) {
      const { address: i } = t, { network: o } = this.#n, a = ke(i, o);
      t = Object.assign({}, t, { script: a });
    }
    return qt(t, t, "addOutput"), this.data.addOutput(t), this.#t.invalidate("outputs"), this;
  }
  extractTransaction(t, n) {
    if (n && (this.data.inputs = this.data.inputs.filter(
      (s) => !s.partialSig
    )), !this.data.inputs.every(Kt)) throw new Error("Not finalized");
    if (t || (this.#t.computeFeeRate(this.data.inputs, n, x), this.#t.checkFees(this.#n)), this.#t.extractedTx) return this.#t.extractedTx;
    const r = this.#t.tx.clone();
    return this.#t.finalizeAndComputeAmounts(
      this.data.inputs,
      r,
      !0,
      n,
      x
    ), r;
  }
  getFeeRate(t = !1) {
    return this.#t.computeFeeRate(this.data.inputs, t, x);
  }
  getFee(t = !1) {
    return this.#t.computeFee(this.data.inputs, t, x);
  }
  finalizeAllInputs() {
    return T(this.data.inputs, 0), L(this.data.inputs.length).forEach((t) => this.finalizeInput(t)), this;
  }
  finalizeInput(t, n, r) {
    const s = T(this.data.inputs, t);
    return O(s) ? this.#i(
      t,
      s,
      void 0,
      n
    ) : this.#a(
      t,
      s,
      n,
      r ?? !0
    );
  }
  finalizeTaprootInput(t, n, r = Zt) {
    const s = T(this.data.inputs, t);
    if (O(s))
      return this.#i(
        t,
        s,
        n,
        r
      );
    throw new Error(`Cannot finalize input #${t}. Not Taproot.`);
  }
  getInputType(t) {
    const n = T(this.data.inputs, t), r = this.#t.getScriptFromUtxo(t, n, x), s = pt(
      r,
      t,
      "input",
      n.redeemScript || this.#t.redeemFromFinalScriptSig(n.finalScriptSig),
      n.witnessScript || this.#t.redeemFromFinalWitnessScript(n.finalScriptWitness)
    ), i = s.type === "raw" ? "" : s.type + "-", o = Gt(s.meaningfulScript);
    return i + o;
  }
  inputHasPubkey(t, n) {
    const r = T(this.data.inputs, t);
    return this.#t.pubkeyInInput(n, r, t, x);
  }
  inputHasHDKey(t, n) {
    const r = T(this.data.inputs, t), s = this.#r.bip32DerivationIsMine(n);
    return !!r.bip32Derivation && r.bip32Derivation.some(s);
  }
  outputHasPubkey(t, n) {
    const r = X(this.data.outputs, t);
    return this.#t.pubkeyInOutput(n, r, t);
  }
  outputHasHDKey(t, n) {
    const r = X(this.data.outputs, t), s = this.#r.bip32DerivationIsMine(n);
    return !!r.bip32Derivation && r.bip32Derivation.some(s);
  }
  validateSignaturesOfAllInputs(t) {
    return T(this.data.inputs, 0), L(this.data.inputs.length).map(
      (r) => this.validateSignaturesOfInput(r, t)
    ).every((r) => r);
  }
  validateSignaturesOfInput(t, n, r) {
    const s = this.data.inputs[t];
    return O(s) ? this.#u(t, n, r) : this.#c(t, n, r);
  }
  signAllInputsHD(t, n = [b.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const r = [];
    for (const s of L(this.data.inputs.length))
      try {
        this.signInputHD(s, t, n), r.push(!0);
      } catch {
        r.push(!1);
      }
    if (r.every((s) => !s))
      throw new Error("No inputs were signed");
    return this;
  }
  async signAllInputsHDAsync(t, n = [b.SIGHASH_ALL]) {
    if (!t || !t.publicKey || !t.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const r = [], s = [];
    for (const i of L(this.data.inputs.length))
      s.push(
        this.signInputHDAsync(i, t, n).then(
          () => {
            r.push(!0);
          },
          () => {
            r.push(!1);
          }
        )
      );
    if (await Promise.all(s), r.every((i) => !i))
      throw new Error("No inputs were signed");
  }
  signInputHD(t, n, r = [b.SIGHASH_ALL]) {
    if (!n || !n.publicKey || !n.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return this.#r.getSignersFromHD(t, this.data.inputs, n).forEach((i) => this.signInput(t, i, r)), this;
  }
  async signInputHDAsync(t, n, r = [b.SIGHASH_ALL]) {
    if (!n || !n.publicKey || !n.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const i = this.#r.getSignersFromHD(t, this.data.inputs, n).map(
      (o) => this.signInputAsync(t, o, r)
    );
    await Promise.all(i);
  }
  signAllInputs(t, n) {
    if (!t || !t.publicKey) throw new Error("Need Signer to sign input");
    const r = [];
    for (const s of L(this.data.inputs.length))
      try {
        this.signInput(s, t, n), r.push(!0);
      } catch {
        r.push(!1);
      }
    if (r.every((s) => !s))
      throw new Error("No inputs were signed");
    return this;
  }
  async signAllInputsAsync(t, n) {
    if (!t || !t.publicKey) throw new Error("Need Signer to sign input");
    const r = [], s = [];
    for (const [i] of this.data.inputs.entries())
      s.push(
        this.signInputAsync(i, t, n).then(
          () => {
            r.push(!0);
          },
          () => {
            r.push(!1);
          }
        )
      );
    if (await Promise.all(s), r.every((i) => !i))
      throw new Error("No inputs were signed");
  }
  signInput(t, n, r) {
    if (!n || !n.publicKey)
      throw new Error("Need Signer to sign input");
    const s = T(this.data.inputs, t);
    return O(s) ? this.#l(t, s, n, void 0, r) : this.#h(t, n, r);
  }
  signTaprootInput(t, n, r, s) {
    if (!n || !n.publicKey)
      throw new Error("Need Signer to sign input");
    const i = T(this.data.inputs, t);
    if (O(i))
      return this.#l(
        t,
        i,
        n,
        r,
        s
      );
    throw new Error(`Input #${t} is not of type Taproot.`);
  }
  async signInputAsync(t, n, r) {
    if (!n || !n.publicKey) throw new Error("Need Signer to sign input");
    const s = T(this.data.inputs, t);
    return O(s) ? this.#f(
      t,
      s,
      n,
      void 0,
      r
    ) : this.#p(t, n, r);
  }
  async signTaprootInputAsync(t, n, r, s) {
    if (!n || !n.publicKey) throw new Error("Need Signer to sign input");
    const i = T(this.data.inputs, t);
    if (O(i))
      return this.#f(
        t,
        i,
        n,
        r,
        s
      );
    throw new Error(`Input #${t} is not of type Taproot.`);
  }
  toBuffer() {
    return Nt(this.#t), new Uint8Array(this.data.toBuffer());
  }
  toHex() {
    return Nt(this.#t), this.data.toHex();
  }
  toBase64() {
    return Nt(this.#t), this.data.toBase64();
  }
  updateGlobal(t) {
    return this.data.updateGlobal(t), this;
  }
  updateInput(t, n) {
    n.witnessScript && ft(n.witnessScript), Yt(this.data.inputs[t], n, "updateInput");
    const r = n.witnessUtxo ? {
      ...n,
      witnessUtxo: {
        script: n.witnessUtxo.script,
        value: typeof n.witnessUtxo.value == "bigint" ? n.witnessUtxo.value : BigInt(n.witnessUtxo.value)
      }
    } : n;
    return this.data.updateInput(t, r), n.nonWitnessUtxo && this.#t.addNonWitnessTxCache(
      this.data.inputs[t],
      t,
      x
    ), this;
  }
  updateOutput(t, n) {
    const r = this.data.outputs[t];
    return qt(r, n, "updateOutput"), this.data.updateOutput(t, n), this;
  }
  addUnknownKeyValToGlobal(t) {
    return this.data.addUnknownKeyValToGlobal(t), this;
  }
  addUnknownKeyValToInput(t, n) {
    return this.data.addUnknownKeyValToInput(t, n), this;
  }
  addUnknownKeyValToOutput(t, n) {
    return this.data.addUnknownKeyValToOutput(t, n), this;
  }
  clearFinalizedInput(t) {
    return this.data.clearFinalizedInput(t), this;
  }
  checkTaprootHashesForSig(t, n, r, s, i) {
    if (!("signSchnorr" in r) || typeof r.signSchnorr != "function")
      throw new Error(`Need Schnorr Signer to sign taproot input #${t}.`);
    const o = r.publicKey instanceof Uint8Array ? r.publicKey : new Uint8Array(r.publicKey), a = this.#r.getTaprootHashesForSig(
      t,
      n,
      this.data.inputs,
      o,
      s,
      i
    );
    if (!a || !a.length)
      throw new Error(`Can not sign for input #${t} with the key ${B(o)}`);
    return a;
  }
  #a(t, n, r = Qs, s = !0) {
    const { script: i, isP2SH: o, isP2WSH: a, isSegwit: u } = this.#o.getScriptFromInput(
      t,
      n
    );
    if (!i) throw new Error(`No script found for input #${t}`);
    $s(n);
    const { finalScriptSig: l, finalScriptWitness: f } = r(
      t,
      n,
      i,
      u,
      o,
      a,
      s
    );
    if (l && this.data.updateInput(t, { finalScriptSig: l }), f && this.data.updateInput(t, { finalScriptWitness: f }), !l && !f)
      throw new Error(`Unknown error finalizing input #${t}`);
    return this.data.clearFinalizedInput(t), this;
  }
  #i(t, n, r, s = Zt) {
    if (!n.witnessUtxo)
      throw new Error(`Cannot finalize input #${t}. Missing witness utxo.`);
    if (n.tapKeySig && !An(n)) {
      const i = Bt({
        output: n.witnessUtxo.script,
        signature: n.tapKeySig
      });
      if (!i.witness) throw new Error("Cannot finalize taproot key spend");
      const o = rt(i.witness);
      this.data.updateInput(t, { finalScriptWitness: o });
    } else {
      const { finalScriptWitness: i } = s(
        t,
        n,
        r
      );
      this.data.updateInput(t, { finalScriptWitness: i });
    }
    return this.data.clearFinalizedInput(t), this;
  }
  #c(t, n, r) {
    const s = this.data.inputs[t], i = s?.partialSig;
    if (!s || !i || i.length < 1)
      throw new Error("No signatures to validate");
    if (typeof n != "function")
      throw new Error("Need validator function to validate signatures");
    const o = r ? i.filter((c) => k(c.pubkey, r)) : i;
    if (o.length < 1) throw new Error("No signatures for this pubkey");
    const a = [];
    let u, l, f;
    for (const c of o) {
      const h = c.signature, S = c.pubkey, g = et.decode(h), { hash: y, script: w } = f !== g.hashType || !u || !l ? this.#r.getHashForSig(
        t,
        Object.assign({}, s, {
          sighashType: g.hashType
        }),
        !0
      ) : { hash: u, script: l };
      f = g.hashType, u = y, l = w, Be(S, w, "verify"), a.push(n(S, y, g.signature));
    }
    return a.every((c) => c);
  }
  #u(t, n, r) {
    const s = this.data.inputs[t], i = s?.tapKeySig, o = s?.tapScriptSig;
    if (!s && !i && !(o && !o.length))
      throw new Error("No signatures to validate");
    if (typeof n != "function")
      throw new Error("Need validator function to validate signatures");
    const a = r ? nt(r) : void 0, u = a ? this.#r.getTaprootHashesForSig(t, s, this.data.inputs, a) : this.#r.getAllTaprootHashesForSig(t, s, this.data.inputs);
    if (!u.length) throw new Error("No signatures for this pubkey");
    const l = u.find((c) => !c.leafHash);
    let f = 0;
    if (i && l) {
      if (!n(
        l.pubkey,
        l.hash,
        this.#r.trimTaprootSig(i)
      )) return !1;
      f++;
    }
    if (o)
      for (const c of o) {
        const h = c.pubkey, S = u.find((g) => k(h, g.pubkey));
        if (S) {
          if (!n(
            h,
            S.hash,
            this.#r.trimTaprootSig(c.signature)
          )) return !1;
          f++;
        }
      }
    return f > 0;
  }
  #h(t, n, r = [b.SIGHASH_ALL]) {
    const s = n.publicKey instanceof Uint8Array ? n.publicKey : new Uint8Array(n.publicKey), { hash: i, sighashType: o } = this.#r.getHashAndSighashType(
      this.data.inputs,
      t,
      s,
      r
    ), a = n.sign(i), u = [
      {
        pubkey: s,
        signature: et.encode(
          a instanceof Uint8Array ? a : new Uint8Array(a),
          o
        )
      }
    ];
    return this.data.updateInput(t, { partialSig: u }), this.#t.hasSignatures = !0, this;
  }
  #l(t, n, r, s, i = [b.SIGHASH_DEFAULT]) {
    const o = r.publicKey instanceof Uint8Array ? r.publicKey : new Uint8Array(r.publicKey);
    if (!("signSchnorr" in r) || typeof r.signSchnorr != "function")
      throw new Error(`Need Schnorr Signer to sign taproot input #${t}.`);
    const a = this.checkTaprootHashesForSig(
      t,
      n,
      r,
      s,
      i
    ), u = r.signSchnorr.bind(r), l = a.filter((c) => !c.leafHash).map(
      (c) => Q(u(c.hash), n.sighashType)
    )[0], f = a.filter((c) => !!c.leafHash).map(
      (c) => ({
        pubkey: nt(o),
        signature: Q(
          u(c.hash),
          n.sighashType
        ),
        leafHash: c.leafHash
      })
    );
    return l && (this.data.updateInput(t, { tapKeySig: l }), this.#t.hasSignatures = !0), f.length && (this.data.updateInput(t, { tapScriptSig: f }), this.#t.hasSignatures = !0), this;
  }
  async #p(t, n, r = [b.SIGHASH_ALL]) {
    const s = n.publicKey instanceof Uint8Array ? n.publicKey : new Uint8Array(n.publicKey), { hash: i, sighashType: o } = this.#r.getHashAndSighashType(
      this.data.inputs,
      t,
      s,
      r
    ), a = await n.sign(i), u = a instanceof Uint8Array ? a : new Uint8Array(a), l = [
      {
        pubkey: s,
        signature: et.encode(u, o)
      }
    ];
    this.data.updateInput(t, { partialSig: l }), this.#t.hasSignatures = !0;
  }
  async #f(t, n, r, s, i = [b.SIGHASH_DEFAULT]) {
    const o = r.publicKey instanceof Uint8Array ? r.publicKey : new Uint8Array(r.publicKey);
    if (!("signSchnorr" in r) || typeof r.signSchnorr != "function")
      throw new Error(`Need Schnorr Signer to sign taproot input #${t}.`);
    const a = this.checkTaprootHashesForSig(
      t,
      n,
      r,
      s,
      i
    ), u = r.signSchnorr.bind(r), l = a.find((c) => !c.leafHash);
    if (l) {
      const c = await u(l.hash), h = Q(c, n.sighashType);
      this.data.updateInput(t, { tapKeySig: h }), this.#t.hasSignatures = !0;
    }
    const f = a.filter(
      (c) => !!c.leafHash
    );
    if (f.length) {
      const c = await Promise.all(
        f.map(async (h) => {
          const S = await u(h.hash);
          return {
            pubkey: nt(o),
            signature: Q(S, n.sighashType),
            leafHash: h.leafHash
          };
        })
      );
      this.data.updateInput(t, { tapScriptSig: c }), this.#t.hasSignatures = !0;
    }
  }
}
const si = {
  BitcoinError: v,
  ValidationError: On,
  InvalidInputError: Rn,
  InvalidOutputError: Kn,
  ScriptError: Cn,
  PsbtError: Fn,
  EccError: Bn,
  AddressError: Wn,
  SignatureError: $n
}, ii = {
  networks: xn,
  address: Pn,
  payments: Hn,
  script: vn,
  crypto: kn,
  Transaction: In
};
export {
  Wn as AddressError,
  v as BitcoinError,
  F as Block,
  ci as EccContext,
  Bn as EccError,
  Ee as FUTURE_MAX_VERSION,
  ot as FUTURE_OPNET_VERSION,
  q as FUTURE_SEGWIT_MAX_SIZE,
  J as FUTURE_SEGWIT_MAX_VERSION,
  Z as FUTURE_SEGWIT_MIN_SIZE,
  mt as FUTURE_SEGWIT_MIN_VERSION,
  bt as FUTURE_SEGWIT_VERSION_DIFF,
  Rn as InvalidInputError,
  Kn as InvalidOutputError,
  Ye as LEAF_VERSION_TAPSCRIPT,
  qe as MAX_TAPTREE_DEPTH,
  Ht as PaymentType,
  Ct as Psbt,
  Gs as PsbtCache,
  Fn as PsbtError,
  zs as PsbtFinalizer,
  Vs as PsbtSigner,
  Le as PsbtTransaction,
  Cn as ScriptError,
  $n as SignatureError,
  ui as SignatureType,
  hi as TAGGED_HASH_PREFIXES,
  li as TAGS,
  fi as TAPLEAF_VERSION_MASK,
  b as Transaction,
  On as ValidationError,
  pi as WorkerSigningPool,
  Te as _toFutureSegwitAddress,
  Pn as address,
  le as alloc,
  di as applySignaturesToPsbt,
  gi as assertPrivateKey,
  yi as assertXOnlyPublicKey,
  yn as checkInputForSig,
  Yt as checkTaprootInputFields,
  gn as checkTaprootInputForSigs,
  qt as checkTaprootOutputFields,
  Xt as clone,
  It as compare,
  wi as concat,
  kn as crypto,
  Si as decompressPublicKey,
  ii as default,
  k as equals,
  si as errors,
  an as findScriptPath,
  Ae as fromBase58Check,
  _n as fromBase64,
  fe as fromBech32,
  St as fromHex,
  Ie as fromOutputScript,
  Ei as fromUtf8,
  mi as getEccLib,
  Qs as getFinalScripts,
  bi as getPsigsFromInputFinalScripts,
  Ti as getSigningPool,
  Ai as getTapKeySigFromWitness,
  Ii as hash160,
  At as hash256,
  ki as initEccLib,
  Ge as isBytes20,
  vi as isBytes32,
  xi as isHex,
  _i as isP2A,
  Ui as isP2MR,
  An as isP2MRInput,
  Sn as isP2MS,
  Pi as isP2OP,
  En as isP2PK,
  wn as isP2PKH,
  Se as isP2SHScript,
  Tn as isP2TR,
  Et as isP2WPKH,
  jt as isP2WSHScript,
  Ni as isPoint,
  Hi as isPrivateKey,
  Oi as isSatoshi,
  Ri as isSchnorrSignature,
  Ki as isScript,
  Ci as isSignature,
  O as isTaprootInput,
  Fi as isTaprootOutput,
  me as isUnknownSegwitVersion,
  Bi as isXOnlyPublicKey,
  Wi as isZero,
  xn as networks,
  M as opcodes,
  Hn as payments,
  ri as prepareFinalScripts,
  $i as prepareSigningTasks,
  it as pubkeyInScript,
  Li as pubkeyPositionInScript,
  Mi as pubkeysMatch,
  st as reverse,
  Di as reverseCopy,
  Gi as ripemd160,
  cn as rootHashFromPath,
  un as rootHashFromPathP2MR,
  vn as script,
  Q as serializeTaprootSignature,
  Vi as sha1,
  zi as sha256,
  ji as signPsbtParallel,
  Xi as signatureBlocksAction,
  Yi as taggedHash,
  hn as tapBranchHash,
  Zt as tapScriptFinalizer,
  qi as tapTreeFromList,
  Zi as tapTreeToList,
  Ji as tapTweakHash,
  we as tapleafHash,
  Ot as toBase58Check,
  ei as toBase64,
  at as toBech32,
  je as toBytes20,
  zt as toBytes32,
  be as toFutureOPNetAddress,
  ln as toHashTree,
  B as toHex,
  ke as toOutputScript,
  Qi as toSatoshi,
  to as toUtf8,
  nt as toXOnly,
  Zs as transactionFromBuffer,
  eo as tweakInternalPubKey,
  fn as tweakKey,
  no as varuint,
  rt as witnessStackToScriptWitness,
  ro as xor
};
