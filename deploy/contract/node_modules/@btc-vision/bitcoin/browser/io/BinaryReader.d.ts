/**
 * Stateful binary reader with a single DataView instance.
 *
 * Zero allocations during read operations. The DataView is created once
 * in the constructor and reused for all reads.
 *
 * @packageDocumentation
 */
/**
 * High-performance binary reader for parsing binary data.
 *
 * Creates exactly ONE DataView instance that is reused for all read operations.
 * This eliminates garbage collection pressure from repeated DataView allocations.
 *
 * @example
 * ```typescript
 * import { BinaryReader, fromHex } from '@btc-vision/bitcoin';
 *
 * // Parse a Bitcoin transaction
 * const data = fromHex('01000000...');
 * const reader = new BinaryReader(data);
 *
 * const version = reader.readInt32LE();
 * const inputCount = reader.readVarInt();
 *
 * for (let i = 0; i < inputCount; i++) {
 *     const txid = reader.readBytes(32);
 *     const vout = reader.readUInt32LE();
 *     const script = reader.readVarBytes();
 *     const sequence = reader.readUInt32LE();
 * }
 * ```
 */
export declare class BinaryReader {
    #private;
    /**
     * Creates a new BinaryReader.
     *
     * @param data - The byte array to read from
     * @param offset - Initial read position (default 0)
     *
     * @example
     * ```typescript
     * import { BinaryReader, fromHex } from '@btc-vision/bitcoin';
     *
     * const data = fromHex('01020304');
     * const reader = new BinaryReader(data);
     * ```
     */
    constructor(data: Uint8Array, offset?: number);
    /**
     * Current read position in the buffer.
     */
    get offset(): number;
    /**
     * Sets the read position.
     *
     * @param value - New offset value
     * @throws RangeError if offset is negative or beyond buffer length
     */
    set offset(value: number);
    /**
     * Total length of the underlying buffer.
     */
    get length(): number;
    /**
     * Number of bytes remaining to be read.
     */
    get remaining(): number;
    /**
     * The underlying data buffer.
     */
    get data(): Uint8Array;
    /**
     * Creates a BinaryReader from a hex string.
     *
     * @param hex - Hex string (with or without 0x prefix)
     * @returns A new BinaryReader instance
     *
     * @example
     * ```typescript
     * import { BinaryReader } from '@btc-vision/bitcoin';
     *
     * const reader = BinaryReader.fromHex('01000000');
     * const version = reader.readInt32LE(); // 1
     * ```
     */
    static fromHex(hex: string): BinaryReader;
    /**
     * Reads an 8-bit unsigned integer.
     *
     * @returns The value (0-255)
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('ff');
     * reader.readUInt8(); // 255
     * ```
     */
    readUInt8(): number;
    /**
     * Reads an 8-bit signed integer.
     *
     * @returns The value (-128 to 127)
     * @throws RangeError if reading past end of buffer
     */
    readInt8(): number;
    /**
     * Reads a 16-bit unsigned integer in little-endian format.
     *
     * @returns The value (0-65535)
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('0100'); // 1 in LE
     * reader.readUInt16LE(); // 1
     * ```
     */
    readUInt16LE(): number;
    /**
     * Reads a 16-bit signed integer in little-endian format.
     *
     * @returns The value (-32768 to 32767)
     * @throws RangeError if reading past end of buffer
     */
    readInt16LE(): number;
    /**
     * Reads a 32-bit unsigned integer in little-endian format.
     *
     * @returns The value (0 to 4294967295)
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('01000000'); // 1 in LE
     * reader.readUInt32LE(); // 1
     * ```
     */
    readUInt32LE(): number;
    /**
     * Reads a 32-bit signed integer in little-endian format.
     *
     * @returns The value (-2147483648 to 2147483647)
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('ffffffff'); // -1 in LE signed
     * reader.readInt32LE(); // -1
     * ```
     */
    readInt32LE(): number;
    /**
     * Reads a 64-bit unsigned integer in little-endian format as bigint.
     *
     * @returns The value as bigint
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('0100000000000000'); // 1 in LE 64-bit
     * reader.readUInt64LE(); // 1n
     * ```
     */
    readUInt64LE(): bigint;
    /**
     * Reads a 64-bit signed integer in little-endian format as bigint.
     *
     * @returns The value as bigint
     * @throws RangeError if reading past end of buffer
     */
    readInt64LE(): bigint;
    /**
     * Reads a specified number of bytes.
     *
     * Returns a subarray view (no copy) for performance.
     * Use readBytesCopy() if you need an independent copy.
     *
     * @param length - Number of bytes to read
     * @returns Uint8Array view into the buffer
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('deadbeefcafebabe');
     * const first4 = reader.readBytes(4); // deadbeef
     * const next4 = reader.readBytes(4); // cafebabe
     * ```
     */
    readBytes(length: number): Uint8Array;
    /**
     * Reads a specified number of bytes as an independent copy.
     *
     * @param length - Number of bytes to read
     * @returns New Uint8Array with copied data
     * @throws RangeError if reading past end of buffer
     */
    readBytesCopy(length: number): Uint8Array;
    /**
     * Reads a Bitcoin CompactSize variable-length integer.
     *
     * CompactSize encoding:
     * - 0x00-0xFC: 1 byte (value as-is)
     * - 0xFD: 3 bytes (0xFD + 2-byte LE uint16)
     * - 0xFE: 5 bytes (0xFE + 4-byte LE uint32)
     * - 0xFF: 9 bytes (0xFF + 8-byte LE uint64)
     *
     * @returns The decoded integer value
     * @throws RangeError if reading past end of buffer
     * @throws RangeError if value exceeds MAX_SAFE_INTEGER
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('fd0302'); // 515 encoded
     * reader.readVarInt(); // 515
     * ```
     */
    readVarInt(): number;
    /**
     * Reads a Bitcoin CompactSize variable-length integer as bigint.
     *
     * Use this when you need the full 64-bit range.
     *
     * @returns The decoded integer value as bigint
     * @throws RangeError if reading past end of buffer
     */
    readVarIntBig(): bigint;
    /**
     * Reads a length-prefixed byte array (VarInt length + bytes).
     *
     * @returns Uint8Array view into the buffer
     * @throws RangeError if reading past end of buffer
     *
     * @example
     * ```typescript
     * const reader = BinaryReader.fromHex('04deadbeef');
     * reader.readVarBytes(); // Uint8Array [0xde, 0xad, 0xbe, 0xef]
     * ```
     */
    readVarBytes(): Uint8Array;
    /**
     * Reads an array of length-prefixed byte arrays.
     *
     * Format: VarInt count + (VarInt length + bytes) for each item.
     *
     * @returns Array of Uint8Array views
     * @throws RangeError if reading past end of buffer
     */
    readVector(): Uint8Array[];
    /**
     * Peeks at the next byte without advancing the position.
     *
     * @returns The next byte value, or undefined if at end
     */
    peek(): number | undefined;
    /**
     * Skips a specified number of bytes.
     *
     * @param length - Number of bytes to skip
     * @throws RangeError if skipping past end of buffer
     */
    skip(length: number): void;
    /**
     * Resets the read position to the beginning.
     */
    reset(): void;
    /**
     * Checks if there are more bytes to read.
     *
     * @returns True if there are remaining bytes
     */
    hasMore(): boolean;
}
//# sourceMappingURL=BinaryReader.d.ts.map