import { Transaction } from './transaction.js';
import { Bytes32 } from './types.js';
/**
 * Represents a Bitcoin block with header fields and optional transactions.
 *
 * @example
 * ```typescript
 * import { Block, fromHex } from '@btc-vision/bitcoin';
 *
 * // Parse a block from hex
 * const block = Block.fromHex('0100000000000000...');
 *
 * // Access block properties
 * console.log(block.version);
 * console.log(block.getId());
 * console.log(block.timestamp);
 *
 * // Check proof of work
 * if (block.checkProofOfWork()) {
 *     console.log('Valid PoW');
 * }
 * ```
 */
export declare class Block {
    #private;
    /** Block version number */
    version: number;
    /** Hash of the previous block (32 bytes) */
    prevHash?: Bytes32;
    /** Merkle root of the transactions (32 bytes) */
    merkleRoot?: Bytes32;
    /** Block timestamp (Unix time) */
    timestamp: number;
    /** Witness commitment for SegWit blocks (32 bytes) */
    witnessCommit?: Bytes32;
    /** Compact representation of the target threshold */
    bits: number;
    /** Nonce used for proof of work */
    nonce: number;
    /** Array of transactions included in the block */
    transactions?: Transaction[];
    /**
     * Parses a Block from a Uint8Array.
     * @param buffer - The raw block data (minimum 80 bytes for header only)
     * @returns Parsed Block instance
     * @throws Error if buffer is too small
     */
    static fromBuffer(buffer: Uint8Array): Block;
    /**
     * Parses a Block from a hex string.
     * @param hex - Hexadecimal representation of the block
     * @returns Parsed Block instance
     */
    static fromHex(hex: string): Block;
    /**
     * Calculates the target threshold from the compact bits representation.
     * @param bits - Compact bits value from block header
     * @returns 32-byte target threshold
     */
    static calculateTarget(bits: number): Bytes32;
    /**
     * Calculates the merkle root for a list of transactions.
     * @param transactions - Array of transactions
     * @param forWitness - If true, calculate witness merkle root (for SegWit)
     * @returns 32-byte merkle root hash
     * @throws TypeError if transactions is empty or not an array
     */
    static calculateMerkleRoot(transactions: Transaction[], forWitness?: boolean): Bytes32;
    /**
     * Extracts the witness commitment from the coinbase transaction.
     * @returns 32-byte witness commitment or null if not found
     */
    getWitnessCommit(): Bytes32 | null;
    /**
     * Checks if this block has a witness commitment.
     * @returns True if the block has a witness commitment
     */
    hasWitnessCommit(): boolean;
    /**
     * Checks if any transaction in this block has witness data.
     * @returns True if any transaction has witness data
     */
    hasWitness(): boolean;
    /**
     * Calculates the weight of this block.
     * Weight = (base size * 3) + total size
     * @returns Block weight in weight units
     */
    weight(): number;
    /**
     * Calculates the serialized byte length of this block.
     * @param headersOnly - If true, return only header size (80 bytes)
     * @param allowWitness - If true, include witness data in calculation
     * @returns Byte length of the serialized block
     */
    byteLength(headersOnly?: boolean, allowWitness?: boolean): number;
    /**
     * Computes the double-SHA256 hash of the block header.
     * @returns 32-byte block hash
     */
    getHash(): Bytes32;
    /**
     * Returns the block ID (hash in reversed hex format, as displayed in block explorers).
     * @returns Block ID as hex string
     */
    getId(): string;
    /**
     * Converts the block timestamp to a Date object.
     * @returns UTC date of the block
     */
    getUTCDate(): Date;
    /**
     * Serializes the block to a Uint8Array.
     * @param headersOnly - If true, only serialize the 80-byte header
     * @returns Serialized block data
     */
    toBuffer(headersOnly?: boolean): Uint8Array;
    /**
     * Serializes the block to a hex string.
     * @param headersOnly - If true, only serialize the 80-byte header
     * @returns Hex string representation of the block
     */
    toHex(headersOnly?: boolean): string;
    /**
     * Validates the merkle root and witness commitment (if present).
     * @returns True if the transaction roots are valid
     */
    checkTxRoots(): boolean;
    /**
     * Validates that the block hash meets the target threshold (proof of work).
     * @returns True if the block's proof of work is valid
     */
    checkProofOfWork(): boolean;
}
//# sourceMappingURL=block.d.ts.map