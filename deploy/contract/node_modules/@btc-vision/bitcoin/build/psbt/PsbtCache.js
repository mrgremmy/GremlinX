import * as bscript from '../script.js';
import { isP2TR, isP2WPKH, pubkeyInScript } from './psbtutils.js';
import { getMeaningfulScript, isPubkeyLike, isSigLike, scriptWitnessToWitnessStack, } from './utils.js';
import { isFinalized } from './validation.js';
import { isUnknownSegwitVersion } from '../address.js';
/**
 * Internal PSBT cache for computed values.
 * Wraps all cache management previously handled by a plain interface + scattered helper functions.
 */
export class PsbtCache {
    nonWitnessUtxoTxCache;
    nonWitnessUtxoBufCache;
    txInCache;
    tx;
    unsafeSignNonSegwit;
    hasSignatures;
    fee;
    feeRate;
    extractedTx;
    prevOuts;
    signingScripts;
    values;
    taprootHashCache;
    constructor(tx) {
        this.nonWitnessUtxoTxCache = [];
        this.nonWitnessUtxoBufCache = [];
        this.txInCache = {};
        this.tx = tx;
        this.unsafeSignNonSegwit = false;
        this.hasSignatures = false;
    }
    /**
     * Invalidates cached computed values.
     * @param scope - 'full' clears everything (for input changes), 'outputs' clears fee/extract/taproot caches
     */
    invalidate(scope) {
        this.fee = undefined;
        this.feeRate = undefined;
        this.extractedTx = undefined;
        this.taprootHashCache = undefined;
        if (scope === 'full') {
            this.prevOuts = undefined;
            this.signingScripts = undefined;
            this.values = undefined;
        }
    }
    addNonWitnessTxCache(input, inputIndex, txFromBuffer) {
        if (!input.nonWitnessUtxo)
            throw new Error('nonWitnessUtxo is required');
        if (input === null || input === Object.prototype) {
            throw new Error('Invalid input object');
        }
        const nonWitnessUtxoBuf = input.nonWitnessUtxo;
        this.nonWitnessUtxoBufCache[inputIndex] = nonWitnessUtxoBuf;
        this.nonWitnessUtxoTxCache[inputIndex] = txFromBuffer(nonWitnessUtxoBuf);
    }
    getNonWitnessUtxoTx(input, inputIndex, txFromBuffer) {
        const cached = this.nonWitnessUtxoTxCache[inputIndex];
        if (!cached) {
            this.addNonWitnessTxCache(input, inputIndex, txFromBuffer);
        }
        return this.nonWitnessUtxoTxCache[inputIndex];
    }
    getScriptFromUtxo(inputIndex, input, txFromBuffer) {
        const { script } = this.getScriptAndAmountFromUtxo(inputIndex, input, txFromBuffer);
        return script;
    }
    getScriptAndAmountFromUtxo(inputIndex, input, txFromBuffer) {
        if (input.witnessUtxo !== undefined) {
            return {
                script: input.witnessUtxo.script,
                value: input.witnessUtxo.value,
            };
        }
        else if (input.nonWitnessUtxo !== undefined) {
            const nonWitnessUtxoTx = this.getNonWitnessUtxoTx(input, inputIndex, txFromBuffer);
            const txIn = this.tx.ins[inputIndex];
            const o = nonWitnessUtxoTx.outs[txIn.index];
            return { script: o.script, value: o.value };
        }
        else {
            throw new Error("Can't find pubkey in input without Utxo data");
        }
    }
    computeFee(inputs, disableOutputChecks = false, txFromBuffer) {
        if (!inputs.every(isFinalized))
            throw new Error('PSBT must be finalized to calculate fee');
        if (this.fee !== undefined)
            return this.fee;
        let tx;
        let mustFinalize = true;
        if (this.extractedTx) {
            tx = this.extractedTx;
            mustFinalize = false;
        }
        else {
            tx = this.tx.clone();
        }
        const { fee } = this.finalizeAndComputeAmounts(inputs, tx, mustFinalize, disableOutputChecks, txFromBuffer);
        return fee;
    }
    computeFeeRate(inputs, disableOutputChecks = false, txFromBuffer) {
        if (!inputs.every(isFinalized))
            throw new Error('PSBT must be finalized to calculate fee rate');
        if (this.feeRate !== undefined)
            return this.feeRate;
        let tx;
        let mustFinalize = true;
        if (this.extractedTx) {
            tx = this.extractedTx;
            mustFinalize = false;
        }
        else {
            tx = this.tx.clone();
        }
        const { feeRate } = this.finalizeAndComputeAmounts(inputs, tx, mustFinalize, disableOutputChecks, txFromBuffer);
        return feeRate;
    }
    checkFees(opts) {
        const feeRate = this.feeRate;
        if (!this.extractedTx)
            throw new Error('Transaction not extracted');
        if (feeRate === undefined)
            throw new Error('Fee rate not computed');
        const vsize = this.extractedTx.virtualSize();
        const satoshis = feeRate * vsize;
        if (feeRate >= opts.maximumFeeRate) {
            throw new Error(`Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +
                `fees, which is ${feeRate} satoshi per byte for a transaction ` +
                `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +
                `byte). Use setMaximumFeeRate method to raise your threshold, or ` +
                `pass true to the first arg of extractTransaction.`);
        }
    }
    pubkeyInInput(pubkey, input, inputIndex, txFromBuffer) {
        const script = this.getScriptFromUtxo(inputIndex, input, txFromBuffer);
        const { meaningfulScript } = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript, input.witnessScript);
        return pubkeyInScript(pubkey, meaningfulScript);
    }
    pubkeyInOutput(pubkey, output, outputIndex) {
        const script = this.tx.outs[outputIndex].script;
        const { meaningfulScript } = getMeaningfulScript(script, outputIndex, 'output', output.redeemScript, output.witnessScript);
        return pubkeyInScript(pubkey, meaningfulScript);
    }
    redeemFromFinalScriptSig(finalScript) {
        if (!finalScript)
            return;
        const decomp = bscript.decompile(finalScript);
        if (!decomp)
            return;
        const lastItem = decomp[decomp.length - 1];
        if (!(lastItem instanceof Uint8Array) || isPubkeyLike(lastItem) || isSigLike(lastItem))
            return;
        const sDecomp = bscript.decompile(lastItem);
        if (!sDecomp)
            return;
        return lastItem;
    }
    redeemFromFinalWitnessScript(finalScript) {
        if (!finalScript)
            return;
        const decomp = scriptWitnessToWitnessStack(finalScript);
        const lastItem = decomp[decomp.length - 1];
        if (!lastItem)
            return;
        if (isPubkeyLike(lastItem))
            return;
        const sDecomp = bscript.decompile(lastItem);
        if (!sDecomp)
            return;
        return lastItem;
    }
    /**
     * Finalize transaction inputs and compute fee amounts.
     * Returns computed values instead of mutating cache parameters directly.
     */
    finalizeAndComputeAmounts(inputs, tx, mustFinalize, disableOutputChecks, txFromBuffer) {
        let inputAmount = 0n;
        inputs.forEach((input, idx) => {
            const txIn = tx.ins[idx];
            if (mustFinalize && input.finalScriptSig)
                txIn.script = input.finalScriptSig;
            if (mustFinalize && input.finalScriptWitness) {
                txIn.witness = scriptWitnessToWitnessStack(input.finalScriptWitness);
            }
            if (input.witnessUtxo) {
                inputAmount += input.witnessUtxo.value;
            }
            else if (input.nonWitnessUtxo) {
                if (!txFromBuffer)
                    throw new Error('txFromBuffer is required for nonWitnessUtxo inputs');
                const nwTx = this.getNonWitnessUtxoTx(input, idx, txFromBuffer);
                const vout = txIn.index;
                const out = nwTx.outs[vout];
                inputAmount += out.value;
            }
        });
        const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0n);
        const feeValue = inputAmount - outputAmount;
        if (!disableOutputChecks) {
            if (feeValue < 0n) {
                throw new Error(`Outputs are spending more than Inputs ${inputAmount} < ${outputAmount}`);
            }
        }
        const bytes = tx.virtualSize();
        const fee = Number(feeValue);
        const feeRate = Math.floor(fee / bytes);
        this.fee = fee;
        this.extractedTx = tx;
        this.feeRate = feeRate;
        return { fee, feeRate };
    }
    getScriptFromInput(inputIndex, input, txFromBuffer) {
        const res = {
            script: null,
            isSegwit: false,
            isP2SH: false,
            isP2WSH: false,
        };
        res.isP2SH = !!input.redeemScript;
        res.isP2WSH = !!input.witnessScript;
        if (input.witnessScript) {
            res.script = input.witnessScript;
        }
        else if (input.redeemScript) {
            res.script = input.redeemScript;
        }
        else {
            if (input.nonWitnessUtxo) {
                const nonWitnessUtxoTx = this.getNonWitnessUtxoTx(input, inputIndex, txFromBuffer);
                const prevoutIndex = this.tx.ins[inputIndex].index;
                res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
            }
            else if (input.witnessUtxo) {
                res.script = input.witnessUtxo.script;
            }
        }
        if (input.witnessScript || (res.script && isP2WPKH(res.script))) {
            res.isSegwit = true;
        }
        else {
            if (res.script && isUnknownSegwitVersion(res.script)) {
                res.isSegwit = true;
            }
        }
        return res;
    }
    getPrevoutTaprootKey(inputIndex, input, txFromBuffer) {
        const { script } = this.getScriptAndAmountFromUtxo(inputIndex, input, txFromBuffer);
        return isP2TR(script) ? script.subarray(2, 34) : null;
    }
}
//# sourceMappingURL=PsbtCache.js.map