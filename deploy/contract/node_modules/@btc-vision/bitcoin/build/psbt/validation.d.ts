/**
 * PSBT validation utilities
 * @packageDocumentation
 */
import type { PsbtInput } from 'bip174';
import type { Payment, PaymentOpts } from '../payments/index.js';
import type { Transaction } from '../transaction.js';
import type { PsbtCacheInterface as PsbtCache } from './types.js';
import type { PublicKey, Script } from '../types.js';
/**
 * Validates that a number is a valid 32-bit unsigned integer.
 * @param num - The number to validate
 * @throws {Error} If the number is not a valid 32-bit integer
 */
export declare function check32Bit(num: number): void;
/**
 * Checks if the cache is in a valid state for export.
 * @param cache - The PSBT cache to check
 * @throws {Error} If the cache is not BIP174 compliant
 */
export declare function checkCache(cache: PsbtCache): void;
/**
 * Checks if a PSBT input has been finalized.
 * @param input - The PSBT input to check
 * @returns True if the input has finalScriptSig or finalScriptWitness
 */
export declare function isFinalized(input: PsbtInput): boolean;
/**
 * Validates that a transaction has empty scriptSigs and witnesses.
 * @param tx - The transaction to check
 * @throws {Error} If any input has non-empty scripts
 */
export declare function checkTxEmpty(tx: Transaction): void;
/**
 * Checks and caches a transaction input to detect duplicates.
 * @param cache - The PSBT cache
 * @param input - The input to check
 * @throws {Error} If a duplicate input is detected
 */
export declare function checkTxInputCache(cache: PsbtCache, input: {
    hash: Uint8Array;
    index: number;
}): void;
/**
 * Checks all transaction inputs for duplicates.
 * @param tx - The transaction to check
 * @param cache - The PSBT cache
 * @throws {Error} If duplicate inputs are detected
 */
export declare function checkTxForDupeIns(tx: Transaction, cache: PsbtCache): void;
/**
 * Checks if any inputs have partial signatures that would prevent modification.
 * @param inputs - The PSBT inputs to check
 * @param action - The action being attempted (for error message)
 * @param hasSignaturesCache - Optional cached flag (true = definitely has sigs, false = check needed)
 * @throws {Error} If signatures exist and prevent modification
 */
export declare function checkInputsForPartialSig(inputs: PsbtInput[], action: string, hasSignaturesCache?: boolean): void;
/**
 * Validates that partial signature sighash types match the input's sighash type.
 * @param input - The PSBT input to check
 * @throws {Error} If sighash types don't match
 */
export declare function checkPartialSigSighashes(input: PsbtInput): void;
/**
 * Validates that a pubkey exists in a script.
 * @param pubkey - The pubkey to find
 * @param script - The script to search
 * @param action - The action being attempted (for error message)
 * @throws {Error} If the pubkey is not found in the script
 */
export declare function checkScriptForPubkey(pubkey: PublicKey, script: Script, action: string): void;
/**
 * Creates a script checker function for validating redeem/witness scripts.
 * @param payment - The payment function to use (p2sh or p2wsh)
 * @param paymentScriptName - Name for error messages
 * @returns A function that validates scripts match
 */
export declare function scriptCheckerFactory(payment: (a: Omit<Payment, 'name'>, opts?: PaymentOpts) => Payment, paymentScriptName: string): (idx: number, scriptPubKey: Script, redeemScript: Script, ioType: 'input' | 'output') => void;
/**
 * Validates that a redeem script matches the scriptPubKey.
 */
export declare const checkRedeemScript: (idx: number, scriptPubKey: Script, redeemScript: Script, ioType: "input" | "output") => void;
/**
 * Validates that a witness script matches the scriptPubKey.
 */
export declare const checkWitnessScript: (idx: number, scriptPubKey: Script, redeemScript: Script, ioType: "input" | "output") => void;
//# sourceMappingURL=validation.d.ts.map