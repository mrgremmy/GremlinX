import { checkForInput, checkForOutput, Psbt as PsbtBase } from 'bip174';
import { clone, equals, fromBase64, fromHex, toHex } from './io/index.js';
import { fromOutputScript, toOutputScript } from './address.js';
import { bitcoin as btcNetwork } from './networks.js';
import * as payments from './payments/index.js';
import { checkTaprootInputFields, checkTaprootOutputFields, isP2MRInput, isTaprootInput, serializeTaprootSignature, tapScriptFinalizer, } from './psbt/bip371.js';
import { toXOnly } from './pubkey.js';
import * as bscript from './script.js';
import { Transaction } from './transaction.js';
// Import composition classes
import { PsbtCache } from './psbt/PsbtCache.js';
import { PsbtSigner } from './psbt/PsbtSigner.js';
import { getFinalScripts as _getFinalScripts, prepareFinalScripts as _prepareFinalScripts, PsbtFinalizer, } from './psbt/PsbtFinalizer.js';
import { PsbtTransaction, transactionFromBuffer } from './psbt/PsbtTransaction.js';
import { check32Bit, checkCache, checkInputsForPartialSig, checkPartialSigSighashes, checkScriptForPubkey, checkTxForDupeIns, checkTxInputCache, isFinalized, } from './psbt/validation.js';
import { checkInvalidP2WSH, classifyScript, getMeaningfulScript, range } from './psbt/utils.js';
import { witnessStackToScriptWitness } from './psbt/psbtutils.js';
// Re-export for backwards compatibility
export { getFinalScripts, prepareFinalScripts };
export { PsbtCache } from './psbt/PsbtCache.js';
export { PsbtSigner } from './psbt/PsbtSigner.js';
export { PsbtFinalizer } from './psbt/PsbtFinalizer.js';
export { PsbtTransaction, transactionFromBuffer } from './psbt/PsbtTransaction.js';
/**
 * These are the default arguments for a Psbt instance.
 */
const DEFAULT_OPTS = {
    network: btcNetwork,
    maximumFeeRate: 5000,
};
/** Helper to create a Transaction from a buffer */
function txFromBuffer(buf) {
    return Transaction.fromBuffer(buf);
}
// Standalone exports that delegate to PsbtFinalizer
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks = true, solution) {
    return _getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks, solution);
}
function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH, solution) {
    return _prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH, solution);
}
/**
 * Psbt class can parse and generate a PSBT binary based off of the BIP174.
 * There are 6 roles that this class fulfills. (Explained in BIP174)
 *
 * Creator: This can be done with `new Psbt()`
 *
 * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,
 *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to
 *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,
 *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`
 *   addInput requires hash: Uint8Array | string; and index: number; as attributes
 *   and can also include any attributes that are used in updateInput method.
 *   addOutput requires script: Uint8Array; and value: bigint; and likewise can include
 *   data for updateOutput.
 *   For a list of what attributes should be what types. Check the bip174 library.
 *   Also, check the integration tests for some examples of usage.
 *
 * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input
 *   information for your pubkey or pubkeyhash, and only sign inputs where it finds
 *   your info. Or you can explicitly sign a specific input with signInput and
 *   signInputAsync. For the async methods you can create a SignerAsync object
 *   and use something like a hardware wallet to sign with. (You must implement this)
 *
 * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`
 *   the psbt calling combine will always have precedence when a conflict occurs.
 *   Combine checks if the internal bitcoin transaction is the same, so be sure that
 *   all sequences, version, locktime, etc. are the same before combining.
 *
 * Input Finalizer: This role is fairly important. Not only does it need to construct
 *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.
 *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`
 *   Running any finalize method will delete any data in the input(s) that are no longer
 *   needed due to the finalized scripts containing the information.
 *
 * Transaction Extractor: This role will perform some checks before returning a
 *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.
 */
export class Psbt {
    data;
    #cache;
    #signer;
    #finalizer;
    #opts;
    constructor(opts = {}, data = new PsbtBase(new PsbtTransaction())) {
        this.data = data;
        this.#opts = Object.assign({}, DEFAULT_OPTS, opts);
        const tx = this.data.globalMap.unsignedTx.tx;
        this.#cache = new PsbtCache(tx);
        if (opts.version === 3) {
            this.setVersionTRUC();
        }
        else if (this.data.inputs.length === 0)
            this.setVersion(2);
    }
    get inputCount() {
        return this.data.inputs.length;
    }
    get version() {
        return this.#cache.tx.version;
    }
    set version(version) {
        this.setVersion(version);
    }
    get locktime() {
        return this.#cache.tx.locktime;
    }
    set locktime(locktime) {
        this.setLocktime(locktime);
    }
    get txInputs() {
        return this.#cache.tx.ins.map((input) => ({
            hash: clone(input.hash),
            index: input.index,
            sequence: input.sequence,
        }));
    }
    get txOutputs() {
        return this.#cache.tx.outs.map((output) => {
            let address;
            try {
                address = fromOutputScript(output.script, this.#opts.network);
            }
            catch (_) {
                // Not all scripts can be converted to an address
            }
            return {
                script: clone(output.script),
                value: output.value,
                address,
            };
        });
    }
    /** Lazily initialized signer - created on first access */
    get #lazySigner() {
        if (!this.#signer) {
            this.#signer = new PsbtSigner(this.#cache, txFromBuffer);
        }
        return this.#signer;
    }
    /** Lazily initialized finalizer - created on first access */
    get #lazyFinalizer() {
        if (!this.#finalizer) {
            this.#finalizer = new PsbtFinalizer(this.#cache, txFromBuffer);
        }
        return this.#finalizer;
    }
    static fromBase64(data, opts = {}) {
        const buffer = fromBase64(data);
        return this.fromBuffer(buffer, opts);
    }
    static fromHex(data, opts = {}) {
        const buffer = fromHex(data);
        return this.fromBuffer(buffer, opts);
    }
    static fromBuffer(buffer, opts = {}) {
        const psbtBase = PsbtBase.fromBuffer(buffer, transactionFromBuffer);
        const psbt = new Psbt(opts, psbtBase);
        checkTxForDupeIns(psbt.#cache.tx, psbt.#cache);
        psbt.#cache.hasSignatures = psbt.data.inputs.some((input) => input.partialSig?.length ||
            input.tapKeySig ||
            input.tapScriptSig?.length ||
            input.finalScriptSig ||
            input.finalScriptWitness);
        return psbt;
    }
    combine(...those) {
        this.data.combine(...those.map((o) => o.data));
        return this;
    }
    clone() {
        const clonedOpts = structuredClone(this.#opts);
        return Psbt.fromBuffer(new Uint8Array(this.data.toBuffer()), clonedOpts);
    }
    get maximumFeeRate() {
        return this.#opts.maximumFeeRate;
    }
    setMaximumFeeRate(satoshiPerByte) {
        check32Bit(satoshiPerByte);
        this.#opts.maximumFeeRate = satoshiPerByte;
    }
    setVersion(version) {
        check32Bit(version);
        checkInputsForPartialSig(this.data.inputs, 'setVersion', this.#cache.hasSignatures);
        this.#cache.tx.version = version;
        this.#cache.invalidate('outputs');
        return this;
    }
    setVersionTRUC() {
        return this.setVersion(Transaction.TRUC_VERSION);
    }
    setLocktime(locktime) {
        check32Bit(locktime);
        checkInputsForPartialSig(this.data.inputs, 'setLocktime', this.#cache.hasSignatures);
        this.#cache.tx.locktime = locktime;
        this.#cache.invalidate('outputs');
        return this;
    }
    setInputSequence(inputIndex, sequence) {
        check32Bit(sequence);
        checkInputsForPartialSig(this.data.inputs, 'setInputSequence', this.#cache.hasSignatures);
        if (this.#cache.tx.ins.length <= inputIndex) {
            throw new Error('Input index too high');
        }
        this.#cache.tx.ins[inputIndex].sequence = sequence;
        this.#cache.invalidate('outputs');
        return this;
    }
    addInputs(inputDatas, checkPartialSigs = true) {
        inputDatas.forEach((inputData) => this.addInput(inputData, checkPartialSigs));
        return this;
    }
    addInput(inputData, checkPartialSigs = true) {
        if (!inputData || inputData.hash === undefined || inputData.index === undefined) {
            throw new Error(`Invalid arguments for Psbt.addInput. ` +
                `Requires single object with at least [hash] and [index]`);
        }
        checkTaprootInputFields(inputData, inputData, 'addInput');
        if (checkPartialSigs) {
            checkInputsForPartialSig(this.data.inputs, 'addInput', this.#cache.hasSignatures);
        }
        if (inputData.witnessScript)
            checkInvalidP2WSH(inputData.witnessScript);
        const normalizedInputData = inputData.witnessUtxo
            ? {
                ...inputData,
                witnessUtxo: {
                    script: inputData.witnessUtxo.script,
                    value: typeof inputData.witnessUtxo.value === 'bigint'
                        ? inputData.witnessUtxo.value
                        : BigInt(inputData.witnessUtxo.value),
                },
            }
            : inputData;
        this.data.addInput(normalizedInputData);
        const txIn = this.#cache.tx.ins[this.#cache.tx.ins.length - 1];
        checkTxInputCache(this.#cache, txIn);
        const inputIndex = this.data.inputs.length - 1;
        const input = this.data.inputs[inputIndex];
        if (input.nonWitnessUtxo) {
            this.#cache.addNonWitnessTxCache(input, inputIndex, txFromBuffer);
        }
        this.#cache.invalidate('full');
        return this;
    }
    addOutputs(outputDatas, checkPartialSigs = true) {
        outputDatas.forEach((outputData) => this.addOutput(outputData, checkPartialSigs));
        return this;
    }
    addOutput(outputData, checkPartialSigs = true) {
        const hasAddress = 'address' in outputData;
        const hasScript = 'script' in outputData;
        if (!outputData || outputData.value === undefined || (!hasAddress && !hasScript)) {
            throw new Error(`Invalid arguments for Psbt.addOutput. ` +
                `Requires single object with at least [script or address] and [value]`);
        }
        if (checkPartialSigs) {
            checkInputsForPartialSig(this.data.inputs, 'addOutput', this.#cache.hasSignatures);
        }
        if (hasAddress) {
            const { address } = outputData;
            const { network } = this.#opts;
            const script = toOutputScript(address, network);
            outputData = Object.assign({}, outputData, { script });
        }
        checkTaprootOutputFields(outputData, outputData, 'addOutput');
        this.data.addOutput(outputData);
        this.#cache.invalidate('outputs');
        return this;
    }
    extractTransaction(disableFeeCheck, disableOutputChecks) {
        if (disableOutputChecks) {
            this.data.inputs = this.data.inputs.filter((i) => !i.partialSig);
        }
        if (!this.data.inputs.every(isFinalized))
            throw new Error('Not finalized');
        if (!disableFeeCheck) {
            this.#cache.computeFeeRate(this.data.inputs, disableOutputChecks, txFromBuffer);
            this.#cache.checkFees(this.#opts);
        }
        if (this.#cache.extractedTx)
            return this.#cache.extractedTx;
        const tx = this.#cache.tx.clone();
        this.#cache.finalizeAndComputeAmounts(this.data.inputs, tx, true, disableOutputChecks, txFromBuffer);
        return tx;
    }
    getFeeRate(disableOutputChecks = false) {
        return this.#cache.computeFeeRate(this.data.inputs, disableOutputChecks, txFromBuffer);
    }
    getFee(disableOutputChecks = false) {
        return this.#cache.computeFee(this.data.inputs, disableOutputChecks, txFromBuffer);
    }
    finalizeAllInputs() {
        checkForInput(this.data.inputs, 0);
        range(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
        return this;
    }
    finalizeInput(inputIndex, finalScriptsFunc, canRunChecks) {
        const input = checkForInput(this.data.inputs, inputIndex);
        if (isTaprootInput(input)) {
            return this.#finalizeTaprootInput(inputIndex, input, undefined, finalScriptsFunc);
        }
        return this.#finalizeInput(inputIndex, input, finalScriptsFunc, canRunChecks ?? true);
    }
    finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = tapScriptFinalizer) {
        const input = checkForInput(this.data.inputs, inputIndex);
        if (isTaprootInput(input))
            return this.#finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc);
        throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
    }
    getInputType(inputIndex) {
        const input = checkForInput(this.data.inputs, inputIndex);
        const script = this.#cache.getScriptFromUtxo(inputIndex, input, txFromBuffer);
        const result = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript || this.#cache.redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript ||
            this.#cache.redeemFromFinalWitnessScript(input.finalScriptWitness));
        const type = result.type === 'raw' ? '' : result.type + '-';
        const mainType = classifyScript(result.meaningfulScript);
        return (type + mainType);
    }
    inputHasPubkey(inputIndex, pubkey) {
        const input = checkForInput(this.data.inputs, inputIndex);
        return this.#cache.pubkeyInInput(pubkey, input, inputIndex, txFromBuffer);
    }
    inputHasHDKey(inputIndex, root) {
        const input = checkForInput(this.data.inputs, inputIndex);
        const derivationIsMine = this.#lazySigner.bip32DerivationIsMine(root);
        return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
    }
    outputHasPubkey(outputIndex, pubkey) {
        const output = checkForOutput(this.data.outputs, outputIndex);
        return this.#cache.pubkeyInOutput(pubkey, output, outputIndex);
    }
    outputHasHDKey(outputIndex, root) {
        const output = checkForOutput(this.data.outputs, outputIndex);
        const derivationIsMine = this.#lazySigner.bip32DerivationIsMine(root);
        return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
    }
    validateSignaturesOfAllInputs(validator) {
        checkForInput(this.data.inputs, 0);
        const results = range(this.data.inputs.length).map((idx) => this.validateSignaturesOfInput(idx, validator));
        return results.every((res) => res);
    }
    validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        if (isTaprootInput(input))
            return this.#validateSignaturesOfTaprootInput(inputIndex, validator, pubkey);
        return this.#validateSignaturesOfInput(inputIndex, validator, pubkey);
    }
    signAllInputsHD(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const results = [];
        for (const i of range(this.data.inputs.length)) {
            try {
                this.signInputHD(i, hdKeyPair, sighashTypes);
                results.push(true);
            }
            catch (err) {
                results.push(false);
            }
        }
        if (results.every((v) => !v)) {
            throw new Error('No inputs were signed');
        }
        return this;
    }
    async signAllInputsHDAsync(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const results = [];
        const promises = [];
        for (const i of range(this.data.inputs.length)) {
            promises.push(this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(() => {
                results.push(true);
            }, () => {
                results.push(false);
            }));
        }
        await Promise.all(promises);
        if (results.every((v) => !v)) {
            throw new Error('No inputs were signed');
        }
    }
    signInputHD(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const signers = this.#lazySigner.getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
        return this;
    }
    async signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            throw new Error('Need HDSigner to sign input');
        }
        const signers = this.#lazySigner.getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        const promises = signers.map((signer) => this.signInputAsync(inputIndex, signer, sighashTypes));
        await Promise.all(promises);
    }
    signAllInputs(keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
            throw new Error('Need Signer to sign input');
        const results = [];
        for (const i of range(this.data.inputs.length)) {
            try {
                this.signInput(i, keyPair, sighashTypes);
                results.push(true);
            }
            catch (err) {
                results.push(false);
            }
        }
        if (results.every((v) => !v)) {
            throw new Error('No inputs were signed');
        }
        return this;
    }
    async signAllInputsAsync(keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
            throw new Error('Need Signer to sign input');
        const results = [];
        const promises = [];
        for (const [i] of this.data.inputs.entries()) {
            promises.push(this.signInputAsync(i, keyPair, sighashTypes).then(() => {
                results.push(true);
            }, () => {
                results.push(false);
            }));
        }
        await Promise.all(promises);
        if (results.every((v) => !v)) {
            throw new Error('No inputs were signed');
        }
    }
    signInput(inputIndex, keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey) {
            throw new Error('Need Signer to sign input');
        }
        const input = checkForInput(this.data.inputs, inputIndex);
        if (isTaprootInput(input)) {
            return this.#signTaprootInput(inputIndex, input, keyPair, undefined, sighashTypes);
        }
        return this.#signInput(inputIndex, keyPair, sighashTypes);
    }
    signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
        if (!keyPair || !keyPair.publicKey) {
            throw new Error('Need Signer to sign input');
        }
        const input = checkForInput(this.data.inputs, inputIndex);
        if (isTaprootInput(input)) {
            return this.#signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, sighashTypes);
        }
        throw new Error(`Input #${inputIndex} is not of type Taproot.`);
    }
    async signInputAsync(inputIndex, keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
            throw new Error('Need Signer to sign input');
        const input = checkForInput(this.data.inputs, inputIndex);
        if (isTaprootInput(input))
            return this.#signTaprootInputAsync(inputIndex, input, keyPair, undefined, sighashTypes);
        return this.#signInputAsync(inputIndex, keyPair, sighashTypes);
    }
    async signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
            throw new Error('Need Signer to sign input');
        const input = checkForInput(this.data.inputs, inputIndex);
        if (isTaprootInput(input))
            return this.#signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
        throw new Error(`Input #${inputIndex} is not of type Taproot.`);
    }
    toBuffer() {
        checkCache(this.#cache);
        return new Uint8Array(this.data.toBuffer());
    }
    toHex() {
        checkCache(this.#cache);
        return this.data.toHex();
    }
    toBase64() {
        checkCache(this.#cache);
        return this.data.toBase64();
    }
    updateGlobal(updateData) {
        this.data.updateGlobal(updateData);
        return this;
    }
    updateInput(inputIndex, updateData) {
        if (updateData.witnessScript)
            checkInvalidP2WSH(updateData.witnessScript);
        checkTaprootInputFields(this.data.inputs[inputIndex], updateData, 'updateInput');
        const normalizedUpdate = updateData.witnessUtxo
            ? {
                ...updateData,
                witnessUtxo: {
                    script: updateData.witnessUtxo.script,
                    value: typeof updateData.witnessUtxo.value === 'bigint'
                        ? updateData.witnessUtxo.value
                        : BigInt(updateData.witnessUtxo.value),
                },
            }
            : updateData;
        this.data.updateInput(inputIndex, normalizedUpdate);
        if (updateData.nonWitnessUtxo) {
            this.#cache.addNonWitnessTxCache(this.data.inputs[inputIndex], inputIndex, txFromBuffer);
        }
        return this;
    }
    updateOutput(outputIndex, updateData) {
        const outputData = this.data.outputs[outputIndex];
        checkTaprootOutputFields(outputData, updateData, 'updateOutput');
        this.data.updateOutput(outputIndex, updateData);
        return this;
    }
    addUnknownKeyValToGlobal(keyVal) {
        this.data.addUnknownKeyValToGlobal(keyVal);
        return this;
    }
    addUnknownKeyValToInput(inputIndex, keyVal) {
        this.data.addUnknownKeyValToInput(inputIndex, keyVal);
        return this;
    }
    addUnknownKeyValToOutput(outputIndex, keyVal) {
        this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
        return this;
    }
    clearFinalizedInput(inputIndex) {
        this.data.clearFinalizedInput(inputIndex);
        return this;
    }
    checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
        if (!('signSchnorr' in keyPair) || typeof keyPair.signSchnorr !== 'function')
            throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
        const pubkey = keyPair.publicKey instanceof Uint8Array
            ? keyPair.publicKey
            : new Uint8Array(keyPair.publicKey);
        const hashesForSig = this.#lazySigner.getTaprootHashesForSig(inputIndex, input, this.data.inputs, pubkey, tapLeafHashToSign, allowedSighashTypes);
        if (!hashesForSig || !hashesForSig.length)
            throw new Error(`Can not sign for input #${inputIndex} with the key ${toHex(pubkey)}`);
        return hashesForSig;
    }
    #finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts, canRunChecks = true) {
        const { script, isP2SH, isP2WSH, isSegwit } = this.#lazyFinalizer.getScriptFromInput(inputIndex, input);
        if (!script)
            throw new Error(`No script found for input #${inputIndex}`);
        checkPartialSigSighashes(input);
        const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH, canRunChecks);
        if (finalScriptSig)
            this.data.updateInput(inputIndex, { finalScriptSig });
        if (finalScriptWitness)
            this.data.updateInput(inputIndex, { finalScriptWitness });
        if (!finalScriptSig && !finalScriptWitness)
            throw new Error(`Unknown error finalizing input #${inputIndex}`);
        this.data.clearFinalizedInput(inputIndex);
        return this;
    }
    #finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = tapScriptFinalizer) {
        if (!input.witnessUtxo)
            throw new Error(`Cannot finalize input #${inputIndex}. Missing witness utxo.`);
        // P2MR has no key-path spend â€” always use script-path finalization
        if (input.tapKeySig && !isP2MRInput(input)) {
            const payment = payments.p2tr({
                output: input.witnessUtxo.script,
                signature: input.tapKeySig,
            });
            if (!payment.witness)
                throw new Error('Cannot finalize taproot key spend');
            const finalScriptWitness = witnessStackToScriptWitness(payment.witness);
            this.data.updateInput(inputIndex, { finalScriptWitness });
        }
        else {
            const { finalScriptWitness } = finalScriptsFunc(inputIndex, input, tapLeafHashToFinalize);
            this.data.updateInput(inputIndex, { finalScriptWitness });
        }
        this.data.clearFinalizedInput(inputIndex);
        return this;
    }
    #validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const partialSig = input?.partialSig;
        if (!input || !partialSig || partialSig.length < 1)
            throw new Error('No signatures to validate');
        if (typeof validator !== 'function')
            throw new Error('Need validator function to validate signatures');
        const mySigs = pubkey ? partialSig.filter((sig) => equals(sig.pubkey, pubkey)) : partialSig;
        if (mySigs.length < 1)
            throw new Error('No signatures for this pubkey');
        const results = [];
        let hashCache;
        let scriptCache;
        let sighashCache;
        for (const pSig of mySigs) {
            const pSigSignature = pSig.signature;
            const pSigPubkey = pSig.pubkey;
            const sig = bscript.signature.decode(pSigSignature);
            const { hash, script } = sighashCache !== sig.hashType || !hashCache || !scriptCache
                ? this.#lazySigner.getHashForSig(inputIndex, Object.assign({}, input, {
                    sighashType: sig.hashType,
                }), true)
                : { hash: hashCache, script: scriptCache };
            sighashCache = sig.hashType;
            hashCache = hash;
            scriptCache = script;
            checkScriptForPubkey(pSigPubkey, script, 'verify');
            results.push(validator(pSigPubkey, hash, sig.signature));
        }
        return results.every((res) => res);
    }
    #validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const tapKeySig = input?.tapKeySig;
        const tapScriptSig = input?.tapScriptSig;
        if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
            throw new Error('No signatures to validate');
        if (typeof validator !== 'function')
            throw new Error('Need validator function to validate signatures');
        const xPubkey = pubkey ? toXOnly(pubkey) : undefined;
        const allHashses = xPubkey
            ? this.#lazySigner.getTaprootHashesForSig(inputIndex, input, this.data.inputs, xPubkey)
            : this.#lazySigner.getAllTaprootHashesForSig(inputIndex, input, this.data.inputs);
        if (!allHashses.length)
            throw new Error('No signatures for this pubkey');
        const tapKeyHash = allHashses.find((h) => !h.leafHash);
        let validationResultCount = 0;
        if (tapKeySig && tapKeyHash) {
            const isValidTapkeySig = validator(tapKeyHash.pubkey, tapKeyHash.hash, this.#lazySigner.trimTaprootSig(tapKeySig));
            if (!isValidTapkeySig)
                return false;
            validationResultCount++;
        }
        if (tapScriptSig) {
            for (const tapSig of tapScriptSig) {
                const tapSigPubkey = tapSig.pubkey;
                const tapSigHash = allHashses.find((h) => equals(tapSigPubkey, h.pubkey));
                if (tapSigHash) {
                    const isValidTapScriptSig = validator(tapSigPubkey, tapSigHash.hash, this.#lazySigner.trimTaprootSig(tapSig.signature));
                    if (!isValidTapScriptSig)
                        return false;
                    validationResultCount++;
                }
            }
        }
        return validationResultCount > 0;
    }
    #signInput(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
        const pubkey = keyPair.publicKey instanceof Uint8Array
            ? keyPair.publicKey
            : new Uint8Array(keyPair.publicKey);
        const { hash, sighashType } = this.#lazySigner.getHashAndSighashType(this.data.inputs, inputIndex, pubkey, sighashTypes);
        const sig = keyPair.sign(hash);
        const partialSig = [
            {
                pubkey,
                signature: bscript.signature.encode(sig instanceof Uint8Array ? sig : new Uint8Array(sig), sighashType),
            },
        ];
        this.data.updateInput(inputIndex, { partialSig });
        this.#cache.hasSignatures = true;
        return this;
    }
    #signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [Transaction.SIGHASH_DEFAULT]) {
        const pubkey = (keyPair.publicKey instanceof Uint8Array
            ? keyPair.publicKey
            : new Uint8Array(keyPair.publicKey));
        if (!('signSchnorr' in keyPair) || typeof keyPair.signSchnorr !== 'function')
            throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
        const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes);
        const signSchnorr = keyPair.signSchnorr.bind(keyPair);
        const tapKeySig = hashesForSig
            .filter((h) => !h.leafHash)
            .map((h) => serializeTaprootSignature(signSchnorr(h.hash), input.sighashType))[0];
        const tapScriptSig = hashesForSig
            .filter((h) => !!h.leafHash)
            .map((h) => ({
            pubkey: toXOnly(pubkey),
            signature: serializeTaprootSignature(signSchnorr(h.hash), input.sighashType),
            leafHash: h.leafHash,
        }));
        if (tapKeySig) {
            this.data.updateInput(inputIndex, { tapKeySig });
            this.#cache.hasSignatures = true;
        }
        if (tapScriptSig.length) {
            this.data.updateInput(inputIndex, { tapScriptSig });
            this.#cache.hasSignatures = true;
        }
        return this;
    }
    async #signInputAsync(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {
        const pubkey = keyPair.publicKey instanceof Uint8Array
            ? keyPair.publicKey
            : new Uint8Array(keyPair.publicKey);
        const { hash, sighashType } = this.#lazySigner.getHashAndSighashType(this.data.inputs, inputIndex, pubkey, sighashTypes);
        const signature = await keyPair.sign(hash);
        const sig = signature instanceof Uint8Array ? signature : new Uint8Array(signature);
        const partialSig = [
            {
                pubkey,
                signature: bscript.signature.encode(sig, sighashType),
            },
        ];
        this.data.updateInput(inputIndex, { partialSig });
        this.#cache.hasSignatures = true;
    }
    async #signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [Transaction.SIGHASH_DEFAULT]) {
        const pubkey = (keyPair.publicKey instanceof Uint8Array
            ? keyPair.publicKey
            : new Uint8Array(keyPair.publicKey));
        if (!('signSchnorr' in keyPair) || typeof keyPair.signSchnorr !== 'function')
            throw new Error(`Need Schnorr Signer to sign taproot input #${inputIndex}.`);
        const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
        const signSchnorr = keyPair.signSchnorr.bind(keyPair);
        const tapKeyHash = hashesForSig.find((h) => !h.leafHash);
        if (tapKeyHash) {
            const sig = await signSchnorr(tapKeyHash.hash);
            const tapKeySig = serializeTaprootSignature(sig, input.sighashType);
            this.data.updateInput(inputIndex, { tapKeySig });
            this.#cache.hasSignatures = true;
        }
        const tapScriptHashes = hashesForSig.filter((h) => !!h.leafHash);
        if (tapScriptHashes.length) {
            const tapScriptSigs = await Promise.all(tapScriptHashes.map(async (tsh) => {
                const signature = await signSchnorr(tsh.hash);
                return {
                    pubkey: toXOnly(pubkey),
                    signature: serializeTaprootSignature(signature, input.sighashType),
                    leafHash: tsh.leafHash,
                };
            }));
            this.data.updateInput(inputIndex, { tapScriptSig: tapScriptSigs });
            this.#cache.hasSignatures = true;
        }
    }
}
//# sourceMappingURL=psbt.js.map