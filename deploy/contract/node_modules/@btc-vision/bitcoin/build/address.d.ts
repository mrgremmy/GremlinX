import { type Bech32Result, fromBech32 } from './bech32utils.js';
import type { Network } from './networks.js';
import { type Bytes20, type Script } from './types.js';
export { fromBech32, type Bech32Result };
/** base58check decode result */
export interface Base58CheckResult {
    /** address hash */
    readonly hash: Bytes20;
    /** address version: 0x00 for P2PKH, 0x05 for P2SH */
    readonly version: number;
}
export declare const FUTURE_SEGWIT_MAX_SIZE: number;
export declare const FUTURE_SEGWIT_MIN_SIZE: number;
export declare const FUTURE_SEGWIT_MAX_VERSION: number;
export declare const FUTURE_MAX_VERSION: number;
export declare const FUTURE_OPNET_VERSION: number;
export declare const FUTURE_SEGWIT_MIN_VERSION: number;
export declare const FUTURE_SEGWIT_VERSION_DIFF: number;
export declare const isUnknownSegwitVersion: (output: Uint8Array) => boolean;
/**
 * Encode a future Taproot-style segwit address (SegWit v2 - v16) using bech32m.
 * Only for versions not yet assigned specific meanings (future use).
 *
 * @param output - Output script buffer containing the version and witness program
 * @param network - Network object containing bech32 and optional bech32Opnet prefix
 * @returns Bech32m-encoded future Taproot-style address
 */
export declare function toFutureOPNetAddress(output: Uint8Array, network: Network): string;
export declare function _toFutureSegwitAddress(output: Uint8Array, network: Network): string;
/**
 * decode address with base58 specification,  return address version and address hash if valid
 */
export declare function fromBase58Check(address: string): Base58CheckResult;
/**
 * encode address hash to base58 address with version
 */
export declare function toBase58Check(hash: Bytes20, version: number): string;
/**
 * encode address hash to bech32 address with version and prefix
 */
export declare function toBech32(data: Uint8Array, version: number, prefix: string, prefixOpnet?: string): string;
/**
 * decode address from output script with network, return address if matched.
 *
 * Uses fast byte-pattern matching for common script types (P2PKH, P2SH,
 * P2WPKH, P2WSH, P2TR) to avoid constructing payment objects and catching
 * exceptions. Falls back to payment constructors for exotic types.
 */
export declare function fromOutputScript(output: Uint8Array | Script, network?: Network): string;
/**
 * Options for toOutputScript function.
 */
export interface ToOutputScriptOptions {
    /**
     * Network to use for encoding. Defaults to bitcoin mainnet.
     */
    readonly network?: Network;
    /**
     * Optional callback for future segwit version warnings.
     * If provided, called with FUTURE_SEGWIT_VERSION_WARNING when encoding
     * to a future segwit version (v2-v15) address.
     * If not provided, no warning is emitted.
     */
    readonly onFutureSegwitWarning?: (warning: string) => void;
}
/**
 * Encodes address to output script with network, return output script if address matched.
 * @param address - The address to encode
 * @param networkOrOptions - Network or options object
 * @returns The output script
 */
export declare function toOutputScript(address: string, networkOrOptions?: Network | ToOutputScriptOptions): Script;
//# sourceMappingURL=address.d.ts.map